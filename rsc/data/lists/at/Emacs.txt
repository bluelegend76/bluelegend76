~/bin/scripts/at/at.Emacs.bash
~/.emacs.d/init.el

emacs-30.1 ~/Dropbox/rsc/samples/code/orgmode-test.org &
    (+Org: = 5gt)

gvim ~/.emacs.d/init.el
emacs-30.1 ~/.emacs.d/init.el

emacs over vim:
    - several code syntaxes active
    - pdf-tools
    - org-mode
    - image/graphics in txt-files

Settings (e.g. Setup for Programming-Languages (Guile Scheme, etc) ____) {{{
___config
LEAN INIT.EL + LOAD SETTINGS FOR ALL LANGUAGES {{{

You've hit on a critical point for a well-maintained Emacs configuration! As you add more languages and features, a single, monolithic init.el quickly becomes unwieldy. The approach you're describing - a lean init.el that loads modular configurations from separate files - is the gold standard for Emacs power users.

We've definitely touched upon this implicitly with the use-package preamble, but now we'll formalize the directory structure and loading mechanism.

Here's how to organize your init.el and supporting configuration files, focusing on modularity and cleanliness.
The Goal: A Modular and Clean init.el

Your init.el will become a central dispatcher. It will:

    Perform essential bootstrapping: Set up package management (use-package).
    Define global settings: Very few, truly universal settings.
    Load feature-specific configuration files: These files (or directories of files) will contain all the use-package declarations and specific customizations for individual languages, tools, or functionalities.

Recommended Directory Structure

A common and highly effective way to organize your Emacs configuration is to create a dedicated directory for your custom configurations, often called ~/.emacs.d/lisp/ or ~/.emacs.d/config/. Within that, you can have subdirectories for categories, or simply put language files directly.

Here's a possible structure:

~/.emacs.d/
├── init.el                     ; The main Emacs initialization file
├── early-init.el               ; (Optional) For very early, package-manager-independent setup
└── lisp/                       ; Or 'config/', a common directory for custom ELisp files
    ├── 00-core-settings.el     ; Global settings (e.g., UI, Dired, general editing)
    ├── 10-programming.el       ; General programming environment settings (optional)
    ├── languages/              ; Directory for language-specific configurations
    │   ├── c-cpp.el
    │   ├── clojure.el
    │   ├── dlang.el
    │   ├── elixir.el
    │   ├── fsharp.el
    │   ├── idris.el
    │   ├── json.el
    │   ├── lua-family.el       ; For Lua, Fennel, MoonScript, Teal combined
    │   ├── markdown.el
    │   ├── postscript.el
    │   ├── scheme-family.el    ; For Guile, Gambit, Chicken, Chez, Racket combined
    │   └── sml.el
    ├── themes/                 ; If you store custom theme configurations
    │   └── my-theme.el
    ├── ui/                     ; UI enhancements (e.g., modeline, dashboard)
    │   └── dashboard.el
    └── other-tools/            ; Other general tools (e.g., Org-mode, Magit, Projectile)
        ├── org-mode.el
        └── magit.el

Naming Convention:

    Using numerical prefixes (e.g., 00-, 10-) helps control the loading order, which can be crucial for some configurations that depend on others.
    Grouping related languages (like lua-family.el or scheme-family.el) can keep the number of files manageable.

The Lean init.el

Your init.el will be very simple. It will handle the package manager setup and then load all .el files from your lisp/ (or config/) directory.
Code snippet

;;; init.el - Emacs Main Configuration File

;; -----------------------------------------------------------
;; 1. Essential Bootstrapping: Package Management (use-package)
;; -----------------------------------------------------------

;; Ensure package.el is loaded and archives are set up
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t) ; For Geiser, etc.
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t) ; Often included by default, or for specific packages.
(package-initialize)

;; Install use-package if it's not already installed
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

;; Enable use-package's automatic package installation
(setq use-package-always-ensure t)

;; -----------------------------------------------------------
;; 2. Global Settings (Minimal)
;; -----------------------------------------------------------

;; Set custom file location (prevents clutter in init.el)
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(unless (file-exists-p custom-file)
  (write-file custom-file))
(load custom-file)

;; Set default indentation for modes not explicitly configured
(setq-default indent-tabs-mode nil) ; Prefer spaces
(setq-default tab-width 4)           ; Default to 4 spaces, override per mode

;; More UI settings, e.g., line numbers, scroll bar, etc.
(global-display-line-numbers-mode 1)
(scroll-bar-mode -1) ; Disable scroll bar
(tool-bar-mode -1)   ; Disable tool bar
(menu-bar-mode -1)   ; Disable menu bar

;; -----------------------------------------------------------
;; 3. Load Modular Configuration Files
;; -----------------------------------------------------------

;; Define the path to your custom configuration directory
(defvar my-config-dir (expand-file-name "lisp/" user-emacs-directory)
  "Directory containing modular Emacs configuration files.")

;; Add it to the load-path so Emacs can find files within it
(add-to-list 'load-path my-config-dir)

;; Load all .el files from the config directory (and its subdirectories)
(message "Loading modular Emacs configurations from %s..." my-config-dir)
(dolist (file (directory-files-recursively my-config-dir "\\.el$"))
  (load-file file))

(message "Finished loading Emacs configurations.")

;; -----------------------------------------------------------
;; Optional: Early Init File (for very early setup)
;; -----------------------------------------------------------
;; For settings that must be loaded *before* package.el or init.el.
;; This often includes things like disabling UI elements *before* they draw,
;; or setting `package-user-dir` if you want it somewhere specific.
;; This file is loaded *before* init.el by Emacs itself.
;; You don't need to explicitly load it here.
;; Example early-init.el:
;; (setq inhibit-startup-message t)
;; (setq package-user-dir (expand-file-name "elpa" user-emacs-directory))
;; (setq default-frame-alist '((menu-bar-lines . 0) (tool-bar-lines . 0) (vertical-scroll-bars . nil)))

How to Create and Fill the Modular Files

Now, for each configuration we've discussed (Lua, Fennel, MoonScript, Teal, etc.):

    Create a new file: E.g., ~/.emacs.d/lisp/languages/lua-family.el

    Move the use-package blocks: Take the entire use-package block for Lua, Fennel, MoonScript, Teal, and Eglot (for Lua) and paste it into lua-family.el.
        Crucial: Remove the use-package preamble from the individual files! It only needs to be in init.el.
        Example ~/.emacs.d/lisp/languages/lua-family.el content:
    Code snippet

    ;;; lua-family.el --- Configuration for Lua, Fennel, MoonScript, Teal -*- lexical-binding: t; -*-

    ;; All 'use-package' declarations will rely on the preamble in init.el

    (use-package lua-mode
      :mode "\\.lua\\'"
      :hook (lua-mode . (lambda ()
                           (setq indent-tabs-mode nil)
                           (setq tab-width 2)
                           (electric-pair-mode 1)
                           (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
      :config
      (use-package flycheck
        :init (global-flycheck-mode)
        :config
        (flycheck-define-checker lua-luacheck
          :command ("luacheck" source)
          :error-patterns
          ((error line-start (file-name) ":" line ":" column ": " (message) line-end)))
        (add-hook 'lua-mode-hook (lambda () (flycheck-mode))))

      (use-package company
        :init (global-company-mode)
        :config
        (setq company-idle-delay 0.1)
        (setq company-minimum-prefix-length 2)
        (add-to-list 'company-backends 'company-capf)))

    (use-package eglot
      :config
      (add-to-list 'eglot-server-programs '(lua-mode . ("lua-language-server")))
      (add-to-list 'eglot-server-programs '(teal-mode . ("lua-language-server")))
      (add-hook 'eglot-managed-mode-hook
                (lambda ()
                  (when (or (eq major-mode 'lua-mode) (eq major-mode 'teal-mode))
                    (add-hook 'before-save-hook #'eglot-format-buffer nil t)))))

    (use-package fennel-mode
      :mode "\\.fnl\\'"
      :hook (fennel-mode . (lambda ()
                              (setq indent-tabs-mode nil)
                              (setq tab-width 2)
                              (setq lisp-indent-offset 2)
                              (electric-pair-mode 1)
                              (add-hook 'before-save-hook 'delete-trailing-whitespace nil t))))

    (use-package moonscript-mode
      :mode "\\.moon\\'"
      :hook (moonscript-mode . (lambda ()
                                  (setq indent-tabs-mode nil)
                                  (setq tab-width 2)
                                  (electric-pair-mode 1)
                                  (add-hook 'before-save-hook 'delete-trailing-whitespace nil t))))

    (use-package teal-mode
      :mode "\\.tl\\'"
      :hook (teal-mode . (lambda ()
                            (setq indent-tabs-mode nil)
                            (setq tab-width 2)
                            (electric-pair-mode 1)
                            (add-hook 'before-save-hook 'delete-trailing-whitespace nil t))))

    ;; End of lua-family.el

    Repeat for other languages/features: Create c-cpp.el, dlang.el, markdown.el, postscript.el, sml.el, scheme-family.el, etc., moving the relevant use-package blocks into each.

Advantages of This Modular Approach

    Readability: Your init.el is clean and easy to understand at a glance.
    Maintainability: When you want to modify settings for a specific language (e.g., Elixir), you know exactly which file to open (elixir.el).
    Organization: Related configurations are grouped together.
    Debugging: If Emacs starts acting up, you can comment out a single load-file line in init.el (or the dolist loop itself for a full revert) or comment out a specific .el file in lisp/ to quickly isolate the problem.
    Sharing: It's easier to share parts of your config with others.
    Performance (Minor): use-package already lazy-loads most packages, so the load-file for each modular config file is quick, as Emacs isn't doing much until you activate a specific mode.

This structure is robust and will scale very well as your Emacs configuration grows. It's an excellent way to keep your Emacs setup tidy and efficient!

}}}
COMPLETION + INTELLISENSE {{{

A follow-up on all of the above questions (in a sense): What are the recommended solutions for getting good completion- and intellisense-support? Could we focus on that and get that into our setup as well? Note: I suspect that this would probably be good to put directly inside init.el, but I'll let you comment on that

You're absolutely right to focus on completion and "IntelliSense" (which is a broad term encompassing features like intelligent code completion, real-time diagnostics, hover information, go-to-definition, refactoring, etc.). These are the core features that transform Emacs into a highly productive development environment.

And your suspicion is correct: the core setup for these features is best placed directly in your init.el (or a file loaded very early by init.el, like 00-core-settings.el) because they are global frameworks. The language-specific integration then goes into your modular language files.

Let's break down the recommended solutions for getting excellent completion and IntelliSense support.
The Emacs "IntelliSense" Stack

Our setup for "IntelliSense" relies on three primary Emacs packages working in concert, plus the external Language Server executables:

    company-mode: This is the completion framework. It provides the actual pop-up completion menu, handles inserting candidates, and is highly configurable. It doesn't know how to generate completions itself; it relies on "backends."

eglot: This is our Language Server Protocol (LSP) client. It's the bridge between Emacs and external Language Servers (like gopls, v-analyzer, kotlin-language-server, pylsp, ada-language-server, nu lsp). Eglot speaks the LSP protocol and translates requests from Emacs into messages the language server understands, and vice-versa. Language Servers are what provide the semantic understanding of your code.
company-capf: This is a specific company-mode backend provided by Emacs itself. eglot (and other LSP clients) registers its capabilities with completion-at-point-functions (capf). When company-capf is enabled, company-mode will query capf (and thus eglot) for completion candidates. This is how company-mode gets its intelligent, context-aware completions from the LSP server.
flycheck: While not directly for completion, flycheck is the standard package for on-the-fly syntax checking and diagnostics. Eglot integrates seamlessly with Flycheck to display errors and warnings reported by the Language Server in real-time. This is a crucial part of the "IntelliSense" experience.

init.el Configuration for Global IntelliSense Frameworks

Place this in your init.el (or a dedicated ~/.emacs.d/lisp/00-core-settings.el that is loaded by init.el).
Code snippet

;;; Core Completion and IntelliSense Setup

;; 1. Company Mode: The Completion Framework
(use-package company
  :ensure t                   ; Ensure company-mode is installed
  :init
  (global-company-mode)       ; Activate company-mode globally for all buffers

  :config
  ;; Common Company Mode settings for a better experience
  (setq company-idle-delay 0.1)          ; Shorter delay for completion pop-up (in seconds)
  (setq company-minimum-prefix-length 2) ; Show completions after 2 characters
  (setq company-show-numbers t)          ; Show candidate numbers
  (setq company-tooltip-limit 10)        ; Limit number of visible candidates in tooltip
  (setq company-selection-wrap-around t) ; Wrap around when navigating candidates

  ;; Priority of backends. `company-capf` comes from LSP.
  ;; `company-dabbrev-code` is good for general word completion.
  ;; `company-yasnippet` for snippets.
  ;; The order matters: put more specific backends first.
  (setq company-backends '(
                           company-capf           ; LSP (Eglot) completion
                           company-yasnippet      ; Yasnippet support
                           company-dabbrev-code   ; General word completion from buffer/code context
                           ))

  ;; Optional: Enable Company Mode in the minibuffer (for M-x, prompts)
  ;; (company-mode-in-minibuffer t)
  )

;; 2. Flycheck: On-the-fly Syntax Checking and Diagnostics
(use-package flycheck
  :ensure t                   ; Ensure flycheck is installed
  :init
  (global-flycheck-mode)      ; Activate flycheck globally for all buffers

  :config
  ;; Optional: Customize flycheck settings (e.g., enable/disable checkers)
  ;; (setq flycheck-checker-version-minimum '((emacs "26.1")))
  ;; (setq flycheck-highlighting-mode 'lines) ; Highlight entire lines with errors
  )

;; 3. Eglot: The Language Server Protocol Client
;; This is the base declaration for Eglot itself.
;; Language-specific hooks and server programs are in their respective language files.
(use-package eglot
  :ensure t
  :config
  ;; Configure Eglot for better performance/behavior
  (setq eglot-connect-timeout 30) ; Increase timeout for LSP server connection
  (setq eglot-autoshutdown t)     ; Shutdown server when last buffer using it is killed
  (setq eglot-stay-out-of-way nil) ; Be more assertive with features (diagnostics, etc.)

  ;; Optional: Show diagnostic messages in minibuffer on cursor idle
  (setq eglot-auto-display-buffer nil) ; Don't auto pop-up help buffer
  (setq eglot-prefer-help-buffer t) ; Prefer help buffer for documentation

  ;; To display documentation in the minibuffer as you type (like Eldoc)
  (add-hook 'eglot-managed-mode-hook #'eglot-init-eldoc)

  ;; Configure formatting capabilities (if not already handled by before-save-hook)
  (setq eglot-formatting-provider :auto) ; Use LSP for formatting if server supports it

  ;; Display flycheck errors in a more readable way
  (add-hook 'flycheck-mode-hook #'flycheck-display-mode-line) ; For mode line display
  (add-hook 'flycheck-mode-hook #'flycheck-display-errors-next-to-lines) ; For errors next to lines
  )

Language-Specific Integration (in your languages/*.el files)

While company-mode, flycheck, and eglot are loaded globally, their behavior is customized per-language. This is where your modular setup shines:

    eglot-ensure Hooks: In each languages/<lang>.el file, you tell Eglot when to activate for that language:
    Code snippet

;; In languages/golang.el
(use-package eglot
  :hook (go-mode . eglot-ensure) ; <--- This is the key
  :config
  (add-to-list 'eglot-server-programs '(go-mode . ("gopls")))
  ...)

eglot-server-programs: This list, built up across your language files, tells Eglot which executable to run for each major mode.
company-backends (Implicit): Because company-capf is globally added to company-backends in init.el, it will automatically interact with Eglot whenever Eglot is active in a buffer.

    flycheck-mode Hooks: Similarly, flycheck-mode is activated per language mode to ensure diagnostics are run when appropriate.

How This Provides "IntelliSense"

With this setup:

    When you open a file (e.g., a .go file), go-mode activates.
    eglot-ensure (from the go-mode hook) tells Eglot to start the gopls language server for your Go project.

As you type:

    Completion: company-mode will automatically pop up with completion candidates. These candidates are provided by gopls via company-capf, giving you semantic, context-aware suggestions (e.g., struct fields, function arguments, variable names).
    Diagnostics: flycheck will show real-time errors and warnings (from gopls) directly in your buffer or in the mode line.

Hover: When you pause your cursor over a symbol, eglot (via eldoc integration) will show documentation or type information in the minibuffer.
Navigation: Commands like M-. (go to definition) and M-x xref-find-references work because Eglot translates these into LSP requests for gopls.
Refactoring/Code Actions: M-x eglot-code-action provides quick fixes or refactoring options suggested by gopls.

By putting the core frameworks in init.el and the specific language integrations in their respective files, you achieve a clean, modular, and highly functional "IntelliSense" setup in Emacs.

What key triggers completion and suggestions for different languages in Emacs, i.e. something akin to ctrl+n or even ctrl+x ctrl+o (I think it is) in Vim?

You're asking about the keybinding to manually trigger completion and suggestions, similar to Ctrl+N or Ctrl+X Ctrl+O in Vim. That's a very common question when transitioning to Emacs!

With the company-mode setup we've established, there are two primary ways to get completion:

    Automatic (Default and Most Common):
    The beauty of company-mode (with the settings we've applied, like company-idle-delay and company-minimum-prefix-length) is that it's designed to be largely automatic. As soon as you type the minimum number of characters for a prefix (we set it to 2), and after a very short delay (we set it to 0.1 seconds), the completion pop-up will usually appear on its own.
        Action: Just start typing your code.

    Manual Invocation:
    If the pop-up doesn't appear automatically (e.g., you want to see all possible completions from the beginning of a word, or you've dismissed it), you can manually invoke it:
        Keybinding: The most common keybinding for this is C-M-i (which is Ctrl + Alt + i or Ctrl + Meta + i).
        Command: The underlying Emacs command is M-x company-complete.

Navigating the Completion Pop-up

Once the company-mode pop-up is active (whether triggered automatically or manually):

    C-n: Move to the next candidate (down).
    C-p: Move to the previous candidate (up).
    M-n / M-p: Also move next/previous.

C-g: Dismiss the completion pop-up without inserting anything.
TAB:

    If there's a unique common prefix among candidates, it will complete that prefix.
    If there's only one candidate, it will complete it.
    Otherwise, it will move to the next candidate (similar to C-n).

RET (Enter): Accept the currently selected candidate and insert it.

    Type More: Continue typing to narrow down the list of candidates.

How This Works Across Languages

Because company-mode is your global completion framework and eglot (our LSP client) integrates with company-mode via company-capf, this same behavior and these same keybindings will work for all languages where Eglot successfully connects to a Language Server.

So, whether you're typing Go, Kotlin, Vlang, Ada, NuShell, or Python (assuming their respective LSP servers are running), company-mode will provide intelligent, semantic completions based on the language server's capabilities, using the same familiar navigation keys.

}}}
SNIPPETS {{{

You're spot on! For snippets in Emacs, the overwhelmingly preferred and most capable solution is yasnippet. It's a highly flexible template system that allows you to define abbreviations that expand into larger blocks of text, often with placeholders you can quickly navigate and fill.

And yes, setting it up pretty early in your configuration loading chain (e.g., directly in init.el or an early-loaded core file) is the correct approach, as it's a global utility that you'll want available across most of your editing sessions.
Why yasnippet?

    Powerful Templating: Supports plain text, Emacs Lisp code evaluation within snippets (for dynamic content like dates, filenames, etc.), tab stops for navigation, mirror fields (where one change updates multiple locations), and transformations.
    Mode-Specific: Snippets are organized by major mode, so your Python snippets don't clutter your HTML files.
    Integration: Seamlessly integrates with company-mode for completion.
    Community Snippets: A large collection of pre-made snippets (yasnippet-snippets package) is available for many languages.

yasnippet Setup in init.el

Here's the recommended setup for yasnippet:
Code snippet

;;; Core Snippets Setup (yasnippet)

(use-package yasnippet
  :ensure t                   ; Ensure yasnippet is installed
  :init
  (yas-global-mode 1)         ; Activate yasnippet globally for all buffers

  :config
  ;; Define where your user-created snippets will be stored
  ;; This directory structure will typically be ~/.emacs.d/snippets/<mode-name>/
  (setq yas-snippet-dirs
        '("~/.emacs.d/snippets"  ; Your personal snippets
          yas-snippet-dirs))     ; Keep the default snippets that come with packages

  ;; Optional: Enable snippet suggestions within company-mode's completion list
  ;; We already added company-yasnippet to company-backends in the previous step,
  ;; but this ensures it's properly handled for all modes.
  (defun company-mode/backend-with-yas (backend)
    (if (or (not company-mode/enable-yas)
            (and (listp backend) (member 'company-yasnippet backend)))
        backend
      (append (if (consp backend) backend (list backend)) '(:with company-yasnippet))))
  (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))

  ;; Reload snippets if you've made changes to files in yas-snippet-dirs
  (yas-reload-all)
  )

;; Optional: Install a common collection of snippets
;; You can explore other snippet collections on MELPA, but this is a good start.
(use-package yasnippet-snippets
  :ensure t) ; This package contains pre-made snippets for many modes

Explanation:

    use-package yasnippet :ensure t: Installs yasnippet if it's not already present.
    :init (yas-global-mode 1): This activates yasnippet in all major modes. You could also activate it selectively per-mode using hooks if you prefer (e.g., (add-hook 'prog-mode-hook #'yas-minor-mode)).
    yas-snippet-dirs: This variable tells yasnippet where to look for snippets.
        "~/.emacs.d/snippets": This is where you should create your own custom snippets. You'll typically create subdirectories inside it for each major mode (e.g., ~/.emacs.d/snippets/python-mode/, ~/.emacs.d/snippets/go-mode/).
        yas-snippet-dirs: By including this, you also ensure that yasnippet loads snippets that come bundled with other Emacs packages you install (like yasnippet-snippets). The order matters: your personal directory comes first, so your snippets will override bundled ones if they have the same trigger key.
    company-backends Integration: This ensures that company-mode will suggest yasnippet completions alongside LSP completions and other types of completions. We've refined the snippet from the previous company-mode answer to explicitly ensure company-yasnippet is considered alongside all other backends.
    yas-reload-all: After defining your snippet directories, it's good practice to reload all snippets. You'll also use this command after creating or modifying a snippet file manually.
    yasnippet-snippets: This is a separate package that provides a large, pre-built collection of snippets for many common programming languages. It's highly recommended to install it.

How to Use yasnippet

    Typing and Expanding:
        In a buffer, type the abbreviation (the "key") for a snippet (e.g., for for a for loop, main for a main function).
        Press TAB. yasnippet will try to expand the snippet. If company-mode is also active, it might appear in the completion list, and you can select it there.
        If multiple snippets have the same abbreviation, yasnippet might prompt you to choose.

    Navigating Placeholders:
        After a snippet expands, your cursor will typically jump to the first placeholder ($1).
        Press TAB repeatedly to jump to the next placeholder ($2, $3, etc.).
        Press S-TAB (Shift + TAB) to jump to the previous placeholder.
        When you reach the final placeholder ($0), pressing TAB again will jump the cursor to the end of the snippet (or back to the normal TAB behavior).
        If a placeholder is mirrored (e.g., $1 appears multiple times), editing one instance will update all mirrored instances.

    Creating Your Own Snippets:
        M-x yas-new-snippet: This is the easiest way. It will create a new buffer in snippet-mode with a template for a new snippet, pre-filled for the current major mode.
            You define the #key: (the abbreviation) and #name: (a descriptive name).
            Below ---, you write the snippet's content. Use $1, $2, etc., for tab stops, ${1:default-value} for placeholders with defaults, and $0 for the final cursor position.
            Press C-c C-c in the snippet-mode buffer to save and load the new snippet. It will be saved to the appropriate subdirectory in your yas-snippet-dirs path (e.g., ~/.emacs.d/snippets/python-mode/).
        M-x yas-visit-snippet-file: If you know the name of an existing snippet, this command will open its definition file for editing.
        Manually: You can also create text files directly in your ~/.emacs.d/snippets/<mode-name>/ directories (e.g., ~/.emacs.d/snippets/go-mode/myfunc). The file's content defines the snippet. After saving, run M-x yas-reload-all.

yasnippet is an incredibly powerful tool that will significantly speed up your coding by reducing repetitive typing. It integrates seamlessly with company-mode and your overall "IntelliSense" setup.

}}}
----
ORG-MODE(Extras !!)
    ~/Dropbox/rsc/samples/code/elisp/Org-DavyWil.el
    Org-Babel
Auto-Render Image-Links in Text-File {{{

That's a very interesting and practical twist! You're looking for an "auto-rendering" feature for image paths within a text buffer, similar to how some rich text editors or markdown viewers might display images inline. Emacs can absolutely do this using its powerful overlays feature.

The idea is to scan the buffer for image file paths when the file is opened, and for each valid path, create an overlay that replaces the text of the path with the actual image.
How it Works (Under the Hood)

    find-file-hook: When you open a file, Emacs runs functions registered to find-file-hook. We'll use this hook to trigger our image display logic.
    Regular Expressions: We'll use a regular expression to search for common image file extensions (.png, .jpg, .gif, .webp, .svg) within the buffer's text.
    file-exists-p: For each potential path found, we'll verify that it actually points to an existing file on your system.
    create-image: Emacs has a built-in function to create an image object from a file.
    make-overlay & overlay-put: An overlay is a temporary, invisible layer on top of your buffer's text. We'll create an overlay that covers the text of the image path. Then, we'll set its display property to the image object we created. This makes the image appear in place of the text.
    Interactivity: We can add a simple keymap to the overlay so that if you click on the displayed image, it can, for example, reveal the original path or even open the image file itself in a dedicated image viewer.
    evaporate property: Overlays can be set to "evaporate" (be deleted) if the text they cover is modified or deleted, which is a good cleanup mechanism.

Emacs Configuration for Auto-Displaying Images

Place the following code in your init.el or a file loaded early by it (e.g., ~/.emacs.d/lisp/image-display.el and then (require 'image-display) in init.el).
Code snippet

;;; image-display.el --- Automatic inline image display from paths -*- lexical-binding: t; -*-

(defvar my-auto-display-images-major-modes
  '(text-mode prog-mode conf-mode markdown-mode org-mode)
  "List of major modes in which to automatically display images from paths.
   Org-mode already has its own image display, so it's included mainly as an example.")

(defun my-display-images-in-buffer ()
  "Finds image paths in the current buffer and displays them as overlays.
   Adds a keymap to click the image to reveal its path and then visit it."
  (when (member major-mode my-auto-display-images-major-modes)
    (save-excursion
      (goto-char (point-min))
      ;; Regex to find common image file paths (excluding URLs, focusing on local paths)
      ;; This looks for patterns like: /path/to/image.png, ../image.jpg, C:/path/file.gif, etc.
      ;; Adjust the regex if you have very specific path formats.
      (while (re-search-forward "\\b\\([^[:space:]\"'\\]+\\.\\(png\\|jpe?g\\|gif\\|webp\\|svg\\)\\)\\b" nil t)
        (let* ((path-start (match-beginning 1))
               (path-end (match-end 1))
               (image-path (buffer-substring path-start path-end))
               image-overlay image-obj)

          ;; Resolve relative paths against the current buffer's directory
          (setq image-path (expand-file-name image-path (file-name-directory (buffer-file-name))))

          (when (file-exists-p image-path)
            ;; Try to create the image object. 'nil t' for scaling to fit line height
            (setq image-obj (ignore-errors (create-image image-path nil t)))
            (when image-obj
              ;; Create an overlay that covers the text path
              (setq image-overlay (make-overlay path-start path-end))
              ;; Set its 'display' property to show the image
              (overlay-put image-overlay 'display image-obj)
              ;; Store a custom property to identify our overlays for later cleanup
              (overlay-put image-overlay 'image-path-overlay-p t)
              ;; Store the original path for interactive use
              (overlay-put image-overlay 'path image-path)
              ;; Ensure it doesn't inherit background/foreground from text
              (overlay-put image-overlay 'face 'default)
              ;; Make the overlay disappear if the text it covers is deleted
              (overlay-put image-overlay 'evaporate t)

              ;; Add a keymap to the overlay for mouse clicks
              (let ((keymap (make-sparse-keymap)))
                (define-key keymap [mouse-1]
                  (lambda (event)
                    (interactive "e")
                    (let* ((clicked-overlay (posn-overlay (event-end event)))
                           (original-path (overlay-get clicked-overlay 'path)))
                      (when original-path
                        (message "Image path: %s. Click again or C-h f to visit file." original-path)
                        ;; Simple toggle: first click reveals, second visits
                        (if (eq (overlay-get clicked-overlay 'last-clicked-at) (current-time))
                            (find-file original-path)
                          (overlay-put clicked-overlay 'last-clicked-at (current-time)))))))
                (overlay-put image-overlay 'keymap keymap))

              ;; Move point past the current match to avoid finding the same path again
              (goto-char path-end)
              ))))))

(defun my-clear-image-overlays ()
  "Remove all image overlays created by `my-display-images-in-buffer` in the current buffer."
  (interactive)
  (dolist (overlay (overlays-in (point-min) (point-max)))
    (when (overlay-get overlay 'image-path-overlay-p) ; Check for our custom property
      (delete-overlay overlay)))
  (message "Image overlays cleared."))

;; --- Hook to activate on file open ---
(add-hook 'find-file-hook 'my-display-images-in-buffer)

;; Optional: Keybinding to clear overlays manually (e.g., if you want to edit paths)
(global-set-key (kbd "C-c i c") 'my-clear-image-overlays)

(provide 'image-display)

Explanation and Usage:

    my-auto-display-images-major-modes: This variable lists the major modes in which you want this feature to activate. I've included common text and programming modes. If you want it in a specific mode, add its mode symbol to this list. (Note: Org-mode has its own robust inline image display for Org links, so this might be redundant for Org files, but it's fine to include).
    my-display-images-in-buffer:
        It uses re-search-forward with a regular expression to find patterns that look like file paths ending with common image extensions. This regex is designed to capture paths like /home/user/pic.png, ../assets/logo.jpg, or even C:/images/test.gif on Windows.
        expand-file-name image-path (file-name-directory (buffer-file-name)) is crucial for correctly resolving relative paths based on the directory of the file you're currently editing.
        It checks file-exists-p to ensure the path is valid.
        create-image image-path nil t: This creates the image object. The t argument tells Emacs to scale the image proportionally to fit within the current line's height, which is usually desirable for inline display (it will make the line taller if the image is large).
        make-overlay and overlay-put 'display image-obj: This is the core of replacing the text with the image.
        overlay-put 'image-path-overlay-p t: This is a custom property we add to identify our overlays, making it easy to clear them later with my-clear-image-overlays.
        The keymap on the overlay allows you to click the displayed image with mouse-1. The first click reveals the path in the minibuffer; a second click will try to open that image file in a new buffer or external viewer using find-file.
        overlay-put image-overlay 'evaporate t: Ensures the overlay is removed automatically if you delete the text it was covering.
    my-clear-image-overlays: A simple function to manually remove all currently displayed image overlays in the buffer. This is useful if you want to see the raw text paths again (e.g., for editing). I've bound it to C-c i c.
    add-hook 'find-file-hook 'my-display-images-in-buffer: This is the line that makes it all happen automatically. Every time you open a file, this function will run.

To Use It:

    Add the code to your init.el or a file loaded by it.
    Restart Emacs.
    Create a new text file (or open an existing one) containing lines like:

    This is my text.
    Here's an image: /home/youruser/pictures/myphoto.png
    Another one: ../images/logo.jpg
    And a GIF: /tmp/animation.gif

    (Make sure these paths point to actual image files on your system).
    Save the file.
    Close the file and reopen it. You should now see the images displayed inline where their paths were!

This solution gives you a neat way to visually integrate images directly into your text files, enhancing your Emacs experience.

}}}
Read Aloud (with Piper/Cepstral) * {{{

Excellent! Focusing on Piper and Cepstral for local, natural-sounding British English voices is a solid plan, especially for reading large amounts of text.

To integrate these for reading Emacs buffers (or regions) aloud, we'll create a set of functions that:

    Extract the desired text from Emacs.
    Construct the appropriate command-line call for Piper or Cepstral.
    Execute this command asynchronously (so Emacs doesn't freeze).
    Play the generated audio file.
    Provide a way to stop the playback.

We'll place this setup in a new file, say ~/.emacs.d/lisp/tts.el, and load it from your init.el.
Prerequisites (Review)

Before configuring Emacs, ensure you have:

    Piper: Installed and its executable (piper) is in your system's PATH. Downloaded desired voice models (e.g., en_GB-cori-high.onnx and its metadata.json). The piper command needs to know where these models are, either by placing them in its default location or specifying the path with --model.
    Cepstral: Installed and its executable (swift) is in your system's PATH. You need at least one British English voice purchased and installed.
    An Audio Player: A command-line audio player like aplay (part of alsa-utils on Linux) or mpv (more versatile) installed and in your PATH. We'll use aplay in the examples for simplicity, but you can change it.
        sudo pacman -S alsa-utils (for aplay)
        sudo pacman -S mpv (for mpv)

Emacs Configuration for TTS (~/.emacs.d/lisp/tts.el)

Create the file ~/.emacs.d/lisp/tts.el and add the following content:
Code snippet

;;; tts.el --- Text-to-Speech integration -*- lexical-binding: t; -*-

(defvar my-tts-player-process nil
  "Holds the process object for the currently playing TTS audio.")

(defvar my-tts-output-dir (expand-file-name "tts/" temporary-file-directory)
  "Directory to store temporary TTS audio files.")

;; Ensure the output directory exists
(unless (file-directory-p my-tts-output-dir)
  (make-directory my-tts-output-dir t))

;; --- Helper Function to Stop Playback ---
(defun my-tts-stop-playback ()
  "Stops any currently playing TTS audio process."
  (interactive)
  (when (and my-tts-player-process (process-live-p my-tts-player-process))
    (message "Stopping TTS playback...")
    (kill-process my-tts-player-process)
    (setq my-tts-player-process nil)))

;; --- Core Function for TTS Synthesis and Playback ---
(defun my-tts-read-text (text tts-command-template &optional tts-binary-name audio-player-cmd)
  "Synthesizes and plays TEXT using TTS-COMMAND-TEMPLATE.
TTS-BINARY-NAME is the name of the TTS executable to check for.
AUDIO-PLAYER-CMD is the command to play the generated audio file."
  (interactive)
  (my-tts-stop-playback) ; Stop any previous playback

  (let* ((temp-file-name (make-temp-file "emacs-tts-" nil ".wav" my-tts-output-dir))
         (tts-binary (or tts-binary-name "espeak")) ; Default to espeak if not specified
         (player-cmd (or audio-player-cmd "aplay")) ; Default audio player
         (escaped-text (shell-quote-string text)))

    (unless (executable-find tts-binary)
      (message "Error: TTS binary '%s' not found in PATH." tts-binary)
      (when (string= tts-binary "piper")
        (message "Suggestion: Install Piper from https://github.com/rhasspy/piper"))
      (when (string= tts-binary "swift")
        (message "Suggestion: Install Cepstral TTS and ensure 'swift' is in PATH."))
      (signal 'user-error (format "TTS binary '%s' not found." tts-binary)))

    (unless (executable-find player-cmd)
      (message "Error: Audio player '%s' not found in PATH." player-cmd)
      (signal 'user-error (format "Audio player '%s' not found." player-cmd)))

    (message "Synthesizing audio (using %s)..." tts-binary)

    ;; Construct the full shell command to synthesize and then play
    ;; The `shell-quote-string` is crucial for handling special characters in text
    (let ((full-command (format tts-command-template
                                escaped-text
                                (shell-quote-string temp-file-name)
                                player-cmd
                                (shell-quote-string temp-file-name))))
      ;; Use `start-process-shell-command` for asynchronous execution
      (setq my-tts-player-process
            (start-process-shell-command "tts-player" "*TTS Process*" full-command))

      ;; Add a sentinel to clean up the temporary file after playback
      (set-process-sentinel my-tts-player-process
                            (lambda (process event)
                              (when (string-match-p "finished" event)
                                (message "TTS playback finished.")
                                (delete-file temp-file-name)
                                (setq my-tts-player-process nil))))
      )))

;; --- Specific Functions for Piper ---

;; Customize these for your Piper models and preferred voice
;; You might need to specify the full path to the .onnx model file
(defvar my-piper-model "en-gb-cori-high"
  "The Piper voice model to use (e.g., 'en-gb-cori-high').")

(defvar my-piper-model-path nil
  "Optional: Full path to the Piper model directory if not in default location.")

(defun my-piper-command-template ()
  "Returns the shell command template for Piper synthesis and playback."
  (format "echo %s | piper --model %s%s --output_file %s && %s %s"
          "%s" ; Placeholder for escaped text
          (shell-quote-string my-piper-model)
          (if my-piper-model-path
              (format " --model_path %s" (shell-quote-string my-piper-model-path))
            "")
          "%s" ; Placeholder for temp audio file
          "%s" ; Placeholder for audio player command
          "%s" ; Placeholder for temp audio file again
          ))

(defun my-read-buffer-aloud-piper ()
  "Reads the entire current buffer aloud using Piper TTS."
  (interactive)
  (my-tts-read-text (buffer-string) (my-piper-command-template) "piper" "aplay")) ; Or "mpv"

(defun my-read-region-aloud-piper ()
  "Reads the current region (selection) aloud using Piper TTS."
  (interactive)
  (if (use-region-p)
      (my-tts-read-text (buffer-substring-no-properties (region-beginning) (region-end))
                        (my-piper-command-template) "piper" "aplay") ; Or "mpv"
    (message "No region selected to read.")))

;; --- Specific Functions for Cepstral ---

;; Customize these for your Cepstral voice
(defvar my-cepstral-voice "William"
  "The Cepstral voice to use (e.g., 'William', 'Mary').")

(defun my-cepstral-command-template ()
  "Returns the shell command template for Cepstral synthesis and playback."
  (format "echo %s | swift --voice %s --output-file %s && %s %s"
          "%s" ; Placeholder for escaped text
          (shell-quote-string my-cepstral-voice)
          "%s" ; Placeholder for temp audio file
          "%s" ; Placeholder for audio player command
          "%s" ; Placeholder for temp audio file again
          ))

(defun my-read-buffer-aloud-cepstral ()
  "Reads the entire current buffer aloud using Cepstral TTS."
  (interactive)
  (my-tts-read-text (buffer-string) (my-cepstral-command-template) "swift" "aplay")) ; Or "mpv"

(defun my-read-region-aloud-cepstral ()
  "Reads the current region (selection) aloud using Cepstral TTS."
  (interactive)
  (if (use-region-p)
      (my-tts-read-text (buffer-substring-no-properties (region-beginning) (region-end))
                        (my-cepstral-command-template) "swift" "aplay") ; Or "mpv"
    (message "No region selected to read.")))

;; --- Keybindings (Optional, but recommended) ---
(global-set-key (kbd "C-c t s") 'my-tts-stop-playback) ; Stop playback

(global-set-key (kbd "C-c t p b") 'my-read-buffer-aloud-piper) ; Piper: Read Buffer
(global-set-key (kbd "C-c t p r") 'my-read-region-aloud-piper) ; Piper: Read Region

(global-set-key (kbd "C-c t c b") 'my-read-buffer-aloud-cepstral) ; Cepstral: Read Buffer
(global-set-key (kbd "C-c t c r") 'my-read-region-aloud-cepstral) ; Cepstral: Read Region

(provide 'tts)

Explanation of the tts.el Code:

    my-tts-player-process: A global variable to hold the Emacs process object of the currently running audio player. This allows us to stop it later.
    my-tts-output-dir: Defines a temporary directory for the generated audio files. This keeps your main directories clean.
    my-tts-stop-playback: This crucial function checks if a TTS process is active and, if so, kills it. Bind this to an easy-to-remember key (e.g., C-c t s).
    my-tts-read-text (text tts-command-template &optional tts-binary-name audio-player-cmd):
        This is the core helper function. It takes the text to read, a template for the TTS command (which we'll customize for Piper and Cepstral), and the names of the TTS binary and audio player to check for.
        It first calls my-tts-stop-playback to ensure no overlapping audio.
        It creates a unique temporary .wav file name.
        It checks if the required TTS binary (piper, swift) and audio player (aplay, mpv) are found in your PATH. If not, it signals an error and gives a hint.
        It constructs the full-command string. This string combines the TTS synthesis command (piping text, generating WAV) and then immediately playing that WAV file using your chosen audio player (e.g., piper ... > /tmp/file.wav && aplay /tmp/file.wav). The && ensures aplay only runs if piper succeeds.
        shell-quote-string is extremely important here. It correctly escapes any special characters in the text, preventing shell injection issues or malformed commands.
        start-process-shell-command executes the full-command in a separate shell process. This is what keeps Emacs responsive while the audio plays.

        set-process-sentinel: This sets up a "callback" function that runs when the tts-player process finishes or changes state. When playback finished, it cleans up the temporary WAV file and resets my-tts-player-process.
    my-piper-command-template: Defines the specific command structure for Piper. You might need to adjust my-piper-model and potentially my-piper-model-path if your Piper models aren't in Piper's default search locations.
    my-read-buffer-aloud-piper / my-read-region-aloud-piper: These are the user-facing functions that call my-tts-read-text with Piper's template and binary name.
    my-cepstral-command-template: Defines the specific command structure for Cepstral's swift tool. Customize my-cepstral-voice to match the voice you purchased.
    my-read-buffer-aloud-cepstral / my-read-region-aloud-cepstral: User-facing functions for Cepstral.
    Keybindings: Global keybindings are provided for convenience. C-c t is a good prefix for TTS commands.

Integrating tts.el into Your init.el

Finally, in your main init.el file, you need to load this new tts.el file. Place it early, but after your use-package setup (so use-package is available).
Code snippet

;; In your init.el file

;; ... other core setup (like use-package, general settings) ...

;; Load TTS functions
(add-to-list 'load-path "~/.emacs.d/lisp") ; Ensure Lisp directory is in load-path
(require 'tts)

;; ... rest of your init.el ...

After setting this up and restarting Emacs, you'll be able to:

    Use C-c t p b to read the entire buffer with Piper.
    Use C-c t p r to read a selected region with Piper.
    Use C-c t c b to read the entire buffer with Cepstral.
    Use C-c t c r to read a selected region with Cepstral.
    Use C-c t s to stop any ongoing playback.

Enjoy your natural-sounding Emacs reader!

}}}


SYNTAX-HIGHLIGHTING FOR SEVERAL LANGUAGES (IN THE SAME FILE) {{{

That's an excellent question, and yes, Emacs does indeed have impressive capabilities for multi-language syntax highlighting within a single file, often referred to as polymode or multi-mode editing.
Emacs's Built-in Capabilities vs. Dedicated Solutions

    Basic Built-in Handling:
    Some major modes are designed to be aware of embedded languages to a certain extent. For instance:
        web-mode: This is a powerful major mode for HTML, CSS, and JavaScript. If you open an .html file, web-mode will automatically detect and apply different syntax highlighting to the HTML tags, the contents of <style> blocks (CSS), and the contents of <script> blocks (JavaScript). It handles indentation reasonably well across these languages.
        Lisp-like Languages (e.g., emacs-lisp-mode, clojure-mode): These often support a certain level of "inner language" highlighting for strings that contain other languages (e.g., SQL queries or regular expressions within Lisp strings), though this is more specialized.

    For common web development (HTML/CSS/JS), web-mode often works "out of the box" for basic highlighting and indentation without extra steps beyond installing the web-mode package itself.

    Dedicated Multi-Mode Solutions (Recommended for Full Power):
    While web-mode is good, for true, robust multi-language editing where each embedded language behaves almost like its own major mode (with its own keybindings, specific LSP features, C-x C-e evaluation, etc.), you typically need a dedicated solution. The most popular and powerful package for this is polymode.

    polymode allows you to define "host" modes (e.g., html-mode) and "inner" modes (e.g., css-mode, js-mode), along with the delimiters that mark their regions. When you move your cursor into an embedded CSS block, polymode effectively activates css-mode (or a derivative) just for that region, giving you all the features of css-mode within that context.

Extra Setup Required for polymode

Yes, polymode requires a bit of extra setup to define how it should handle different embedded languages, as it's highly customizable.

Here's how you might configure polymode for HTML/CSS/JS, to be placed in your modular configuration (e.g., ~/.emacs.d/lisp/web.el):
Code snippet

;;; web.el --- Configuration for web development with polymode -*- lexical-binding: t; -*-

;; Ensure polymode is installed
(use-package polymode
  :ensure t
  :hook (html-mode . poly-web-mode) ; Activate poly-web-mode when html-mode starts
  :config

  ;; You might want to disable default web-mode for polymode,
  ;; or ensure html-mode is the base for .html files.
  ;; If you primarily use web-mode for web files, keep it:
  (use-package web-mode
    :mode (("\\.html?\\'" . web-mode)
           ("\\.erb\\'" . web-mode)
           ("\\.ejs\\'" . web-mode)
           ("\\.php\\'" . web-mode)
           ("\\.vue\\'" . web-mode))
    :hook (web-mode . (lambda ()
                        (setq indent-tabs-mode nil)
                        (setq web-mode-markup-indent-offset 2) ; HTML indent
                        (setq web-mode-css-indent-offset 2)    ; CSS indent
                        (setq web-mode-javascript-indent-offset 2) ; JS indent
                        (electric-pair-mode 1)
                        (add-hook 'before-save-hook 'delete-trailing-whitespace nil t))))


  ;; Define the polymode for web files (HTML as host, CSS/JS as inner)
  ;; This tells polymode to use `html-mode` as the base, and then embed
  ;; `css-mode` for `<style>` blocks and `js-mode` for `<script>` blocks.
  (define-hostmode poly-html-hostmode :mode 'html-mode)
  (define-innermode poly-css-innermode :mode 'css-mode :hostmode 'poly-html-hostmode
    :head-regex "<style[^>]*>" :tail-regex "</style>")
  (define-innermode poly-js-innermode :mode 'js-mode :hostmode 'poly-html-hostmode
    :head-regex "<script[^>]*>" :tail-regex "</script>")

  ;; Now, combine these into a multi-mode
  (define-multimode poly-web-mode
    :hostmode 'poly-html-hostmode
    :innermodes '(poly-css-innermode poly-js-innermode))

  ;; Optional: Associate file types with `poly-web-mode` instead of `web-mode`
  ;; If you prefer `polymode` over `web-mode` for multi-language files,
  ;; you'd typically set this after the `web-mode` definition to override it.
  ;; (add-to-list 'auto-mode-alist '("\\.html?\\'" . poly-web-mode))
  ;; Or, use a hook with `web-mode` if you want `web-mode` to be the base,
  ;; and polymode to activate on top of it.
  ;; A common pattern is to use `web-mode` as the major mode, and `polymode`
  ;; acts like a minor mode on top of it. However, the above `define-hostmode`
  ;; usually implies `html-mode` as the core.
  ;; For HTML, `web-mode` is so good that you might not need polymode unless
  ;; you have very specific requirements or non-standard embedding.

  ;; Polymode shines more for things like Markdown with embedded code blocks,
  ;; or configuration files with embedded snippets of other languages.
  ;; For standard web files, `web-mode` is often sufficient for highlighting.

  ;; If you want LSP with Polymode:
  ;; Eglot generally works very well with polymode. When you're in an inner mode region,
  ;; Eglot will correctly send requests to the LSP server appropriate for that inner mode.
  ;; For example, when in a <script> block, Eglot will talk to your JavaScript LSP server.
  ;; You just need to ensure you have your `eglot-server-programs` set up for `js-mode`
  ;; and `css-mode` as usual in their respective config files (e.g., `javascript.el`, `css.el`).
  ;; No special `polymode` configuration is typically needed for Eglot itself.
  )

Key Takeaways on Polymode Setup:

    define-hostmode: Specifies the base mode for the file (e.g., html-mode).
    define-innermode: Specifies the embedded mode (css-mode, js-mode), its host, and the regular expressions that define its start (:head-regex) and end (:tail-regex).
    define-multimode: Combines the host and inner modes into a single multimode.
    auto-mode-alist or Hooks: You then associate your file types with this new poly-web-mode using add-to-list 'auto-mode-alist.

Polymode and LSP (Eglot)

One of the greatest strengths of polymode is its excellent compatibility with LSP clients like Eglot. When you're editing within an embedded region managed by polymode:

    Eglot Context: Eglot becomes aware of the "inner" major mode (e.g., js-mode when in a JavaScript block).
    Correct Server Invocation: When you ask for completion or diagnostics (M-., C-x C-e), Eglot will correctly send the request to the appropriate language server for that embedded language, assuming you have configured eglot-server-programs for js-mode, css-mode, etc., in their respective language configuration files.

So, for example, your javascript.el file would still have:
Code snippet

;;; javascript.el
(use-package js-mode ...)
(use-package eglot
  :hook (js-mode . eglot-ensure)
  :config
  (add-to-list 'eglot-server-programs '(js-mode . ("typescript-language-server" "--stdio")))
  ...)

And polymode would ensure that when you're in a <script> block, Emacs behaves as if you're in js-mode, and Eglot will route requests to typescript-language-server.

In conclusion, for simple highlighting in common web formats, web-mode might be enough without explicit polymode setup. But for true, interactive multi-language editing with full features like LSP, polymode is the way to go, and it does require specific configuration to tell it how your languages are embedded.

}}}
NuShell {{{

Okay, let's dive into NuShell! NuShell (nu) is a very modern and interesting shell that blends traditional shell concepts with a structured data approach, often inspired by functional programming.

Emacs support for NuShell is primarily provided by nu-mode and its integration with the official NuShell Language Server (nu-lsp).
Emacs Configuration for NuShell (init.el / ~/.emacs.d/lisp/languages/nushell.el)

We'll set up nu-mode and then integrate it with eglot for LSP support, which will provide features like completion, diagnostics, and definition lookup.

Crucial Prerequisite (Outside of Emacs):

    NuShell (nu): You need to have NuShell installed on your system.
        Installation: The recommended way is often via cargo (Rust's package manager) if you have Rust installed, or via a system package manager.
            With cargo: cargo install nu --features default,extra
            Arch Linux (from AUR): yay -S nushell or paru -S nushell
            Refer to the official NuShell website for the most up-to-date installation instructions for your OS.
        Ensure the nu executable (and thus nu-lsp, which is often bundled or invoked by nu) is in your system's PATH.

Here's the use-package configuration to go into your modular setup (e.g., ~/.emacs.d/lisp/languages/nushell.el):
Code snippet

;;; nushell.el --- Configuration for NuShell -*- lexical-binding: t; -*-

(use-package nu-mode
  :mode (("\\.nu\\'" . nu-mode)     ; Activate nu-mode for .nu files
         ("\\.config.nu\\'" . nu-mode) ; Common NuShell config file
         )
  :hook (nu-mode . (lambda ()
                       (setq indent-tabs-mode nil) ; Prefer spaces
                       (setq tab-width 2)           ; 2 spaces (common for shell scripts/configs)
                       (electric-pair-mode 1)       ; Auto-pair brackets, parens, etc.
                       (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; --- Eglot for NuShell Language Server (nu-lsp) ---
  ;; This provides advanced features like completion, definition lookup, diagnostics.
  (use-package eglot
    :hook (nu-mode . eglot-ensure) ; Automatically activate eglot when nu-mode is used
    :config
    ;; Tell eglot how to start the NuShell Language Server.
    ;; The `nu` executable itself typically invokes the LSP server.
    ;; If `nu-lsp` was a standalone binary, you'd use that here.
    (add-to-list 'eglot-server-programs '(nu-mode . ("nu" "lsp")))

    ;; --- Optional: Check for NuShell binary presence ---
    ;; This leverages your custom `my-check-and-suggest-install-binary` function.
    (add-hook 'eglot-managed-mode-hook
              (lambda ()
                (when (eq major-mode 'nu-mode)
                  (my-check-and-suggest-install-binary
                   "nu"
                   "cargo install nu --features default,extra"
                   "sudo pacman -S nushell (Arch Linux AUR)"
                   "brew install nushell (macOS)"
                   "scoop install nu (Windows with Scoop)"
                   "winget install nushell.nushell (Windows with Winget)")
                  ;; Enable formatting on save via LSP (if nu-lsp supports it fully)
                  (add-hook 'before-save-hook #'eglot-format-buffer nil t))))
    )

  ;; --- Flycheck for diagnostics (integrates with eglot) ---
  (use-package flycheck
    :hook (nu-mode . flycheck-mode)
    :init (global-flycheck-mode))

  ;; --- Company-mode for auto-completion (integrates with eglot) ---
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 2)
    (add-to-list 'company-backends 'company-capf)) ; Eglot provides completion via company-capf

  ;; --- Optional: Inferior NuShell Process ---
  ;; For running NuShell scripts interactively from Emacs.
  ;; You might want to define a custom function or use `M-x shell` and then `nu`.
  ;; A more integrated inferior process would require a package like `compilation-mode`
  ;; or custom Elisp to send region/buffer to a `nu` process.
  ;; As of now, `nu-mode` doesn't provide built-in `M-x run-nushell` or `C-c C-c` like
  ;; some other language modes do directly. You'd typically use `M-!` to run commands
  ;; or `M-x compile` for a project build.
  )

Explanation of the nushell.el snippet:

    use-package nu-mode: The main mode for NuShell.
        :mode: Associates .nu files and the common .config.nu file with nu-mode.
        :hook: Sets up 2-space indentation, electric pairing (for {} and []), and trimming trailing whitespace on save.
    use-package eglot: Integrates with the NuShell Language Server.
        :hook (nu-mode . eglot-ensure): Activates Eglot when you open a .nu file.
        add-to-list 'eglot-server-programs '(nu-mode . ("nu" "lsp")): This is the crucial line that tells Eglot to launch the NuShell LSP server by running nu lsp.
        Binary Check: The my-check-and-suggest-install-binary call within eglot-managed-mode-hook will use your helper function to warn you if nu isn't found, displaying installation suggestions.
        Formatting on Save: A common LSP feature, enabled if the nu-lsp server supports it.
    use-package flycheck & use-package company: These integrate seamlessly with Eglot to provide real-time diagnostics (errors, warnings) and intelligent code completion, powered by the NuShell Language Server.

Useful Keyboard Shortcuts for NuShell in Emacs

Most of your interaction will leverage general Emacs commands and Eglot's LSP features.

General Emacs Shortcuts:

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: You can use this to run NuShell scripts directly or to compile project (if your NuShell project uses a build system).
        Example command: nu path/to/your/script.nu
        M-g n / M-g p: Navigate to next/previous error in the *compilation* buffer.
    C-M-a / C-M-e: Move backward/forward S-expression (useful for structured data in NuShell).
    M-! (shell-command): Run a single NuShell command in the minibuffer.
    M-x shell: Open a general shell buffer (*shell*), where you can then type nu to start a NuShell interactive session.

Eglot/LSP Shortcuts (when nu-mode is active):

These are the standard Eglot commands, powered by nu-lsp:

    M-.: Go to definition.
    M-,: Go back (pop mark).
    M-x xref-find-references: Find all references to the symbol at point.
    M-x eglot-rename: Rename a symbol across your project.
    M-x eglot-code-action: Access quick fixes or refactoring options.
    M-x eglot-hover: Show documentation/type info for the symbol at point.
    M-x eglot-format-buffer: Format the current buffer (if nu-lsp supports it).
    M-x eglot-reconnect: Reconnect to the language server if it crashes or you need to restart it.

This setup should give you a very productive environment for writing NuShell scripts and configuration files within Emacs!

}}}
(Guile) Scheme {{{

- And as an example, what exact
  lines would I have to add to my
  init.el to get it to include or
  install geiser?

Okay, here are the exact lines you would typically add to your init.el file to ensure that the geiser package is available and installed (if it's not already):
Code snippet


;; Ensure package.el is initialized and MELPA is configured
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(unless package-archive-contents
  (package-refresh-contents))
(package-initialize)


___config
;; Install geiser if it's not already installed
(unless (package-installed-p 'geiser)
  (package-install 'geiser))

;; Optional: Load geiser mode automatically for Scheme files
(add-to-list 'auto-mode-alist '("\\.scm\\'" . geiser-mode))
(add-to-list 'auto-mode-alist '("\\.ss\\'" . geiser-mode))
(add-to-list 'auto-mode-alist '("\\.rkt\\'" . geiser-mode)) ;; For Racket files as well, if you use it

;; Optional: Basic configuration for geiser (you can customize further)
(setq geiser-default-implementation 'guile) ;; Set Guile as the default implementation


Explanation of each part:

    ;; Ensure package.el is initialized and MELPA is configured:
        (require 'package): Loads the package.el library, which is Emacs' built-in package manager.
        (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/")): Adds the MELPA package archive to the list of sources Emacs checks for packages. MELPA is a popular community-maintained archive with many useful packages, including geiser.
        (unless package-archive-contents (package-refresh-contents)): Checks if the list of available packages is downloaded. If not, it refreshes the package contents from the configured archives.
        (package-initialize): Initializes the package system, making installed packages available.

    ;; Install geiser if it's not already installed:
        (unless (package-installed-p 'geiser) ...): This checks if the geiser package is already installed. package-installed-p returns t (true) if the package is installed and nil (false) otherwise.
        (package-install 'geiser): If geiser is not installed, this line will download and install it from the configured package archives (in this case, MELPA).

    ;; Optional: Load geiser mode automatically for Scheme files:
        (add-to-list 'auto-mode-alist '("\\\\.scm\\''" . geiser-mode)): This tells Emacs to automatically switch to geiser-mode whenever you open a file with the .scm extension. The double backslashes are needed to escape the special characters in the regular expression. The \' at the end ensures it matches the whole filename component.
        The following lines do the same for files with .ss and .rkt extensions, which are also commonly used for Scheme-like languages (including Racket, which geiser can also support).

    ;; Optional: Basic configuration for geiser (you can customize further):
        (setq geiser-default-implementation 'guile): This sets the default Scheme implementation that geiser will try to connect to as guile. Make sure you have guile installed on your system and that it's in your system's PATH.

How to use these lines:

    Open your init.el file (usually found at ~/.emacs or ~/.config/emacs/init.el).
    Copy and paste these lines into your init.el file. You can place them anywhere after the initial comments or setup you might already have. It's generally good practice to group package-related configuration together.
    Save your init.el file.
    Restart Emacs.

When Emacs starts, it will:

    Initialize the package system.
    Check if geiser is installed. If not, it will download and install it. You might see some activity in the minibuffer at the bottom of the Emacs window during this process.
    For any .scm, .ss, or .rkt files you open, Emacs should automatically enable geiser-mode.
    Set Guile as the default implementation for geiser.

After Emacs restarts, try opening a .scm file. You should see syntax highlighting, and you can then use geiser's commands (like C-c C-s i to start the Guile REPL) to interact with your Guile environment.

Remember to have Guile installed on your system for geiser to connect to it. If Guile is not in your system's PATH, you might need to configure geiser-guile-program to point to the Guile executable. You can do this with (setq geiser-guile-program "/path/to/guile") in your init.el.


- Could we go back to Emacs and
  geiser for just a bit: Could you
  give me some direction on some
  interesting and useful features
  that are available when editing
  and testing Guile Scheme code?

Absolutely! geiser provides a wealth of fantastic features that significantly enhance the experience of editing and testing Guile Scheme code within Emacs. Here's a rundown of some of the most interesting and useful ones:

1. Interactive REPL (Read-Eval-Print Loop):

    Starting the REPL: The most fundamental feature is the interactive Guile REPL. You can typically start it with C-c C-s i (Ctrl+c Ctrl+s followed by i). This will open a new Emacs window or buffer where you can directly type and evaluate Guile expressions.
    Evaluating Code from Buffer: You can send code from your current Scheme buffer to the REPL for evaluation:
        C-c C-e (Eval Expression): Evaluates the expression at point (cursor).
        C-c C-r (Eval Region): Evaluates the currently selected region of code.
        C-c C-b (Eval Buffer): Evaluates the entire current buffer.
    Output in REPL: The results of the evaluated expressions are displayed directly in the REPL buffer, allowing you to see the output and any errors immediately.

2. Navigation and Information:

    Finding Definitions: Quickly jump to the definition of a function, variable, or module:
        M-. (Meta+period) on a symbol will take you to its definition.
        M-*, (Meta+comma) will take you back to where you jumped from.
    Finding Documentation: Access Guile's documentation directly within Emacs:
        C-c C-d d (Describe Definition): Shows the documentation string (if available) for the symbol at point.
        C-c C-d i (Describe Implementation): Shows information about the implementation of the symbol.
        C-c C-d m (Describe Module): Shows information about the current module or the module at point.
    Autocompletion: geiser often provides autocompletion for symbols as you type, especially when connected to the REPL. You can usually trigger it with M-TAB (Meta+Tab).

3. Debugging:

    Integration with Guile's Debugger: geiser provides excellent integration with Guile's built-in debugger.
        Setting Breakpoints: You can set breakpoints in your code using C-c C-a b (Add Breakpoint).
        Starting the Debugger: When your code hits a breakpoint, the debugger will activate in the REPL buffer, allowing you to step through code, inspect variables, and examine the call stack.
        Stepping Commands: Common debugger commands like n (next), s (step), c (continue), f (finish), and q (quit) are available within the debugger.
        Inspecting Variables: You can evaluate expressions in the debugger to inspect the values of variables.

4. Code Editing Enhancements:

    Syntax Highlighting: geiser (building on scheme-mode) provides accurate and helpful syntax highlighting, making your code easier to read and understand.
    Indentation: It automatically handles Scheme's indentation rules, ensuring your code is formatted correctly and consistently.
    Parenthesis Matching: Emacs' built-in parenthesis matching is enhanced in geiser-mode, making it easier to keep track of nested expressions.
    Code Formatting: While geiser itself might not have extensive code formatting capabilities, it works well with external formatting tools that you can integrate into your Emacs workflow.

5. Module Management:

    Loading Modules: You can easily load Guile modules within the REPL using standard Guile syntax. geiser helps in keeping track of the loaded environment.
    Exploring Modules: The "Describe Module" (C-c C-d m) command is very useful for understanding the contents of a Guile module.

6. Customization:

    Implementation Switching: If you work with multiple Scheme implementations, geiser allows you to switch between them (though you've already set Guile as the default).
    REPL Customization: You can customize the appearance and behavior of the REPL buffer.
    Keybindings: Many of geiser's keybindings can be customized to fit your preferences.

How to Explore These Features:

    Start geiser-mode: Open a .scm file, and Emacs should automatically enter geiser-mode (if you added the auto-mode-alist lines). You'll likely see (Geiser) in your mode line.
    Start the REPL: Press C-c C-s i.
    Evaluate Code: Type some simple Guile expressions in your .scm buffer and try C-c C-e, C-c C-r, and C-c C-b. Observe the output in the REPL.
    Navigate: Place your cursor on a known function or variable in your code and try M-. to jump to its definition. Use M-*, to go back.
    Check Documentation: With the cursor on a standard Guile function (like map or +), try C-c C-d d.
    Experiment with Breakpoints and Debugging: Insert a (debug) statement in your Guile code. Evaluate the code (e.g., with C-c C-b). When the debug statement is reached, you should enter the Guile debugger in the REPL. Try the stepping commands (n, s). You can also try setting a breakpoint using C-c C-a b and then running your code.

By actively using these keybindings and exploring the commands available under the C-c C-s and C-c C-d prefixes in geiser-mode, you'll quickly discover how powerful it is for Guile development in Emacs. Don't hesitate to consult the geiser documentation (often accessible via C-h i g geiser RET) for even more advanced features and customization options. Enjoy your Guile coding!


}}}
+Other Schemes {{{

You're looking to expand your Emacs Scheme horizons beyond just Guile, which is a fantastic goal! Geiser is indeed an excellent choice for a unified interactive Scheme development environment in Emacs, as it supports multiple Scheme implementations. The key to "dabbling" in other dialects with Geiser is to tell it where to find each interpreter.

Here's how you'd extend your init.el to include support for Gambit, Chicken, Chez Scheme, and Racket alongside your existing Guile setup, leveraging Geiser's capabilities and adding specific mode configurations where beneficial.

Crucial Prerequisites (Outside of Emacs):

For each Scheme dialect, you must have its interpreter installed on your system and accessible in your PATH. Geiser will launch these interpreters as inferior processes.

    Gambit Scheme: Download and install from the Gambit website. Ensure gsi (Gambit Scheme Interpreter) is in your PATH.
    Chicken Scheme: Download and install from the Chicken Scheme website. Ensure csi (Chicken Scheme Interpreter) is in your PATH.
    Chez Scheme: Download and install from the Chez Scheme website. Ensure scheme (or chez depending on your install) is in your PATH.
    Racket: Download and install from the Racket website. Ensure racket is in your PATH.

Emacs Configuration for Multiple Scheme Dialects (init.el)

We'll leverage Geiser's ability to handle multiple backends. For Racket, there's also racket-mode which provides some Racket-specific niceties that geiser-mode might not cover by default, so we'll include that.
Code snippet

;; --- Emacs Package Management Preamble ---
;; (As established, this section ensures that packages are automatically installed
;; if they are not already present, based on your use-package declarations.)

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
;; (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

;; --- End of Emacs Package Management Preamble ---


;; --- Geiser (General Scheme) Configuration ---
;; Assuming you already have a basic Geiser setup for Guile.
;; The key is to tell Geiser about the other interpreters.

(use-package geiser
  :defer t ; Defer loading until a Scheme file is opened or command run
  :config
  ;; Global hook for all Geiser modes (geiser-mode, geiser-repl-mode)
  (add-hook 'geiser-mode-hook (lambda ()
                                (setq indent-tabs-mode nil) ; Use spaces
                                (setq tab-width 2)           ; 2 spaces for Scheme (common)
                                (setq lisp-indent-offset 2)  ; Crucial for Lisp-like languages
                                (electric-pair-mode 1)
                                (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))

  ;; --- Configure Geiser for each Scheme implementation ---
  ;; Geiser uses `geiser-implementations` to know about different Scheme binaries.
  ;; You can specify the executable path directly or just the name if it's in your PATH.

  ;; Guile (assuming you already have this set up, but for completeness)
  (setq geiser-guile-binary "guile") ; or "/path/to/guile"

  ;; Gambit Scheme
  (setq geiser-gambit-binary "gsi") ; or "/path/to/gsi"
  ;; Ensure .scm files are handled by geiser-mode, but specify Gambit if preferred for some files
  (add-to-list 'auto-mode-alist '("\\.scm\\'" . geiser-mode))
  (add-to-list 'geiser-implementations '(gambit . "Gambit Scheme")) ; For displaying in Geiser menus

  ;; Chicken Scheme
  (setq geiser-chicken-binary "csi") ; or "/path/to/csi"
  (add-to-list 'geiser-implementations '(chicken . "Chicken Scheme"))

  ;; Chez Scheme
  (setq geiser-chez-binary "scheme") ; or "/path/to/scheme" (or "/path/to/chez")
  (add-to-list 'geiser-implementations '(chez . "Chez Scheme"))

  ;; Racket
  ;; Racket has its own mode (`racket-mode`), but Geiser can also connect to it.
  ;; If you primarily use `racket-mode` for `.rkt` files, this might be less critical.
  (setq geiser-racket-binary "racket") ; or "/path/to/racket"
  (add-to-list 'geiser-implementations '(racket . "Racket"))

  ;; Default implementation (optional, otherwise Geiser prompts you)
  ;; (setq geiser-default-implementation 'guile) ; or 'racket, 'chicken, etc.

  ;; Flycheck for Scheme (e.g., using a linter or compiler warnings)
  (use-package flycheck
    :init (global-flycheck-mode)
    :config
    ;; Geiser often integrates its own Flycheck checkers, but you can add general ones.
    ;; For Racket, `racket-mode` will configure its own checker if available.
    )

  ;; Company-mode for Scheme completion (integrates with Geiser)
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 2)
    (add-to-list 'company-backends 'company-geiser) ; Geiser provides its own backend
    )
  )

;; --- Racket-mode (Specific for Racket features) ---
;; While Geiser can connect to Racket, `racket-mode` often provides
;; more Racket-specific tooling and better integration with `racket` itself.
;; It's generally recommended for Racket development.
(use-package racket-mode
  :mode "\\.rkt\\'" ; Activate racket-mode for .rkt files
  :hook (racket-mode . (lambda ()
                         (setq indent-tabs-mode nil)
                         (setq tab-width 2)
                         (setq lisp-indent-offset 2)
                         (electric-pair-mode 1)
                         (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; Customize racket-mode specific settings
  ;; For example, to use a specific racket executable if not in PATH
  ;; (setq racket-program "/path/to/racket")

  ;; Integrate with `raco` tools
  ;; (setq racket-run-program "raco")
  )

Explanation of the init.el Snippet:

    use-package geiser: This is your central hub for Scheme.
        :defer t: Geiser is a large package, so deferring its loading means Emacs starts faster and only loads Geiser when you open a Scheme file or explicitly invoke a Geiser command.
        geiser-mode-hook: This hook applies consistent Lisp-style indentation (2 spaces, lisp-indent-offset) and electric pairing to all Geiser-managed buffers.
        geiser-implementations: This is the critical variable. You add entries for each Scheme interpreter you want Geiser to recognize.
            geiser-guile-binary, geiser-gambit-binary, geiser-chicken-binary, geiser-chez-binary, geiser-racket-binary: These variables define the executable path for each interpreter. If the executable is in your system's PATH, just the name (e.g., "gsi") is sufficient. Otherwise, provide the full path.
            (add-to-list 'geiser-implementations '(gambit . "Gambit Scheme")): This adds a human-readable name for each implementation, which will appear in Geiser's "Switch to Implementation" menu.
        flycheck and company: Geiser integrates well with both. company-geiser provides completion directly from the running Scheme REPL.
    use-package racket-mode: While Geiser can talk to Racket, racket-mode is often preferred for dedicated Racket development because it provides features more tightly integrated with the Racket toolchain (like raco).
        :mode "\\.rkt\\'": Ensures .rkt files (Racket's standard extension) open in racket-mode.
        Its :hook sets similar Lisp-style indentation.
        racket-program: Similar to Geiser's interpreter settings, you can specify the racket executable path.

How to Use and "Dabble"

Once this is set up:

    Open a Scheme file:
        For .scm files, it will default to geiser-mode.
        For .rkt files, it will open in racket-mode.
    Select your Scheme Implementation (in geiser-mode buffers):
        If you're in a geiser-mode buffer (e.g., a .scm file), press C-c C-c. Geiser will ask you which Scheme implementation you want to use for that buffer (if it's the first time). You'll see "Guile", "Gambit Scheme", "Chicken Scheme", "Chez Scheme", "Racket", etc., based on your geiser-implementations list.
        Once chosen, Geiser will start the corresponding REPL (*scheme* or *guile*, *gambit*, etc.) and connect the buffer to it.
        To change the implementation for the current buffer, use M-x geiser-switch-implementation.
    Racket-mode: For .rkt files, racket-mode starts its own interactive process (*Racket* buffer) when you evaluate code. It generally manages itself well.

Useful Keyboard Shortcuts

Many shortcuts are common across Geiser-managed Scheme modes, and some are specific to racket-mode.

General Emacs Shortcuts (applicable to all Schemes):

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    C-M-a / C-M-e: Move backward/forward S-expression (essential for Lisp navigation!).
    C-M-f / C-M-b: Move forward/backward a sexp.
    C-M-k: Kill sexp.
    C-M-DEL: Kill backward sexp.
    C-M-t: Transpose sexps.
    C-M-q (indent-sexp): Indent the current S-expression.
    M-x indent-region: Indent the selected region.
    M-x compile: For compiling Scheme projects or running build commands.
        csc my_file.scm (Chicken)
        gambitc my_file.scm (Gambit)
        raco make my_file.rkt (Racket)
        M-x recompile / M-g n / M-g p for error navigation.

Geiser Specific Shortcuts (in geiser-mode or geiser-repl-mode):

These commands interact with the chosen inferior Scheme process.

    C-x C-e: Evaluate the form preceding point and display result in the minibuffer. (Very common!)
    C-M-x: Evaluate the top-level form at point.
    C-c C-r: Evaluate the current region.
    C-c C-l: Load the current buffer into the Scheme REPL.
    C-c C-z: Switch to the current Scheme REPL buffer (*scheme*, *guile*, *gambit*, etc.).
    C-c C-b: Interrupt the running Scheme process.
    C-c C-k: Kill the running Scheme process.
    C-c C-a: Insert (Geiser) template for a definition (e.g., define).
    C-c C-d C-t: Show type of symbol at point (if supported by the implementation).
    C-c C-d C-d: Show documentation for symbol at point.
    C-c C-d C-f: Find definition of symbol at point.
    C-c C-p: Switch to previous buffer.
    C-c C-n: Switch to next buffer.

Racket-mode Specific Shortcuts (in .rkt files):

    C-c C-c (racket-run): Run the current Racket file. Output appears in *Racket* buffer.
    C-x C-e: Evaluate the form preceding point (displays result in minibuffer).
    C-c C-b (racket-debug): Start debugger for the current Racket file.
    C-c C-k (racket-kill): Kill the Racket process.
    C-c C-z (racket-repl): Switch to the *Racket* REPL buffer.
    C-c C-f (racket-format): Format the buffer using raco fmt. (Requires raco fmt to be installed).
    C-c C-d C-p (racket-doc): Look up documentation for the symbol at point.
    C-c C-d C-t (racket-describe): Show type of expression at point.
    M-. (racket-goto-definition): Go to definition.
    M-, (racket-pop-to-mark): Go back after jumping.

This extensive setup should equip you to comfortably explore and "dabble" in multiple Scheme dialects directly from Emacs, building on your existing Geiser knowledge!

Is there anything else you'd like to configure or discuss?
This is an excellent goal! Geiser is indeed the standard and most powerful way to interact with Scheme dialects in Emacs. The beauty of Geiser is its modular design, allowing you to plug in support for various Scheme implementations.

Since you already have Geiser set up for Guile, extending it to other dialects involves:

    Installing the specific Geiser packages for each Scheme (e.g., geiser-gambit, geiser-chicken, geiser-chez, geiser-racket).
    Installing the Scheme implementations themselves on your system and ensuring they are in your PATH.
    Potentially configuring the binary paths within Geiser if the executables aren't directly named (e.g., racket, gsi, csi, chez).

Let's break down the configuration for each.
Crucial Prerequisites (Outside of Emacs)

You MUST install these Scheme implementations on your system.

    Gambit Scheme: Download from gambitscheme.org. Install gsi (the interpreter) and gsc (the compiler).
    Chicken Scheme: Download from www.call-cc.org. Install csi (the interpreter) and chicken (the compiler). You'll also need to install Geiser support eggs:
    Bash

    chicken-install -s apropos chicken-doc
    # For Chicken 5, you might also need SRFI-18
    chicken-install -s srfi-18

    Chez Scheme: Download from cisco.github.io/ChezScheme/. Install scheme (or petite for Petite Chez Scheme, though scheme is more common).
    Racket: Download from racket-lang.org. Install racket and raco.

Ensure all executables (gsi, csi, scheme, racket, raco) are in your system's PATH.
Emacs Configuration (init.el)

We'll leverage use-package to install and configure the necessary Geiser components.
Code snippet

;; --- Emacs Package Management Preamble ---
;; (As established, this section ensures that packages are automatically installed
;; if they are not already present, based on your use-package declarations.)

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t) ; Geiser is typically on NonGNU ELPA
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

;; --- End of Emacs Package Management Preamble ---


;; --- Geiser Core Configuration (assuming you have this) ---
;; Geiser itself is a meta-package that brings in the core modes.
;; If you already have this, this block ensures it's available.
(use-package geiser
  :ensure t
  :hook (scheme-mode . geiser-mode) ; Automatically enable geiser for scheme files
  :config
  ;; This lists the implementations Geiser should try to find.
  ;; Add the ones you want to use. Geiser will prompt you if multiple are found.
  (setq geiser-active-implementations '(guile gambit chicken chez racket))

  ;; Optional: Set a default if you primarily work with one Scheme
  ;; (setq geiser-default-implementation 'guile) ; or 'gambit, 'chicken, 'chez, 'racket

  ;; You can also customize `geiser-mode-hook` if you have specific setup
  ;; for all Scheme modes, e.g., paredit.
  (add-hook 'geiser-mode-hook #'paredit-mode)
  (add-hook 'geiser-mode-hook #'company-mode)
  (add-hook 'geiser-mode-hook #'eldoc-mode)
  )

;; --- Geiser for Gambit Scheme ---
(use-package geiser-gambit
  :ensure t
  :config
  ;; Set the path to the Gambit interpreter if `gsi` is not in your PATH
  ;; (setq geiser-gambit-binary "gsi")
  ;; Or full path: (setq geiser-gambit-binary "/path/to/gambit/bin/gsi")

  ;; For autodoc and full debugging, you might need specific Gambit builds
  ;; as mentioned in Gambit's docs or geiser-gambit README.
  ;; (setq geiser-gambit-runtime-flags '("--enable-rtlib-debug-source"))
  )

;; --- Geiser for Chicken Scheme ---
(use-package geiser-chicken
  :ensure t
  :config
  ;; Set the path to the Chicken interpreter if `csi` is not in your PATH
  ;; (setq geiser-chicken-binary "csi")
  ;; Or full path: (setq geiser-chicken-binary "/path/to/chicken/bin/csi")

  ;; Chicken needs specific "eggs" installed for full Geiser support (see prerequisites)
  ;; `chicken-install -s apropos chicken-doc`
  ;; `chicken-install -s srfi-18` (for Chicken 5)
  )

;; --- Geiser for Chez Scheme ---
(use-package geiser-chez
  :ensure t
  :config
  ;; Chez Scheme's interpreter is often named 'scheme' or 'chez'.
  ;; Geiser defaults to 'scheme', but if you installed it as 'chez', set it here:
  ;; (setq geiser-chez-binary "chez")
  ;; Or full path: (setq geiser-chez-binary "/path/to/chez/bin/scheme")
  )

;; --- Geiser for Racket ---
(use-package geiser-racket
  :ensure t
  :config
  ;; Racket's interpreter is `racket`.
  ;; (setq geiser-racket-binary "racket")
  ;; Or full path: (setq geiser-racket-binary "/Applications/Racket/bin/racket")

  ;; Racket can be a bit more complex with modules.
  ;; If you're working with specific Racket variants (e.g. #lang racket/base),
  ;; ensure your files declare them.
  )

;; --- General Scheme Mode Enhancements (if not already part of your setup) ---

(use-package paredit
  :hook ((scheme-mode . paredit-mode)
         (emacs-lisp-mode . paredit-mode)
         (lisp-mode . paredit-mode)))

(use-package company
  :init (global-company-mode)
  :config
  (setq company-idle-delay 0.1)
  (setq company-minimum-prefix-length 2)
  ;; Geiser's company backend is usually picked up automatically
  )

(use-package eldoc
  :hook (scheme-mode . turn-on-eldoc-mode))

(use-package rainbow-delimiters
  :hook ((scheme-mode . rainbow-delimiters-mode)
         (emacs-lisp-mode . rainbow-delimiters-mode)
         (lisp-mode . rainbow-delimiters-mode)))

Explanation of the init.el snippet:

    Geiser Core (geiser): This ensures the base Geiser package is installed. The :hook (scheme-mode . geiser-mode) line ensures that whenever you open a file in scheme-mode (which is often the default for .scm and .ss files), Geiser's interactive features are enabled.
        geiser-active-implementations: This is important! It tells Geiser which Scheme implementations it should be aware of. When you start a REPL with M-x geiser, it will prompt you with a list of these active implementations (if more than one is installed).
        geiser-default-implementation: If you prefer a specific Scheme to start by default without prompting, set this.
        Hooks: I've included common hooks for paredit-mode, company-mode, and eldoc-mode which are fantastic companions for Lisp/Scheme development.
    Individual Geiser Implementation Packages:
        geiser-gambit, geiser-chicken, geiser-chez, geiser-racket: Each of these packages provides the specific plumbing for Geiser to communicate with that particular Scheme interpreter. They also handle the necessary syntax highlighting and REPL behavior unique to each.
        geiser-<impl>-binary: This is where you override the default executable name if it's not simply gsi, csi, scheme, or racket, or if it's not in your system's PATH. Uncomment and set the appropriate path for your installation.
    General Scheme Mode Enhancements: These use-package blocks ensure paredit, company, eldoc, and rainbow-delimiters are enabled for all Scheme-related modes, providing a consistent and powerful editing experience across dialects.

Workflow with Multiple Scheme Dialects and Geiser

    Open a Scheme file: Open a .scm or .ss file (or .rkt for Racket). geiser-mode will activate automatically.
    Start a REPL:
        Press M-x geiser. If you have geiser-active-implementations set, it will prompt you to choose which Scheme interpreter to start (e.g., guile, gambit, chicken, chez, racket). Select the one you want.
        Alternatively, you can directly invoke the implementation-specific command: M-x run-gambit, M-x run-chicken, M-x run-chez, M-x run-racket, or M-x run-guile. This will start the REPL for that specific Scheme.
    Interactive Development: Once the REPL is running, all your standard Geiser commands will work:
        C-x C-e (geiser-eval-last-sexp): Evaluate the S-expression before point in the REPL.
        C-c C-r (geiser-eval-region): Evaluate the selected region.
        C-c C-b (geiser-eval-buffer): Evaluate the entire buffer.
        C-c C-l (geiser-load-file): Load the current file into the REPL (often safer than eval-buffer for larger files or those with complex definitions).
        C-c C-a (geiser-doc-apropos): Search for documentation (behavior varies by Scheme).
        C-c C-d (geiser-doc-symbol-at-point): Get documentation for the symbol at point.
        C-c C-z (geiser-switch-to-repl): Switch to the current Scheme REPL buffer.
        C-c C-k (geiser-kill-scheme): Kill the current Scheme REPL process.
        M-. (geiser-goto-definition): Jump to the definition of a symbol.
        M-, (geiser-pop-definition-stack): Go back from a definition jump.

By setting up these geiser-<impl> packages and ensuring your Scheme executables are in PATH (or explicitly configured), you'll have a wonderfully integrated and powerful environment for dabbling in various Scheme dialects right within Emacs.

You've covered some truly unique and powerful languages and tools! This is a fantastic set of configurations. Is there anything else you'd like to fine-tune or explore in Emacs?

}}}
Common Lisp (Slime)  ¤
Python              ___TODO {{{

I'm ready to help you configure Emacs for Python!

Here's what you need to know for your init.el and some useful shortcuts:
Emacs Configuration for Python (init.el)

The recommended way to get a great Python development experience in Emacs is to use elpy (Emacs Lisp Python Environment). It bundles together many useful features like autocompletion, linting, code formatting, and more.

You'll typically install elpy through Emacs' package manager (MELPA). Here are the lines you'd add to your init.el:
Code snippet

;; --- Package Management (if you haven't set this up already) ---
;; This block makes sure Emacs knows where to find packages from MELPA.
;; If you already have (require 'package) and package-initialize, you can skip this.
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)

;; --- Install Elpy (run M-x package-install RET elpy RET once) ---
;; You'll run `M-x package-install RET elpy RET` in Emacs once to install it.
;; After installation, Emacs will likely prompt you to restart or will load it.

;; --- Elpy Configuration ---
(elpy-enable)

;; Optional: Some useful Elpy customizations
;; Set your preferred Python interpreter (e.g., if you use a virtual environment)
;; (setq elpy-rpc-python-command "python3") ; Or "python" or path to virtualenv's python

;; Enable company-mode for intelligent autocompletion (comes with elpy)
(add-hook 'python-mode-hook 'company-mode)

;; Enable flycheck for on-the-fly syntax checking (comes with elpy)
(add-hook 'python-mode-hook 'flycheck-mode)

;; Optional: Customize indentation (Python typically uses 4 spaces)
(setq python-indent-offset 4)

;; Optional: If you want to use ipython/jupyter console
;; (setq python-shell-interpreter "ipython")
;; (setq python-shell-interpreter-args "-i --simple-prompt")

Steps to get Elpy working:

    Add the package-archives and package-initialize lines to your init.el if they aren't already there.
    Restart Emacs.
    Install elpy: Type M-x package-install RET elpy RET and press Enter. Emacs will download and install the package.
    Add (elpy-enable) and any other optional Elpy configurations to your init.el.
    Restart Emacs again.

After this, when you open a .py file, elpy should automatically activate.
Useful Python Keyboard Shortcuts in Emacs (with Elpy)

Elpy integrates many common functionalities, so a lot of these shortcuts are provided by elpy itself or common Emacs modes that elpy enables (like company-mode for completion, flycheck-mode for error highlighting).

    General Emacs (Works for Python too):
        C-x C-f: Find file (open a Python file)
        C-x C-s: Save file
        C-s: Search forward
        C-r: Search backward
        M-x compile: Run an arbitrary compilation command (you'd type python your_script.py here).
        M-g M-g or C-u M-g M-g: Go to line number
        C-M-v (or C-M-u): Scroll other window (useful when you have a Python shell open)
        C-x o: Switch to other window
        C-g: Quit/cancel current command

    Python-specific (often provided by Elpy):
        Running Code/Shell:
            C-c C-p: Open a Python shell (or switch to it if already open).
            C-c C-c: Evaluate the current buffer or region in the Python shell.
            C-c C-r: Evaluate the current region in the Python shell.
            C-c C-l: Evaluate the current line in the Python shell.
            M-p / M-n: Navigate command history in the Python shell.
        Navigation & Code Exploration:
            M-.: Find definition of the symbol at point (e.g., jump to where a function is defined).
            M-,: Pop mark/return from definition (go back to where you were before M-.).
            C-c C-d: Show documentation for the symbol at point.
            C-c C-j: Jump to line number (Elpy specific, or use M-g M-g).
            C-M-a / C-M-e: Go to beginning/end of current top-level statement (e.g., start/end of function or class).
            C-M-h: Mark current defun (e.g., select the entire function).
        Completion:
            M-/ or just start typing: company-mode will offer completions automatically. Use TAB or Enter to select.
        Linting/Error Checking (Flycheck):
            Errors and warnings will be highlighted directly in your buffer.
            M-g n: Go to the next error/warning.
            M-g p: Go to the previous error/warning.
            Hovering over the highlighted text often shows the error message.
        Refactoring:
            C-c C-f: Elpy refactor menu (provides options like rename, extract, etc.).
        Code Formatting:
            C-c C-t: Toggle docstring/comment and format (Elpy might integrate with tools like black or autopep8 if configured).

This should give you a solid starting point for Python development in Emacs! Let me know if you have more questions or want to look at another language.
Excellent! Python is a great choice for Emacs. Emacs provides a robust environment for Python development, especially when augmented with a few popular packages.

Here's a breakdown of how to configure Emacs for Python and some useful shortcuts:
Emacs Configuration for Python (init.el)

The standard way to get a good Python development experience in Emacs is to use python-mode (which is built-in to Emacs) and then enhance it with packages like Elpy, Jedi, and Flycheck.

Here's a common init.el setup using use-package (which is highly recommended for managing Emacs packages):
Code snippet

;; First, ensure package.el is initialized
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)

;; Install use-package if it's not already installed
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

;; Ensure packages are installed automatically
(setq use-package-always-ensure t)

;; --- Python Configuration ---

(use-package python
  :hook (python-mode . (lambda ()
                         (setq indent-tabs-mode nil) ; Use spaces for indentation
                         (setq python-indent-offset 4) ; 4 spaces for Python
                         (electric-pair-mode 1) ; Auto-close parentheses, brackets, etc.
                         (add-hook 'before-save-hook 'delete-trailing-whitespace nil t))))

(use-package elpy
  :init
  (elpy-enable)
  :config
  ;; You might want to specify your Python interpreter, especially if using virtual environments.
  ;; For example, if you use a virtual environment activated through `pyvenv-activate`:
  ;; (setq python-shell-interpreter "python") ; or "ipython" if you have it
  ;; (setq python-shell-interpreter-args '("-i" "--simple-prompt"))

  ;; For better auto-completion, install 'jedi' and 'epc' in your Python environment:
  ;; pip install jedi epc black ruff

  ;; Flycheck for on-the-fly syntax checking (linting)
  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode))

  ;; Company-mode for auto-completion
  (use-package company
    :ensure t
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1) ; Faster completion
    (setq company-minimum-prefix-length 2) ; Start completing after 2 characters
    (add-to-list 'company-backends 'company-elpy)) ; Use elpy's backend for Python completion

  ;; Jedi for more intelligent completion and navigation
  (use-package company-jedi
    :after (company elpy)
    :ensure t
    :config
    (add-hook 'python-mode-hook 'jedi:setup)
    (setq jedi:complete-on-dot t)) ; Auto-complete after typing a dot
  )

Explanation of the init.el snippet:

    package.el and use-package: These lines set up Emacs's package manager and the use-package macro, which simplifies loading and configuring packages.
    python: This is the built-in python-mode. The :hook section configures basic Python-specific settings like:
        indent-tabs-mode nil and python-indent-offset 4: Ensures consistent 4-space indentation.
        electric-pair-mode 1: Automatically inserts closing parentheses, brackets, and quotes.
        add-hook 'before-save-hook 'delete-trailing-whitespace nil t: Automatically removes unnecessary whitespace at the end of lines when you save a file.
    elpy: This is a powerful Emacs package that turns Emacs into a full-featured Python IDE. (elpy-enable) activates it.
        Python Interpreter: If you use pyenv or conda for virtual environments, elpy often handles detecting them, but you can explicitly set python-shell-interpreter if needed.
        External Python Libraries: For elpy to provide the best features (completion, linting, etc.), you'll need to install some Python packages in your Python environment (e.g., in your virtual environment). The common ones are jedi, epc, black (for formatting), and ruff or flake8 (for linting). You would typically do this in your terminal: pip install jedi epc black ruff
    flycheck: This package provides on-the-fly syntax checking and linting. It will show warnings and errors as you type.
    company and company-jedi: company-mode is a popular auto-completion framework, and company-jedi provides a backend for company-mode using the jedi Python library for intelligent, context-aware Python completion.

Useful Keyboard Shortcuts for Python in Emacs

Many shortcuts are generic Emacs shortcuts that work well with Python. Some are specific to python-mode or packages like Elpy.

General Emacs Shortcuts (applicable to Python and many other languages):

    C-x C-s: Save the current buffer (file).
    C-x C-w: Save the current buffer to a new file (Write file).
    C-x C-f: Find file (open an existing file or create a new one).
    C-s: Incremental search forward.
    C-r: Incremental search backward.
    M-%: Query-replace (find and replace text interactively).
    C-g: Cancel the current command or operation.
    C-/ (or C-_): Undo.
    C-M-v: Scroll other window (if you have multiple windows).
    C-x b: Switch to another buffer.
    C-x k: Kill (close) the current buffer.
    C-M-a: Move backward S-expression (useful for jumping between blocks of code).
    C-M-e: Move forward S-expression.
    M-x compile: Run a compilation command. You'll be prompted for the command. For Python, this could be python your_script.py, pytest, ruff check ., etc.
        M-x recompile: Rerun the last compile command. This is incredibly useful for quickly re-running tests or scripts.
        M-g n (or M-g M-n): Go to the next error in the *compilation* buffer.
        M-g p (or M-g M-p): Go to the previous error.

Python-Specific Shortcuts (primarily from python-mode and Elpy):

    C-c C-c (in a Python buffer): Execute the entire buffer in the Python inferior process (REPL). The output will appear in a *Python* buffer.
    C-c C-r (in a Python buffer): Evaluate the current region in the Python inferior process.
    C-c C-e (in a Python buffer): Evaluate the current definition (e.g., function, class) in the Python inferior process.
    C-c C-z: Switch to the Python inferior process buffer (*Python*).
    C-M-h: Mark the current function/class definition.
    C-c C-f (Elpy): Reformat the current buffer using the configured formatter (e.g., black).
    C-c C-d (Elpy): Jump to the definition of the symbol at point.
    M-. (Jedi/Xref): Jump to definition.
    M-, (Jedi/Xref): Pop mark (go back after jumping to definition).
    M-x elpy-rpc-restart: If elpy or jedi seem stuck, restarting the RPC server can often fix it.
    M-x flycheck-list-errors: Show a buffer with all the errors detected by Flycheck.

Debugging with pdb (Python Debugger) in Emacs:

Emacs has built-in support for interacting with pdb.

    M-x pdb: Starts the pdb debugger for your Python script. It will prompt you for the Python script and arguments.
    Once in pdb mode (in the *pdb* buffer):
        n: Next line (step over).
        s: Step into.
        c: Continue until next breakpoint.
        r: Return from current function.
        b: Set breakpoint.
        l: List source code around current line.

Remember that you can always use C-h k (describe-key) followed by a key combination to see what command it's bound to, and C-h f (describe-function) followed by a function name to get documentation on it. C-h m (describe-mode) gives you information about the current major and minor modes and their specific keybindings.

This should give you a solid starting point for Python development in Emacs! Let me know when you're ready for the next language.


___config

;; --- Emacs Package Management Preamble ---
;; This section ensures that packages are automatically installed
;; if they are not already present, based on your use-package declarations.

;; 1. Add MELPA (and other) package archives.
;;    MELPA is where many useful Emacs packages are hosted.
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; You might also want GNU ELPA (usually included by default but good to be explicit)
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
;; And potentially Non-GNU ELPA
;; (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)

;; 2. Initialize the package system.
;;    This makes installed packages available and prepares for installation.
(package-initialize)

;; 3. Check if 'use-package' is installed. If not, install it.
;;    'use-package' is a highly recommended macro for declarative package configuration.
(unless (package-installed-p 'use-package)
  (package-refresh-contents) ; Refresh package list before installing
  (package-install 'use-package))

;; 4. Configure 'use-package' to automatically install missing packages.
;;    This is the crucial line for automatic installation.
(setq use-package-always-ensure t)

;; --- End of Emacs Package Management Preamble ---


;; --- Python Configuration (with packages automatically installed by use-package) ---

(use-package python
  :hook (python-mode . (lambda ()
                         (setq indent-tabs-mode nil) ; Use spaces for indentation
                         (setq python-indent-offset 4) ; 4 spaces for Python
                         (electric-pair-mode 1) ; Auto-close parentheses, brackets, etc.
                         (add-hook 'before-save-hook 'delete-trailing-whitespace nil t))))

(use-package elpy
  :init
  (elpy-enable)
  :config
  ;; You might want to specify your Python interpreter, especially if using virtual environments.
  ;; For example, if you use a virtual environment activated through `pyvenv-activate`:
  ;; (setq python-shell-interpreter "python") ; or "ipython" if you have it
  ;; (setq python-shell-interpreter-args '("-i" "--simple-prompt"))

  ;; For better auto-completion, install 'jedi' and 'epc' in your Python environment:
  ;; pip install jedi epc black ruff

  ;; Flycheck for on-the-fly syntax checking (linting)
  (use-package flycheck
    :init (global-flycheck-mode)) ; No need for :ensure t here if use-package-always-ensure is t

  ;; Company-mode for auto-completion
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1) ; Faster completion
    (setq company-minimum-prefix-length 2) ; Start completing after 2 characters
    (add-to-list 'company-backends 'company-elpy)) ; Use elpy's backend for Python completion

  ;; Jedi for more intelligent completion and navigation
  (use-package company-jedi
    :after (company elpy) ; Ensure company and elpy are loaded first
    :config
    (add-hook 'python-mode-hook 'jedi:setup)
    (setq jedi:complete-on-dot t)) ; Auto-complete after typing a dot
  )

}}}
Lua  ___TODO {{{

Could you give me a couple of useful keyboard shortcuts and commands that can be used in Emacs for evaluation and such, both in the modes I would likely want to install (i.e. lua-mode, fennel-mode etc), and in Emacs itself (although focusing mostly on the former)?

Sure thing! Given your interest in Lua, Fennel, Moonscript, and Teal, and your appreciation for Emacs's evaluation capabilities, let's break down some useful keyboard shortcuts and commands. We'll cover both general Emacs evaluation techniques and those specific to the modes you'll likely be using.

As you noted, Emacs generally excels at interactive evaluation, which is fantastic for dynamic languages and those with a strong REPL culture like Lua and especially Fennel.
Core Emacs Evaluation Commands (Universal)

These commands work across many modes, including the ones you'll install, as they interact with Emacs's own Lisp interpreter or external processes.

    M-x eval-buffer: Evaluates the entire current buffer as Emacs Lisp. While this directly evaluates Elisp, it's a powerful command to be aware of if you're ever writing Emacs Lisp code to extend your environment.
    M-x eval-region: Evaluates the currently active region (text selection) as Emacs Lisp.
    M-x eval-current-buffer: Similar to eval-buffer, but often used in programming modes to "re-evaluate" or load the current file as if it were a script.
    M-x compile: Prompts you for a shell command to execute. The output appears in a *compilation* buffer, and Emacs can parse errors to jump to relevant lines in your code. This is extremely useful for languages that require a compilation step (like Teal) or for running transpilers (like Moonscript to Lua) or for executing your Lua scripts.
        Example: You could type tl main.tl && lua main.lua to compile a Teal file and then run the resulting Lua.
        Example: You could type moonc -o output.lua input.moon to transpile Moonscript.
    M-x shell-command: Prompts you for a shell command and displays the output in the minibuffer or a new *shell-command output* buffer. Good for quick, single commands.
    M-x start-process: Starts an external process. More for complex interactions than simple evaluation, but worth knowing.

Evaluation and Interaction in Specific Modes

The following commands are tailored for your specific language modes. These often integrate with a running REPL (Read-Eval-Print Loop) or send code to an external interpreter.
1. Lua Mode (lua-mode / inf-lua.el)

lua-mode provides basic syntax highlighting and indentation. For interactive evaluation, you'll typically use inf-lua (Inferior Lua mode) or a more modern LSP integration.

    C-c C-l (or M-x inf-lua): Starts or switches to an Inferior Lua process. This opens a *inferior-lua* buffer where you can type Lua commands and see the output.
    In *inferior-lua* buffer:
        RET (Enter): Evaluates the line you typed.
        C-c C-f: Evaluates the current file you're working on (sends it to the Lua process).
        C-c C-e: Evaluates the current definition (function, variable assignment, etc.) at point.
        C-c C-r: Evaluates the selected region.
    In a Lua source buffer:
        C-c C-e: Evaluate the current function or expression at point and send it to the inferior Lua process.
        C-c C-r: Evaluate the currently selected region and send it to the inferior Lua process.

2. Fennel Mode (fennel-mode)

Fennel is a Lisp, and Emacs's Lisp heritage means its support for interactive Fennel development is excellent. fennel-mode will often integrate with a fennel-repl process.

    C-c C-z: (Often the default for fennel-connect-and-switch-to-repl) Connects to or starts a Fennel REPL and switches to its buffer.
    In a Fennel source buffer:
        C-x C-e (Control-x, Control-e): Evaluate expression at point (last S-expression before cursor). This is perhaps the most fundamental and useful Lisp evaluation command. You'll use this constantly to test small pieces of code.
        C-M-x (Control-Meta-x): Evaluate the current "defun" (top-level form, often a function definition like (fn [...] ...)). This is excellent for re-evaluating an entire function after changes.
        C-c C-c: Evaluate the current buffer (or often the selected region) and send it to the REPL.
        C-c C-r: Evaluate the selected region and send it to the REPL.
        C-c C-k: Compile the current buffer.
        C-c C-p: Toggle the current top-level form between (set!) and (local). (Useful for interactive development).
    In the Fennel REPL buffer:
        RET (Enter): Evaluates the line you typed.
        C-M-x: Evaluate the last S-expression at point (often the line you just typed).
        M-p and M-n: Navigate command history (previous/next).

3. Moonscript Mode (moonscript-mode)

Moonscript typically involves transpilation to Lua. moonscript-mode primarily offers syntax highlighting and indentation. For execution, you'll generally:

    Use M-x compile: As mentioned above, this is your best friend here. You'd set up a compilation command like moonc -o output.lua %f && lua output.lua (where %f is the current file).
    M-x shell-command: For one-off transpilation or execution.
    M-! (Meta-Bang): Shell command on region. You could select a region, press M-!, and pipe it to moonc if you wanted to transpile a snippet on the fly, though this is less common.

4. Teal Mode (teal-mode)

Teal is a typed Lua. The workflow usually involves type-checking and then compiling to Lua before execution.

    M-x compile: This is again your primary tool. You'd use commands like:
        tl check %f: To run the type checker on the current file.
        tl build %f: To compile the current Teal file to a Lua file.
        tl build %f && lua $(dirname %f)/$(basename %f .tl).lua: To compile and then run the resulting Lua file.
    teal-mode might offer a specific command to run tl check directly (e.g., C-c C-t or similar, depending on the specific package). Check its documentation (C-h m in teal-mode).
    Like Moonscript, direct interactive REPL evaluation of Teal before compilation is less common. You'd likely evaluate the generated Lua code in a Lua REPL.

General Emacs Tips for Interactive Development

    C-h m (Control-h, m): Describe Mode. This is your best friend! It lists all the keybindings and commands for the current major mode and any minor modes. Always check this when in a new mode to discover its features.
    C-h k (Control-h, k): Describe Key. Press C-h k then any keybinding, and Emacs will tell you what command it runs.
    C-h f (Control-h, f): Describe Function. Prompts for a function name and tells you what it does, its arguments, and its keybindings.
    C-h v (Control-h, v): Describe Variable. Prompts for a variable name and tells you its value and documentation.
    C-g (Control-g): Quit or abort current command. Essential if you get stuck or run an unwanted command.
    C-x C-e (Control-x, Control-e): Evaluate the Emacs Lisp expression before the cursor. While technically for Elisp, it's so fundamental to Emacs's philosophy that it's worth mastering for general interactive tasks.

By combining these general Emacs evaluation techniques with the specific commands provided by lua-mode, fennel-mode, and strategic use of M-x compile for transpiled languages, you'll have a very powerful and flexible development environment for your Lua, Moonscript, Fennel, and Teal projects. Enjoy the interactive power of Emacs!



Okay, this is an excellent challenge! Lua is a versatile language, and including its interesting derivatives (Fennel, MoonScript, and Teal) adds a great "twist." You're looking for a comprehensive Emacs setup that integrates these.

Since you mentioned you have a good existing Lua setup, I'll provide configurations that build upon that, ensuring lua-mode is well-configured, and then add the specific modes and integrations for Fennel, MoonScript, and Teal. The key will be integrating their respective compilers/transpilers and language servers (where available).
Overview of Languages and Emacs Packages

    Lua: Standard lua-mode.
    Fennel: fennel-mode, integrates with fennel compiler.
    MoonScript: moonscript-mode, integrates with moon compiler.
    Teal (Typed Lua): teal-mode, integrates with tl compiler, and potentially lua-lsp for LSP support (which might include Teal features).

Crucial Prerequisites (Outside of Emacs):

You'll need to install the compilers/transpilers for these languages. The easiest way is often via LuaRocks (Lua's package manager) or npm (for some tools).

    Lua: A working Lua interpreter (Lua 5.1, 5.2, 5.3, 5.4, or LuaJIT).
    LuaRocks: Highly recommended for installing Lua packages.
        sudo apt-get install luarocks (Debian/Ubuntu)
        brew install luarocks (macOS)
    Fennel:
        luarocks install fennel
    MoonScript:
        luarocks install moonscript
    Teal:
        luarocks install teal
        For LSP: lua-lsp is a general Lua Language Server that has some Teal support. You might install it via npm: npm install -g lua-language-server (ensure lua-language-server is in your PATH).

Ensure all these executables (fennel, moon, tl, lua-language-server, and your Lua interpreter) are in your system's PATH.
Emacs Configuration for Lua, Fennel, MoonScript, and Teal (init.el)

We'll use our standard package management preamble and then configure each language.
Code snippet

;; --- Emacs Package Management Preamble ---
;; (As established, this section ensures that packages are automatically installed
;; if they are not already present, based on your use-package declarations.)

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
;; (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

;; --- End of Emacs Package Management Preamble ---


;; --- Lua Configuration (building on your existing setup) ---

(use-package lua-mode
  :mode "\\.lua\\'" ; Activate lua-mode for .lua files
  :hook (lua-mode . (lambda ()
                       (setq indent-tabs-mode nil) ; Use spaces
                       (setq tab-width 2)           ; 2 spaces for Lua (common)
                       (electric-pair-mode 1)
                       (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; You might have specific Lua interpreter settings here:
  ;; (setq inferior-lua-program "lua5.4")

  ;; Flycheck for Lua (e.g., using luacheck)
  (use-package flycheck
    :init (global-flycheck-mode)
    :config
    ;; Requires luacheck: `luarocks install luacheck`
    (flycheck-define-checker lua-luacheck
      :command ("luacheck" source)
      :error-patterns
      ((error line-start (file-name) ":" line ":" column ": " (message) line-end)))
    (add-hook 'lua-mode-hook (lambda () (flycheck-mode))))

  ;; Company-mode for Lua completion (integrates with LSP)
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 2)
    (add-to-list 'company-backends 'company-capf)) ; For LSP integration
  )

;; --- Eglot for Lua Language Server (lua-language-server) ---
;; This provides advanced features like completion, definition lookup, diagnostics for Lua,
;; and potentially for Teal (as lua-language-server has some Teal integration).
(use-package eglot
  :config
  ;; Tell eglot how to start the Lua Language Server.
  ;; Assumes `lua-language-server` is in your system's PATH.
  ;; On Windows, it might be `lua-language-server.exe`
  (add-to-list 'eglot-server-programs '(lua-mode . ("lua-language-server")))
  ;; If you want to enable Eglot for Teal files as well:
  (add-to-list 'eglot-server-programs '(teal-mode . ("lua-language-server")))

  ;; Optional: Enable formatting on save via LSP
  (add-hook 'eglot-managed-mode-hook
            (lambda ()
              (when (or (eq major-mode 'lua-mode) (eq major-mode 'teal-mode))
                (add-hook 'before-save-hook #'eglot-format-buffer nil t))))
  )

;; --- Fennel Configuration ---
(use-package fennel-mode
  :mode "\\.fnl\\'" ; Activate fennel-mode for .fnl files
  :hook (fennel-mode . (lambda ()
                          (setq indent-tabs-mode nil)
                          (setq tab-width 2)
                          (setq lisp-indent-offset 2) ; Fennel is a Lisp, use lisp-indent-offset
                          (electric-pair-mode 1)
                          (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; Set the path to the fennel executable if not in PATH
  ;; (setq fennel-interpreter-path "/path/to/fennel")
  )

;; --- MoonScript Configuration ---
(use-package moonscript-mode
  :mode "\\.moon\\'" ; Activate moonscript-mode for .moon files
  :hook (moonscript-mode . (lambda ()
                              (setq indent-tabs-mode nil)
                              (setq tab-width 2) ; MoonScript usually uses 2 spaces
                              (electric-pair-mode 1)
                              (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; Set the path to the moon executable if not in PATH
  ;; (setq moonscript-compiler-command "moon")
  )

;; --- Teal Configuration ---
(use-package teal-mode
  :mode "\\.tl\\'" ; Activate teal-mode for .tl files
  :hook (teal-mode . (lambda ()
                        (setq indent-tabs-mode nil)
                        (setq tab-width 2) ; Teal usually uses 2 spaces
                        (electric-pair-mode 1)
                        (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; Set the path to the tl executable if not in PATH
  ;; (setq teal-interpreter-path "tl")
  )

Explanation of the init.el snippet:

    Lua Configuration:
        lua-mode: Standard mode for Lua files. Sets 2-space indentation.
        flycheck with luacheck: I've added a flycheck setup to use luacheck (a Lua linter). You'll need to install luacheck via luarocks install luacheck. This provides real-time linting for your Lua code.
        eglot with lua-language-server: This is crucial for modern Lua development. lua-language-server provides rich LSP features. I've configured it to work with both lua-mode and teal-mode (as lua-language-server has some Teal support). Remember to install lua-language-server globally via npm.
    Fennel Configuration:
        fennel-mode: The dedicated mode for Fennel. It automatically handles .fnl files.
        lisp-indent-offset: Since Fennel is a Lisp, setting lisp-indent-offset (in addition to tab-width) is important for correct indentation.
        fennel-interpreter-path: You can explicitly set the path to your fennel executable if it's not in PATH.
    MoonScript Configuration:
        moonscript-mode: Handles .moon files.
        moonscript-compiler-command: You can set the path to the moon executable here.
    Teal Configuration:
        teal-mode: Handles .tl files.
        teal-interpreter-path: You can set the path to the tl executable here.
        LSP with Teal: As mentioned, lua-language-server is configured to also serve teal-mode files, giving you completion and diagnostics for Teal as well.

Useful Keyboard Shortcuts

Many shortcuts are shared across these modes or are general Emacs commands. I'll highlight the specific ones for each.

General Emacs Shortcuts (apply to all these languages):

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: Your go-to for running compilers/transpilers.
        Lua: lua your_script.lua
        Fennel: fennel --compile your_script.fnl (to .lua), then lua your_script.lua
        MoonScript: moon your_script.moon (to .lua), then lua your_script.lua
        Teal: tl build (in a project), or tl gen your_script.tl (to .lua), then lua your_script.lua
        M-x recompile: Rerun the last compile command.
        M-g n / M-g p: Navigate to next/previous error in the *compilation* buffer.
    C-M-a / C-M-e: Move backward/forward S-expression (especially useful for Fennel!).
    C-M-h: Mark current definition.

Lua (lua-mode) Specific Shortcuts:

    C-c C-c: Execute the current buffer in an inferior Lua process (*lua* REPL).
    C-c C-r: Execute the current region in the Lua REPL.
    C-c C-z: Switch to the Lua REPL buffer.
    C-c C-l: Load the current file into the Lua REPL.
    M-x lua-indent-buffer: Reindent the entire buffer.

Eglot/LSP Shortcuts (for Lua and Teal, via lua-language-server):

    M-.: Go to definition.
    M-,: Go back (pop mark).
    M-x xref-find-references: Find all references to the symbol at point.
    M-x eglot-rename: Rename a symbol across your project.
    M-x eglot-code-action: Access quick fixes or refactoring options.
    M-x eglot-hover: Show documentation/type info.
    M-x eglot-format-buffer: Format the current buffer (if the LSP server supports it, lua-language-server does).
    M-x eglot-reconnect: Reconnect to the language server.

Fennel (fennel-mode) Specific Shortcuts:

    C-c C-c: Evaluate the current buffer in an inferior Lua process (running the compiled Fennel).
    C-c C-e: Evaluate the current expression/definition.
    C-c C-l: Compile the current Fennel file to Lua.
    C-c C-z: Switch to the inferior Lua process buffer.
    M-x fennel-compile-file: Compile the current Fennel file.
    M-x fennel-eval-buffer: Evaluate the entire Fennel buffer.

MoonScript (moonscript-mode) Specific Shortcuts:

    C-c C-c: Compile the current MoonScript file to Lua and run it.
    C-c C-l: Compile the current MoonScript file to Lua.
    M-x moonscript-compile-buffer: Compile the current buffer.
    M-x moonscript-run-buffer: Compile and run the current buffer.

Teal (teal-mode) Specific Shortcuts:

    C-c C-c: Execute the current buffer by first compiling to Lua and then running.
    C-c C-t: Show the type of the expression at point.
    M-x teal-compile-file: Compile the current Teal file to Lua.
    M-x teal-run-file: Compile and run the current Teal file.

This setup should give you a robust and integrated environment for working with Lua and its fascinating dialects, Fennel, MoonScript, and Teal!

Is there anything else you'd like to configure in Emacs?

}}}
Dlang               ___TODO {{{

Okay, Dlang! That's an interesting choice, and Emacs can definitely be configured for it.

Dlang support in Emacs primarily comes from d-mode. There isn't as rich an ecosystem of high-level IDE-like packages for Dlang as there is for Python (like Elpy), but d-mode provides the core functionalities, and you can integrate common Emacs features like company-mode and flycheck for a good experience.
Emacs Configuration for Dlang (init.el)

The main package you'll need is d-mode. You'll want to ensure it's set up to be automatically installed.
Code snippet

;; --- Dlang Configuration ---

(use-package d-mode
  :mode "\\.d\\'" ; Automatically activate d-mode for .d files
  :hook (d-mode . (lambda ()
                    (setq indent-tabs-mode nil) ; Use spaces
                    (setq tab-width 4)         ; 4 spaces for D
                    (electric-pair-mode 1)      ; Auto-close parentheses, brackets, etc.
                    (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; Optionally, if you use a specific D compiler like DMD, GDC, or LDC,
  ;; you might configure paths or default build commands here.
  ;; d-mode often tries to guess, but explicit is sometimes better.
  ;; Example (uncomment and adjust if needed):
  ;; (setq d-build-command "dmd -g -unittest -v -o- %s")

  ;; Integrate with Company-mode for completion
  (use-package company-dlang
    :after (company d-mode)
    :init
    ;; Add company-dlang to the list of backends for d-mode
    (add-to-list 'company-backends 'company-dlang t))

  ;; Integrate with Flycheck for on-the-fly syntax checking
  (use-package flycheck
    :config
    ;; Tell Flycheck to use dlint or dmd -v as a checker for D files
    ;; You'll likely need `dlint` installed in your system for best linting.
    ;; `dub lint` is another common way to lint D projects.
    (flycheck-add-next-checker 'd-mode 'dlint 'dmd-syntax))) ; You might prefer `dmd-syntax` initially if `dlint` isn't set up.

Explanation of the init.el snippet:

    d-mode: This is the major mode for Dlang.
        :mode "\\.d\\'": This tells Emacs to automatically load d-mode when you open files with the .d extension.
        :hook (d-mode . (lambda () ...)): Similar to Python, this sets up basic formatting preferences like 4-space indentation and electric-pair-mode for auto-closing delimiters.
        :config: Here you can add more specific configurations for d-mode. d-build-command is an example, but d-mode is usually quite good at detecting dub or dmd.
    company-dlang: This package provides company-mode completion specifically for Dlang. It integrates with d-mode to offer completion based on Dlang's syntax and available symbols.
    flycheck: For on-the-fly syntax checking.
        flycheck-add-next-checker 'd-mode 'dlint 'dmd-syntax): This configures Flycheck to use dlint (a Dlang linter) as its primary checker for D files. If dlint isn't found, it falls back to dmd -v for basic syntax checking. For best results, you should install dlint in your system. You can usually get it with dub fetch dlint or dub run dlint -- --install.

Prerequisites for Dlang tools (outside Emacs):

To get the most out of Emacs for Dlang, you should have the following installed on your system:

    DMD (Dlang compiler): Or GDC/LDC. The Dlang installer will typically handle this.
    Dub (Dlang package manager): Essential for managing D projects and dependencies.
    Dlint (optional but recommended): A Dlang linter for better static analysis and Flycheck integration. Install via dub: dub fetch dlint and then dub run dlint -- --install or similar.

Useful Keyboard Shortcuts for Dlang in Emacs

Many of the general Emacs shortcuts (like C-x C-s for save, C-s for search, C-/ for undo) will apply here too. Here are some Dlang-specific or highly relevant shortcuts:

Compilation and Running:

    M-x compile: This is your go-to for running Dlang commands.
        You'll be prompted for a command. Common commands for Dlang projects managed by dub are:
            dub build: Build your Dlang project.
            dub run: Build and run your Dlang project.
            dub test: Run your project's unit tests.
            dmd your_file.d: Compile a single D file with the DMD compiler.
        M-x recompile: Rerun the last compilation command. Incredibly useful for quick iterations.
    M-g n (or M-g M-n): Go to the next error in the *compilation* buffer (after running M-x compile).
    M-g p (or M-g M-p): Go to the previous error.

Navigation and Editing:

    C-c C-f (d-mode specific): Auto-format the current D file using dfmt (if dfmt is installed on your system). You'll likely need to dub fetch dfmt and install it.
    C-M-a: Move backward S-expression (useful for jumping between code blocks like functions, loops).
    C-M-e: Move forward S-expression.
    M-. (xref-find-definitions or similar): If configured with company-dlang and an underlying D completion engine (like DCD if integrated), this might jump to definition. Note: d-mode's definition jumping capabilities are not as advanced out-of-the-box as some other languages like Python with Jedi. You might need to configure DCD (D Completion Daemon) separately for robust definition lookup, but company-dlang usually handles the integration.
    M-, (xref-pop-marker-stack): Go back to the previous location after jumping to a definition.

General Productivity (also good for Dlang):

    C-x s: Save all modified buffers.
    C-x C-b: List all active buffers.
    C-M-f: Move forward by a balanced expression.
    C-M-b: Move backward by a balanced expression.
    C-M-k: Kill (delete) next balanced expression.
    M-x replace-string: Replace all occurrences of a string.
    M-x query-replace: Interactively replace occurrences of a string.
    M-x indent-region: Indent the currently marked region.
    M-x indent-buffer: Indent the entire buffer.

Important Note on Dlang Completion/Definition Lookup:

For advanced features like robust auto-completion and "jump to definition," Dlang typically relies on tools like DCD (D Completion Daemon). While company-dlang integrates with it, setting up DCD itself might require separate steps (downloading, building, and ensuring it's in your system's PATH). Without DCD, company-dlang might offer basic syntax-based completion but not intelligent symbol lookup across your project.

This configuration should give you a solid foundation for Dlang development in Emacs! What's the next language on your list?
Alright, let's get Emacs configured for Dlang!

Dlang (or D) is a fascinating language, and Emacs has good support for it through the d-mode package.
Emacs Configuration for Dlang (init.el)

The primary package you'll want is d-mode. We'll also look into flycheck for linting and company for completion, similar to Python, as these are general Emacs packages that can often be configured to work with various language modes.

Here's the init.el snippet for Dlang, building upon our robust package management preamble:
Code snippet

;; --- Emacs Package Management Preamble ---
;; (As established, this section ensures that packages are automatically installed
;; if they are not already present, based on your use-package declarations.)

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
;; (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

;; --- End of Emacs Package Management Preamble ---


;; --- Dlang Configuration ---

(use-package d-mode
  :mode "\\.d\\'" ; Automatically activate d-mode for .d files
  :hook (d-mode . (lambda ()
                    (setq indent-tabs-mode nil)  ; Use spaces for indentation
                    (setq tab-width 4)           ; 4 spaces for indentation (common D style)
                    (electric-pair-mode 1)
                    (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; You might want to set specific paths for D tools if they're not in your system PATH
  ;; For example:
  ;; (setq d-mode-dmd-command "/path/to/dmd")
  ;; (setq d-mode-dub-command "/path/to/dub")

  ;; Flycheck for Dlang linting/syntax checking
  ;; Flycheck can use tools like DScanner or the D compiler itself for checks.
  (use-package flycheck
    :init (global-flycheck-mode))

  ;; Company-mode for auto-completion with Dlang
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 2)
    ;; d-mode often provides its own company backend, or you might use
    ;; a language server protocol (LSP) client for more advanced completion.
    ;; We'll cover LSP later if you're interested.
    (add-to-list 'company-backends 'company-dabbrev-code) ; Fallback to code word completion
    )
  )

;; If you want LSP (Language Server Protocol) support for Dlang,
;; which provides much richer features like advanced completion,
;; go-to-definition, refactoring, etc., you'll need 'lsp-mode'
;; and a Dlang LSP server (e.g., dls).
;; This requires installing the LSP server *outside* Emacs.
;; Example for dls: `dub fetch dls && dub build dls`
;; Then add this to your init.el:
;; (use-package lsp-mode
;;   :commands (lsp lsp-deferred)
;;   :hook (d-mode . lsp-deferred) ; Start LSP when d-mode is active
;;   :config
;;   (setq lsp-log-io t) ; Enable logging for debugging LSP issues
;;   (setq lsp-prefer-flycheck t) ; Use flycheck for diagnostics
;;   (setq lsp-auto-configure t) ; Automatically configure major modes for LSP
;;   )

;; (use-package lsp-ui
;;   :commands lsp-ui-mode
;;   :after lsp-mode
;;   :hook (lsp-mode . lsp-ui-mode))

;; (use-package dap-mode ; Debug Adapter Protocol for debugging
;;   :after lsp-mode
;;   :commands dap-mode
;;   :config
;;   (dap-tooltip-mode t)
;;   (dap-ui-mode t))

Explanation of the init.el snippet for Dlang:

    use-package d-mode: This loads the primary major mode for D files.
        :mode "\\.d\\'": This automatically associates files ending with .d (the standard Dlang extension) with d-mode.
        :hook (d-mode . (lambda () ...)): Similar to Python, this sets up basic formatting preferences like 4-space indentation and electric pairing.
        D Compiler/Tool Paths: You might need to explicitly tell d-mode where your dmd (D compiler) or dub (D package manager) executables are if they are not in your system's PATH environment variable. Uncomment and adjust the setq d-mode-dmd-command and d-mode-dub-command lines if needed.
    use-package flycheck: This integrates with d-mode to provide real-time syntax checking. flycheck can be configured to use Dlang-specific linters like DScanner (which you'd install separately: dub fetch dscanner && dub build dscanner) or it can leverage the D compiler itself for diagnostics.
    use-package company: Sets up auto-completion. d-mode provides some basic completion, but for more intelligent completion, you'd typically want to use a Language Server Protocol (LSP) setup.
    LSP (Optional but Recommended): The commented-out lsp-mode, lsp-ui, and dap-mode sections are for setting up a full Language Server Protocol client. For Dlang, dls (D Language Server) is a popular choice.
        To use LSP:
            Install dls: This is a Dlang program itself, so you'd typically install it using dub: dub fetch dls && dub build dls. Make sure the dls executable is in your system's PATH.
            Uncomment the lsp-mode and lsp-ui blocks in your init.el.
            lsp-mode will then connect to dls (or another Dlang LSP server if configured) to provide features like advanced completion, signature help, go-to-definition, find references, refactoring, and more robust diagnostics. lsp-ui provides a better visual experience for these features.

Useful Keyboard Shortcuts for Dlang in Emacs

Again, many general Emacs shortcuts apply. Here are some Dlang-specific ones or commands that are particularly relevant:

General Emacs Shortcuts (reiterated for convenience):

    C-x C-s: Save the current buffer.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: This is your go-to for running compilation.
        For a single D file: dmd your_file.d
        For a dub project: dub build or dub run
        M-x recompile: Repeat the last compile command. Essential!
        M-g n (or M-g M-n) / M-g p (or M-g M-p): Navigate to next/previous error in the *compilation* buffer.
    C-M-a / C-M-e: Move backward/forward S-expression (useful for D's block structure).
    C-M-h: Mark the current function/class definition.

d-mode Specific Shortcuts:

    C-c C-c: Compile the current D file using dmd or dub. This usually provides helpful output in the *compilation* buffer.
    C-c C-r: Run the compiled D program (if successfully built).
    C-c C-l: Toggle comments on selected lines (or current line if no selection). This is often bound to a more general prog-mode command like M-; or C-c C-c depending on your setup. d-mode usually makes C-c C-l available.
    C-c C-p: Switch to a D REPL (Read-Eval-Print Loop) if d-mode has support for it (often via an inferior process).
    M-x d-mode-indent-buffer: Reindent the entire buffer according to Dlang style.
    M-x d-mode-format-buffer: If you have an external formatter like dfmt installed (dub fetch dfmt && dub build dfmt), you can configure d-mode to use it for automatic formatting. You might then bind this to a key.

LSP-mode Shortcuts (if you enable lsp-mode):

These are very powerful and worth the setup effort.

    M-.: Go to definition.
    M-,: Go back (pop mark).
    M-x lsp-find-references: Find all references to the symbol at point.
    M-x lsp-rename: Rename a symbol across your project.
    M-x lsp-execute-code-action: Access quick fixes or refactoring options (e.g., "Extract function", "Add missing import").
    M-x lsp-hover: Show documentation for the symbol at point.
    M-x lsp-mode-restart: Restart the D language server if things go wrong.

Remember to install the D compiler (DMD, LDC, or GDC) and the dub package manager on your system for Emacs to compile and run D programs effectively. For advanced features, consider installing dls for LSP support.

You're well on your way to a powerful Emacs setup for Dlang! Let me know when you're ready for the next language.

}}}
F#                  ___TODO {{{

The primary Emacs mode for F# is fsharp-mode. For a truly productive F# development experience, you'll almost certainly want to leverage a Language Server Protocol (LSP) client like eglot or lsp-mode to connect to an F# language server. The most common F# language server is FsAutoComplete (FSAC).
Emacs Configuration for F# (init.el)

We'll structure this to automatically install fsharp-mode and then configure eglot (which is built into recent Emacs versions and often simpler to set up for a single language server than lsp-mode) to work with FsAutoComplete.

Crucial Prerequisites (Outside of Emacs):

Before Emacs can fully support F#, you'll need the following installed on your system:

    .NET SDK: This includes the F# compiler (fsc), the F# interactive (fsi), and dotnet CLI for project management.
    FsAutoComplete (FSAC): This is the F# Language Server. You typically install it as a .NET global tool:
    Bash

    dotnet tool install -g fsautocomplete

    Make sure the fsautocomplete executable is in your system's PATH.

Now, here's the init.el snippet:
Code snippet

;; --- Emacs Package Management Preamble ---
;; (As established, this section ensures that packages are automatically installed
;; if they are not already present, based on your use-package declarations.)

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
;; (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

;; --- End of Emacs Package Management Preamble ---


;; --- F# Configuration ---

(use-package fsharp-mode
  :mode ("\\.fs[ix]?\\'" . fsharp-mode) ; Match .fs, .fsi, .fsx files
  :hook (fsharp-mode . (lambda ()
                         (setq indent-tabs-mode nil) ; Use spaces
                         (setq tab-width 4)           ; 4 spaces for F#
                         (setq fsharp-indent-offset 4) ; Specific to fsharp-mode for correct indentation
                         (electric-pair-mode 1)
                         (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; Optionally set F# Interactive (fsi) and compiler (fsc) paths
  ;; These should usually be found via PATH if .NET SDK is installed correctly.
  ;; For Unix-like systems, you might need --readline-
  ;; (setq inferior-fsharp-program "fsharpi --readline-")
  ;; (setq fsharp-compiler "fsharpc")

  ;; --- Eglot for F# Language Server (FsAutoComplete) ---
  ;; Eglot is built-in to Emacs 27+ and provides LSP client functionality.
  ;; This connects to the FsAutoComplete language server.
  (use-package eglot
    :config
    ;; Tell eglot how to start the F# language server
    ;; This assumes 'fsautocomplete' is in your system's PATH.
    (add-to-list 'eglot-server-programs '(fsharp-mode . ("fsautocomplete" "--languageServer")))

    ;; Set preferred indentation style for F# (Fantomas)
    ;; This will format on save (or with `C-c C-f` if bound)
    (add-hook 'eglot-managed-mode-hook
              (lambda ()
                (when (eq major-mode 'fsharp-mode)
                  (setq-local format-all-buffer-format-function 'eglot-format-buffer)))))

  ;; --- Other useful packages that integrate with LSP/eglot ---
  ;; Flycheck for diagnostics (linting/errors)
  (use-package flycheck
    :init (global-flycheck-mode))

  ;; Company-mode for auto-completion (integrates with eglot)
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 2)
    ;; Eglot automatically provides a company backend
    (add-to-list 'company-backends 'company-capf)) ; Common backend for `completion-at-point-functions`
  )

Explanation of the init.el snippet for F#:

    use-package fsharp-mode: This loads the primary mode for F#.
        :mode ("\\.fs[ix]?\\'" . fsharp-mode): This regex matches .fs (F# source files), .fsi (F# interface files), and .fsx (F# script files) and activates fsharp-mode.
        :hook: Sets up standard indentation (4 spaces) and electric pairing. fsharp-indent-offset is specific to fsharp-mode for better F# indentation.
        F# Compiler/Interactive Paths: Similar to Dlang, if your fsharpi or fsharpc executables aren't in your PATH, you might need to set inferior-fsharp-program and fsharp-compiler explicitly. The --readline- flag for fsharpi is crucial on Unix-like systems for interactive mode to work correctly with Emacs.
    use-package eglot: This is the recommended way to get rich LSP features for F#.
        add-to-list 'eglot-server-programs '(fsharp-mode . ("fsautocomplete" "--languageServer")): This tells Eglot that when fsharp-mode is active, it should start the fsautocomplete executable with the --languageServer argument.
        eglot-managed-mode-hook: This hook is used to configure format-all-buffer-format-function to eglot-format-buffer when fsharp-mode is active. This allows eglot to use FsAutoComplete's formatting capabilities (which rely on tools like Fantomas internally).
    use-package flycheck: Integrates with Eglot to display real-time diagnostics (errors, warnings) from the F# language server.
    use-package company: Auto-completion framework. Eglot automatically populates completion-at-point-functions, which company-mode then uses via company-capf.

Useful Keyboard Shortcuts for F# in Emacs

F# development often involves interacting with the F# Interactive (FSI) REPL, and fsharp-mode provides excellent integration for this.

General Emacs Shortcuts (applicable to F#):

    C-x C-s: Save the current buffer.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: For compiling F# projects.
        For a single .fsx script: dotnet fsi your_script.fsx
        For a .NET project (most common): dotnet build or dotnet run (from the project root).
        M-x recompile: Repeat the last compile command.
        M-g n / M-g p: Navigate to next/previous error in the *compilation* buffer.

fsharp-mode and FSI Interaction Shortcuts:

    C-c C-s: Show/switch to the F# Interactive buffer (*FSharp* or *fsharp-interactive*). This is your F# REPL.
    C-c C-r: Evaluate the current region in FSI. This is incredibly useful for testing snippets of code.
    C-c C-e: Evaluate the current top-level phrase (e.g., function, module, type definition) in FSI.
    C-c C-c: Interrupt the running FSI process. Useful if it's stuck in an infinite loop.
    C-c C-k: Kill the FSI process.
    C-c C-d: Jump to the definition of the symbol at point (if not using LSP, fsharp-mode provides some of this).
    C-c C-.: Manually invoke completion at point. (Company mode usually handles this automatically).
    C-c C-t: Show type information for the symbol at point (if not using LSP, fsharp-mode provides this).

Eglot/LSP Shortcuts (if you enabled eglot with FsAutoComplete):

These override or enhance some fsharp-mode commands for richer functionality.

    M-.: Go to definition.
    M-,: Go back (pop mark).
    M-x xref-find-references: Find all references to the symbol at point.
    M-x eglot-rename: Rename a symbol across your project.
    M-x eglot-code-action: Access quick fixes or refactoring options provided by the language server.
    M-x eglot-hover: Show documentation/type information for the symbol at point (often appears automatically on hover).
    C-c C-f (or M-x eglot-format-buffer): Format the current buffer using the configured formatter (usually Fantomas via FSAC).
    M-x eglot-reconnect: Reconnect to the F# language server if it seems unresponsive.

Debugging:

For debugging F# applications, you'll typically use dap-mode (Debug Adapter Protocol) in Emacs, which would require an F# Debug Adapter. The F# language server (FsAutoComplete) also includes debug adapter functionality.

    Ensure dap-mode is installed (add (use-package dap-mode) to your init.el).
    You'll then typically use M-x dap-debug and select a debug configuration (which you might need to define in your project's .vscode/launch.json or create ad-hoc within Emacs).

This setup should give you a very capable F# development environment in Emacs! Ready for the next language?

}}}
OCaml/Dune (Merlin)
PicoLisp {{{

I suspect that the best editor or IDE for editing and testing PicoLisp code on desktop would be Emacs. Would you agree with that statement?

You are absolutely on the right track! Emacs is indeed a very strong candidate, arguably the best, for editing and testing PicoLisp code on desktop.

Here's why, and what makes it such a good fit:
Why Emacs is a Great Choice for PicoLisp:

     Lisp Heritage: Emacs itself is written in Emacs Lisp. It has deeply ingrained support for Lisp-like syntax, including parentheses matching, indentation, and s-expression manipulation. This is fundamental for working with any Lisp dialect, and PicoLisp is no exception.

 picolisp-mode: There are dedicated Emacs modes specifically for PicoLisp, such as picolisp-mode (and older variants). These modes provide:

    Syntax Highlighting: Makes your code readable with different colors for symbols, strings, comments, etc.
    Smart Indentation: Automatically indents your code according to PicoLisp conventions, which is crucial for readability in Lisp.

S-expression Navigation and Editing: Commands to jump over s-expressions, transpose them, slurp/barf (expand/contract), and generally manipulate code as a tree structure. This is a game-changer for Lisp programming.
Transient Symbols Markup (TSM): PicoLisp has a unique feature called "transient symbols" which look like strings but are treated as symbols. picolisp-mode has support for highlighting or hiding the delimiters for these, significantly improving readability.

inferior-picolisp (REPL Integration): This is where Emacs truly shines for interactive development. inferior-picolisp allows you to:

    Run a PicoLisp REPL (Read-Eval-Print Loop) directly within an Emacs buffer.

Send code from your file buffer to the REPL for evaluation. This means you can write a function, send it to the running PicoLisp process, test it immediately, modify it, and send it again, without ever leaving your editor. This interactive workflow is incredibly productive for Lisp development.

    Load entire files into the running PicoLisp process.
    Switch between your code and the REPL buffer easily.

paredit-mode (Highly Recommended): While not specific to PicoLisp, paredit-mode (or similar structural editing modes like smartparens) is almost universally recommended for Lisp development in Emacs. It helps maintain the structural integrity of your Lisp code by:

    Automatically inserting closing parentheses.
    Preventing unbalanced parentheses.
    Providing powerful commands for manipulating s-expressions (e.g., wrapping, unwrapping, splitting, joining expressions). This prevents many common Lisp syntax errors.

 Org Mode Integration: If you're an Org Mode user, PicoLisp can be integrated with Org Babel, allowing you to embed and execute PicoLisp code blocks directly within your Org Mode documents. This is fantastic for literate programming, documentation, and tutorials.

    Debugger Integration: While PicoLisp has its own debugger, Emacs can often be configured to work alongside it, allowing you to set breakpoints and inspect the state of your PicoLisp program.

Alternatives and Considerations:

    Vim/Neovim: The PicoLisp author, Alexander Burger, famously uses vi (or vip, his PicoLisp-implemented vi-like editor). Vim also has excellent Lisp support (via plugins) and can integrate with a REPL. If you're a Vim user, it's a very capable alternative.

Other Text Editors (VS Code, Sublime Text, Atom): These editors have Lisp syntax highlighting and basic indentation. However, they typically lack the deep, structural s-expression editing capabilities and seamless REPL integration that Emacs offers out-of-the-box for Lisps. You might find extensions for these, but they are often not as mature or comprehensive as Emacs's Lisp modes.
PicoLisp's vip editor: As mentioned, PicoLisp includes its own vi-like editor (vip) written in PicoLisp itself. This is minimalist and functional, and can be useful if you're already deeply immersed in the PicoLisp ecosystem. It's a testament to the language's power that a text editor can be written in it.

Conclusion:

Your suspicion is correct. Emacs is indeed an excellent and highly recommended environment for PicoLisp development on desktop. Its long history with Lisp, powerful structural editing features, and robust REPL integration (inferior-picolisp with picolisp-mode and paredit-mode) make it an incredibly productive choice for working with PicoLisp. If you're comfortable with Emacs, or willing to learn it, you'll find it to be a very rewarding experience for PicoLisp development.

Could you quickly walk me through what I would need to put into my init.el to have the tools you mentioned above included, and some good keyboard-shortcuts that would be good for me to know, focusing on the ones that are specific to editing PicoLisp in Emacs, rather than more general Emacs-specific keyboard-shortcuts for dealing with code? (Note: If most of the Emacs-specific functionality mentioned in your last answer, we can mostly focus on the keyboard-shortcuts question)

You're right to focus on the shortcuts once the basic setup is covered, as much of Emacs's Lisp power comes from its core capabilities.

Here's a quick walk-through for your init.el and essential PicoLisp-specific (or highly Lisp-relevant) keyboard shortcuts.
1. init.el Setup for PicoLisp

To get picolisp-mode and inferior-picolisp working, you'll typically need to install them via Emacs's package manager (MELPA is the most common source).

Here's what you'd put in your init.el (usually ~/.emacs.d/init.el):
Code snippet

;; --- Package Management ---
;; Add MELPA to your package archives (if not already there)
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)

;; Install picolisp-mode and paredit if not already installed
(unless (package-installed-p 'picolisp-mode)
  (package-install 'picolisp-mode))
(unless (package-installed-p 'paredit)
  (package-install 'paredit))

;; --- PicoLisp Mode Configuration ---
;; Auto-load picolisp-mode for .l files
(add-to-list 'auto-mode-alist '("\\.l\\'" . picolisp-mode))

;; Enable paredit-mode in picolisp-mode buffers
(add-hook 'picolisp-mode-hook 'paredit-mode)

;; --- Inferior PicoLisp (REPL) Configuration ---
;; You'll likely need to tell Emacs where your picolisp executable is
;; If it's in your PATH, you might not need this, but it's good practice.
;; Replace "/usr/local/bin/picolisp" with the actual path if different.
(setq inferior-picolisp-program-name "picolisp") ; Assuming it's in your PATH
;; OR:
;; (setq inferior-picolisp-program-name "/path/to/your/picolisp/executable")

;; You might also want to set the default directory for inferior-picolisp
;; (setq inferior-picolisp-default-directory "~/my-picolisp-projects/")

;; Optional: Set the initial command line arguments for picolisp
;; (setq inferior-picolisp-program-args '("-load" "my-init.l")) ; Example to load an init file

;; --- End of init.el setup ---

After adding this to init.el:

    Restart Emacs (or evaluate the lines in your init.el buffer).
    Run M-x package-refresh-contents to fetch the latest package list.
    Run M-x package-install RET picolisp-mode RET and M-x package-install RET paredit RET if they don't auto-install.

2. Essential Keyboard Shortcuts for PicoLisp (and Lisp in general) in Emacs

These shortcuts are primarily relevant when you're in a picolisp-mode buffer. C-c usually means Ctrl + c, M-x means Alt + x (or Esc then x).
Interacting with the PicoLisp REPL (inferior-picolisp):

    C-c C-s (or C-c C-z): Start the inferior-picolisp process (the REPL). This will open a new buffer with the PicoLisp interpreter running.
    C-c C-l: Load the current file into the running PicoLisp process. Very useful after making changes to your code.
    C-x C-e: Evaluate the s-expression before the cursor and print the result in the minibuffer (bottom of the screen). This is incredibly useful for testing small pieces of code or inspecting values.
    C-M-x: Evaluate the s-expression at or around the cursor and print the result. Similar to C-x C-e but often more convenient as you don't need to position the cursor at the end.
    C-c C-b: Evaluate the entire buffer into the REPL.
    C-c C-r: Evaluate the region (selected text) into the REPL.
    C-c C-k: Kill the inferior-picolisp process.

Structural Editing (from paredit-mode):

These are vital for efficient Lisp editing, as they ensure your parentheses are always balanced and you manipulate code as logical blocks.

    ( or [ or {: Auto-inserts the matching closing parenthesis/bracket/brace.
    ): If paredit-mode is active, typing ) will often just move over the existing closing parenthesis, rather than inserting a new one. This is by design.
    M-f / M-b: Move forward/backward by one s-expression. (Often Alt + f / Alt + b)
    C-M-f / C-M-b: Move forward/backward across a balanced s-expression.
    C-M-k: Kill (cut) the s-expression forward.
    C-M-SPC (C-M-Space): Mark the s-expression (select it).
    C-k: Kill (cut) until the end of the line.
    M-(: Wrap the current s-expression or region in parentheses.
    M-): Splice the current s-expression (remove its surrounding parentheses and merge its contents into the parent).
    M-}: Raise the current s-expression (move it up one level in the hierarchy, replacing its parent).
    C-c <: (Paredit) Slurp, move the closing paren to the left, incorporating the next expression into the current one.
    C-c >: (Paredit) Barf, move the closing paren to the right, pushing the last expression out of the current one.
    C-c C-d: (Paredit) Delete surrounding parentheses/brackets.
    C-c C-a: (Paredit) Split the current expression at point.
    C-c C-j: (Paredit) Join two expressions.

General PicoLisp Mode specific:

    C-c .: Toggle transient symbol highlighting (if picolisp-mode is configured for it). Transient symbols (e.g., (2 "Foo")) are a unique PicoLisp feature, and this helps with readability.

How to Practice:

    Open an empty .l file (e.g., test.l) in Emacs.
    Type some simple PicoLisp code.
    Use C-c C-s to start the REPL.
    Experiment with C-x C-e and C-M-x to evaluate code snippets.
    Try out the paredit commands to manipulate parentheses and s-expressions. You'll quickly see how they prevent errors and speed up editing.

This setup and these shortcuts will give you a very productive and enjoyable PicoLisp development experience within Emacs. Good luck!

}}}
.  SML {{{

Excellent! Standard ML (SML) is a powerful, expressive functional programming language with a strong type system. Emacs has good support for SML, primarily through sml-mode and its integration with the SML interactive environment.

The core of SML support in Emacs relies on:

    sml-mode: Provides syntax highlighting, indentation, and basic SML-specific commands.
    Integration with an SML interactive system: Similar to Scheme, you'll want to send code to an SML REPL (Read-Eval-Print Loop) for interactive testing and development. The most common SML implementations are Standard ML of New Jersey (SML/NJ), Moscow ML, and Poly/ML.

Emacs Configuration for Standard ML (init.el)

We'll set up sml-mode and configure it to work with an SML interpreter.

Crucial Prerequisite (Outside of Emacs):

You must install an SML implementation on your system.

    Standard ML of New Jersey (SML/NJ): This is a very popular choice. Download from www.smlnj.org.
    Moscow ML: Another common implementation. Download from www.mosml.org.
    Poly/ML: Used by proof assistants like Isabelle/HOL. Download from polyml.org.

After installation, ensure the SML interpreter executable (e.g., sml, mosml, polyml) is in your system's PATH.

Here's the init.el snippet:
Code snippet

;; --- Emacs Package Management Preamble ---
;; (As established, this section ensures that packages are automatically installed
;; if they are not already present, based on your use-package declarations.)

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
;; (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

;; --- End of Emacs Package Management Preamble ---


;; --- Standard ML Configuration ---

(use-package sml-mode
  :mode "\\.sml\\'" ; Activate sml-mode for .sml files
  :hook (sml-mode . (lambda ()
                       (setq indent-tabs-mode nil) ; Use spaces
                       (setq tab-width 2)           ; 2 spaces for SML (common)
                       (electric-pair-mode 1)
                       (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; Crucial: Tell sml-mode where to find the SML interpreter.
  ;; This defaults to "sml". If you use Moscow ML ("mosml") or Poly/ML ("polyml"),
  ;; or if your 'sml' executable is not in PATH, set it explicitly:
  ;; (setq sml-program "mosml")
  ;; (setq sml-program "polyml")
  ;; (setq sml-program "/path/to/your/smlnj/bin/sml")

  ;; Optional: Customize command-line arguments for the SML process
  ;; (setq sml-args '("-H128M" "@SMLload=/path/to/my_library.sml"))

  ;; Flycheck for SML (uses sml-mode's built-in checker or external tools)
  (use-package flycheck
    :init (global-flycheck-mode)
    :config
    ;; sml-mode automatically defines `sml-sml-checker` for Flycheck,
    ;; which runs `sml` with checking flags.
    (add-hook 'sml-mode-hook (lambda () (flycheck-mode)))
    )

  ;; Company-mode for auto-completion (basic completion from sml-mode)
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 2)
    ;; sml-mode has a built-in company backend
    (add-to-list 'company-backends 'company-sml)
    )

  ;; Eldoc for displaying type signatures/documentation in the minibuffer
  (use-package eldoc
    :hook (sml-mode . turn-on-eldoc-mode))
  )

Explanation of the init.el snippet for SML:

    use-package sml-mode: The primary Emacs mode for Standard ML.
        :mode "\\.sml\\'": Activates sml-mode for files ending with .sml.
        :hook: Sets up 2-space indentation (common for SML), electric pairing, and trimming trailing whitespace on save.
        sml-program: Crucial! This variable tells sml-mode which SML interpreter executable to use. It defaults to "sml". If you use Moscow ML (mosml), Poly/ML (polyml), or if your chosen SML executable isn't in your PATH, you must uncomment and set this variable to the correct name or full path.
        sml-args: Allows you to pass command-line arguments to the SML interpreter when it starts (e.g., for memory limits, loading specific libraries).
    use-package flycheck: Integrates with sml-mode to display SML compiler errors and warnings directly in your buffer. sml-mode provides a built-in Flycheck checker that uses the SML interpreter for diagnostics.
    use-package company: The auto-completion framework. sml-mode provides a company-sml backend for basic identifier completion.
    use-package eldoc: Shows type information or documentation for the symbol at point in the minibuffer.

Useful Keyboard Shortcuts for Standard ML in Emacs

SML development in Emacs heavily leverages its interactive REPL.

General Emacs Shortcuts (still apply):

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: For compiling SML projects (if your SML implementation supports building standalone executables or libraries, e.g., using CM or ml-build with SML/NJ).
        M-g n / M-g p: Navigate to next/previous error.
    C-M-a / C-M-e: Move backward/forward S-expression (useful for SML's block structure).

sml-mode Specific Shortcuts (interactive with the SML REPL):

    C-c C-l (sml-load-file): Load the current SML file into the SML interactive process (*sml* buffer). This is a primary command – use it often to check your code.
    C-c C-r (sml-send-region): Send the selected region of SML code to the REPL for evaluation.
    C-c C-b (sml-send-buffer): Send the entire buffer to the REPL.
    C-c C-e (sml-send-definition): Send the current top-level definition (e.g., fun, val, type) to the REPL. This is very efficient for incremental development.
    C-c C-s (sml-switch-to-process-buffer): Switch to the *sml* REPL buffer.
    C-c C-z (sml-pop-to-process-buffer): Similar to C-c C-s, switches to the REPL.
    C-c C-k (sml-kill-process): Kill the running SML interactive process.
    C-c C-p (sml-cd): Change the working directory of the SML process to the current file's directory.
    M-x sml-indent-buffer: Reindent the entire buffer according to SML style.

Tips for SML Development in Emacs:

    REPL-Driven Development: SML, like Scheme, shines with REPL-driven development. Use C-c C-e to send definitions incrementally, observe types, and test functions.
    Error Messages: SML compiler error messages can be quite detailed and sometimes a bit cryptic at first. Look at the *sml* buffer for the full output, not just the flycheck pop-ups.
    Save Frequently: C-c C-l (load file) often works best on a saved version of the file.

This setup should provide a very capable and comfortable environment for working with Standard ML in Emacs!

What's next on your Emacs configuration journey?

}}}
HTML, CSS/SASS/Suzy, JavaScript/Ts, REACT, (+PHP)
    web-mode
ReasonML, PureScript {{{

Excellent! Adding ReasonML and PureScript will further enhance your Emacs for functional and type-safe programming. Both languages benefit greatly from Language Server Protocol (LSP) integration for a rich development experience.

Let's prepare the configuration for each. Remember, these snippets should go into separate .el files within your ~/.emacs.d/lisp/languages/ directory (e.g., reasonml.el and purescript.el), and not include the use-package bootstrapping preamble, as that's now handled by your lean init.el.
1. ReasonML Configuration

ReasonML is a syntax for OCaml, focusing on a more C-like, JavaScript-friendly syntax. Most of its tooling is built on the OCaml ecosystem.

Crucial Prerequisites (Outside of Emacs):

    OCaml/Reason Toolchain: The most common way to get ReasonML is via bs-platform (for compiling to JavaScript) or a native OCaml setup.
        bs-platform: npm install -g bs-platform (or via yarn). This provides bsc (BuckleScript compiler) and refmt (formatter).
        Native OCaml: Install opam (OCaml package manager), then use opam install ocaml-lsp-server.
    OCaml Language Server (ocaml-lsp): This is the recommended LSP server for both OCaml and ReasonML.
        Install via opam: opam install ocaml-lsp-server
        Ensure ocaml-lsp (the executable) is in your system's PATH.

Emacs Configuration (~/.emacs.d/lisp/languages/reasonml.el)
Code snippet

;;; reasonml.el --- Configuration for ReasonML -*- lexical-binding: t; -*-

(use-package reason-mode
  :mode (("\\.re\\'" . reason-mode) ; ReasonML source files
         ("\\.rei\\'" . reason-mode) ; ReasonML interface files
         ("\\.bs.js\\'" . js-mode)   ; Generated BuckleScript JS files (optional, handled by js-mode)
         ("\\.jsx\\'" . rjsx-mode))  ; React JSX syntax (often used with ReasonML)
  :hook (reason-mode . (lambda ()
                          (setq indent-tabs-mode nil) ; Use spaces
                          (setq tab-width 2)           ; 2 spaces for ReasonML (common)
                          (electric-pair-mode 1)
                          (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; Optionally, configure `refmt` (the formatter) if you want `M-x reason-format`
  ;; (setq reason-format-command "refmt")
  ;; (setq reason-format-args '("--in-place"))

  ;; --- Eglot for OCaml Language Server (ocaml-lsp) ---
  ;; This provides advanced features for ReasonML.
  (use-package eglot
    :hook ((reason-mode . eglot-ensure)
           (rjsx-mode . eglot-ensure))
    :config
    ;; Tell eglot how to start the OCaml Language Server for ReasonML modes.
    ;; Assumes `ocaml-lsp` is in your system's PATH.
    (add-to-list 'eglot-server-programs '(reason-mode . ("ocaml-lsp")))
    (add-to-list 'eglot-server-programs '(rjsx-mode . ("ocaml-lsp")))

    ;; Enable formatting on save via LSP
    (add-hook 'eglot-managed-mode-hook
              (lambda ()
                (when (or (eq major-mode 'reason-mode) (eq major-mode 'rjsx-mode))
                  (add-hook 'before-save-hook #'eglot-format-buffer nil t))))
    )

  ;; --- Flycheck for diagnostics (integrates with eglot) ---
  (use-package flycheck
    :hook ((reason-mode . flycheck-mode)
           (rjsx-mode . flycheck-mode))
    :init (global-flycheck-mode))

  ;; --- Company-mode for auto-completion (integrates with eglot) ---
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 2)
    (add-to-list 'company-backends 'company-capf)) ; Eglot provides completion via company-capf

  ;; --- Optional: rjsx-mode for JSX syntax with ReasonML ---
  ;; If you write ReasonReact code with JSX, rjsx-mode provides better support.
  (use-package rjsx-mode
    :ensure t ; rjsx-mode often comes with reason-mode or is readily available
    :hook (rjsx-mode . (lambda ()
                          (setq indent-tabs-mode nil)
                          (setq tab-width 2)
                          (electric-pair-mode 1)
                          (add-hook 'before-save-hook 'delete-trailing-whitespace nil t))))
  )

ReasonML Keyboard Shortcuts:

    C-x C-s: Save.
    M-x compile: Use for npm run build, esy build, or dune build in OCaml/Reason projects.
    M-x reason-format-buffer: Format the current ReasonML buffer using refmt (if configured).
    Eglot/LSP shortcuts:
        M-.: Go to definition.
        M-,: Go back.
        M-x xref-find-references: Find references.
        M-x eglot-rename: Rename symbol.
        M-x eglot-code-action: Quick fixes/refactorings.
        M-x eglot-hover: Show type/doc info.

2. PureScript Configuration

PureScript is a strongly-typed functional programming language that compiles to JavaScript. It's often described as "Haskell that compiles to JavaScript."

Crucial Prerequisites (Outside of Emacs):

    PureScript Compiler (purs):
        NPM: npm install -g purescript
        Direct Download: From the PureScript GitHub releases page.
    PureScript Language Server (purescript-language-server): This provides excellent LSP features.
        NPM: npm install -g purescript-language-server
        Ensure purescript-language-server is in your system's PATH.

Emacs Configuration (~/.emacs.d/lisp/languages/purescript.el)
Code snippet

;;; purescript.el --- Configuration for PureScript -*- lexical-binding: t; -*-

(use-package purescript-mode
  :mode (("\\.purs\\'" . purescript-mode)) ; Activate purescript-mode for .purs files
  :hook (purescript-mode . (lambda ()
                              (setq indent-tabs-mode nil) ; Use spaces
                              (setq tab-width 2)           ; 2 spaces for PureScript (common)
                              (electric-pair-mode 1)
                              (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; --- Eglot for PureScript Language Server (purescript-language-server) ---
  ;; This provides advanced features like completion, definition lookup, and diagnostics.
  (use-package eglot
    :hook (purescript-mode . eglot-ensure)
    :config
    ;; Tell eglot how to start the PureScript Language Server.
    ;; Assumes `purescript-language-server` is in your system's PATH.
    (add-to-list 'eglot-server-programs '(purescript-mode . ("purescript-language-server" "--stdio")))

    ;; Enable formatting on save via LSP (purescript-language-server supports this)
    (add-hook 'eglot-managed-mode-hook
              (lambda ()
                (when (eq major-mode 'purescript-mode)
                  (add-hook 'before-save-hook #'eglot-format-buffer nil t))))
    )

  ;; --- Flycheck for diagnostics (integrates with eglot) ---
  (use-package flycheck
    :hook (purescript-mode . flycheck-mode)
    :init (global-flycheck-mode))

  ;; --- Company-mode for auto-completion (integrates with eglot) ---
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 2)
    (add-to-list 'company-backends 'company-capf)) ; Eglot provides completion via company-capf

  ;; --- Optional: psc-ide-mode (older, but some prefer) ---
  ;; Before LSP, psc-ide-mode was used directly with `purs-ide`.
  ;; If you prefer it or have issues with the LSP server, you can try this.
  ;; (use-package psc-ide
  ;;   :hook (purescript-mode . psc-ide-mode)
  ;;   :config
  ;;   (setq psc-ide-purs-path "purs")
  ;;   (setq psc-ide-repl-path "psci")
  ;;   )
  )

PureScript Keyboard Shortcuts:

    C-x C-s: Save.
    M-x compile: Use for spago build (if using Spago), purs compile, or npm run build in a PureScript project.
    Eglot/LSP shortcuts: (Identical to ReasonML's LSP shortcuts)
        M-.: Go to definition.
        M-,: Go back.
        M-x xref-find-references: Find references.
        M-x eglot-rename: Rename symbol.
        M-x eglot-code-action: Quick fixes/refactorings.
        M-x eglot-hover: Show type/doc info.

With these additions, your modular Emacs configuration will now provide robust support for ReasonML and PureScript, fully leveraging their respective language servers for an optimal development experience!

}}}
XML-mode (nXML)
  SVG
  Prolog/Mercury
Kotlin {{{

Kotlin is a fantastic modern language, especially popular for Android development and backend services. Setting up Emacs for Kotlin provides a powerful alternative to heavier IDEs like IntelliJ IDEA.

Here's how to configure Emacs for Kotlin, along with useful shortcuts.
Emacs Configuration for Kotlin (init.el / ~/.emacs.d/lisp/languages/kotlin.el)

Crucial Prerequisites (Outside of Emacs):

    Java Development Kit (JDK): Kotlin runs on the JVM, so you need a JDK (version 11 or higher, preferably Java 17+ for modern Kotlin versions).
        Arch Linux:
        Bash

    sudo pacman -S jdk-openjdk # Installs the default OpenJDK

    You might also use sdkman for managing multiple JDK versions: curl -s "https://get.sdkman.io" | bash then sdk install java <version>.
    Verify: java -version

Kotlin Compiler: While IDEs bundle it, for command-line use and some tools, having the kotlinc compiler is useful.

    Arch Linux (AUR):
    Bash

    yay -S kotlin # or paru -S kotlin

    SDKMAN!: sdk install kotlin
    Manual: Download from github.com/JetBrains/kotlin/releases, unzip, and add the bin directory to your PATH.
    Verify: kotlinc -version

Kotlin Language Server (kotlin-language-server or kotlin-lsp): This is critical for IDE-like features. The official one is kotlin-lsp from the Kotlin GitHub organization, but fwcd/kotlin-language-server is another well-known community project. The official one seems to be getting more traction lately.

    kotlin-lsp (Official): This is under active development by JetBrains/Kotlin.
        Installation: It's often distributed as a .zip or VSIX (for VS Code). You'll typically clone its repository and build it:
        Bash

    # Choose a good location for language servers, e.g., ~/.local/share/language_servers
    mkdir -p ~/.local/share/language_servers
    cd ~/.local/share/language_servers
    git clone https://github.com/Kotlin/kotlin-lsp.git
    cd kotlin-lsp
    ./gradlew :server:installDist # This builds the server and places it in server/build/install/server

    Add to PATH: You'll need to add ~/.local/share/language_servers/kotlin-lsp/server/build/install/server/bin to your system's PATH.
    Verify: Run ~/.local/share/language_servers/kotlin-lsp/server/build/install/server/bin/kotlin-language-server --help to ensure it runs.

fwcd/kotlin-language-server (Community):

    Installation (via Gradle):
    Bash

            git clone https://github.com/fwcd/kotlin-language-server.git
            cd kotlin-language-server
            ./gradlew installDist

            The executable will be in build/install/kotlin-language-server/bin. Add this directory to your PATH.
            Homebrew (macOS): brew install kotlin-language-server (if you're on macOS)
            Verify: kotlin-language-server --help

    Note: The official kotlin-lsp is built on IntelliJ IDEA components and might require more specific JVM/Gradle setup. If you run into issues, the fwcd one might be simpler to get running, but the official one is likely to have better long-term support and feature parity with IntelliJ. I'll provide config for the official one.

    Kotlin Formatter (ktlint or ktfmt): For consistent code style.
        ktlint: curl -sSL https://install.ktlint.dev | bash (installs to /usr/local/bin or similar)
        ktfmt: Download ktfmt.jar from its GitHub releases (github.com/google/ktfmt) and place it somewhere in your PATH. You'd then run it with java -jar ktfmt.jar. ktfmt is often preferred for deterministic formatting.

Here's the use-package configuration to go into your modular setup (e.g., ~/.emacs.d/lisp/languages/kotlin.el):
Code snippet

;;; kotlin.el --- Configuration for Kotlin -*- lexical-binding: t; -*-

(use-package kotlin-mode
  :ensure t ; Ensure it's installed from MELPA
  :mode "\\.kt\\'" ; Activate kotlin-mode for .kt files
  :hook (kotlin-mode . (lambda ()
                          (setq tab-width 4)         ; Kotlin community standard is 4 spaces
                          (setq indent-tabs-mode nil) ; Prefer spaces
                          (electric-pair-mode 1)     ; Auto-pair brackets, parens, etc.
                          (add-hook 'before-save-hook #'delete-trailing-whitespace nil t)
                          ;; Optionally, add formatter on save
                          ;; (add-hook 'before-save-hook #'kotlin-format-on-save nil t)
                          ;; Or use LSP formatting (often preferred if robust)
                          (add-hook 'before-save-hook #'eglot-format-buffer nil t)
                          ))
  :config
  ;; --- Eglot for Kotlin Language Server ---
  (use-package eglot
    :hook (kotlin-mode . eglot-ensure) ; Automatically activate eglot when kotlin-mode is used
    :config
    ;; Tell eglot how to start the Kotlin Language Server.
    ;; Assuming 'kotlin-language-server' or 'kotlin-lsp' is in your PATH.
    ;; Adjust this path if you installed `kotlin-lsp` to a specific directory.
    (add-to-list 'eglot-server-programs '(kotlin-mode . ("kotlin-language-server")))
    ;; If using the official `kotlin-lsp` built from source, it might be:
    ;; (add-to-list 'eglot-server-programs '(kotlin-mode . ("~/.local/share/language_servers/kotlin-lsp/server/build/install/server/bin/kotlin-language-server")))

    ;; --- Optional: Check for language server binary presence ---
    (add-hook 'eglot-managed-mode-hook
              (lambda ()
                (when (eq major-mode 'kotlin-mode)
                  (my-check-and-suggest-install-binary
                   "kotlin-language-server" ; Or "kotlin-lsp" depending on the binary name
                   "See https://github.com/Kotlin/kotlin-lsp for installation (build from source with Gradle).
                      Make sure ~/.local/share/language_servers/kotlin-lsp/server/build/install/server/bin is in your PATH.")
                  ;; Ensure Java is installed and JAVA_HOME is set for the LSP server
                  (unless (executable-find "java")
                    (message "Java (JDK 17+) not found. Kotlin Language Server requires Java."))
                  (unless (getenv "JAVA_HOME")
                    (message "JAVA_HOME environment variable not set. Kotlin Language Server might need it."))
                  )))
    )

  ;; --- Flycheck for diagnostics (integrates with eglot) ---
  (use-package flycheck
    :hook (kotlin-mode . flycheck-mode)
    :init (global-flycheck-mode))

  ;; --- Company-mode for auto-completion (integrates with eglot) ---
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 2)
    (add-to-list 'company-backends 'company-capf)) ; Eglot provides completion via company-capf

  ;; --- Kotlin Formatter Integration (Optional, but highly recommended) ---
  ;; Use `ktlint` or `ktfmt`
  (defun kotlin-format-buffer-with-ktlint ()
    "Format the current Kotlin buffer using `ktlint --stdin --format`."
    (interactive)
    (when (executable-find "ktlint")
      (let* ((buffer-content (buffer-string))
             (process (start-process-shell-command
                       "ktlint-formatter"
                       nil
                       "ktlint --stdin --format")))
        (process-send-string process buffer-content)
        (process-send-eof process)
        (let ((formatted-output (process-get-output process)))
          (when (stringp formatted-output)
            (delete-region (point-min) (point-max))
            (insert formatted-output))))
      (message "Buffer formatted with ktlint."))
    (save-buffer))

  (defun kotlin-format-buffer-with-ktfmt ()
    "Format the current Kotlin buffer using `ktfmt`."
    (interactive)
    (when (executable-find "java") ; ktfmt is a JAR, needs java
      (let* ((buffer-content (buffer-string))
             (ktfmt-path (executable-find "ktfmt.jar")) ; Or full path to ktfmt.jar
             (process (start-process-shell-command
                       "ktfmt-formatter"
                       nil
                       (format "java -jar %s" ktfmt-path))))
        (process-send-string process buffer-content)
        (process-send-eof process)
        (let ((formatted-output (process-get-output process)))
          (when (stringp formatted-output)
            (delete-region (point-min) (point-max))
            (insert formatted-output))))
      (message "Buffer formatted with ktfmt."))
    (save-buffer))

  ;; Choose your preferred formatter on save.
  ;; If you use `eglot-format-buffer` on save, ensure your LSP server
  ;; (`kotlin-language-server`) is configured to provide formatting.
  ;; Some users prefer external formatters like ktlint/ktfmt explicitly.
  ;; (add-hook 'before-save-hook #'kotlin-format-buffer-with-ktlint nil t) ; For ktlint
  ;; (add-hook 'before-save-hook #'kotlin-format-buffer-with-ktfmt nil t) ; For ktfmt
  )

Explanation of the kotlin.el snippet:

    use-package kotlin-mode: The primary major mode for Kotlin.
        :mode "\\.kt\\'": Automatically activates kotlin-mode for .kt files.
        :hook: Sets up 4-space indentation, electric pairing, and an optional before-save-hook for formatting.
    use-package eglot: Integrates with kotlin-language-server.
        :hook (kotlin-mode . eglot-ensure): Ensures Eglot starts for Kotlin files.
        add-to-list 'eglot-server-programs '(kotlin-mode . ("kotlin-language-server")): Tells Eglot to launch the Kotlin LSP server. You might need to adjust the exact command/path here based on which server you installed and where it's located.
        Binary Check: Uses your my-check-and-suggest-install-binary helper and also checks for Java and JAVA_HOME.
    use-package flycheck & use-package company: Standard integrations for on-the-fly diagnostics and advanced completion, which will be powered by the Kotlin Language Server via Eglot.
    Formatter Integration (kotlin-format-buffer-with-ktlint/ktfmt): Custom functions to manually run external formatters (ktlint or ktfmt). You can hook one of these to before-save-hook if you prefer explicit external formatting. LSP also provides formatting via eglot-format-buffer.

Useful Keyboard Shortcuts for Kotlin in Emacs

Most of your interaction will leverage general Emacs commands and Eglot's LSP features.

General Emacs Shortcuts (always useful):

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: For compiling and running Kotlin code (e.g., kotlinc %f -include-runtime -d output.jar && java -jar output.jar).
        M-g n / M-g p: Navigate to next/previous error in the *compilation* buffer.
    C-M-a / C-M-e: Move backward/forward S-expression.
    M-! (shell-command): Run a single shell command (e.g., kotlinc -version).
    M-x shell: Open a general shell buffer for interactive commands.
    C-M-\ (indent-region): Re-indent the selected region.
    C-c C-e: (If you have comment-dwim or similar set up) comment/uncomment region/line.

Eglot/LSP Shortcuts (when kotlin-mode is active):

These are the standard Eglot commands, powered by the Kotlin Language Server:

    M-. (xref-find-definitions): Go to definition.
    M-, (xref-pop-marker-stack): Go back (pop mark).
    M-x xref-find-references: Find all references to the symbol at point.
    M-x eglot-rename: Rename a symbol across your project.
    M-x eglot-code-action: Access quick fixes or refactoring options (e.g., "Organize Imports", "Extract function").
    M-x eglot-hover: Show documentation/type info for the symbol at point.
    M-x eglot-format-buffer: Format the current buffer using the LSP server.
    M-x eglot-reconnect: Reconnect to the language server if it crashes or you need to restart it.
    M-x eldoc: Show function signatures and documentation in the minibuffer.

kotlin-mode Specific Shortcuts (if defined):

kotlin-mode (the Emacs package itself) might offer some basic commands, but much of the "IDE" functionality will come from the language server.

    If you added the formatting functions:
        M-x kotlin-format-buffer-with-ktlint: Manually format the current buffer with ktlint.
        M-x kotlin-format-buffer-with-ktfmt: Manually format the current buffer with ktfmt.

Kotlin development in Emacs can be very productive. The key is ensuring your Java environment, Kotlin compiler, and especially the Kotlin Language Server are correctly installed and in your system's PATH.

}}}
GoLang {{{

Excellent choice! Golang (Go) is a fantastic language, and Emacs offers a robust development environment for it, especially with the help of go-mode and gopls (the official Go language server).

Here's a breakdown of how to set up Emacs for Go development, along with useful shortcuts.
Emacs Configuration for Golang (init.el / ~/.emacs.d/lisp/languages/golang.el)

Crucial Prerequisite (Outside of Emacs):

    Go Installation: You need to have Go installed on your system.
        Arch Linux:
        Bash

    sudo pacman -S go

    For other systems, refer to the official Go website: go.dev/doc/install
    Verify Installation: After installing, ensure go version works in your terminal.

gopls (Go Language Server): This is the official and highly recommended LSP server for Go, providing most of the advanced IDE features.

    Installation:
    Bash

        go install golang.org/x/tools/gopls@latest

        Ensure the directory containing gopls (typically $(go env GOBIN) or $(go env GOPATH)/bin) is in your system's PATH. If you've set up your Go environment correctly, this usually happens automatically.
        Verify Installation: gopls version should output its version.

Here's the use-package configuration for Go, to be placed in your modular setup (e.g., ~/.emacs.d/lisp/languages/golang.el):
Code snippet

;;; golang.el --- Configuration for Golang -*- lexical-binding: t; -*-

(use-package go-mode
  :mode "\\.go\\'" ; Activate go-mode for .go files
  :hook (go-mode . (lambda ()
                      (setq tab-width 4)         ; Go community standard is 4 spaces
                      (setq indent-tabs-mode nil) ; Prefer spaces
                      (electric-pair-mode 1)     ; Auto-pair brackets, parens, etc.
                      (add-hook 'before-save-hook #'go-organize-imports-before-save nil t) ; Organize imports on save
                      (add-hook 'before-save-hook #'eglot-format-buffer nil t) ; Format on save (via LSP)
                      ))
  :config
  ;; --- Eglot for gopls (Go Language Server) ---
  (use-package eglot
    :hook (go-mode . eglot-ensure) ; Automatically activate eglot when go-mode is used
    :config
    ;; Tell eglot how to start the Go Language Server.
    ;; `gopls` is the executable.
    (add-to-list 'eglot-server-programs '(go-mode . ("gopls")))

    ;; --- Optional: Check for gopls binary presence ---
    ;; This leverages your custom `my-check-and-suggest-install-binary` function.
    (add-hook 'eglot-managed-mode-hook
              (lambda ()
                (when (eq major-mode 'go-mode)
                  (my-check-and-suggest-install-binary
                   "gopls"
                   "go install golang.org/x/tools/gopls@latest"))))

    ;; Gopls specific settings (via eglot-workspace-configuration)
    ;; Refer to `gopls` documentation for all available settings.
    ;; Example: Enable optional analyses by gopls
    (setq eglot-workspace-configuration
          '(:gopls (:analyses (:nilness t :shadow t :unusedwrite t)
                     :codelenses (:test t :tidy t :upgrade_dependency t))))
    )

  ;; --- Flycheck for diagnostics (integrates with eglot) ---
  (use-package flycheck
    :hook (go-mode . flycheck-mode)
    :init (global-flycheck-mode))

  ;; --- Company-mode for auto-completion (integrates with eglot) ---
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 2)
    (add-to-list 'company-backends 'company-capf)) ; Eglot provides completion via company-capf

  ;; --- go-mode specific tools (some might be superseded by gopls) ---
  ;; `go-mode` provides some commands that `gopls` also handles,
  ;; but they can still be useful.
  (define-key go-mode-map (kbd "C-c C-r") 'go-run)         ; Run current Go file
  (define-key go-mode-map (kbd "C-c C-b") 'go-build)        ; Build Go project
  (define-key go-mode-map (kbd "C-c C-t") 'go-test)         ; Run tests
  (define-key go-mode-map (kbd "C-c C-c") 'go-play-buffer)  ; Send buffer to Go Playground
  (define-key go-mode-map (kbd "C-c C-f i") 'go-goto-imports) ; Go to imports section
  (define-key go-mode-map (kbd "C-c C-a") 'go-import-add)   ; Add an import (often handled by gopls now)
  (define-key go-mode-map (kbd "C-c C-u") 'go-remove-unused-imports) ; Remove unused imports (often handled by gopls now)

  ;; `go-mode` has a hook for `gofmt` and `goimports` on save.
  ;; `gopls` also provides this functionality as an LSP code action (`textDocument/codeAction`).
  ;; The `go-organize-imports-before-save` function is part of `go-mode` and uses `goimports`.
  ;; If you prefer `gopls`'s method for formatting/organizing, make sure `eglot-format-buffer`
  ;; and relevant `eglot-code-action` settings are correct.
  (setq gofmt-command "goimports") ; Use goimports as the default formatter
  (add-hook 'go-mode-hook 'go-eldoc-setup) ; Show function signatures in minibuffer
  )

Explanation of the golang.el snippet:

    use-package go-mode: The primary major mode for Go.
        :mode "\\.go\\'": Automatically activates go-mode for .go files.
        :hook (go-mode . (lambda () ...)): Sets up Go-specific indentation (4 spaces, no tabs), electric pairing, and crucial before-save-hooks for organizing imports and formatting the code using gopls's capabilities.
    use-package eglot: Integrates with gopls.
        :hook (go-mode . eglot-ensure): Ensures Eglot starts for Go files.
        add-to-list 'eglot-server-programs '(go-mode . ("gopls")): Tells Eglot to launch gopls for Go files.
        Binary Check: Uses your my-check-and-suggest-install-binary helper to prompt if gopls is missing.
        eglot-workspace-configuration: Allows you to pass specific settings to gopls, such as enabling additional code analyses.
    use-package flycheck & use-package company: Standard integrations for on-the-fly diagnostics and advanced completion, which will be powered by gopls via Eglot.
    go-mode specific tools: While gopls handles many IDE features, go-mode still provides useful commands like go-run, go-build, and go-test to interact with the Go toolchain directly from Emacs.

Useful Keyboard Shortcuts for Golang in Emacs

Most of your interaction will leverage general Emacs commands and Eglot's LSP features.

General Emacs Shortcuts (always useful):

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: For custom go run or go build commands, like go run . or go test ./....
        M-g n / M-g p: Navigate to next/previous error in the *compilation* buffer.
    C-M-a / C-M-e: Move backward/forward S-expression (useful for navigating Go's AST structure).
    M-! (shell-command): Run a single shell command (e.g., go env).
    M-x shell: Open a general shell buffer for interactive commands.
    C-c C-e: (If you have comment-dwim or similar set up) comment/uncomment region/line.
    C-M-\ (indent-region): Re-indent the selected region.

Eglot/LSP Shortcuts (when go-mode is active):

These are the standard Eglot commands, powered by gopls:

    M-. (xref-find-definitions): Go to definition.
    M-, (xref-pop-marker-stack): Go back (pop mark).
    M-x xref-find-references: Find all references to the symbol at point.
    M-x eglot-rename: Rename a symbol across your project.
    M-x eglot-code-action: Access quick fixes or refactoring options (e.g., "Organize Imports" from gopls).
    M-x eglot-hover: Show documentation/type info for the symbol at point.
    M-x eglot-format-buffer: Format the current buffer using gofmt/goimports via gopls (this is also triggered on save if configured).
    M-x eglot-reconnect: Reconnect to the language server if it crashes or you need to restart it.
    M-x eldoc: Show function signatures and documentation in the minibuffer.

go-mode Specific Shortcuts:

go-mode provides its own set of useful bindings, many of which leverage go CLI tools:

    C-c C-r (go-run): Run the current Go file.
    C-c C-b (go-build): Build the current Go project.
    C-c C-t (go-test): Run tests for the current package.
    C-c C-c (go-play-buffer): Send the current buffer's content to the Go Playground (play.golang.org) and open the result in a browser.
    C-c C-f i (go-goto-imports): Jump to the imports section of the file.
    C-c C-a (go-import-add): Add an import (though gopls often handles this automatically with "Organize Imports").
    C-c C-u (go-remove-unused-imports): Remove unused imports.
    M-x gofmt: Explicitly run gofmt (or goimports if gofmt-command is set) on the buffer.
    M-x godoc-at-point: Show documentation for the symbol at point using godoc.

This setup should give you a very powerful and efficient environment for developing in Go within Emacs!

}}}
Vlang {{{

Vlang is indeed a very interesting, relatively new language that focuses on simplicity, safety, and performance. Emacs support for V is available and can be quite good with the right setup, leveraging a dedicated major mode and the official V Language Server.

Here's how you can configure Emacs for Vlang, along with useful shortcuts:
Emacs Configuration for Vlang (init.el / ~/.emacs.d/lisp/languages/vlang.el)

Crucial Prerequisites (Outside of Emacs):

    Vlang Installation: You need to have the V compiler installed on your system.
        Recommended (from source, most up-to-date):
        Bash

git clone https://github.com/vlang/v ~/.v
cd ~/.v
make # On Linux/macOS
# or make.bat on Windows

Arch Linux (from AUR): There might be vlang-bin or vlang-git packages in the AUR.
Bash

yay -S vlang-bin # or paru -S vlang-bin

Symlinking V to PATH: After installation, it's highly recommended to symlink the v executable to your PATH:
Bash

    sudo ~/.v/v symlink # On Linux/macOS
    # On Windows, open an Administrator shell and run: .\.v\v.exe symlink

    Verify Installation: v version should output its version.

v-analyzer (V Language Server): This is the official LSP server for V.

    Installation (from source): v-analyzer is a V project itself.
    Bash

        git clone --filter=blob:none --recursive --shallow-submodules https://github.com/vlang/v-analyzer ~/.v-analyzer
        cd ~/.v-analyzer
        v build.vsh release # Or `v build.vsh debug` for debug version

        Add to PATH: Ensure the bin/ directory within your ~/.v-analyzer clone (where v-analyzer binary is compiled) is added to your system's PATH.
        Verify Installation: v-analyzer -h should show help output.

Here's the use-package configuration to go into your modular setup (e.g., ~/.emacs.d/lisp/languages/vlang.el):
Code snippet

;;; vlang.el --- Configuration for Vlang -*- lexical-binding: t; -*-

(use-package vlang-mode
  :ensure t ; Ensure it's installed from MELPA
  :mode "\\.v\\'" ; Activate vlang-mode for .v files
  :hook (vlang-mode . (lambda ()
                         (setq indent-tabs-mode nil) ; Prefer spaces
                         (setq tab-width 4)           ; Vlang often uses 4 spaces
                         (electric-pair-mode 1)       ; Auto-pair brackets, parens, etc.
                         (add-hook 'before-save-hook #'vlang-format-on-save nil t) ; Format on save
                         (add-hook 'before-save-hook #'delete-trailing-whitespace nil t)))
  :config
  ;; --- Eglot for v-analyzer (V Language Server) ---
  (use-package eglot
    :hook (vlang-mode . eglot-ensure) ; Automatically activate eglot when vlang-mode is used
    :config
    ;; Tell eglot how to start the V Language Server (`v-analyzer`).
    (add-to-list 'eglot-server-programs '(vlang-mode . ("v-analyzer")))

    ;; --- Optional: Check for v-analyzer binary presence ---
    (add-hook 'eglot-managed-mode-hook
              (lambda ()
                (when (eq major-mode 'vlang-mode)
                  (my-check-and-suggest-install-binary
                   "v-analyzer"
                   "git clone https://github.com/vlang/v-analyzer ~/.v-analyzer && cd ~/.v-analyzer && v build.vsh release && add ~/.v-analyzer/bin to PATH"))))

    ;; v-analyzer specific settings (via eglot-workspace-configuration)
    ;; Refer to `v-analyzer` documentation for available settings.
    ;; (setq eglot-workspace-configuration '(:v (:buildFlags "-enable-debugger")))
    )

  ;; --- Flycheck for diagnostics (integrates with eglot) ---
  (use-package flycheck
    :hook (vlang-mode . flycheck-mode)
    :init (global-flycheck-mode))

  ;; --- Company-mode for auto-completion (integrates with eglot) ---
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 2)
    (add-to-list 'company-backends 'company-capf)) ; Eglot provides completion via company-capf

  ;; --- Vlang-mode specific functions ---
  ;; vlang-mode might have some specific commands. Check its documentation (C-h m) for more.
  ;; For example, to run the current file or format it manually.
  (defun vlang-format-buffer-and-save ()
    "Format the current V buffer using `v fmt -w` and save."
    (interactive)
    (shell-command (format "v fmt -w %s" (buffer-file-name)))
    (save-buffer))

  ;; Hook this to before-save-hook, if you prefer `v fmt -w` over LSP formatting.
  ;; If using Eglot's formatting (`eglot-format-buffer`), you might not need this.
  ;; However, `v fmt -w` is the official formatter, so it's good to ensure it runs.
  (defun vlang-format-on-save ()
    "Run `v fmt -w` on the current file before saving."
    (when (buffer-file-name)
      (shell-command (format "v fmt -w %s" (buffer-file-name)))))

  ;; Ensure the formatter runs *after* Eglot has done its thing,
  ;; or if Eglot's formatting isn't perfect.
  ;; (add-hook 'before-save-hook #'vlang-format-on-save nil t)
  ;; Make sure `eglot-format-buffer` runs if you want LSP formatting.
  ;; You can choose one or the other, or run `v fmt -w` after LSP.
  ;; For V, `v fmt -w` is very canonical.
  )

Explanation of the vlang.el snippet:

    use-package vlang-mode: The major mode for V.
        :mode "\\.v\\'": Activates vlang-mode for files with a .v extension.
        :hook (vlang-mode . (lambda () ...)): Sets up indentation (4 spaces), electric pairing, and adds a before-save-hook to format the file on save using v fmt -w.
    use-package eglot: Integrates with v-analyzer.
        :hook (vlang-mode . eglot-ensure): Ensures Eglot starts for V files.
        add-to-list 'eglot-server-programs '(vlang-mode . ("v-analyzer")): Tells Eglot to launch v-analyzer when in vlang-mode.
        Binary Check: Uses your my-check-and-suggest-install-binary helper function to prompt if v-analyzer isn't found.
    use-package flycheck & use-package company: Standard integrations for on-the-fly diagnostics and intelligent code completion, powered by v-analyzer via Eglot.
    vlang-format-on-save: A custom function that runs v fmt -w (the official V formatter) on your file before saving. This is highly recommended for V. You can decide if you want this in addition to or instead of eglot-format-buffer (which would also use v-analyzer's formatting capabilities). For V, v fmt -w is the most common and robust way to format.

Useful Keyboard Shortcuts for Vlang in Emacs

Most of your interaction will leverage general Emacs commands and Eglot's LSP features.

General Emacs Shortcuts (always useful):

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: You can use this to run V programs or build projects.
        Example: v run %f (to run the current file) or v build . (to build the current directory).
        M-g n / M-g p: Navigate to next/previous error in the *compilation* buffer.
    C-M-a / C-M-e: Move backward/forward S-expression (useful for navigating V's AST-like structure).
    M-! (shell-command): Run a single shell command (e.g., v version).
    M-x shell: Open a general shell buffer for interactive commands.
    C-M-\ (indent-region): Re-indent the selected region.
    C-c C-e: (If you have comment-dwim or similar set up) comment/uncomment region/line.

Eglot/LSP Shortcuts (when vlang-mode is active):

These are the standard Eglot commands, powered by v-analyzer:

    M-. (xref-find-definitions): Go to definition.
    M-, (xref-pop-marker-stack): Go back (pop mark).
    M-x xref-find-references: Find all references to the symbol at point.
    M-x eglot-rename: Rename a symbol across your project.
    M-x eglot-code-action: Access quick fixes or refactoring options.
    M-x eglot-hover: Show documentation/type info for the symbol at point.
    M-x eglot-format-buffer: Format the current buffer using v-analyzer's formatting capabilities.
    M-x eglot-reconnect: Reconnect to the language server if it crashes or you need to restart it.
    M-x eldoc: Show function signatures and documentation in the minibuffer (provided by v-analyzer).

Vlang-mode Specific Shortcuts (if defined):

The vlang-mode package itself might define some bindings, though often with LSP, you'll rely more on the generic Eglot commands. If you added the vlang-format-buffer-and-save function as suggested:

    M-x vlang-format-buffer-and-save: Manually format the current buffer using v fmt -w and save it.

V is still rapidly evolving, so ensure you keep both your V compiler and v-analyzer updated (v up for the compiler, and v-analyzer up for the language server if it supports it, or git pull in the v-analyzer directory and rebuild).

This setup should provide you with a very capable and integrated Emacs environment for working with Vlang!

}}}
Latex
JSON {{{

Of course! JSON (JavaScript Object Notation) isn't a programming language in the traditional sense, but it's a ubiquitous data interchange format. Emacs offers fantastic tools for working with JSON, especially for formatting, syntax highlighting, and navigating its structure.

The standard Emacs mode for JSON is json-mode. We'll also integrate jq (a command-line JSON processor) for advanced querying and formatting, and json-outline-mode for structural navigation.
Emacs Configuration for JSON (init.el)

We'll set up json-mode and then enhance it with jq for formatting and json-outline-mode for structural viewing.

Crucial Prerequisite (Outside of Emacs for jq features):

    jq (Command-line JSON processor): While Emacs can do basic JSON formatting, jq is incredibly powerful for pretty-printing, extracting data, filtering, and transforming JSON. It's highly recommended.
        Installation:
            macOS (Homebrew): brew install jq
            Debian/Ubuntu: sudo apt-get install jq
            Windows: Download from the jq GitHub releases page or use Chocolatey.

Make sure jq is in your system's PATH.

Here's the init.el snippet:
Code snippet

;; --- Emacs Package Management Preamble ---
;; (As established, this section ensures that packages are automatically installed
;; if they are not already present, based on your use-package declarations.)

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
;; (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

;; --- End of Emacs Package Management Preamble ---


;; --- JSON Configuration ---

(use-package json-mode
  :mode ("\\.json\\'" . json-mode) ; Activate json-mode for .json files
  :hook (json-mode . (lambda ()
                        (setq indent-tabs-mode nil) ; Use spaces
                        (setq tab-width 2)           ; 2 spaces for JSON (standard)
                        (electric-pair-mode 1)
                        (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; Optionally, use `jq` for pretty-printing.
  ;; If `jq` is not in PATH, set it explicitly:
  ;; (setq json-reformat-program "/path/to/jq")

  ;; Set the default indentation for `json-pretty-print-buffer` if you want it different from `tab-width`
  (setq json-pretty-print-indent-level 2)

  ;; --- JSON Outline Mode for structured navigation ---
  (use-package json-outline-mode
    :hook (json-mode . json-outline-mode) ; Automatically enable in json-mode
    :config
    ;; You can customize keybindings or behavior here if needed
    )

  ;; --- Flycheck for JSON validation (optional, requires external tools like 'jsonlint' or LSP) ---
  ;; For real-time validation, you'd typically need a JSON linter like `jsonlint` (npm install -g jsonlint)
  ;; or an LSP server for JSON (e.g., from VS Code's JSON language server).
  ;; If using `jsonlint`:
  ;; (use-package flycheck
  ;;   :init (global-flycheck-mode)
  ;;   :config
  ;;   (flycheck-define-checker json-jsonlint
  ;;     :command ("jsonlint" "-q")
  ;;     :error-patterns
  ;;     ((error line-start (file-name) ":" line ":" column ":" (message) line-end)))
  ;;   (add-to-list 'flycheck-checkers 'json-jsonlint)
  ;;   (add-hook 'json-mode-hook (lambda () (flycheck-mode)))) ; Enable only for JSON files

  ;; If using LSP (e.g., from `vscode-json-languageserver` npm package):
  ;; (use-package eglot
  ;;   :config
  ;;   (add-to-list 'eglot-server-programs '(json-mode . ("json-language-server" "--stdio"))))
  )

Explanation of the init.el snippet for JSON:

    use-package json-mode: The core major mode for JSON.
        :mode ("\\.json\\'" . json-mode): Activates json-mode for files ending with .json.
        :hook: Sets up 2-space indentation (standard for JSON), electric pairing (for {} and []), and removes trailing whitespace on save.
        json-reformat-program: By default, json-mode can use jq for pretty-printing if it's in your PATH. If not, you can set the full path to jq here.
        json-pretty-print-indent-level: Sets the default indentation level for json-pretty-print-buffer.
    use-package json-outline-mode: This minor mode provides a structural outline of your JSON data, similar to how outline-mode works for code. It allows you to collapse/expand objects and arrays, making large JSON files much easier to navigate.
        :hook (json-mode . json-outline-mode): Automatically enables json-outline-mode when you open a JSON file.
    flycheck and eglot (Optional for Validation):
        JSON doesn't have a compiler in the same way as programming languages. Validation usually involves a linter. I've included commented-out examples for jsonlint (a Node.js package) or an LSP server for JSON. If you need real-time validation, you'd uncomment and install the respective external tool.

Useful Keyboard Shortcuts for JSON in Emacs

JSON interaction in Emacs focuses on formatting, navigation, and sometimes, quick querying.

General Emacs Shortcuts (still apply):

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    C-M-a / C-M-e: Move backward/forward S-expression (useful for jumping between JSON objects/arrays).
    C-M-h: Mark the current object/array.

json-mode Specific Shortcuts:

    C-c C-e (json-pretty-print-buffer): Reformat the entire JSON buffer with standard indentation. This is your primary formatting command.
    C-c C-r (json-pretty-print-region): Reformat the selected JSON region.
    C-c C-j (json-send-region-or-buffer): Send the current region or buffer to the jq command (if configured). This opens a *jq-output* buffer with the results. You can use this for quick queries like . (pretty-print), .[].name, etc.
    C-c C-c: If json-reformat-on-save is true (not enabled by default in the snippet, but possible), this might trigger a format.

json-outline-mode Specific Shortcuts (when json-outline-mode is active):

These are similar to standard outline-mode commands:

    C-c C-o C-t (hide-body): Hide all JSON values, leaving only keys.
    C-c C-o C-a (show-all): Show everything.
    C-c C-o C-l (show-all-levels): Show all levels.
    C-c C-o C-d (outline-hide-subtree): Hide the current JSON object/array subtree.
    C-c C-o C-i (outline-show-subtree): Show the current JSON object/array subtree.
    C-c C-o C-s (outline-show-branches): Show branches up to a certain level.
    TAB: Toggle visibility of the current item's children.
    S-TAB: Toggle visibility of all item's children at the current level.
    C-c C-o C-f (outline-next-visible-heading): Go to next visible JSON key/object.
    C-c C-o C-b (outline-previous-visible-heading): Go to previous visible JSON key/object.

Working with JSON in Emacs with this setup should be efficient and comfortable, especially when dealing with large or complex JSON documents.

What's the final language or format on your list for Emacs configuration?

}}}
Markdown-mode (+Org with Markdown) {{{

Could you give me some quick direction on tools I can install and use for rendering Markdown with Pandoc, and also what tools are available for Markdown-mode, both these questions referring to using Emacs?

You're in good company using Emacs for Markdown! It has excellent support. Here's a quick rundown of tools for rendering with Pandoc and for a great Markdown editing experience within Emacs:

Tools for Rendering Markdown with Pandoc:

You'll primarily need Pandoc itself. It's a command-line tool that handles the conversion.  

    Installation:
        Linux (Debian/Ubuntu): sudo apt-get update && sudo apt-get install pandoc   

    Linux (Fedora/CentOS/RHEL): sudo dnf install pandoc or sudo yum install pandoc
    macOS: You can use Homebrew: brew install pandoc. If you don't have Homebrew, you can install it from https://brew.sh/. Alternatively, you can download a .pkg installer from the Pandoc website.
    Windows: Download the installer from the official Pandoc website: https://pandoc.org/installing.html.

Usage (from the command line/terminal):

    To convert a Markdown file (my_report.md) to a PDF (my_report.pdf):
    Bash

pandoc my_report.md -o my_report.pdf --citeproc --bibliography references.bib --csl apa.csl

(Adjust the bibliography and CSL file names as needed. You might omit --citeproc, --bibliography, and --csl if you're not using citations yet.)
To convert to other formats (HTML, DOCX, etc.), just change the output file extension and potentially adjust options. For example, to HTML:
Bash

        pandoc my_report.md -o my_report.html

Markdown Mode in Emacs:

Emacs has a built-in markdown-mode which is quite good. However, there are also enhanced alternatives:  

    Built-in markdown-mode:
        Activation: Emacs usually automatically detects .md files and opens them in markdown-mode. If not, you can manually enable it with M-x markdown-mode.
        Features: Provides basic syntax highlighting, indentation, and some keybindings for common Markdown elements. It's a solid starting point.

    Enhanced markdown-mode (from MELPA):
        Installation: This is a more actively maintained and feature-rich version that has replaced the built-in one in many Emacs configurations. You'll need to have MELPA (or another package repository like GNU ELPA) set up in your Emacs. If you haven't already, you can add MELPA to your init.el or .emacs file:
        Code snippet

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(package-initialize)

Then, you can install it with M-x package-install RET markdown-mode RET.  

        Features: This enhanced mode typically includes:
            Improved syntax highlighting.
            Better indentation and list handling.
            Keybindings for inserting links, images, headings, etc.
            Support for Markdown extensions.
            Integration with previewers.

    org-mode (Alternative with Markdown Capabilities):
        While primarily an outlining and note-taking tool, org-mode can also handle Markdown syntax and export to various formats via Pandoc. If you're already familiar with org-mode, this could be an option.
        It's usually bundled with Emacs, so no separate installation is needed. You can try opening a .md file and see how it's handled, or you might need to enable Markdown syntax support within org-mode if you prefer its features.

Recommended Emacs Setup for Markdown:

For a good Markdown editing experience in Emacs, I'd recommend:

    Install the enhanced markdown-mode from MELPA. It offers a more comprehensive set of features.
    Consider a live previewer. Packages like markdown-preview-mode can render your Markdown in a separate buffer or window as you type. You can install it from MELPA as well.
    Explore keybindings. The enhanced markdown-mode comes with useful keybindings (check its documentation or use C-h m when in the mode). You might also want to customize your own.
    Integrate with Pandoc. You can set up Emacs to run Pandoc commands directly from within your Markdown buffer. Packages like projectile or simple shell-command calls can help with this.

By installing Pandoc and setting up a good Markdown mode in Emacs (especially the enhanced version from MELPA), you'll have a powerful and efficient environment for writing your academic reports in Markdown and rendering them into professional-looking documents.
Getting started with pandoc
Source icon
pandoc.org
How to Use pandoc to Convert Files on the Linux Command Line - How-To Geek
Source icon
www.howtogeek.com
Read Guide to Markdown Mode for Emacs - Leanpub
Source icon
leanpub.com
A simple emacs init.el file to configure melpa and load the solarized-dark theme. · GitHub
Source icon
gist.github.com

Could you give me a snapshot of useful keybindings for the enhanced markdown-mode, not necessarily completely exhaustive, but both some basic and more advanced ones

Alright, here's a snapshot of useful keybindings for the enhanced markdown-mode in Emacs, covering both basic and more advanced functionality. Keep in mind that keybindings can sometimes be customized, so these are the defaults you'll likely encounter.

Basic Formatting:

    M-s h 1 to M-s h 6 (Meta + s, then h, then 1-6): Set heading level 1 through 6. For example, M-s h 2 will insert ## at the beginning of the line or around the selected region.
    M-s b (Meta + s, then b): Toggle bold formatting (**bold** or __bold__). If text is selected, it will be enclosed in the markers.
    M-s i (Meta + s, then i): Toggle italic formatting (*italic* or _italic_). Works similarly to bold.
    M-s l (Meta + s, then l): Insert a link. It will prompt you for the link text and the URL.
    M-s i m (Meta + s, then i, then m): Insert an image. It will prompt you for the image description (alt text) and the file path/URL.
    M-s q (Meta + s, then q): Insert a blockquote (>). If a region is selected, it will prefix each line with >.
    M-s c (Meta + s, then c): Insert inline code (`code`).
    M-s C (Meta + s, then Shift + c): Insert a fenced code block. It might prompt you for the language.

List Management:

    M-RET (Meta + Return): Insert a new list item. If you're in an unordered list (*, -, +), it will insert the same marker. If in an ordered list (1., 2., etc.), it will insert the next number.
    M-S-RET (Meta + Shift + Return): Insert a new list item without continuing the numbering or bullet.
    TAB (within a list): Indent the current list item (creating a sublist).
    S-TAB (Shift + Tab within a list): Dedent the current list item (move it up a level).

Navigation and Structure:

    C-c C-j (Control + c, then Control + j): Jump to a heading. It will display a list of headings in your buffer.
    C-c C-n (Control + c, then Control + n): Move to the next heading.
    C-c C-p (Control + c, then Control + p): Move to the previous heading.
    C-c C-o (Control + c, then Control + o): Cycle through the visibility of the current section (show/hide body).
    C-c C-s (Control + c, then Control + s): Show the structure overview (similar to org-mode's structure buffer).

Advanced Features:

    C-c C-e (Control + c, then Control + e): Export/Convert the current buffer. This often integrates with Pandoc if you have it configured. It might present you with different output format options.
    C-c C-v (Control + c, then Control + v): Preview the current buffer. This might use a tool like markdown-preview-mode if installed, or an external browser.
    M-x markdown-edit-link: If your cursor is on a link, this command allows you to edit the link text and URL.
    M-x markdown-edit-image: Similar to the above, but for images (editing alt text and path).
    M-x markdown-table-create: Helps you create a Markdown table by prompting for the number of rows and columns.
    M-x markdown-table-align: Aligns the columns of the Markdown table at point.
    M-x markdown-move-item-up / M-x markdown-move-item-down: Move the current list item (or table row) up or down. You might want to bind these to keys.

Tips for Remembering:

    Many keybindings start with M-s (Meta + s), which can be thought of as "Markdown specific."
    For headings, h followed by the level number is quite mnemonic.
    b for bold, i for italic, l for link, im for image, q for quote, c for code.
    RET for new list item, TAB/S-TAB for indent/dedent.
    C-c C-j for jump, C-c C-n/C-c C-p for next/previous heading, C-c C-o for overview.
    C-c C-e for export, C-c C-v for view.

This snapshot should give you a solid foundation for efficiently editing Markdown documents in Emacs using the enhanced markdown-mode. As you use it more, you'll naturally discover other useful keybindings and might even customize some to your liking. Don't hesitate to use C-h m within a Markdown buffer to see the full list of available commands and their keybindings. Happy editing!



Could you just briefly tell me a bit about what some of the perks may be when having Org installed in Emacs, specifically when it comes to Markdown, i.e. pertaining to the last couple of questions about Markdown and Emacs?

You're right to wonder about the interplay between Org mode and Markdown in Emacs! While they are distinct modes with different primary purposes, having Org mode installed can offer some interesting perks when working with Markdown:

    Enhanced Export Capabilities via Pandoc: Org mode has excellent integration with Pandoc. If you have Org mode installed, you can leverage its powerful export features to convert your Markdown files to a wider range of formats than markdown-mode might offer on its own. Org mode's export can often provide more fine-grained control over the Pandoc conversion process.

    Potential for Hybrid Workflows: If you sometimes work with Org files and sometimes with Markdown, having both modes available in Emacs allows for a more seamless transition between the two. You might even find ways to incorporate elements or concepts from Org mode (like its outlining capabilities) into your Markdown workflow, even if you're primarily writing in .md files.

    Outline Navigation and Manipulation: Org mode excels at outlining. While markdown-mode has decent heading navigation (C-c C-j, C-c C-n, C-c C-p), Org mode's outlining features (TAB for visibility cycling, S-TAB for global cycling, M-up/M-down for moving subtrees) are often more robust and intuitive for managing the structure of your document, which can be beneficial even for Markdown files with many headings.

    Table Editing Features: Org mode has very powerful table editing capabilities. While markdown-mode offers some basic table creation and alignment, Org mode's table editor (activated with C-c { within a table) provides features like formula calculation, column and row manipulation, and more advanced formatting. You can edit Markdown tables using Org mode's table editor, which might be more convenient for complex tables than plain text editing.

    Capture Templates and Note-Taking: If you use Org mode for note-taking and knowledge management, you might find it convenient to have it installed alongside your Markdown setup. You could potentially link to your Markdown reports from your Org notes or use Org mode's capture templates to quickly jot down ideas related to your Markdown writing.

    Extensibility and Customization: Having Org mode installed means you have access to its extensive ecosystem of extensions and customization options within Emacs. While these are primarily designed for Org files, some might offer general benefits or could be adapted for use with Markdown workflows.

In short, while you might primarily use markdown-mode for editing .md files, having Org mode installed in your Emacs environment can enrich your overall writing experience by providing more powerful export options, potentially better outlining and table editing features, and a more integrated environment if you also work with Org files. It broadens the toolkit available within Emacs for handling various text-based formats. You might not directly use Org syntax within your Markdown, but the presence of Org mode can enhance how Emacs handles and processes your Markdown files.


You're absolutely right, Markdown has some nuances depending on the dialect! The great news is that Emacs's markdown-mode (the standard package) is highly configurable and has excellent support for various Markdown flavors, including GitHub Flavored Markdown (GFM).

The "twists and turns" mainly involve:

    Dialect support: markdown-mode handles CommonMark, GFM, and standard Markdown very well. GFM is particularly popular due to GitHub, GitLab, and other platforms using it.
    Previewing: How you want to see the rendered output (external browser, internal Emacs browser, live update).
    Table of Contents (TOC): Generating and updating a TOC within your Markdown file.

Let's dive into the configuration.
Emacs Configuration for Markdown (init.el)

We'll primarily use markdown-mode. For GFM specifics, gfm-mode is a minor mode that comes with markdown-mode and activates features specific to GitHub Flavored Markdown (like task lists). For preview, we'll set up markdown-live-preview-mode (which is also part of markdown-mode). For TOC, markdown-toc is a great package.

Crucial Prerequisite (Outside of Emacs for Preview/Export):

For markdown-mode to render Markdown to HTML, it relies on an external Markdown processor. Pandoc is the most powerful and flexible choice, as it supports many Markdown dialects and output formats.

    Install Pandoc:
        macOS (Homebrew): brew install pandoc
        Debian/Ubuntu: sudo apt-get install pandoc
        Windows: Download from the Pandoc website or use Chocolatey.

Make sure pandoc is in your system's PATH.

Here's the init.el snippet:
Code snippet

;; --- Emacs Package Management Preamble ---
;; (As established, this section ensures that packages are automatically installed
;; if they are not already present, based on your use-package declarations.)

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
;; (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

;; --- End of Emacs Package Management Preamble ---


;; --- Markdown Configuration ---

(use-package markdown-mode
  :mode (("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode)
         ("\\.mkd\\'" . markdown-mode)
         ("README\\.md\\'" . gfm-mode)) ; Use gfm-mode for README.md by default
  :hook ((markdown-mode . (lambda ()
                            (setq indent-tabs-mode nil) ; Use spaces
                            (setq tab-width 2)           ; 2 spaces for Markdown (common)
                            (electric-pair-mode 1)
                            (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
         (gfm-mode . (lambda ()
                       (setq indent-tabs-mode nil)
                       (setq tab-width 2)
                       (electric-pair-mode 1)
                       (add-hook 'before-save-hook 'delete-trailing-whitespace nil t))))
  :config
  ;; Customize the Markdown command if you want to use Pandoc specifically
  ;; or pass specific arguments for a dialect.
  ;; For example, to use Pandoc with GFM and smart typography:
  (setq markdown-command '("pandoc" "--from=gfm+smart" "--to=html5"))

  ;; Or if you prefer using the basic 'markdown' command (less powerful than Pandoc)
  ;; (setq markdown-command "markdown")

  ;; For live preview
  (use-package markdown-live-preview-mode
    :hook (markdown-mode . markdown-live-preview-mode) ; Automatically enable in markdown-mode
    :config
    ;; You can customize how it previews. Default is in a new Emacs window (eww).
    ;; If you have xwidget-webkit enabled in your Emacs (requires Emacs compiled with it),
    ;; you can get a truly rendered preview inside Emacs:
    ;; (setq markdown-live-preview-window-function 'markdown-live-preview-window-xwidget)
    ;; Otherwise, it will open in your default external browser.
    ;; Or you can force external browser:
    ;; (setq markdown-live-preview-window-function 'markdown-live-preview-window-external-browser)
    )

  ;; For GitHub Flavored Markdown (GFM) specific features like task lists checkboxes
  ;; gfm-mode is already handled by the :mode association above.
  ;; If you want task list checkboxes to be interactive:
  (add-hook 'gfm-mode-hook (lambda ()
                             (setq markdown-gfm-additional-markup-p t) ; Enable GFM extensions
                             (add-to-list 'markdown-fontify-code-blocks-at-creation t) ; Fontify code blocks
                             (define-key gfm-mode-map (kbd "C-c C-x C-x") 'markdown-gfm-checkbox-toggle) ; Toggle checkbox
                             ))

  ;; For Table of Contents generation
  (use-package markdown-toc
    :hook (markdown-mode . (lambda ()
                             ;; Automatically update TOC on save if it exists
                             (add-hook 'before-save-hook 'markdown-toc-generate-or-refresh-toc nil t)))
    :config
    ;; Customize TOC appearance if needed
    ;; (setq markdown-toc-header-toc-title "**Table of Contents**")
    ;; (setq markdown-toc-indentation-space 2) ; Match your desired indentation
    )
  )

Explanation of the init.el snippet for Markdown:

    use-package markdown-mode: This is the core package.
        :mode: This regular expression ensures that files with common Markdown extensions (.md, .markdown, .mkd) and README.md are opened in markdown-mode. For README.md, we specifically assign gfm-mode because README.md files are almost universally GFM. gfm-mode is a minor mode provided by markdown-mode.
        :hook: Sets indentation to 2 spaces (common for Markdown), ensures electric pairing, and removes trailing whitespace on save.
        markdown-command: This is crucial. It tells markdown-mode what external program to use for converting Markdown to HTML.
            '("pandoc" "--from=gfm+smart" "--to=html5"): Highly recommended. This configures markdown-mode to use pandoc.
                --from=gfm+smart: Specifies GitHub Flavored Markdown with "smart" typography (e.g., converting -- to an en dash).
                --to=html5: Outputs HTML5.
            If you don't have Pandoc, you could try "markdown" (the original Perl script), but it's much less powerful and less dialect-aware.
    use-package markdown-live-preview-mode: This provides a side-by-side live preview.
        :hook (markdown-mode . markdown-live-preview-mode): Automatically starts live preview when you open a Markdown file.
        :config: Shows options for how the preview is displayed (internal Emacs eww browser, external browser, or xwidget-webkit if your Emacs build supports it for a truly integrated browser view).
    GFM (GitHub Flavored Markdown) specifics:
        The gfm-mode hook enables markdown-gfm-additional-markup-p for full GFM syntax, and markdown-gfm-checkbox-toggle binds a key for interactive checkboxes (e.g., - [ ] to - [x]).
    use-package markdown-toc: This package helps with generating and maintaining a Table of Contents.
        :hook: The before-save-hook automatically updates the TOC if one already exists in the buffer. This is a very convenient feature for documentation.

Useful Keyboard Shortcuts for Markdown in Emacs

markdown-mode offers a rich set of keybindings for common Markdown tasks, typically under the C-c C-s (insert style) and C-c C-c (run command) prefixes.

General Emacs Shortcuts (still apply):

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Search.
    M-x compile: If you need to run a custom command on your Markdown, e.g., pandoc -s input.md -o output.pdf.
    M-g n / M-g p: Navigate errors (less common for Markdown unless you have a linter).

markdown-mode Specific Shortcuts:

    C-c C-s h: Insert heading (prompts for level/type).
    C-c C-s 1 through C-c C-s 6: Insert ATX (hash-style) heading of that level.
    C-c C-s b: Toggle bold markup.
    C-c C-s i: Toggle italic markup.
    C-c C-s c: Toggle inline code markup.
    C-c C-s p: Toggle code block (preformatted). With a region, converts the region.
    C-c C-s q: Toggle blockquote.
    C-c C-s l: Insert list item.
    M-RET: Insert a new list item at the same level.
    C-c <left> / C-c <right>: Outdent/indent list item (promote/demote).
    C-c C-l: Insert or edit a link.
    C-c C-i: Insert or edit an image link.
    C-c C-o: Follow link at point (opens in browser or internal Emacs browser).
    C-c C-d: Jump between reference link and definition.
    C-c C-t: Toggle markup hiding (makes **bold** display as bold and _italic_ display as italic). This is great for readability!
    C-c C-x C-m: Toggle markup hiding (global setting).
    C-c C-x C-l: Toggle URL hiding (shows a clickable link name instead of the full URL).
    C-c C-c m: Run Markdown processor on the current buffer and display output in a temporary *markdown-output* buffer.
    C-c C-c p: Run Markdown processor and preview in your default external browser.
    C-c C-c e: Run Markdown processor and export to an HTML file (basename.html).
    C-c C-c v: Run Markdown processor, export, and preview in browser.
    C-c C-c l: Toggle markdown-live-preview-mode.
    C-c C-c n: Renumber ordered lists in the buffer.
    C-c C-c ]: Complete/normalize all headings and horizontal rules in the buffer.

gfm-mode Specific Shortcuts (if enabled for GFM files):

    C-c C-x C-x: Toggle GFM checkbox at point (e.g., - [ ] task becomes - [x] task).

markdown-toc Shortcuts:

    M-x markdown-toc-generate-toc: Generates a Table of Contents at the current point.
    M-x markdown-toc-generate-or-refresh-toc: Generates a TOC if none exists, or updates an existing one. (This is what the before-save-hook uses).
    M-x markdown-toc-refresh-toc: Refreshes an existing TOC.

With this setup, you should have a very comfortable and powerful environment for writing Markdown in Emacs, with good support for different dialects and convenient preview and TOC features.

}}}
Csound, SuperCollider {{{

Emacs ----

CSound:

Plugin: csound-mode.

Features:

- REPL (Read-Eval-Print Loop) based
  on running a Csound-instance
  through the Csound-API.
- Interactive code-evaluation.
- Code-completion.
- ElDoc (displays documentation in
  the minibuffer).
- Indentation-rules.
- Syntax-highlighting and
  rainbow-delimited
  score-parameters.

Installation: Can be installed from
MELPA (M-x package-install RET
csound-mode RET) or manually by
adding it to the load-path.
Requires Emacs 25+ and Csound
6.10+. Alternative Plugin: Csound-x
offers a dual-mode approach
(orchestra and score in separate
buffers) with features like
compiling orchestras/scores,
playing files, formatting,
function-visualization,
score-editing (column alignment),
and opcode-documentation access.

Installation involves downloading
and adding to Emacs' load-path.   

SuperCollider:

- Plugin: scel.
- Features: Provides an Emacs Lisp
  interface to the SuperCollider
  system. Allows running sclang
  (the SuperCollider language
  interpreter) from within Emacs.
  Includes key bindings and
  potentially integration with the
  Help browser.
- Installation: Can be installed
  using SuperCollider's Quarks
  package manager
  (Quarks.install("https://github.com/supercollider/scel")),
  from a Debian package
  (supercollider-emacs), or by
  compiling from source with the
  -DSC_EL=ON flag. May require
  adding the load path in Emacs.

Note: The Gentoo Wiki indicates
that scel has not been updated
since September 2021 and might have
issues with starting the
sclang-server due to hardcoded
command-line options. Another Emacs
package, sclang-extensions, is also
listed as unmaintained.

JetBrains IDEs (e.g., IntelliJ IDEA, PyCharm)

Based on the search results, there
aren't dedicated, actively
maintained plugins specifically for
CSound or SuperCollider in the
JetBrains Marketplace. JetBrains
IDEs are known for their extensive
plugin ecosystem supporting various
programming languages and tools,
but the focus tends to be on more
mainstream development
environments.

- General Plugins: While there
  might not be specific CSound or
  SuperCollider plugins, you could
  potentially use generic plugins
  for text editing, syntax
  highlighting (if you can define
  custom languages), or terminal
  integration to work with these
  environments. For instance, the
  "IdeaVim" plugin allows Vim
  keybindings within JetBrains
  IDEs, which could be appealing if
  you're comfortable with Vim.   

- SuperCollider IDE: SuperCollider
  itself comes with its own
  dedicated IDE (SuperCollider
  IDE), which is cross-platform and
  provides features tailored for
  SuperCollider development,
  including code completion, help
  system integration, and server
  control. This might be the
  primary environment for many
  SuperCollider users who prefer a
  GUI.
- CSound Editors: While not a
  JetBrains plugin, there are
  dedicated CSound editors like
  CsoundQt which provide a
  graphical interface for CSound
  development.


Summary of Vim vs. Emacs for CSound and SuperCollider:

Both Vim and Emacs offer robust plugin ecosystems that extend their functionality to support CSound and SuperCollider development.
Vim provides lightweight and efficient environments with plugins focusing on syntax highlighting, code navigation, compilation/execution from within the editor, and integration with external tools like REPLs or help systems. Vim's modal editing might be a preference for some users.

- Emacs offers highly customizable
  and extensible environments with
  plugins that often provide deeper
  integration, such as REPLs within
  the editor, more comprehensive
  code-assistance features
  (completion, documentation), and
  potentially more features
  out-of-the-box for Csound (like
  score-alignment in csound-mode or
  the broader toolset of csound-x).
  Emacs' modeless interface might
  be more approachable for
  beginners, but its customization
  can have a steeper learning-curve.

The choice between Vim and Emacs often comes down to personal preference regarding editing philosophy (modal vs. modeless), the desired level of extensibility and customization, and the specific features offered by the available plugins for CSound and SuperCollider.   


- I'm thinking of using Emacs,
  although I've used Vim for many
  many years. I have a general
  setup that works, and I also have
  Evil installed, and I can
  therefore use the part from Vim
  that is really second to none -
  its scheme for keybinding.

That's a fantastic approach!
Leveraging your familiarity with
Vim's keybindings through Evil in
Emacs could provide a very
comfortable transition. You get the
best of both worlds: the powerful
extensibility and ecosystem of
Emacs while retaining the efficient
and ingrained muscle-memory of
Vim's modal editing.

Since you're considering Emacs and
already have Evil in mind, focusing
on how well Emacs handles Csound
and SuperCollider with that setup
makes perfect sense.

Given that the core
editing-experience will feel
familiar thanks to Evil, the key
aspects to consider for Csound and
SuperCollider would be:

- Plugin Functionality with Evil:
  Do the Csound (csound-mode,
  Csound-x) and SuperCollider
  (scel) modes in Emacs work
  seamlessly with Evil? Generally,
  major-modes in Emacs are designed
  to be compatible with Evil, as
  Evil aims to emulate Vim's
  behavior comprehensively.
  However, it's always good to be
  aware of potential minor
  conflicts or the need for
  specific Evil-configurations
  within those modes.
- Keybinding-Conflicts/Customization:
  While Evil provides the Vim
  keybinding-scheme, you might
  encounter situations where Emacs'
  default keybindings in the Csound
  or SuperCollider modes clash with
  Evil's. Emacs' strength lies in
  its customizability, so you'll
  likely be able to resolve these
  conflicts to your preference.
  This might involve adjusting
  keybindings in the specific major
  modes or within Evil itself.   

Integration with Emacs-Features:
Emacs has a wealth of features
beyond basic text-editing, such as
Org-mode, Magit (for Git), and
various other tools. Using Emacs
with Evil allows you to potentially
integrate your Csound and
SuperCollider workflows with these
other Emacs-capabilities if
desired.  

Regarding Csound with Emacs and
Evil:

csound-mode seems to offer a good
level of integration with features
like a REPL, code-completion, and
documentation-lookup. With Evil,
you should be able to navigate and
interact with these features using
your familiar Vim keybindings. For
instance, moving around the code,
selecting regions to evaluate, and
accessing help should all be
possible within the Evil-framework.   

Csound-x's dual-buffer approach and
various editing-tools might also be
navigable using Evil. The key will
be to ensure that the keybindings
provided by Csound-x don't
interfere with your Evil-setup or
that you can customize them
effectively.

Keybindings

https://github.com/hlolli/csound-mode

C-c C-p csound-play Same as doing csound filename -odac
C-c C-r csound-render Same as doing csound filename -o filename.wav
C-c C-z csound-repl-start
C-c C-k csound-abort-compilation abort compilation (e.g. playback)
C-M-x/C-c C-c csound-evaluate-region
C-x C-e csound-evaluate-line
C-c C-l csound-repl-interaction-evaluate-last-expression
C-c C-s csound-score-align-block cursor needs to be within a score block
M-. csound-score-find-instr-def cursor needs to be within a score block
C-c C-d h csound-manual-lookup searches for a function definition in the Csound-manual


Regarding SuperCollider with Emacs and Evil:

The notes about scel potentially
being outdated are worth
considering. If you encounter
issues with it, you might need to
explore alternative approaches or
even consider contributing to its
maintenance if you become a regular
user. Even if scel has some
limitations, you would still
benefit from Emacs' excellent
text-editing capabilities (enhanced
by Evil) for writing
SuperCollider-code. You could then
potentially use Emacs'
terminal-integration to interact
with the SuperCollider-server
(sclang) if the direct integration
via scel isn't ideal.

In summary, your plan to use Emacs
with Evil for Csound and
SuperCollider is a very viable one.
You'll likely find a comfortable
and powerful environment that
leverages your existing Vim
knowledge. The key will be to:

Install the relevant Emacs modes
(csound-mode or Csound-x for
Csound, and scel for
SuperCollider).   

- Ensure Evil is correctly
  configured and active.
- Explore the functionality of the
  Csound and SuperCollider modes
  within the Evil context.
- Be prepared to customize
  keybindings if there are any
  conflicts or if you want to
  tailor the experience further.

Here are some of the most useful
keyboard-shortcuts for scel-mode,
focusing on what you asked for
(compiling/previewing code) and
some other common actions:

Compiling and Previewing Code
(Interpreting):

C-c C-c (Control-c, Control-c): Interpret the current line or selected region. This is your primary shortcut for evaluating code.
C-c C-d (Control-c, Control-d): Interpret the current selection. This is often used when you've explicitly highlighted a block of code. In some contexts, it might behave similarly to C-c C-c.
C-M-x (Control-Meta-x): Evaluate the current "defun" (a defined function or code block). This is great for running entire functions or classes quickly.
C-c C-f (Control-c, Control-f): Evaluate the entire current document (file). Use with caution, especially if you have a complex setup!

Other Useful SuperCollider-Specific
Shortcuts:

C-c C-s (Control-c, Control-s): Stop all running sounds/the SuperCollider interpreter (Main.stop). This is crucial if a synth goes haywire!
C-c C-r (Control-c, Control-r): Run Main.run. This is often used to boot your SuperCollider server and execute your main startup script.
C-c C-l (Control-c, Control-l): Recompile the SuperCollider class library.
C-c C-h (Control-c, Control-h): Open a help file for the word at point (where your cursor is). This is incredibly useful for looking up documentation on classes, methods, and functions.
C-c C-m (Control-c, Control-m): Show method arguments (in the minibuffer). Very handy for knowing what arguments a function expects.
C-c C-n (Control-c, Control-n) or M-TAB (Meta-Tab/Alt-Tab): Autocomplete a keyword.
C-c < (Control-c, Shift-comma): Clear the "post window" (the output buffer).
C-c C-p p (Control-c, Control-p, p): Show server panels.

General Emacs Shortcuts (also very useful in scel):

C-h m (Control-h, m): Describe Mode. This will show you a list of all active keybindings in the current mode, including scel's specific ones. This is your go-to for discovering more commands!
C-x C-f (Control-x, Control-f): Find file (open a file).
C-x C-s (Control-x, Control-s): Save file.
C-x C-w (Control-x, Control-w): Save file as.
C-x k (Control-x, k): Kill (close) buffer.
C-/ (Control-slash) or C-x u (Control-x, u): Undo.
M-w (Meta-w/Alt-w): Copy region.
C-y (Control-y): Paste (yank).
C-s (Control-s): Incremental search forward.
C-r (Control-r): Incremental search backward.
M-; (Meta-semicolon/Alt-semicolon): Comment/uncomment region (adds or removes //).

+ Check other bindings with c-h m

Given your long history with Vim,
you'll likely find Emacs'
customizability, combined with
Evil, to be a very flexible and
ultimately rewarding environment
for your audio-programming
endeavors. Let me know if you
decide to proceed and encounter any
specific configuration-questions!

916 Days of Emacs - Hacker News
Source icon
news.ycombinator.com
Emacs - Wikipedia
Source icon
en.wikipedia.org
ICSC2017 Conference - Csound
Source icon
csound.com
supercollider/scel: Supercollider emacs package - GitHub
Source icon
github.com

- It's also possible to turn off
  Evil-keys using c-z inside Emacs,
  so I'm not too concerned with
  those things (at the moment). The
  thing I want to focus on is
  getting the most mileage from my
  editor-environment, and I think
  Emacs looks like a more
  interesting pick to me in that
  department.

That's an excellent point! The
ability to toggle Evil mode with
C-z provides a fantastic
escape-hatch and allows you to
seamlessly transition between the
Vim-style modal editing and Emacs'
more traditional keybindings. This
flexibility can be incredibly
useful as you explore Emacs' unique
features and potentially encounter
situations where Emacs' native
keybindings are more idiomatic or
convenient.

Your focus on "getting the most
mileage" from your editor
environment aligns perfectly with
Emacs' philosophy. It's more than
just a text-editor; it's often
described as an extensible,
customizable, self-documenting
live-in environment. Here's why
Emacs could be a compelling choice
for maximizing your
editor-experience, especially in
the context of Csound and
SuperCollider:

Beyond Basic Editing:

- Extensibility: Emacs' core is
  written in Lisp, and almost every
  aspect of its behavior can be
  customized and extended through
  Emacs Lisp. This means that if a
  particular feature or integration
  doesn't exist, or doesn't work
  exactly as you'd like, you often
  have the power to modify or
  create it yourself (or leverage
  the vast ecosystem of
  community-developed packages).
- Org-mode: This is a killer-app
  for many Emacs users. It's a
  powerful system for note-taking,
  task-management, outlining,
  literate programming, and even
  creating presentations. Imagine
  being able to keep your Csound or
  SuperCollider project-notes,
  code-snippets, and even generate
  documentation all within the same
  Emacs-environment, tightly
  integrated with your
  editing-workflow.
- Magit: For version-control with
  Git, Magit is widely considered
  one of the best interfaces
  available. Its intuitive and
  comprehensive approach can
  significantly enhance how you
  manage your audio-programming
  projects.
- Tramp: This feature allows you to
  transparently edit files on
  remote-servers as if they were
  local. This could be incredibly
  useful if you're working on
  sound-installations or
  collaborating on projects hosted
  remotely.
- Dired: Emacs' directory editor,
  Dired, provides a powerful way to
  manage files and directories
  directly within Emacs. You can
  perform various file-operations,
  run shell-commands, and even
  preview audio-files (with the
  right packages).
- Integration with Other Tools:
  Emacs has a strong tradition of
  integrating with other
  command-line tools. For Csound
  and SuperCollider, this could
  mean seamless interaction with
  their command-line interfaces,
  external synthesis-servers, or
  other audio-processing utilities,
  potentially through Emacs'
  shell-mode or dedicated packages.

Potential Benefits for Csound and
SuperCollider:

- Deeper Integration: While
  Vim-plugins often focus on text
  editing features like
  syntax-highlighting and basic
  execution, Emacs-modes sometimes
  offer deeper integration with the
  underlying software. For example,
  csound-mode's REPL-capability
  aims for a more interactive
  development-experience.
- TT@Literate Programming: The
  combination of Org-mode and
  Emacs' code-execution
  capabilities could be
  particularly powerful for Csound,
  allowing you to embed your .orc
  and .sco code directly within
  documentation, making your
  projects more understandable and
  reproducible.
- Customized Workflows: With Emacs
  Lisp, you could potentially
  create highly tailored workflows
  specifically for your Csound and
  SuperCollider
  development-process. This could
  involve custom keybindings (even
  beyond Evil's emulation),
  automated tasks, or specialized
  interfaces.

The Learning Curve:

It's worth acknowledging that Emacs has a steeper initial learning curve compared to Vim, even with Evil installed. The sheer number of features and customization options can be overwhelming at first. However, your existing comfort with Vim's keybindings through Evil will significantly mitigate this. The key will be to explore Emacs gradually, focusing on the features that are most relevant to your workflow and learning Emacs Lisp as needed to further enhance your environment.

In conclusion, your intuition about Emacs offering more "mileage" seems well-founded. Its extensibility and rich ecosystem provide a platform for a highly integrated and customized development environment that goes far beyond basic text editing. By leveraging Evil for your familiar keybindings while exploring Emacs' unique capabilities, you're well-positioned to create a powerful and personalized setup for working with Csound and SuperCollider.

What aspects of "getting the most mileage" are most interesting to you right now? Perhaps you'd like to explore specific Emacs features related to Csound/SuperCollider integration, literate programming, or project management? Knowing your current priorities can help guide our discussion further.

- The things that turn me off from
  using SuperCollider IDE and
  CsoundQt (although I will almost
  certainly use them for certain
  tasks and tests) is the way they
  are structured when it comes to
  indenting code, having different
  themes and dark-mode present.
  Both Vim and Emacs is a whole
  other level of
  editor-environments.

I completely understand your
perspective. The level of
customization and control offered
by Vim and Emacs, especially
regarding fundamental aspects like
indentation and theming, is indeed
a significant step up from many
dedicated IDEs. The ability to
tailor these editors precisely to
your preferences contributes
greatly to a comfortable and
efficient workflow.

You've hit on a key advantage of
using more general-purpose, highly
configurable editors like Vim (and
by extension, Emacs with Evil) over
specialized IDEs:

- Consistent Experience: You can
  maintain a consistent look and
  feel, keybinding scheme
  (especially with Evil), and
  coding-style across different
  programming languages and
  environments. This reduces
  cognitive load and allows you to
  switch between tasks more
  seamlessly.
- Fine-grained Control: You have
  granular control over every
  aspect of the editor, from the
  exact indentation-rules for
  different file-types to the
  specific shades of your chosen
  dark theme. This level of
  customization can significantly
  impact your comfort and reduce
  eye-strain.
- Extensibility Beyond the Specific
  Language: While SuperCollider IDE
  and CsoundQt are tailored for
  their respective languages, Vim
  and Emacs can be extended to
  handle a vast array of other
  tasks and workflows beyond just
  audio-programming, as we
  discussed earlier with Org-mode,
  Magit, and other tools.

It's wise to consider using the
dedicated IDEs for specific tasks
like quick tests, debugging with
their built-in tools, or leveraging
visual aids they might offer.
However, for the core
development-experience where
coding-comfort and consistency are
paramount, Emacs (with your
familiar Vim keybindings via Evil)
appears to be a very strong
contender.

Regarding your specific points:

- Indentation: Both Vim and Emacs
  have highly sophisticated
  indentation management
  capabilities. They can
  automatically detect indentation
  styles based on file type and
  offer extensive options for
  customization. You can define
  indentation rules precisely to
  your liking, ensuring your code
  always looks the way you prefer.
- Themes and Dark Mode: Both
  editors have a vast ecosystem of
  themes, including numerous
  excellent dark mode options.
  Emacs, in particular, has a very
  active theming community, and
  you'll find a wide variety of
  visually appealing and
  well-maintained themes that you
  can easily install and customize.

By choosing Emacs with Evil, you're
essentially bringing your preferred
level of control and customization
to the world of Csound and
SuperCollider development, while
also opening up the potential for
deeper integration with the broader
Emacs ecosystem.

Given this, what are your next
steps in exploring Emacs for your
audio work? Are you thinking of
trying out the Csound and
SuperCollider modes? Perhaps
experimenting with theming or
indentation settings? I'm here to
help you navigate those initial
steps if you'd like.


- It would be very nice if you
  could give me some direction on
  which packages to install and
  most importantly what to put into
  my init.el

Absolutely! Getting the initial
packages set up and configuring
your init.el is a crucial first
step. Here's a suggested approach
for Csound and SuperCollider,
keeping in mind your interest in
Emacs and your familiarity with Vim
via Evil:

Assumptions:

- You have Emacs installed.
- You have the evil package
  installed (you mentioned this).

Recommended Packages:

For a good starting point, I
recommend the following packages:

- use-package: This is a fantastic
  package that simplifies the
  configuration of other packages
  in your init.el. It helps keep
  your configuration organized and
  declarative. It's highly
  recommended for managing your
  Emacs setup.
- csound-mode: For editing Csound
  orchestra (.orc), score (.sco),
  and unified (.csd) files.
- scel: For interacting with
  SuperCollider from within Emacs.
- A good theme: Choose one that you
  like, especially a dark theme if
  that's your preference. Popular
  choices include doom-themes,
  modus-themes, nord-theme,
  dracula-theme, and many others
  available on MELPA.

Optional but Recommended:

- lsp-mode and a language server
  for SuperCollider (if one exists
  and you're interested in more
  advanced code intelligence
  features). I'm not certain about
  the current state of LSP for
  SuperCollider, but it's worth
  looking into if code completion
  and other IDE-like features are
  important to you beyond what scel
  offers.

Putting it into your init.el:

Here's a basic example of how you
might configure these packages in
your init.el using use-package.
Make sure you have use-package
itself installed first (you might
need to add a repository like MELPA
to Emacs if you haven't already).

;; Ensure package.el is initialized
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(package-initialize)

;; Install use-package if it's not already installed
(unless (package-installed-p 'use-package)
(package-refresh-contents)
(package-install 'use-package))

;; Load use-package
(require 'use-package)

;;; Evil Configuration
(use-package evil
:init
(setq evil-want-integration t)
(setq evil-want-keybinding nil)
:config
(evil-mode 1)
(define-key evil-normal-state-map (kbd "C-z") 'evil-exit-emacs-state)) ;; Your toggle key

;;; Theme Configuration (Example with doom-themes - install it first)
(use-package doom-themes
:ensure t
:config
(load-theme 'doom-one t)) ;; Replace 'doom-one' with your chosen theme


___config
;;; Csound Mode Configuration
(use-package csound-mode
:ensure t
:mode (("\\.orc\\'" . csound-mode)
       ("\\.sco\\'" . csound-mode)
       ("\\.csd\\'" . csound-mode)
       ("\\.udo\\'" . csound-mode))
:config
;; You can add specific configurations for csound-mode here if needed
)

;;; SuperCollider Mode Configuration
(use-package scel
:ensure t
:mode "\\.scd\\'"
:config
;; You might need to configure the sclang path or other scel settings here
;; Example (adjust the path if necessary):
;; (setq scel-sclang-program "/Applications/SuperCollider.app/Contents/Resources/sclang")
)

;;; Optional: LSP Mode for SuperCollider (if available and desired)
;; (use-package lsp-mode
;;   :ensure t
;;   :hook (supercollider-mode . lsp-deferred)
;;   :config
;;   (setq lsp-ui-sideline-enable t)
;;   (setq lsp-ui-doc-enable t))

;; (use-package supercollider-mode
;;   :ensure t
;;   :mode "\\.scd\\'"
;;   :hook (supercollider-mode . (lambda ()
;;                                 (when (require 'lsp-mode nil t)
;;                                   (lsp-deferred))))
;;   :config
;;   ;; Any supercollider-mode specific configurations
;;   )

;; Add any other general Emacs-configurations below this line


Explanation:

- Package Initialization: The first
  few lines ensure that Emacs'
  package system is set up and that
  it knows where to download
  packages from (MELPA in this
  case). package-initialize loads
  any already installed packages.
- use-package: We ensure
  use-package is installed and then
  require it.

Evil Configuration:
    :init: Sets some initial variables for Evil.
    :config: Activates Evil mode (evil-mode 1) and defines your C-z keybinding to exit Evil state.

Theme Configuration:
    :ensure t: Ensures the doom-themes package is installed.
    :config: Loads the doom-one theme. Replace 'doom-one' with the name of the theme you choose. You'll need to install the theme package separately if it's not part of the default Emacs distribution.

Csound Mode Configuration:
    :ensure t: Ensures csound-mode is installed.
    :mode: Associates .orc, .sco, .csd, and .udo files with csound-mode.
    :config: This section is for any specific configurations you might want for csound-mode later.

SuperCollider Mode Configuration:
    :ensure t: Ensures scel is installed.
    :mode: Associates .scd files with scel-mode.
    :config: Here, you might need to set the path to your sclang executable. The example shows a typical path on macOS; you'll need to adjust it based on your operating system and SuperCollider installation location.

Optional LSP-Configuration: This is
commented out as the availability
and setup of LSP for SuperCollider
might vary. If you're interested in
exploring this for more advanced
code-intelligence (autocompletion,
go-to-definition, etc.), you would
uncomment these sections and
potentially need to install a
SuperCollider language-server if
one exists. The supercollider-mode
hook is included to potentially
integrate with LSP if available.

How to Use This:

- Open your init.el file. This is
  usually located at
  ~/.emacs.d/init.el or
  ~/.config/emacs/init.el. If it
  doesn't exist, create it.
- Copy and paste the code above
  into your init.el.
- Modify the theme name in the
  doom-themes section to your
  preferred theme.
- Adjust the scel-sclang-program
  path in the scel section to the
  correct location of your sclang
  executable.
- Save the init.el file.
- Restart Emacs.

Emacs should now install the
necessary packages and configure
them according to your init.el. You
might see some messages in the
minibuffer as it downloads and
installs the packages for the first
time.

Next Steps:

- Explore the modes: Open a .orc,
  .sco, .csd, or .scd file to see
  the syntax highlighting and any
  default keybindings provided by
  csound-mode and scel.
- Customize further: Read the
  documentation for csound-mode and
  scel to see what other
  configuration options are
  available. You can add more
  settings within their respective
  :config blocks in your init.el.
- Theme exploration: If you don't
  like the initial theme, try out
  others by changing the load-theme
  line in your init.el and
  restarting Emacs.
- Consider LSP: If you're
  interested in more advanced code
  assistance for SuperCollider,
  research the current state of LSP
  for it and how to set it up in
  Emacs.

This should give you a solid
foundation for using Emacs with
Evil for your Csound and
SuperCollider work. Don't hesitate
to ask if you have more questions
as you delve deeper!

}}}
Clojure
Elixir              ___TODO {{{

You got it! Elixir is a fantastic language, known for its expressiveness, fault tolerance, and concurrency. Emacs has excellent support for Elixir, primarily through elixir-mode and, for a full IDE-like experience, integration with the Elixir Language Server (elixir-ls) via eglot (or lsp-mode).

Historically, alchemist.el was a popular choice, but its development has stalled, and the community largely recommends using elixir-mode combined with elixir-ls for the best and most up-to-date features.
Emacs Configuration for Elixir (init.el)

We'll set up elixir-mode for basic syntax highlighting and indentation, and then integrate eglot with elixir-ls for advanced features like completion, definition lookup, and diagnostics. We'll also include mix.el for mix task integration and exunit.el for ExUnit test running.

Crucial Prerequisites (Outside of Emacs):

    Elixir and Erlang/OTP: You need a working Elixir installation, which includes the Erlang runtime.
    elixir-ls (Elixir Language Server): This is the most important external tool for rich Emacs integration.
        Installation:
        Bash

        git clone https://github.com/elixir-lsp/elixir-ls.git ~/.elixir-ls
        cd ~/.elixir-ls
        mix deps.get
        mix compile
        mix elixir_ls.release -o release

        Add to PATH: Make sure the release/language_server.sh (or .bat on Windows) script is in your system's PATH. A common way is to add export PATH=$PATH:$HOME/.elixir-ls/release to your shell's config file (e.g., ~/.bashrc, ~/.zshrc). Remember to re-login or source your shell config after editing.

Here's the init.el snippet:
Code snippet

;; --- Emacs Package Management Preamble ---
;; (As established, this section ensures that packages are automatically installed
;; if they are not already present, based on your use-package declarations.)

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
;; (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

;; --- End of Emacs Package Management Preamble ---


;; --- Elixir Configuration ---

(use-package elixir-mode
  :mode ("\\.ex\\'" . elixir-mode)     ; .ex files
  :mode ("\\.exs\\'" . elixir-mode)    ; .exs (script) files
  :mode ("\\.eex\\'" . web-mode)       ; .eex (EEx templates) are often better handled by web-mode
  :hook (elixir-mode . (lambda ()
                         (setq indent-tabs-mode nil) ; Use spaces
                         (setq tab-width 2)           ; 2 spaces for Elixir (standard)
                         (setq elixir-basic-offset 2) ; Specific to elixir-mode for correct indentation
                         (electric-pair-mode 1)
                         (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; Optional: Enable prettify-symbols for nicer display of operators (e.g., => as ⇒)
  (add-hook 'elixir-mode-hook (lambda ()
                                (prettify-symbols-mode 1)
                                (push '("=>" . ?⇒) prettify-symbols-alist)
                                (push '("<-" . ?←) prettify-symbols-alist)
                                (push '("|>" . ?▶) prettify-symbols-alist)
                                (push '("!=" . ?≠) prettify-symbols-alist)
                                (push '("<=" . ?≤) prettify-symbols-alist)
                                (push '(">=" . ?≥) prettify-symbols-alist)))

  ;; --- Eglot for Elixir Language Server (elixir-ls) ---
  ;; This connects to the `elixir-ls` language server for advanced features.
  (use-package eglot
    :config
    ;; Tell eglot how to start the Elixir language server.
    ;; Assumes `language_server.sh` (or `.bat`) from `elixir-ls/release` is in your PATH.
    (add-to-list 'eglot-server-programs '(elixir-mode . ("language_server.sh")))

    ;; You can enable formatting on save via elixir-ls
    (add-hook 'eglot-managed-mode-hook
              (lambda ()
                (when (eq major-mode 'elixir-mode)
                  (add-hook 'before-save-hook #'eglot-format-buffer nil t))))

    ;; Customize elixir-ls specific options if needed (e.g., disable Dialyzer for performance)
    ;; (add-hook 'eglot-after-initialize-hook
    ;;           (lambda ()
    ;;             (eglot-workspace-configuration :elixirLS '(:dialyzerEnabled :json-false))))
    )

  ;; --- Flycheck for diagnostics (integrates with eglot) ---
  (use-package flycheck
    :init (global-flycheck-mode))

  ;; --- Company-mode for auto-completion (integrates with eglot) ---
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 2)
    (add-to-list 'company-backends 'company-capf)) ; Eglot provides completion via company-capf

  ;; --- Mix integration ---
  (use-package mix
    :after elixir-mode
    :config
    ;; Optionally format on save using `mix format`
    ;; (add-hook 'elixir-mode-hook (lambda ()
    ;;                               (add-hook 'before-save-hook #'mix-format-buffer nil t)))
    )

  ;; --- ExUnit test runner integration ---
  (use-package exunit
    :after elixir-mode
    :config
    ;; Optional: auto-run tests on save
    ;; (setq exunit-run-tests-on-save t)
    )

  ;; --- Optional: web-mode for EEx templates ---
  ;; If you want to edit .eex files with HTML/Elixir templating support.
  ;; You already associated .eex with web-mode in elixir-mode's :mode above.
  (use-package web-mode
    :config
    (setq web-mode-engines-alist '(("elixir" . "\\.eex\\'")))
    (add-hook 'web-mode-hook (lambda ()
                               (setq web-mode-markup-indent-offset 2) ; HTML indentation
                               (setq web-mode-css-indent-offset 2)
                               (setq web-mode-code-indent-offset 2) ; Elixir code indentation
                               (setq web-mode-script-padding 0)
                               (setq web-mode-block-padding 0)))
    )
  )

Explanation of the init.el snippet for Elixir:

    use-package elixir-mode: The core major mode.
        :mode: Associates .ex and .exs files with elixir-mode. Crucially, it associates .eex (Elixir Embedded EXtensible) template files with web-mode. web-mode is generally better for mixed-language files like templates.
        :hook: Sets 2-space indentation (Elixir's standard), electric pairing, and trailing whitespace removal. elixir-basic-offset is specific to elixir-mode.
        prettify-symbols-mode: This minor mode makes certain symbols (like =>, |>) display as Unicode characters (e.g., ⇒, ▶). It's purely cosmetic but can enhance readability.
    use-package eglot: Your LSP client.
        eglot-server-programs: This tells eglot to run the language_server.sh executable when elixir-mode is active. This is how Emacs connects to elixir-ls.
        before-save-hook with eglot-format-buffer: This automatically formats your Elixir code on save using elixir-ls's built-in formatter (which uses mix format).
        eglot-after-initialize-hook: An example for advanced configuration of elixir-ls, such as disabling Dialyzer if it's too slow for your project (though Dialyzer is very useful for static analysis).
    use-package flycheck and use-package company: These integrate seamlessly with eglot. flycheck shows diagnostics from elixir-ls, and company provides completions powered by elixir-ls.
    use-package mix: Provides convenient Emacs commands for interacting with the mix build tool (e.g., running mix test, mix compile, mix deps.get).
    use-package exunit: Specifically for running ExUnit tests. It can highlight test failures and jump to test locations.
    use-package web-mode (for .eex files): Configures web-mode to handle EEx templates, ensuring proper indentation for both HTML and embedded Elixir code.

Useful Keyboard Shortcuts for Elixir in Emacs

Many Emacs general commands apply, plus specific ones from elixir-mode, eglot, mix.el, and exunit.el.

General Emacs Shortcuts:

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: Use this to run mix commands manually.
        mix test
        mix compile
        mix phx.server (for Phoenix projects)
        M-x recompile: Repeat last compile command.
        M-g n / M-g p: Navigate to next/previous error in *compilation* buffer.
    C-M-a / C-M-e: Move backward/forward S-expression. (Useful for nested Elixir structures).
    C-M-h: Mark current def/function.

elixir-mode Specific (and mix.el/exunit.el):

    C-c C-e: Evaluate region in IEx (if inf-elixir is running).
    C-c C-r: Run Elixir code (via elixir command).
    M-x elixir-format: Format the current buffer using mix format. (This will also happen on save if you enabled the eglot-format-buffer hook).
    M-x iex: Start an IEx (Elixir Interactive) session.
    M-x iex-project: Start IEx in the context of your Mix project (iex -S mix).
    C-c C-s: (in IEx buffer) Send current line to IEx.
    C-c C-r: (in IEx buffer) Send current region to IEx.
    M-x mix-test: Run all tests in the current project.
    M-x mix-test-this-file: Run tests in the current file.
    M-x mix-test-at-point: Run the specific test under the cursor.
    M-x mix-compile: Compile the current project.
    M-x mix-deps-get: Fetch project dependencies.

Eglot/LSP Shortcuts (for elixir-ls):

These are very powerful for navigation and understanding your codebase.

    M-.: Go to definition.
    M-,: Go back (pop mark).
    M-x xref-find-references: Find all references to the symbol at point.
    M-x eglot-rename: Rename a symbol across your project.
    M-x eglot-code-action: Access quick fixes or refactoring options (e.g., "Add missing import").
    M-x eglot-hover: Show documentation/type information for the symbol at point (often appears automatically).
    M-x eglot-format-buffer: Format the current buffer (same as mix format).
    M-x eglot-reconnect: Reconnect to the language server.

With this setup, your Emacs environment for Elixir should be highly productive, offering strong code intelligence and integration with the Elixir toolchain.

What's the next language you'd like to tackle?

}}}
  Haskell           ___TODO {{{


}}}
asm
OWL/SparQl, SUMO, Gremlin {{{

Okay, this set definitely leans into the "oddball" but very interesting category! These languages/formats are more about knowledge representation, querying, and graph traversal than traditional general-purpose programming. As such, Emacs support might be less feature-rich (especially concerning robust LSP servers) compared to languages like Go or Python, but we can certainly get basic syntax highlighting, indentation, and sometimes integration with their respective tools.

As before, create separate .el files for each, e.g., ~/.emacs.d/lisp/languages/owl.el, sparql.el, sumo.el, and gremlin.el, and ensure your init.el loads them (e.g., (require 'owl)).
1. OWL (Web Ontology Language)

OWL files are typically serialized using RDF syntaxes like Turtle (.ttl), RDF/XML (.rdf, .owl), or N-Triples (.nt). Emacs support for OWL will primarily come from a good RDF mode.

    Nature: A W3C-standardized language for representing rich and complex knowledge about things, groups of things, and relations between things. It's built on a formal logical foundation.
    Preferred Emacs Mode: rdf-mode (supports Turtle, TriG, N-Quads, N-Triples, RDF/XML).
    External Prerequisites: None for editing. For processing OWL ontologies, you'd use tools like Protégé, ontology reasoners (e.g., HermiT, Pellet, FaCT++), or triple stores (e.g., Virtuoso, Blazegraph, Jena Fuseki).
    LSP Support: No dedicated OWL LSP server is widely available. Some generic XML LSP might provide basic features for RDF/XML, but it won't understand OWL semantics. Therefore, eglot will not provide rich IntelliSense.

~/.emacs.d/lisp/languages/owl.el Configuration:
Code snippet

;;; owl.el --- Configuration for OWL (via rdf-mode) -*- lexical-binding: t; -*-

(use-package rdf-mode
  :ensure t
  :mode (("\\.owl\\'" . rdf-mode)
         ("\\.rdf\\'" . rdf-mode)
         ("\\.ttl\\'" . rdf-mode) ; Often used for Turtle, which is common for OWL
         ("\\.nt\\'" . rdf-mode))
  :hook (rdf-mode . (lambda ()
                       (setq indent-tabs-mode nil)
                       (setq tab-width 2) ; Common for RDF/XML, Turtle
                       (electric-pair-mode 1)
                       (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; LSP support is generally not available for RDF/OWL.
  ;; Therefore, flycheck and company-mode will offer basic features only.

  ;; Flycheck: Will check for basic syntax errors if rdf-mode provides a checker.
  (use-package flycheck
    :hook (rdf-mode . flycheck-mode))

  ;; Company-mode: Will offer keyword and dabbrev completion.
  (use-package company
    :hook (rdf-mode . company-mode)
    :config
    (add-to-list 'company-backends 'company-dabbrev-code))

  ;; You might consider integrating an external linter for RDF/OWL validation
  ;; if a command-line tool exists and provides useful output.
  ;; Example (hypothetical):
  ;; (add-to-list 'flycheck-checkers '(rdf-validator :command ("your-rdf-validator" "--format=flycheck" source)))
  )

Useful Shortcuts (within rdf-mode):

    TAB: Indent current line.
    C-x C-s: Save.
    C-s / C-r: Search.
    Basic navigation (e.g., C-f, C-b, M-f, M-b, C-a, C-e).
    M-x rdf-mode-reindent-buffer: Reindent the entire buffer.

2. SPARQL (SPARQL Protocol and RDF Query Language)

SPARQL is the standard query language for RDF data, much like SQL is for relational databases.

    Nature: A declarative query language for RDF graphs.
    Preferred Emacs Mode: sparql-mode (available on Melpa).
    External Prerequisites: A SPARQL endpoint (a server that understands SPARQL queries, like Virtuoso, Jena Fuseki, or Blazegraph) or a local triple store to query against.
    LSP Support: No dedicated SPARQL LSP server is widely available. eglot will not provide advanced features.

~/.emacs.d/lisp/languages/sparql.el Configuration:
Code snippet

;;; sparql.el --- Configuration for SPARQL -*- lexical-binding: t; -*-

(use-package sparql-mode
  :ensure t
  :mode "\\.rq\\'" ; Common extension for SPARQL queries
  :hook (sparql-mode . (lambda ()
                          (setq indent-tabs-mode nil)
                          (setq tab-width 2) ; Often uses 2 spaces
                          (electric-pair-mode 1)
                          (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; LSP support is generally not available for SPARQL.
  ;; Flycheck and Company-mode will offer basic features.

  ;; Flycheck: Basic syntax checks if sparql-mode provides a checker.
  (use-package flycheck
    :hook (sparql-mode . flycheck-mode))

  ;; Company-mode: Keyword and dabbrev completion.
  (use-package company
    :hook (sparql-mode . company-mode)
    :config
    (add-to-list 'company-backends 'company-dabbrev-code))

  ;; --- Sending Queries to a SPARQL Endpoint (Example) ---
  ;; This is a hypothetical example. You'd need to customize
  ;; `sparql-endpoint-url` and potentially authentication details.
  ;; This assumes you have `curl` or a similar tool.
  (defvar sparql-endpoint-url "http://localhost:8890/sparql"
    "URL of the SPARQL endpoint to query.")

  (defun sparql-send-query-at-point ()
    "Sends the current SPARQL query (or region) to the endpoint."
    (interactive)
    (unless sparql-endpoint-url
      (error "sparql-endpoint-url is not set."))
    (let* ((query-string (if (use-region-p)
                             (buffer-substring-no-properties (region-beginning) (region-end))
                           (buffer-string)))
           (encoded-query (url-encode-url query-string))
           (curl-command (format "curl -G --data-urlencode 'query=%s' %s"
                                 encoded-query
                                 (shell-quote-string sparql-endpoint-url))))
      (message "Sending query to %s..." sparql-endpoint-url)
      (shell-command curl-command "*SPARQL Query Result*")))

  (define-key sparql-mode-map (kbd "C-c C-e") 'sparql-send-query-at-point)
  )

Useful Shortcuts (within sparql-mode):

    TAB: Indent current line.
    C-x C-s: Save.
    C-s / C-r: Search.
    C-c C-e (sparql-send-query-at-point): (If configured) Send the current query to a SPARQL endpoint.

3. SUMO (Suggested Upper Ontology)

SUMO is a very niche case. It's a formal ontology expressed in SUO-KIF (Standard Upper Ontology Knowledge Interchange Format), which is a Lisp-like syntax. There isn't a widely available, dedicated sumo-mode on Melpa.

    Nature: A formal ontology designed to be a foundation for all other ontologies. Used in AI, knowledge engineering.
    Preferred Emacs Mode (Fallback): Given its Lisp-like syntax, lisp-mode or cl-mode might provide the best generic highlighting. Otherwise, prog-mode or even fundamental-mode with custom font-lock rules.
    External Prerequisites: SUMO tools for reasoning or knowledge base management.
    LSP Support: Extremely unlikely.

~/.emacs.d/lisp/languages/sumo.el Configuration (Using lisp-mode as a proxy):
Code snippet

;;; sumo.el --- Configuration for SUMO (using lisp-mode as proxy) -*- lexical-binding: t; -*-

(defun my-sumo-mode-setup ()
  "Setup for SUMO files, using lisp-mode as a base."
  (setq major-mode 'lisp-mode) ; Explicitly set major mode to lisp-mode
  (lisp-mode)                 ; Call lisp-mode setup
  (setq indent-tabs-mode nil)
  (setq tab-width 2) ; SUO-KIF often uses 2-space indentation
  (electric-pair-mode 1)
  (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)
  (message "Opened in Lisp mode for SUMO.")

  ;; LSP support is not available for SUMO/SUO-KIF.
  ;; Company-mode will only offer dabbrev completion.
  (use-package company
    :hook (lisp-mode . company-mode) ; Hook into lisp-mode for completion
    :config
    (add-to-list 'company-backends 'company-dabbrev-code)))

;; You'll need to define a file extension for SUMO files.
;; Common ones are .kif or .sumo.
(add-to-list 'auto-mode-alist '("\\.kif\\'" . my-sumo-mode-setup))
(add-to-list 'auto-mode-alist '("\\.sumo\\'" . my-sumo-mode-setup))

;; If a proper SUMO mode or specific font-lock rules emerge, you'd update this.
;; Example of adding specific keywords if you know them:
;; (font-lock-add-keywords 'lisp-mode
;;    '(("(:?implies|and|or|exists|forall)" . font-lock-keyword-face)
;;      ("(=|=>|\\|\\||&)" . font-lock-operator-face)))

Useful Shortcuts (within lisp-mode for SUMO):

    TAB: Indent current line (Lisp-style indentation).
    C-M-f / C-M-b: Move forward/backward S-expression.
    C-M-k: Kill S-expression.
    C-M-u: Move up S-expression.
    C-x C-s: Save.
    C-s / C-r: Search.

4. Gremlin (Graph Traversal Language)

Gremlin is the graph traversal language of Apache TinkerPop, used to query and manipulate graph databases.

    Nature: A functional, imperative language used to traverse graph data.
    Preferred Emacs Mode: gremlin-mode (available on Melpa).
    External Prerequisites: Apache TinkerPop (e.g., Gremlin Console, Gremlin Server, or a TinkerPop-compatible graph database like JanusGraph, Neo4j with TinkerPop plugin).
    LSP Support: No official Gremlin LSP server is widely available. eglot will not provide advanced features.

~/.emacs.d/lisp/languages/gremlin.el Configuration:
Code snippet

;;; gremlin.el --- Configuration for Gremlin -*- lexical-binding: t; -*-

(use-package gremlin-mode
  :ensure t
  :mode "\\.gremlin\\'" ; Common extension for Gremlin scripts
  :hook (gremlin-mode . (lambda ()
                           (setq indent-tabs-mode nil)
                           (setq tab-width 2) ; Common for Groovy-like languages
                           (electric-pair-mode 1)
                           (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; LSP support is generally not available for Gremlin.
  ;; Flycheck and Company-mode will offer basic features.

  ;; Flycheck: Basic syntax checks if gremlin-mode provides a checker.
  (use-package flycheck
    :hook (gremlin-mode . flycheck-mode))

  ;; Company-mode: Keyword and dabbrev completion.
  (use-package company
    :hook (gremlin-mode . company-mode)
    :config
    (add-to-list 'company-backends 'company-dabbrev-code))

  ;; --- Sending Gremlin Queries to a Gremlin Console/Server (Example) ---
  ;; This assumes you have the Gremlin Console installed and accessible.
  ;; This will start a Gremlin Console process and send the query.
  (defun gremlin-send-query-to-console ()
    "Sends the current Gremlin query (or region) to a Gremlin Console process."
    (interactive)
    (unless (executable-find "gremlin.sh") ; Check for the console script
      (error "Gremlin Console script 'gremlin.sh' not found in PATH."))
    (let* ((query-string (if (use-region-p)
                             (buffer-substring-no-properties (region-beginning) (region-end))
                           (buffer-string))))
      (message "Sending Gremlin query...")
      ;; This is a simplified example; for robust interaction, you might
      ;; want a dedicated package that manages a Gremlin Console process.
      (shell-command (format "gremlin.sh -e \"%s\"" (shell-quote-string query-string))
                     "*Gremlin Console Output*")))

  (define-key gremlin-mode-map (kbd "C-c C-e") 'gremlin-send-query-to-console)

  ;; If you frequently use a specific Gremlin Server endpoint, you might
  ;; write a function to send HTTP POST requests (e.g., using `url-retrieve`).
  )

Useful Shortcuts (within gremlin-mode):

    TAB: Indent current line.
    C-x C-s: Save.
    C-s / C-r: Search.
    C-c C-e (gremlin-send-query-to-console): (If configured) Send the current query to the Gremlin Console.

Remember to install any necessary external tools (like curl for SPARQL example, gremlin.sh for Gremlin example) and their respective binaries to your system's PATH for these Emacs integrations to work.

}}}
Idris               ___TODO {{{

You've chosen a truly fascinating and indeed more "exotic" language with Idris! Idris (and particularly Idris 2) is a dependently typed functional programming language, great for verified programming. Emacs support for Idris is mature and powerful, leveraging its interactive nature.

The core of Emacs's Idris support comes from idris-mode (which also supports Idris 2). It's designed to integrate deeply with the Idris interactive environment (the REPL or the IDE protocol), allowing you to interact with the type checker directly from your Emacs buffer.
Emacs Configuration for Idris (init.el)

We'll configure idris-mode and touch on some common integrations.

Crucial Prerequisites (Outside of Emacs):

    Idris (or Idris 2) Installation: You need a working Idris compiler on your system.
        Idris 1: Usually installed via Haskell's cabal or stack.
        Idris 2: Often built from source or installed via elan. The instructions from the Idris 2 GitHub page are the most reliable.
        Crucially: Ensure the idris (or idris2) executable is in your system's PATH.

Here's the init.el snippet:
Code snippet

;; --- Emacs Package Management Preamble ---
;; (As established, this section ensures that packages are automatically installed
;; if they are not already present, based on your use-package declarations.)

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
;; (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

;; --- End of Emacs Package Management Preamble ---


;; --- Idris Configuration ---

(use-package idris-mode
  :mode "\\.idr\\'" ; Activate idris-mode for .idr files
  :hook (idris-mode . (lambda ()
                         (setq indent-tabs-mode nil) ; Use spaces
                         (setq tab-width 2)           ; 2 spaces for Idris (common)
                         (setq idris-indent-offset 2) ; Specific to idris-mode indentation
                         (electric-pair-mode 1)
                         (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)
                         ;; Enable interactive features when opening a file
                         (idris-load-file))) ; Automatically load file into Idris compiler on open
  :config
  ;; Crucial: Tell idris-mode where to find the Idris executable
  ;; If 'idris' or 'idris2' is in your system's PATH, this might not be strictly necessary,
  ;; but it's good practice to be explicit.
  ;; For Idris 1:
  ;; (setq idris-interpreter-path "idris")
  ;; For Idris 2:
  (setq idris-interpreter-path "idris2") ; Or "/path/to/your/idris2"

  ;; Set up the IDE protocol for better interaction (highly recommended for Idris 2)
  ;; By default, idris-mode tries to use the IDE protocol if available.
  ;; If you encounter issues, you might need to adjust this.
  ;; (setq idris-ide-mode-type 'socket) ; 'socket' or 'stdio', 'socket' is often more robust

  ;; Configure Flycheck for real-time diagnostics from Idris
  (use-package flycheck
    :init (global-flycheck-mode)
    :config
    ;; Define a flycheck checker for Idris
    ;; idris-mode integrates with Flycheck automatically, but this ensures it's set up
    (flycheck-define-checker idris
      :command ("idris" "--check" source) ; Basic check command
      :error-patterns
      ((warning line-start (file-name) ":" line ":" column ":Warning -" (message (and (* nonl) (* "\\n" (not (any "/" "~")) (* nonl)))))
       (error line-start (file-name) ":" line ":" column ":" (message (and (* nonl) (* "\\n" (not (any "/" "~")) (* nonl))))))
      :modes (idris-mode))
    (add-to-list 'flycheck-checkers 'idris))

  ;; Configure Company-mode for auto-completion
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 1) ; Start completing very quickly for Idris
    (add-to-list 'company-backends 'company-idris) ; Use idris-mode's completion backend
    )

  ;; Eldoc for displaying type signatures/documentation in the minibuffer
  (use-package eldoc
    :hook (idris-mode . turn-on-eldoc-mode)
    :config
    ;; By default, idris-mode should set this up.
    ;; If not, you can manually set it:
    ;; (setq eldoc-documentation-function 'idris-eldoc-lookup)
    )

  ;; Popwin can be useful for managing the *Idris* (REPL) and *Idris-events* buffers
  ;; (use-package popwin
  ;;   :config
  ;;   (popwin-mode 1)
  ;;   (setq popwin-buffer-config
  ;;         '(("*Idris*" :position bottom :height 0.3)
  ;;           ("*Idris-events*" :position bottom :height 0.3))))
  )

Explanation of the init.el snippet for Idris:

    use-package idris-mode: The main package for Idris support.
        :mode "\\.idr\\'": Activates idris-mode for .idr files.
        :hook: Sets 2-space indentation (common for Idris), electric pairing, trailing whitespace removal.
            (idris-load-file): This is important! It automatically loads the current Idris file into the Idris compiler (which typically starts an interactive Idris process) when you open the file. This allows Emacs to get feedback from the compiler, like type errors and semantic highlighting.
    idris-interpreter-path: Crucial! You must set this to the correct executable name for your Idris version. If you're using Idris 2, set it to "idris2". If it's not in your PATH, provide the full path (e.g., "/usr/local/bin/idris2" or "/Users/youruser/.elan/bin/idris2").
    eglot / lsp-mode for Idris: While Idris has an IDE protocol, a dedicated Language Server Protocol (LSP) server for Idris (like idris2-lsp) is still under active development and adoption. idris-mode directly implements the IDE protocol, so eglot or lsp-mode aren't strictly necessary for the core features with idris-mode. However, if idris2-lsp matures and becomes the preferred way, you'd configure eglot similar to Elixir. For now, sticking with idris-mode's direct interaction is generally the way to go. I've omitted the eglot block here, as idris-mode handles the interaction itself.
    use-package flycheck: Integrates with idris-mode to display compiler errors and warnings in real-time within your buffer. The flycheck-define-checker idris block explicitly defines how flycheck should invoke idris to check files.
    use-package company: The auto-completion framework. idris-mode provides its own company-idris backend that uses the interactive Idris process for intelligent completion based on the current context and scope.
    use-package eldoc: Shows type signatures and documentation of the symbol at point in the minibuffer as you move around or type. idris-mode provides the idris-eldoc-lookup function for this.
    use-package popwin (Optional): If you find the various *Idris* and *Idris-events* buffers floating around inconvenient, popwin can help manage them by popping them up in a consistent location (e.g., always at the bottom of the frame) when they appear.

Useful Keyboard Shortcuts for Idris in Emacs

Idris is highly interactive, and idris-mode exposes many commands for interacting with the compiler/type checker directly from your code. Many commands follow the C-c C-d prefix for documentation and C-c C-a for actions.

General Emacs Shortcuts (still apply):

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: To compile your Idris project directly (e.g., idris --build myproject.ipkg or idris2 --build myproject.ipkg).
    M-g n / M-g p: Navigate to next/previous error.

idris-mode Specific Shortcuts (highly interactive!):

    C-c C-l (idris-load-file): Load the current file into the Idris compiler. This is the most fundamental command – do this often after making changes! It will show type errors and warnings.
    C-c C-r (idris-reload-file): Reload the file. (Often the same as C-c C-l in practice).
    C-c C-t (idris-type-at-point): Show the type of the expression or name at the cursor. This is invaluable for understanding your code.
    C-c C-d (idris-doc-at-point): Show documentation for the name at the cursor.
    C-c C-a (idris-add-clause): Generate an initial clause for a function definition. Place cursor on the type signature and press this.
    C-c C-s (idris-case-split): Perform a case split on a variable in a pattern match. Place cursor on the variable in the hole and press this.
    C-c C-w (idris-add-with-clause): Add a with clause.
    C-c C-m (idris-make-lemma): Generate a lemma for a hole.
    C-c C-p (idris-proof-search): Attempt to fill a hole using proof search.
    C-c C-c: Depending on context, this is often bound to a "do what I mean" command that performs a relevant interactive action (e.g., case split, adding a clause).
    C-c C-z (idris-pop-to-repl): Switch to the *Idris* interactive buffer (the REPL).
    C-c C-x (idris-interrupt): Interrupt the running Idris process (useful if it's stuck).
    C-c C-k (idris-kill): Kill the Idris process.
    C-c C-b C-b (idris-ipkg-build): Build an Idris package if you are in a project with an .ipkg file.
    C-c C-b C-c (idris-ipkg-clean): Clean an Idris package.

Tips for Idris Development in Emacs:

    Keep the Idris Process Running: The interactive features rely on idris-mode communicating with a running Idris process. Always C-c C-l a file to start it.
    Read the Idris Output Buffers: Pay attention to *Idris* (the interactive REPL) and *Idris-events* for detailed compiler feedback, errors, and interaction.
    Learn the Interactive Commands: The real power of Idris in Emacs comes from using C-c C-t, C-c C-a, C-c C-s, C-c C-w, and C-c C-p to build your programs type-directed.

This setup should give you a very robust environment for developing in Idris, leveraging its interactive nature to the fullest. This was a good "exotic" one! What's next on your Emacs customization journey?

}}}
  https://github.com/idris-hackers/idris-mode  #Idris-Mode Emacs
F* {{{

F* (pronounced F star) is indeed another esoteric but extremely interesting language, a higher-order, dependently typed language for program verification. It compiles to F#, OCaml, and C, and is used for verifying critical software.

Emacs support for F* is primarily provided by fstar-mode. Similar to Idris, fstar-mode integrates with the F* interactive prover. It's often used alongside flycheck for displaying verification errors.
Emacs Configuration for F* (init.el)

We'll set up fstar-mode and flycheck to get a good environment.

Crucial Prerequisites (Outside of Emacs):

    F Installation*: You need a working F* installation on your system. This typically involves cloning the F* repository and building it, which pulls in its dependencies (like OCaml, Z3, and eventually the F* compiler binaries).
        Installation Instructions: Refer to the official F* GitHub repository for the most up-to-date installation instructions. It usually involves commands like git submodule update --init --recursive, opam install . --deps-only, make -C ulib, make -C src/ocaml-output, etc.
        Crucially: Ensure that the F* executables (especially fstar.exe or fstar.js if running with Node.js) are in your system's PATH.

Here's the init.el snippet:
Code snippet

;; --- Emacs Package Management Preamble ---
;; (As established, this section ensures that packages are automatically installed
;; if they are not already present, based on your use-package declarations.)

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
;; (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

;; --- End of Emacs Package Management Preamble ---


;; --- F* Configuration ---

(use-package fstar-mode
  :mode "\\.fst\\'" ; Activate fstar-mode for .fst files
  :hook (fstar-mode . (lambda ()
                         (setq indent-tabs-mode nil) ; Use spaces
                         (setq tab-width 4)           ; 4 spaces for F* (common)
                         (setq fstar-indent-offset 4) ; Specific to fstar-mode indentation
                         (electric-pair-mode 1)
                         (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)
                         (fstar-enable-auto-mode-when-loaded))) ; Enable background checking
  :config
  ;; Crucial: Tell fstar-mode where to find the F* executable.
  ;; This must point to the fstar.exe or fstar.js (if using Node.js) binary.
  ;; Example for a typical installation:
  ;; (setq fstar-exec-path "/path/to/your/fstar/bin/fstar.exe")
  ;; Or if fstar.exe is in your PATH:
  (setq fstar-exec-path "fstar.exe") ; Or "fstar.js" if you installed with Node.js

  ;; You might also need to specify the F* library path if it's not default
  ;; (setq fstar-ulib-path "/path/to/your/fstar/ulib")

  ;; Flycheck for real-time verification errors and warnings
  (use-package flycheck
    :init (global-flycheck-mode)
    :config
    ;; fstar-mode should automatically register its flycheck checker,
    ;; but it doesn't hurt to ensure global mode is active.
    )

  ;; Company-mode for auto-completion (if fstar-mode provides a backend)
  ;; F* often has its own internal completion mechanisms or requires a language server
  ;; (which is not yet standard for F* in the same way as Elixir/F#).
  ;; So, company integration might be more basic than for other languages.
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 1)
    ;; fstar-mode should automatically add its backend to company-backends
    (add-to-list 'company-backends 'company-capf) ; Fallback
    )

  ;; Eldoc for displaying type signatures/documentation in the minibuffer
  (use-package eldoc
    :hook (fstar-mode . turn-on-eldoc-mode))

  ;; Optional: Magit for version control, useful for managing F* projects
  ;; (use-package magit)
  )

Explanation of the init.el snippet for F*:

    use-package fstar-mode: The core package for F* support.
        :mode "\\.fst\\'": Activates fstar-mode for .fst files, which is the standard extension for F* source code.
        :hook: Sets up common indentation (4 spaces are typical for F*), electric pairing, and trailing whitespace removal. fstar-indent-offset is specific to fstar-mode.
            (fstar-enable-auto-mode-when-loaded): This crucial hook enables the background checking mechanism of fstar-mode when you open an F* file. This means F* will start verifying your code in the background and send diagnostics to Emacs.
    fstar-exec-path: Absolutely essential! You must set this variable to the correct path of your F* executable (fstar.exe or fstar.js). If it's not in your system's PATH, provide the full path. This is how Emacs knows where to find the F* verifier.
    fstar-ulib-path (Optional): If your F* standard library (ulib) is not in a default location, you might need to specify its path here.
    use-package flycheck: Integrates with fstar-mode to display verification errors, warnings, and information messages from F* directly in your Emacs buffer. fstar-mode automatically registers its checker with flycheck.
    use-package company: The auto-completion framework. fstar-mode should provide a completion backend that leverages the F* interactive process, though its capabilities might differ from a full LSP server for a more mainstream language.
    use-package eldoc: Shows type information, definitions, and possibly documentation of the symbol at point in the minibuffer.

Useful Keyboard Shortcuts for F* in Emacs

F* development is highly interactive, centered around sending declarations or regions to the F* prover and inspecting the results. Many commands are prefixed with C-c.

General Emacs Shortcuts (still apply):

    C-x C-s: Save the current buffer.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: For compiling your F* project or running F* directly.
        fstar.exe my_file.fst
        fstar.exe --lax my_file.fst (for lax checking, faster but less strict)
        M-x recompile: Repeat last compile command.
        M-g n / M-g p: Navigate to next/previous error/warning in the *compilation* buffer or from Flycheck.

fstar-mode Specific Shortcuts (highly interactive for verification):

    C-c C-s (fstar-send-statement): Send the current top-level declaration (e.g., let, val, type, assume, lemma definition) to the F* prover. This is one of the most frequently used commands. The results (success/failure) will appear in the *Fstar* buffer.
    C-c C-r (fstar-send-region): Send the currently active region to the F* prover. Useful for verifying a specific block of code.
    C-c C-l (fstar-load-file): Load the entire current file into the F* prover. This will verify the whole file.
    C-c C-v (fstar-view-output): Switch to the *Fstar* buffer (the interactive prover output).
    C-c C-e (fstar-send-expression): Send the expression at point to the F* prover.
    C-c C-p (fstar-pretty-print): Pretty-print the current buffer (formats the code).
    C-c C-a (fstar-auto-mode-toggle): Toggle background auto-checking on/off.
    C-c C-x (fstar-interrupt): Interrupt the running F* process (useful if it's stuck on a long proof attempt).
    C-c C-k (fstar-kill): Kill the F* prover process.
    C-c C-d (fstar-query): Query for definition/type of symbol at point (if supported by the F* backend).
    C-c C-m (fstar-module-check): Check the current F* module.

Important Considerations for F*:

    Performance: F* verification can be computationally intensive. Expect some commands to take time, especially on larger files or complex proofs.
    Error Messages: F* error messages can be quite detailed and sometimes daunting. Spend time understanding them. The *Fstar* buffer is key.
    Interactive Workflow: F* development is highly interactive. You'll frequently send small chunks of code to the prover, get feedback, and refine your definitions and proofs.

This setup should provide a solid foundation for working with F* in Emacs. It's a challenging but rewarding language, and Emacs is a great environment to tackle it in.

What's the final language you'd like to configure?
You're really diving into the deep end with F*! F* (pronounced "F-star") is a research-oriented, dependently-typed, effectful programming language developed at Microsoft Research and Inria. It's used for writing and verifying high-assurance code.

Emacs support for F* is provided by fstar-mode.el. Similar to Idris, fstar-mode integrates directly with the F* compiler/prover (fstar.exe or fstar). This direct interaction is key to its functionality, as F* involves significant proof checking and interaction with an SMT solver (Z3).
Emacs Configuration for F* (init.el)

We'll focus on fstar-mode and its integration with Z3, which is an essential component of the F* workflow.

Crucial Prerequisites (Outside of Emacs):

    F Installation*: You need a working F* installation. The F* project provides binaries and installation instructions on their GitHub page (e.g., fstar-lang.org).
        Note: F* versions can be sensitive, so it's often recommended to use a specific release or build from source according to their INSTALL.md.
    Z3 Solver: F* relies heavily on the Z3 SMT solver for proof automation. You must have Z3 installed and accessible in your system's PATH.
        Installation: Often available via package managers (e.g., brew install z3 on macOS, sudo apt-get install z3 on Debian/Ubuntu), or directly from the Z3 GitHub releases page.

Make sure both fstar.exe (or fstar on Unix-like systems) and z3 are in your system's PATH.

Here's the init.el snippet:
Code snippet

;; --- Emacs Package Management Preamble ---
;; (As established, this section ensures that packages are automatically installed
;; if they are not already present, based on your use-package declarations.)

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
;; (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

;; --- End of Emacs Package Management Preamble ---


;; --- F* Configuration ---

(use-package fstar-mode
  :mode (("\\.fst\\'" . fstar-mode) ; F* source files
         ("\\.fsti\\'" . fstar-mode)) ; F* interface files
  :hook (fstar-mode . (lambda ()
                         (setq indent-tabs-mode nil) ; Use spaces
                         (setq tab-width 2)           ; 2 spaces for F* (common)
                         (setq fstar-indent-offset 2) ; Specific to fstar-mode indentation
                         (electric-pair-mode 1)
                         (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; Crucial: Tell fstar-mode where to find the F* executable and Z3
  ;; If 'fstar.exe' and 'z3' are in your system's PATH, this might not be strictly necessary,
  ;; but it's good practice to be explicit.
  ;; Example:
  ;; (setq fstar-executable "/path/to/FStar/bin/fstar.exe")
  ;; (setq fstar-smt-executable "/path/to/z3")
  ;; Default values assume they are in PATH:
  (setq fstar-executable "fstar.exe") ; or "fstar" on Unix/Linux/macOS
  (setq fstar-smt-executable "z3")

  ;; Optional: Customize F* prover arguments for specific projects/needs
  ;; You can also use .dir-locals.el for project-specific settings.
  ;; For example, to include a library path:
  ;; (setq-default fstar-subp-prover-args '("--include" "/path/to/your/fstar/library"))

  ;; Flycheck integration for real-time diagnostics from F*
  ;; fstar-mode integrates with Flycheck automatically, often using `fstar-flycheck-checker`
  (use-package flycheck
    :init (global-flycheck-mode)
    :config
    ;; You can customize the flycheck checker. Default often uses full-buffer verification.
    ;; You might prefer a lightweight typechecking for speed:
    ;; (setq fstar-flycheck-checker 'fstar-typecheck-checker)
    )

  ;; Company-mode for auto-completion
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 1)
    (add-to-list 'company-backends 'company-dabbrev-code) ; fstar-mode provides completion, or uses dabbrev
    )

  ;; Eldoc for displaying type signatures/documentation in the minibuffer
  (use-package eldoc
    :hook (fstar-mode . turn-on-eldoc-mode)
    :config
    ;; fstar-mode should automatically set `eldoc-documentation-function`
    )

  ;; Popwin can be useful for managing the *FStar* and *goals* windows
  ;; (use-package popwin
  ;;   :config
  ;;   (popwin-mode 1)
  ;;   (setq popwin-buffer-config
  ;;         '(("*FStar*" :position bottom :height 0.3)
  ;;           ("*goals*" :position right :width 0.4))))

  ;; If you're working on a project with a Makefile that echoes F* arguments,
  ;; you can configure fstar-mode to use it:
  ;; (defun my-fstar-compute-prover-args-using-make ()
  ;;   "Construct arguments to pass to F* by calling make."
  ;;   (with-temp-buffer
  ;;     (call-process "make" nil t nil (buffer-file-name) "-in")
  ;;     (split-string (buffer-string) " " t)))
  ;; (setq fstar-compute-prover-args-function 'my-fstar-compute-prover-args-using-make)
  )

Explanation of the init.el snippet for F*:

    use-package fstar-mode: The main Emacs mode for F*.
        :mode: Associates .fst (F* source files) and .fsti (F* interface files) with fstar-mode.
        :hook: Sets up 2-space indentation (standard for F*), electric pairing, and trimming trailing whitespace on save. fstar-indent-offset is specific for F* indentation.
    fstar-executable and fstar-smt-executable: Absolutely essential! These variables tell fstar-mode the paths to your F* executable and the Z3 SMT solver. Even if they are in your PATH, explicitly setting them (e.g., "fstar.exe" and "z3") is good practice. If they are not in PATH, provide full paths (e.g., "/path/to/FStar/bin/fstar.exe").
    fstar-subp-prover-args (Optional): This is where you pass additional arguments to the F* prover, such as --include paths for libraries. For project-specific flags, using a .dir-locals.el file in your project root is a common and recommended practice.
    use-package flycheck: Integrates with fstar-mode to display F* verification errors and warnings directly in your buffer. fstar-mode has built-in flycheck checkers, and you can customize whether it performs full-buffer verification or just lightweight type checking (fstar-typecheck-checker) for performance.
    use-package company: The auto-completion framework. fstar-mode provides completion capabilities that integrate with company-mode.
    use-package eldoc: Shows type signatures and documentation in the minibuffer as you navigate or type.
    use-package popwin (Optional): F* interaction can open multiple temporary windows (e.g., for goals or prover output). popwin can help manage these by positioning them consistently.
    Makefile Integration (Advanced/Optional): The commented-out my-fstar-compute-prover-args-using-make function demonstrates how you could configure fstar-mode to read F* arguments from a Makefile. This is often used in larger F* projects.

Useful Keyboard Shortcuts for F* in Emacs

F* development is highly interactive, focusing on verifying code piece by piece. fstar-mode provides keybindings to send code to the F* prover, view goals, and navigate errors.

General Emacs Shortcuts (still apply):

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: For compiling your F* project (e.g., fstar.exe my_file.fst or fstar.exe --lax my_file.fst for lax checking).
    M-g n / M-g p: Navigate to next/previous error.

fstar-mode Specific Shortcuts (highly interactive!):

The core workflow involves sending chunks of code to F* for verification.

    C-c C-RET or C-c RET: Send the current phrase/definition (up to the next top-level definition or ;;) to F* for processing and verification. This is your primary command for interactive development.
    C-S-i: Send everything from the beginning of the buffer up to the current point to F*.
    C-c C-l (fstar-lax-mode): Send everything from the beginning of the buffer to the current point in lax mode (less strict verification, faster).
    C-c C-b (fstar-buffer): Send the entire buffer to F* in lax mode.
    C-c C-s C-e (fstar-eval-expr): Evaluate an expression at point.
    C-c C-s C-d (fstar-show-type-and-docs): Show the type and documentation of the identifier at point.
    C-c C-q (fstar-quit-all-satellite-windows): Close all temporary windows opened by fstar-mode (like *FStar* and *goals*).
    C-c C-x (fstar-kill-subp): Kill the F* subprocess (if it's stuck or you want to restart).
    C-c C-v (fstar-verify-file-command-line): Verify the current file using the F* command line (useful for a full check).
    C-c C-a (fstar-browse-alternate): Switch to the interface file (.fsti) or back to the implementation (.fst).
    C-c C-' (fstar-jump-to-definition): Jump to the definition of the symbol at point.
    C-c C-S-l: (Or C-c C-u then C-c C-l) Reload dependencies of the current buffer and reprocess its contents (with optional lax mode).
    C-c C-t: Show the goal at point (if you are in a proof context). F* will often open a *goals* buffer.
    M-p / M-n (Page Up/Page Down in *goals* buffer): Navigate between goals.

Tips for F Development in Emacs:*

    Interactive Verification: The core of F* is interactive verification. You write a little, prove a little. Use C-c C-RET constantly to verify definitions as you write them.
    Goal Window (*goals*): When F* requires a proof, a *goals* window will typically appear. This shows you the current proof obligation.
    Error Messages: F* error messages can be very detailed. flycheck will show basic indicators, but always check the *FStar* buffer for the full output from the prover.
    Performance: F* verification can be computationally intensive. Be patient, and consider using --lax mode (C-c C-l) for initial development before full verification.

This setup will provide a solid foundation for working with F* in Emacs. It's a challenging but rewarding language, and Emacs's interactive environment is well-suited for it.

What's the next language on your list?

}}}
Ada {{{

Ada is a classic and robust language, especially prevalent in high-integrity systems. Emacs provides solid support for Ada, integrating with the GNAT toolchain and the official Ada Language Server (ada-language-server).

Here's how to configure Emacs for Ada, along with useful shortcuts.
Emacs Configuration for Ada (init.el / ~/.emacs.d/lisp/languages/ada.el)

Crucial Prerequisites (Outside of Emacs):

    GNAT (GCC for Ada): This is the standard Ada compiler suite.
        Arch Linux:
        Bash

    sudo pacman -S gnat

    For other systems, refer to AdaCore's GNAT downloads or your system's package manager.
    Verify Installation: gnat --version should output its version.

ada-language-server (ALS): This is the official and recommended LSP server for Ada, developed by AdaCore.

    Installation: ALS is often distributed with GNAT toolchains from AdaCore. If not, you might need to build it from source or install it via Go (as it's written in Go).
        Via go install (if you have Go installed):
        Bash

            go install github.com/AdaCore/ada-language-server@latest

            Ensure $(go env GOBIN) (typically ~/go/bin) is in your system's PATH.
            From GNAT distribution: Check your GNAT installation's bin directory for ada-language-server.
        Verify Installation: ada-language-server --version should output its version.

Here's the use-package configuration for Ada, to be placed in your modular setup (e.g., ~/.emacs.d/lisp/languages/ada.el):
Code snippet

;;; ada.el --- Configuration for Ada -*- lexical-binding: t; -*-

(use-package ada-mode
  :ensure t ; Ensure it's installed from GNU ELPA or Melpa
  :mode (("\\.ada\\'" . ada-mode)   ; Ada source files
         ("\\.ads\\'" . ada-mode)   ; Ada Specification files
         ("\\.adb\\'" . ada-mode))  ; Ada Body files
  :hook (ada-mode . (lambda ()
                       (setq tab-width 3)         ; Ada style guides often suggest 3 spaces
                       (setq indent-tabs-mode nil) ; Prefer spaces
                       (electric-pair-mode 1)     ; Auto-pair brackets, parens, etc.
                       (add-hook 'before-save-hook #'delete-trailing-whitespace nil t)
                       ;; Optional: Auto-format on save using gnatpp (part of GNAT)
                       ;; (add-hook 'before-save-hook #'ada-gnatpp-buffer nil t)
                       ;; Or use LSP formatting
                       (add-hook 'before-save-hook #'eglot-format-buffer nil t)
                       ))
  :config
  ;; Configure paths for Ada tools if they are not in your system's PATH
  ;; (setq ada-compiler-path "/opt/gnat/bin")
  ;; (setq ada-language-server-path "/opt/gnat/bin")

  ;; --- Eglot for Ada Language Server (ALS) ---
  (use-package eglot
    :hook (ada-mode . eglot-ensure) ; Automatically activate eglot when ada-mode is used
    :config
    ;; Tell eglot how to start the Ada Language Server.
    ;; Assuming `ada-language-server` is in your PATH.
    (add-to-list 'eglot-server-programs '(ada-mode . ("ada-language-server")))

    ;; --- Optional: Check for ALS binary presence ---
    (add-hook 'eglot-managed-mode-hook
              (lambda ()
                (when (eq major-mode 'ada-mode)
                  (my-check-and-suggest-install-binary
                   "ada-language-server"
                   "go install github.com/AdaCore/ada-language-server@latest
                    (Requires Go, and ensure ~/go/bin is in PATH)"
                   "Install GNAT toolchain from AdaCore (which might include ALS)."))))
    )

  ;; --- Flycheck for diagnostics (integrates with eglot) ---
  (use-package flycheck
    :hook (ada-mode . flycheck-mode)
    :init (global-flycheck-mode))

  ;; --- Company-mode for auto-completion (integrates with eglot) ---
  (use-package company
    :init (global-company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 2)
    (add-to-list 'company-backends 'company-capf)) ; Eglot provides completion via company-capf

  ;; --- ada-mode specific keybindings and features ---
  ;; Navigation between specification (.ads) and body (.adb) files
  (define-key ada-mode-map (kbd "C-c C-v") 'ada-goto-spec-or-body) ; Very useful!

  ;; Compilation and project management
  (define-key ada-mode-map (kbd "C-c C-c") 'ada-compile) ; Compile current file or project
  (define-key ada-mode-map (kbd "C-c C-k") 'ada-check-syntax) ; Check syntax

  ;; Code formatting with GNATPP
  (define-key ada-mode-map (kbd "C-c C-f") 'ada-gnatpp-buffer) ; Format buffer with gnatpp

  ;; Verify (similar to compile but specifically for checks)
  (define-key ada-mode-map (kbd "C-c C-a") 'ada-verify)
  )

Explanation of the ada.el snippet:

    use-package ada-mode: The core major mode for Ada.
        :mode declarations ensure .ada, .ads, and .adb files open with ada-mode.
        :hook sets up 3-space indentation (a common Ada convention), electric pairing, and adds hooks for formatting and trimming whitespace on save.
    use-package eglot: Integrates with ada-language-server.
        :hook (ada-mode . eglot-ensure): Activates Eglot for Ada files.
        add-to-list 'eglot-server-programs '(ada-mode . ("ada-language-server")): Tells Eglot to launch ALS.
        Binary Check: Uses your my-check-and-suggest-install-binary helper to warn if ada-language-server is missing.
    use-package flycheck & use-package company: Standard integrations for on-the-fly diagnostics and advanced completion, powered by ada-language-server via Eglot.
    ada-mode specific keybindings: Ada's structure with separate specification (.ads) and body (.adb) files makes ada-goto-spec-or-body (C-c C-v) particularly useful for navigation. Commands for compilation (ada-compile) and formatting (ada-gnatpp-buffer) are also included.

Useful Keyboard Shortcuts for Ada in Emacs

You'll heavily rely on both general Emacs commands and the specialized ada-mode commands, complemented by Eglot's LSP features.

General Emacs Shortcuts (always useful):

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: For custom gprbuild or gnatmake commands.
        M-g n / M-g p: Navigate to next/previous error in the *compilation* buffer.
    C-M-a / C-M-e: Move backward/forward S-expression (useful for navigating Ada's block structures).
    M-! (shell-command): Run a single shell command (e.g., gnat --version).
    M-x shell: Open a general shell buffer.
    C-M-\ (indent-region): Re-indent the selected region.
    C-c C-e: (If you have comment-dwim or similar set up) comment/uncomment region/line.

Eglot/LSP Shortcuts (when ada-mode is active):

These are the standard Eglot commands, powered by ada-language-server:

    M-. (xref-find-definitions): Go to definition.
    M-, (xref-pop-marker-stack): Go back (pop mark).
    M-x xref-find-references: Find all references to the symbol at point.
    M-x eglot-rename: Rename a symbol across your project.
    M-x eglot-code-action: Access quick fixes or refactoring options.
    M-x eglot-hover: Show documentation/type info for the symbol at point.
    M-x eglot-format-buffer: Format the current buffer using the LSP server.
    M-x eglot-reconnect: Reconnect to the language server if it crashes or you need to restart it.
    M-x eldoc: Show function signatures and documentation in the minibuffer.

ada-mode Specific Shortcuts:

    C-c C-v (ada-goto-spec-or-body): Jump between a package's specification (.ads) and its body (.adb) file. This is incredibly useful in Ada projects.
    C-c C-c (ada-compile): Compile the current file or project (uses gnatmake or gprbuild automatically).
    C-c C-k (ada-check-syntax): Check the syntax of the current file.
    C-c C-f (ada-gnatpp-buffer): Format the current buffer using gnatpp (the GNAT Pretty Printer).
    C-c C-a (ada-verify): Run static analysis or other verification checks via the GNAT toolchain.

This setup should provide you with a capable and integrated Emacs environment for developing in Ada!

}}}
Ring {{{

The Ring programming language is indeed an interesting "oddball" choice! It aims to be a practical and general-purpose language with a focus on simplicity and embedded systems. Due to its relatively niche status, Emacs support might not be as feature-rich as for Kotlin or Go, especially regarding Language Server Protocol (LSP) integration.

Let's look at what's available and how to set it up.
Emacs Configuration for Ring (init.el / ~/.emacs.d/lisp/languages/ring.el)

Crucial Prerequisite (Outside of Emacs):

    Ring Language Compiler/Interpreter: You need to have the Ring language installed on your system.
        Installation: The official Ring website (ring-lang.net) provides installation instructions. Typically, this involves downloading a release or compiling from source.
        Verify: After installation, ensure ring -v or ring --version works in your terminal. Ensure the ring executable is in your system's PATH.

Current Status of LSP for Ring:

As of my last update, there isn't a widely adopted or official Language Server Protocol (LSP) server specifically for the Ring language. This means that advanced IDE features like intelligent real-time diagnostics, robust refactoring, and context-aware completion (beyond basic keyword completion) might be limited when using eglot or lsp-mode.

Therefore, our Emacs configuration will focus on the dedicated ring-mode for syntax highlighting, indentation, and running Ring scripts. flycheck and company-mode will have basic functionality if ring-mode provides it, but won't benefit from a full LSP server.

Here's the use-package configuration to go into your modular setup (e.g., ~/.emacs.d/lisp/languages/ring.el):
Code snippet

;;; ring.el --- Configuration for Ring Language -*- lexical-binding: t; -*-

(use-package ring-lang-mode ; The package is usually named 'ring-lang-mode' on Melpa
  :ensure t ; Ensure it's installed from MELPA
  :mode "\\.ring\\'" ; Activate ring-lang-mode for .ring files
  :hook (ring-lang-mode . (lambda ()
                              (setq indent-tabs-mode nil) ; Prefer spaces
                              (setq tab-width 4)           ; Common default for many languages
                              (electric-pair-mode 1)       ; Auto-pair brackets, parens, etc.
                              (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; --- Language Server Protocol (LSP) Support ---
  ;; As of now, there isn't a widely adopted official LSP server for Ring.
  ;; Therefore, `eglot` integration will not provide full LSP features.
  ;; However, if one emerges, you would configure it like this:
  ;; (use-package eglot
  ;;   :hook (ring-lang-mode . eglot-ensure)
  ;;   :config
  ;;   ;; Replace "ring-lsp-server" with the actual binary name if it exists
  ;;   ;; (add-to-list 'eglot-server-programs '(ring-lang-mode . ("ring-lsp-server")))
  ;;   ;; (add-hook 'eglot-managed-mode-hook
  ;;   ;;           (lambda ()
  ;;   ;;             (when (eq major-mode 'ring-lang-mode)
  ;;   ;;               (my-check-and-suggest-install-binary
  ;;   ;;                "ring-lsp-server"
  ;;   ;;                "Please install the Ring Language Server (if available)."))))
  ;;   )

  ;; --- Flycheck for basic diagnostics (if ring-mode supports it) ---
  ;; Flycheck might work for basic syntax checks if `ring-lang-mode` provides
  ;; a `flycheck-checker` or if you can integrate an external linter.
  (use-package flycheck
    :hook (ring-lang-mode . flycheck-mode)
    :init (global-flycheck-mode))

  ;; --- Company-mode for auto-completion (basic completion only) ---
  ;; Without an LSP server, Company mode will primarily offer keyword completion
  ;; and completion from existing words in the buffer.
  (use-package company
    :init (global-company-mode)
    :hook (ring-lang-mode . company-mode)
    :config
    (setq company-idle-delay 0.1)
    (setq company-minimum-prefix-length 2)
    ;; 'company-dabbrev-code' is a good default for basic modes
    (add-to-list 'company-backends 'company-dabbrev-code))

  ;; --- Running Ring Scripts ---
  ;; You can use Emacs's `compile` command to run Ring scripts.
  ;; Define a custom function for convenience.
  (defun ring-run-current-file ()
    "Run the current Ring file using 'ring run'."
    (interactive)
    (when (buffer-file-name)
      (compile (format "ring run %s" (buffer-file-name)))))

  ;; You can bind this to a key, e.g., C-c C-r
  (define-key ring-lang-mode-map (kbd "C-c C-r") 'ring-run-current-file)

  ;; For interactive shell
  (defun ring-shell ()
    "Start an interactive Ring shell."
    (interactive)
    (shell-command "ring" "*Ring Shell*"))

  (define-key ring-lang-mode-map (kbd "C-c C-s") 'ring-shell)

  ;; --- Optional: Formatter Integration ---
  ;; If Ring has an official formatter (like `ring fmt`), you can integrate it.
  ;; Check Ring's documentation for a dedicated formatter command.
  ;; Example (hypothetical):
  ;; (defun ring-format-buffer ()
  ;;   "Format the current Ring buffer using `ring fmt -w`."
  ;;   (interactive)
  ;;   (when (executable-find "ring")
  ;;     (shell-command (format "ring fmt -w %s" (buffer-file-name)))
  ;;     (message "Buffer formatted with Ring formatter.")))
  ;; (add-hook 'before-save-hook #'ring-format-buffer nil t)
  )

Explanation of the ring.el snippet:

    use-package ring-lang-mode: This is the major mode for Ring.
        :ensure t: Ensures the package is installed from Melpa.
        :mode "\\.ring\\'": Activates ring-lang-mode for .ring files.
        :hook: Sets up 4-space indentation, electric pairing, and trims trailing whitespace on save.
    LSP Support (Commented Out): I've included a commented-out section for eglot. If a robust LSP server for Ring emerges in the future, you would uncomment and configure this section, replacing "ring-lsp-server" with the actual binary name.
    use-package flycheck & use-package company:
        flycheck will provide basic syntax checking if ring-lang-mode integrates with the Ring compiler for diagnostics. Without a full LSP, its capabilities will be limited.
        company-mode will offer "dabbrev" completion (completing words already in the buffer) and basic keyword completion, but not context-aware, semantic completion provided by an LSP.
    Running Ring Scripts:
        ring-run-current-file: A custom function bound to C-c C-r that uses M-x compile to execute your current Ring file. This is a standard and effective way to run scripts directly.
        ring-shell: A custom function bound to C-c C-s to open an interactive Ring shell in an Emacs buffer.

Useful Keyboard Shortcuts for Ring in Emacs

Without an LSP server, your interaction will rely more on general Emacs commands and basic ring-lang-mode features.

General Emacs Shortcuts (always useful):

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: Run custom build/run commands (e.g., ring run %f to run the current file).
        M-g n / M-g p: Navigate to next/previous error in the *compilation* buffer.
    C-M-a / C-M-e: Move backward/forward S-expression (useful for navigating code blocks).
    M-! (shell-command): Run a single shell command (e.g., ring -v).
    M-x shell: Open a general shell buffer for interactive commands, then you can type ring to start the interpreter.
    C-M-\ (indent-region): Re-indent the selected region.
    C-c C-e: (If you have comment-dwim or similar set up) comment/uncomment region/line.

ring-lang-mode Specific Shortcuts (as defined above):

    C-c C-r (ring-run-current-file): Run the current Ring file.
    C-c C-s (ring-shell): Open an interactive Ring shell.

Even without a full LSP, ring-lang-mode provides a solid foundation for editing Ring code within Emacs, making use of Emacs's powerful text editing capabilities and basic integration with the Ring toolchain.

}}}
PostScript {{{

Alright, PostScript! This is a fascinating and truly "classic" choice. PostScript isn't just a graphics language; it's a Turing-complete programming language designed primarily for vector graphics and printing, and it was revolutionary in its time.

Emacs support for PostScript primarily revolves around postscript-mode. Given PostScript's unique nature (often compiled directly by a printer or interpreter like Ghostscript), the Emacs integration is more about editing convenience, syntax highlighting, and very basic interaction, rather than a full-blown interactive REPL like with Lisp or SML.
Emacs Configuration for PostScript (init.el)

We'll set up postscript-mode and mention integration with Ghostscript, which is the de-facto standard for interpreting and rendering PostScript outside of a physical printer.

Crucial Prerequisite (Outside of Emacs):

    Ghostscript: This is the essential tool for working with PostScript files on your computer. It allows you to view, convert, and process PostScript files.
        Installation:
            macOS (Homebrew): brew install ghostscript
            Debian/Ubuntu: sudo apt-get install ghostscript
            Windows: Download from the Ghostscript website.

Ensure the gs (or gswin64c.exe on Windows) executable is in your system's PATH.

Here's the init.el snippet:
Code snippet

;; --- Emacs Package Management Preamble ---
;; (As established, this section ensures that packages are automatically installed
;; if they are not already present, based on your use-package declarations.)

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
;; (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)

;; --- End of Emacs Package Management Preamble ---


;; --- PostScript Configuration ---

(use-package postscript-mode
  :mode (("\\.ps\\'" . postscript-mode) ; Activate postscript-mode for .ps files
         ("\\.eps\\'" . postscript-mode)) ; And .eps (Encapsulated PostScript) files
  :hook (postscript-mode . (lambda ()
                              (setq indent-tabs-mode nil) ; Use spaces (or customize for PostScript style)
                              (setq tab-width 4)           ; 4 spaces (common for PostScript, customize as needed)
                              ;; PostScript doesn't use balanced delimiters in the same way as Lisp
                              ;; so electric-pair-mode might be less useful or even annoying here.
                              ;; (electric-pair-mode 1)
                              (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)))
  :config
  ;; Optionally, customize the Ghostscript command if `gs` is not in PATH
  ;; (setq postscript-gs-command "gswin64c.exe") ; For Windows
  ;; (setq postscript-gs-command "/path/to/your/gs/bin/gs")

  ;; Flycheck for PostScript syntax checking (if a linter exists, less common)
  ;; This is less common for PostScript as a dedicated linter isn't as widespread
  ;; as for other languages. Ghostscript itself will report errors on interpretation.
  ;; If you find a PostScript linter, you could configure Flycheck here.
  ;; (use-package flycheck
  ;;   :init (global-flycheck-mode))

  ;; No specific Company-mode backend for PostScript is common,
  ;; but `company-dabbrev-code` would still work for word completion.
  ;; (use-package company
  ;;   :init (global-company-mode))

  ;; Eldoc is also less common as PostScript doesn't have standard "type signatures"
  ;; or easily queryable documentation in the same way.
  ;; (use-package eldoc
  ;;   :hook (postscript-mode . turn-on-eldoc-mode))
  )

Explanation of the init.el snippet for PostScript:

    use-package postscript-mode: The core Emacs mode for PostScript.
        :mode: Associates .ps and .eps files with postscript-mode.
        :hook: Sets up basic indentation. I've commented out electric-pair-mode because PostScript's syntax, while stack-based, doesn't use nested parentheses in the same way as Lisp or C-like languages, and it might not be beneficial here. You can uncomment it if you find it helpful.
        postscript-gs-command: This variable allows you to specify the path to your Ghostscript executable if it's not in your system's PATH. It defaults to "gs".
    Optional Integrations (flycheck, company, eldoc): I've commented out blocks for flycheck, company, and eldoc because dedicated linters, robust completion engines, or type-signature providers are not as common or standardized for PostScript compared to other programming languages. The primary "checker" for PostScript is often Ghostscript itself, which will report errors when it tries to interpret the code. If you discover specialized tools for these purposes, you can enable and configure them here.

Useful Keyboard Shortcuts for PostScript in Emacs

PostScript interaction in Emacs usually focuses on editing, viewing the rendered output, and perhaps sending commands to a Ghostscript interactive session (though this is less common than with a full REPL).

General Emacs Shortcuts (still apply):

    C-x C-s: Save.
    C-x C-f: Find file.
    C-s / C-r: Incremental search.
    M-x compile: This is how you'd typically process a PostScript file with Ghostscript.
        Example: gs -sDEVICE=pdfwrite -o output.pdf input.ps (to convert to PDF)
        Example: gs -sDEVICE=pngalpha -r300 -o output.png input.ps (to convert to PNG at 300 DPI)
        M-x recompile: Repeat the last compile command.
        M-g n / M-g p: Navigate to next/previous error in the *compilation* buffer.
    C-M-a / C-M-e: Move backward/forward S-expression (can be somewhat useful for PostScript's nested array/dictionary syntax).

postscript-mode Specific Shortcuts:

    C-c C-c (postscript-evaluate-region): Evaluate the selected region using the gs command and show output in a *gs* buffer. This can be used for simple calculations or testing small PostScript snippets.
    C-c C-b (postscript-evaluate-buffer): Evaluate the entire buffer using gs.
    C-c C-e (postscript-evaluate-expression): Evaluate the expression at point.
    C-c C-p (postscript-preview): Preview the current PostScript file in an external viewer (which is typically your default PDF viewer if you've configured Ghostscript to output PDF, or an image viewer if outputting images). This is a very useful command for visual feedback.
    C-c C-s (postscript-shell): Start an interactive Ghostscript shell (*gs* buffer). You can then type PostScript commands directly.
    M-x postscript-indent-line: Indent the current line.
    M-x postscript-indent-region: Indent the selected region.

Tips for PostScript Development in Emacs:

    Visual Feedback: PostScript is all about graphics. The C-c C-p (postscript-preview) command is your best friend for seeing the results of your code.
    Ghostscript is Key: Your understanding of PostScript will be greatly enhanced by learning to use gs from the command line, as Emacs's integration is essentially wrapping these calls.
    Stack-based Thinking: PostScript is a stack-based language. Debugging often involves keeping track of what's on the stack.
    Documentation: Keep a reference for PostScript operators handy.

This setup should give you a good environment for editing and basic interaction with PostScript files. It's a journey back to the roots of digital printing!

What's the next language or technology on your list?

}}}
Nyquist {{{

Okay, let's dive into the world of music programming with Nyquist!

Nyquist is a fascinating and powerful programming language for sound synthesis and analysis. It's built on top of XLISP, which is a dialect of the Lisp programming language. This Lisp heritage means that Emacs's excellent Lisp modes will be your best friend for Nyquist development.
Nyquist (Music Programming Language)

    Nature: A powerful open-source language for sound synthesis and analysis, widely used for creating audio plugins (e.g., in Audacity) and for academic research in computer music.
    Preferred Emacs Mode: Since Nyquist is based on XLISP, Emacs's built-in lisp-mode (or cl-mode for Common Lisp) is the most appropriate and capable choice. While there isn't a dedicated nyquist-mode on Melpa, lisp-mode provides excellent syntax highlighting, indentation, and S-expression navigation for Lisp dialects.
    External Prerequisites:
        Nyquist Interpreter: You need the Nyquist executable (ny).
            You can download the standalone Nyquist environment from the CMU Auditory website.
            Alternatively, if you use Audacity, it comes with a Nyquist interpreter for running Nyquist plug-ins. However, for command-line execution, you'll need the standalone version.
        ny in PATH: Ensure the ny executable is in your system's PATH so Emacs can find it.
    LSP Support: No dedicated Nyquist Language Server Protocol (LSP) exists. Therefore, eglot will not provide advanced features like semantic completion or diagnostics.
    Key Features for Emacs Integration: We'll focus on using lisp-mode's powerful structural editing, and a custom function to send Nyquist code directly to the Nyquist interpreter for execution.

~/.emacs.d/lisp/languages/nyquist.el Configuration:
Code snippet

;;; nyquist.el --- Configuration for Nyquist (via lisp-mode) -*- lexical-binding: t; -*-

(defun my-nyquist-mode-setup ()
  "Setup for Nyquist files, using lisp-mode as a base."
  (setq major-mode 'lisp-mode) ; Explicitly set major mode to lisp-mode
  (lisp-mode)                 ; Call lisp-mode setup
  (setq indent-tabs-mode nil) ; Prefer spaces
  (setq tab-width 2)          ; Common for Lisp dialects (or 4, customize as you prefer)
  (electric-pair-mode 1)      ; Auto-pair parentheses, brackets, etc.
  (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)
  (message "Opened in Lisp mode for Nyquist. Use C-c C-e or C-c C-r to evaluate.")

  ;; LSP support is not available for Nyquist.
  ;; Flycheck and Company-mode will only offer basic features.
  (use-package flycheck
    :hook (lisp-mode . flycheck-mode)) ; Hook into lisp-mode for diagnostics (basic)

  (use-package company
    :hook (lisp-mode . company-mode)    ; Hook into lisp-mode for completion
    :config
    (add-to-list 'company-backends 'company-dabbrev-code) ; Only dabbrev (word-based) completion
    )

  ;; You could also add custom font-lock keywords for Nyquist-specific functions
  ;; if lisp-mode doesn't highlight them sufficiently.
  ;; Example (hypothetical, requires specific Nyquist function names):
  ;; (font-lock-add-keywords 'lisp-mode
  ;;   '(("(\\(play\\|osc\\|sound\\|peak\\|loud\\)\\b" . font-lock-function-name-face)))
  )

;; Auto-associate .ny files with our setup function
(add-to-list 'auto-mode-alist '("\\.ny\\'" . my-nyquist-mode-setup))

;; --- Nyquist Evaluation Functions ---

(defvar nyquist-interpreter-path "ny"
  "Path to the Nyquist interpreter executable. Make sure 'ny' is in your system's PATH.")

(defun nyquist-evaluate-buffer ()
  "Sends the entire current buffer's content to the Nyquist interpreter.
The output (e.g., sound data, print statements) will appear in *Nyquist Output*."
  (interactive)
  (unless (executable-find nyquist-interpreter-path)
    (error "Nyquist interpreter '%s' not found in PATH.
Please install Nyquist (http://www.cs.cmu.edu/~rbd/nyquist/nyquist-install/nyquist-install.html)
and ensure 'ny' is accessible in your system's PATH." nyquist-interpreter-path))
  (message "Evaluating Nyquist buffer (check *Nyquist Output*)...")
  ;; shell-command-on-region pipes the text to the external command.
  ;; The output is captured in a buffer named *Nyquist Output*.
  (shell-command-on-region (point-min) (point-max) nyquist-interpreter-path "*Nyquist Output*"))

(defun nyquist-evaluate-region ()
  "Sends the current region's content to the Nyquist interpreter.
The output (e.g., sound data, print statements) will appear in *Nyquist Output*."
  (interactive)
  (unless (use-region-p)
    (error "No region selected to evaluate."))
  (unless (executable-find nyquist-interpreter-path)
    (error "Nyquist interpreter '%s' not found in PATH.
Please install Nyquist (http://www.cs.cmu.edu/~rbd/nyquist/nyquist-install/nyquist-install.html)
and ensure 'ny' is accessible in your system's PATH." nyquist-interpreter-path))
  (message "Evaluating Nyquist region (check *Nyquist Output*)...")
  (shell-command-on-region (region-beginning) (region-end) nyquist-interpreter-path "*Nyquist Output*"))

;; --- Keybindings ---
;; These keybindings are typical for Lisp evaluation in Emacs
(define-key lisp-mode-map (kbd "C-x C-e") 'eval-last-sexp) ; Evaluate S-expression at point
(define-key lisp-mode-map (kbd "C-c C-e") 'nyquist-evaluate-buffer) ; Evaluate whole buffer
(define-key lisp-mode-map (kbd "C-c C-r") 'nyquist-evaluate-region)  ; Evaluate selected region

(provide 'nyquist)

Explanation and Usage:

    my-nyquist-mode-setup: This function is called when you open a file with a .ny extension. It explicitly sets the major mode to lisp-mode and then calls lisp-mode's setup functions. It also configures basic editing preferences (spaces for indentation, electric pairing).
    nyquist-interpreter-path: This variable holds the name of the Nyquist interpreter executable. By default, it's set to "ny". Ensure that ny is installed and accessible in your system's PATH.
    nyquist-evaluate-buffer: This function sends the entire content of your current Emacs buffer directly to the ny interpreter. The Nyquist program will then execute, and any text output (e.g., from print statements) will appear in a new Emacs buffer named *Nyquist Output*. If the Nyquist program generates sound, it will typically play it through your system's default audio output.
    nyquist-evaluate-region: Similar to the buffer evaluation, but it only sends the currently selected text region to the Nyquist interpreter. This is great for testing small snippets of code.
    Keybindings:
        C-x C-e (eval-last-sexp): This is a standard Lisp keybinding that evaluates the S-expression (a parenthesized expression) before your cursor. This is incredibly useful for interactive Lisp development, allowing you to test small parts of your Nyquist code immediately.
        C-c C-e (nyquist-evaluate-buffer): Evaluates the entire Nyquist buffer.
        C-c C-r (nyquist-evaluate-region): Evaluates the currently selected region.

To Use It:

    Install Nyquist: Download and install the standalone Nyquist environment and ensure the ny executable is in your system's PATH.
    Add Configuration: Place the Elisp code above into ~/.emacs.d/lisp/languages/nyquist.el.
    Load Configuration: In your init.el, add (require 'nyquist) somewhere in your load-path setup (e.g., after (add-to-list 'load-path "~/.emacs.d/lisp/languages")).
    Restart Emacs.
    Create a .ny file: Open a new buffer, save it as my_song.ny, and paste some Nyquist code:
    Code snippet

    (play (osc (hz-to-midi 440) 1)) ; Plays a 1-second sine wave at 440 Hz
    (print "Hello from Nyquist!")

    Evaluate:
        Place your cursor after (play (osc (hz-to-midi 440) 1)) and press C-x C-e. You should hear a sine wave!
        Press C-c C-e to run the whole buffer.
        Select (print "Hello from Nyquist!") and press C-c C-r. Check the *Nyquist Output* buffer.

This setup will give you a very capable Emacs environment for writing and interactively testing your Nyquist music programs!

}}}
}}}

~/Empire/Doks/Comp/editor/emacs/masteringemacs-v3.txt    #mickey peterson
~/Empire/Doks/Comp/editor/emacs/emacsextend.txt          #glickstein
~/Empire/Doks/Comp/editor/emacs/elisp/Elisp-IntroTo.txt  ¤¤¤
    ~/Empire/Doks/Comp/editor/emacs/Emacs01-Learning3_534.txt
    ~/Empire/Doks/Comp/editor/emacs/sams-emacs-in24h.txt
        ~/Empire/Doks/Comp/editor/emacs/hackemacs.txt
+Vanki-decks

Per N: Emacs-Dlang-UBUNTUINSTALL 2024 {{{
  Fork + Download PN GitLab Repo
  Clone + Updating the Clone (i.e. instead of Forking) {{{
    For now, I would like to switch
    to another question really
    quickly: I would like to fork a
    repository from Gitlab. It
    seems though that I do not have
    permission to do that. What I'm
    thinking is that I could clone
    it to my local computer. Let's
    say I have cloned it, and at a
    later point, I would like to
    pull down all the additions /
    amendments added by the owner.
    How would I carry out that last
    step from a Linux command-line
    with git?

    Cloning and Pulling Changes
    from a GitLab Repository

    1. Clone the Repository:

    git clone https://gitlab.com/username/repository-name.git

    Replace
    https://gitlab.com/username/repository-name.git
    with the actual URL of the
    repository you want to clone.

    2. Add a Remote:

    If you don't have a remote
    named upstream configured, add
    it:

    git remote add upstream https://gitlab.com/username/repository-name.git

    3. Fetch Changes:

    Fetch the latest changes from
    the upstream repository:

    git fetch upstream

    4. Merge Changes:

    Merge the changes from the
    upstream main branch (or the
    branch you want to merge from)
    into your local branch:

    git merge upstream/main


    5. Push Changes (Optional):

    If you've made local changes
    and want to push them to your
    fork, you can do so:

    git push origin your-branch-name

    Note: If you encounter merge
    conflicts, you'll need to
    resolve them manually before
    pushing.

    By following these steps, you
    can clone a GitLab repository,
    fetch changes from the upstream
    repository, and merge them into
    your local branch.

    Would you like to explore other
    Git commands or workflows?
  }}}
  Patch Own Settings (I.e. Evil, Emp-Vim_Mappings, SysCrafters_Org, etc) {{{

    Here are a couple of options
    you can explore to seamlessly
    integrate your Evil keybindings
    into your friend's Emacs
    configuration while using his
    forked GitLab repository:

    Option 1: Utilize Emacs Load Paths

    - 1. Fork the Repository: Go
      ahead and fork your friend's
      GitLab repository containing
      his Emacs configuration.
    - 2. Local Init File: Create a
      local init.el file in your
      Emacs configuration directory
      (usually ~/.emacs.d/).
    - 3. Load Paths: Within your
      local init.el file, use the
      load-path function to add the
      directory containing your
      friend's forked repository.
      This allows Emacs to find his
      configuration files.
    - 4. Evil Mode Configuration:
      In your local init.el file,
      add the line (require
      'evil-mode) to enable Evil
      keybindings. You can add any
      other custom configurations
      you prefer here.
    - 5. Override or Extend: For
      configurations you want to
      modify or add on top of your
      friend's setup, use Emacs
      Lisp functions like defadvice
      or after-init to selectively
      override or extend specific
      functionalities.

    Benefits:

    - Clean Separation: Your local
      init.el file keeps your Evil
      mode configuration and
      personal touches separate
      from your friend's base
      configuration.
    - Easy Maintenance: You can
      manage your Evil mode setup
      and other preferences
      independently.

    Option 2: Leverage Emacs Package Manager (MELPA)

    - 1. Fork the Repository:
      Similar to Option 1, fork
      your friend's repository.
    - 2. Package Configuration:
      Within your friend's forked
      repository, consider creating
      a separate package
      specifically for Evil mode
      configurations. This package
      can include require
      'evil-mode' and any other
      Evil mode customizations.
    - 3. Install from Package: In
      your local Emacs
      configuration, use the Emacs
      Package Manager (MELPA) to
      install the Evil mode package
      you created within the forked
      repository.

    Benefits:

    - Modular Approach: This option
      breaks down configurations
      into smaller, manageable
      packages.
    - Potential Sharing: If your
      Evil mode configuration is
      generally useful, you could
      even consider publishing it
      to MELPA for wider use.

    Considerations:

    - Understanding Emacs Lisp:
      Both options require some
      familiarity with Emacs Lisp
      for effective configuration
      management (using load-path,
      defadvice, or package
      creation).
    - Conflicting Configurations:
      Be mindful of potential
      conflicts between your Evil
      mode setup and your friend's
      existing configuration.

    Additional Tips:

    - Communicate with your Friend:
      Discuss your approach with
      your friend. They might have
      valuable insights or
      suggestions regarding their
      repository structure.
    - Start Small: Begin with basic
      Evil mode configuration and
      gradually add more
      customizations as needed.
    - Consult Emacs Documentation:
      The Emacs documentation is a
      valuable resource for
      understanding Emacs Lisp and
      configuration options:
      https://www.gnu.org/software/emacs/manual/

    By using either approach and
    leveraging Emacs' powerful
    configuration capabilities, you
    can seamlessly integrate your
    Evil mode preferences with your
    friend's Emacs configuration,
    allowing you to enjoy the
    benefits of both!

  }}}
  Run Emacs Install-script
  - Går det/Finns det ett skript för att/Hur gör man för att uppdatera Emacs från nyaste repot(=om man redan har det installerat)?
}}}
Modularize init.el {{{

emacs split configuration into multiple files (=split up emacs init file)
https://emacs.stackexchange.com/questions/18418/split-configuration-into-multiple-files

https://www.emacswiki.org/emacs/ElispCookbook
    https://superuser.com/questions/231384/how-to-get-code-completion-in-emacs
    https://stackoverflow.com/questions/61446/what-is-the-best-code-template-facility-for-emacs

Emacs:

- 1. Create Lisp Files: Create separate Lisp files for each module or functionality, similar to Vim's module files. Each Lisp file should handle a specific aspect of your Emacs configuration.

- 2. Load Module Files: In your init.el file, use the require form to load each module file. For instance, to load a module file named keybindings.lisp, use the following form:

Code snippet

(require 'keybindings)

- 3. Maintain Central init.el File: Keep the central init.el file focused on global settings, initialization, and package management. Avoid placing module-specific configurations directly into the central init.el file.

- 4. Organize Directories: Create a directory structure that reflects the module files. For example, you could have a ~/.emacs.d/modules directory where all the module files reside.

- 5. Use Relative Paths: Use relative paths when loading module files to ensure portability across different environments. This will prevent issues when moving your Emacs configuration to another machine.

- 6. Utilize Custom Load Path: You can also define a custom load-path variable to specify the directory where Emacs should look for module files. This allows you to centralize the module files and avoid having to explicitly require each one.


By following these guidelines, you can effectively organize your Emacs resource files into a modular structure, making them easier to manage, maintain, and extend.



I think I've asked this question before, but I'll ask it again just to jog my memory: If I use the M-x package-install command, I would have to repeat that again when starting afresh with Emacs on another computer. Is there a good way to set it into my configuration file, and in that case, what syntax would I use? Is it 'require PACKAGENAME' or something like that?
Yes, you can set the installed packages into your configuration file. This is a good way to ensure that you have the same packages installed on all of your computers. You can use the following syntax to add packages to your configuration file:

Lisp
(require 'PACKAGENAME)

Replace PACKAGENAME with the name of the package you want to install. For example, to install the html-mode package, you would use the following code:

Lisp
(require 'html-mode)

You can also use the following syntax to enable a package after it has been installed:

Lisp
(add-to-list 'load-path "~/.emacs.d/lisp")
(load "PACKAGENAME")

Replace PACKAGENAME with the name of the package you want to enable. For example, to enable the css-mode package, you would use the following code:

Lisp
(add-to-list 'load-path "~/.emacs.d/lisp")
(load "css-mode")

By adding these lines to your configuration file, you can ensure that you have the same packages installed and enabled on all of your computers. This can save you a lot of time and effort, and it can also help to ensure that you are always using the latest versions of the packages.

Here's an example of how to set up your configuration file to install and enable the html-mode and css-mode packages:

Lisp
(add-to-list 'load-path "~/.emacs.d/lisp")
(require 'html-mode)
(add-to-list 'load-path "~/.emacs.d/lisp")
(load "css-mode")

This code will install both packages and enable them for all files you open in Emacs.

I hope this helps!

}}}
Package-Management (Gemini-question) {{{

Could you give me a quick and VERY high-level view of the options for managing packages and such in Emacs. What I mean is, there are some newer such as Alpaca (or something like that), but it would be interesting to get a snapshot, because it's an area where there has hopefully been happening things in the recent past

You're right, package management in Emacs has evolved quite a bit! Here's a very high-level snapshot of the main options, including some of the newer developments:

The Built-in Foundation:

    package.el: This is the package manager that comes bundled with Emacs. It allows you to:
        Browse and install packages from package archives (like MELPA, GNU ELPA, etc.).
        Manage installed packages (list, upgrade, uninstall).
        Configure package archives (add/remove repositories).
        It's the bedrock upon which other package management tools often build.

The Popular Enhancements:

    use-package: While not a package manager itself, use-package is an incredibly popular configuration tool that sits on top of package.el. It allows you to:
        Declare the source, installation, and configuration of a package in a single concise block in your init.el.
        Lazy-load packages to improve startup time (load only when needed).
        Ensure packages are installed (:ensure t).
        Define hooks, keybindings, and modes associated with a package.
        It's the de facto standard for modern Emacs configuration.

The Newer Alternatives/Evolutions:

    straight.el: This is a newer, more advanced package manager that offers:
        Git-based package management: Packages are cloned directly from their Git repositories, giving you more control over versions and the ability to pin specific commits.
        Reproducible builds: Ensures consistent package versions across different machines.
        More fine-grained control over the build process.
        It's gaining popularity among users who want more control and reproducibility.

    package.el Improvements: Even package.el itself has seen improvements over time, although the fundamental workflow remains the same. These improvements often focus on stability and efficiency.

    Declarative Configuration Trends: The general trend in Emacs configuration, influenced by tools like use-package and straight.el, is towards more declarative and reproducible setups. Instead of a long list of imperative commands, you declare the desired state of your packages and Emacs manages it.

In a Nutshell:

    package.el is the built-in workhorse.
    use-package is the most common way to configure packages managed by package.el in a clean and efficient manner.
    straight.el is a more recent, Git-centric alternative package manager for greater control and reproducibility.

Most new Emacs users today are recommended to start with use-package due to its ease of use and organizational benefits. straight.el is often adopted by more experienced users or those with specific needs around version control and reproducibility of their Emacs environment.

Hopefully, this very high-level overview gives you the snapshot you were looking for!

}}}
  = Package|Save Per N - Emacs-inits(+Emacs Compilations)
  - Evil installation
  - noblink cursor
   - Personal (vimlike) Keybindings
  - Slime
___ElispStartwith

Jump between declaration/definition and implementation
  # function, method, class, symbol (and other code elements) ----
-- Emacs
go to Declaration  a-.
go to Implementation  ca-.

__
___Em1+evil/Org
Tip Search: emacs frequency package **[!!]
    c-pageup/c-pagedown
~/Dropbox/rsc/Doks/phone/Comp/lang/lisp/emacs_lispcodemovements-tut.txt
Emacs Markdown Mode  https://www.emacswiki.org/emacs/MarkdownMode
https://github.com/redguardtoo/evil-matchit
inits {{{
    ~/.emacs.d/init.el ~/Dropbox/config/emacs/init.el
      ~/.emacs.d/elpa/evil-20230120.2022/evil-maps.el
    ~/Empire/curr-desktop/emacs-config-master/init.el  #per nordlöw init

    https://gitlab.com/per.nordlow/emacs-config/-/tree/master/lilypond
    https://gitlab.com/-/ide/project/per.nordlow/emacs-config/edit/master/-/lilypond/
}}}
empire dropbox checkable txt ref-lists [**] {{{
~/Dropbox/rsc/data/lists/ref/comp/Emacs-Tocs.txt  #+TODO: START FILLING WITH FUNCTIONS FOR THE NEOVIM LUA API(**** etc)

~/Dropbox/rsc/data/lists/ref/comp/Em1-notes_x2.txt

~/Dropbox/rsc/data/lists/ref/comp/emacs-dired.txt
~/Dropbox/rsc/data/lists/ref/comp/emacsman1.index.txt
~/Dropbox/rsc/data/lists/ref/comp/emacs-mastextend.check.txt
~/Dropbox/rsc/data/lists/ref/comp/emacsrefcard-Long.txt
~/Dropbox/rsc/data/lists/ref/comp/emacsrefcard-org.txt
~/Dropbox/rsc/data/lists/ref/comp/emacsrefcard-shortessential.txt
~/Dropbox/rsc/data/lists/ref/emacs-quicklistcondens.Mast-extendglick-thbot.txt
~/Dropbox/rsc/data/lists/ref/comp/orgman-emacs.index.txt
 ~/Dropbox/rsc/data/lists/ref/OrgmanNotes1-2021.txt
}}}
~/Dropbox/rsc/data/lists/learnqna/vanki/pick.legacy/em-mastext1.txt {{{

  ---- p32
    [ modeline ]  ,,  mini-buffer | echo area
  ---- p35
    cut           copy           paste
    kill    save to kill-ring    yank
  ---- p38
    'faces'             # fonts
    'font locking'
    'font-lock faces'   # set syntax highlight + color theme
  ---- p50
    'key sequence'      # =seq. of keyb/muose actions
    'prefix key'        # eg. c-x
    'complete key'      # =one or more key-seq.s that invoce a command
    'key map'           # eg. c-f, c-x 8  (=prefix w. set of sub-cmds)
      'c-'               ='the c- modifier'   p111
  ---- p54-p55, p53
    interactive commands
    extended command funcionality

  ---- p58 ****
    Check keys in c-x 8--map ; c-x 8 c-h  *******

  ---- p66
    open customize interface ; a-x customize
                                    a-x customize-colors
    a-x list-colors-display
    a-x info-apropos Colors on a TTY
     a-x customize-themes  p71
  ---- p66
    a-x customize subcommands
        = customized, changed, face, group,  mode, saved,  themes

  ---- p68
    Evaluating Elisp Code ***!(!)
        a-x eval-buffer
        a-x eval-region
          --
        ca-x (eval-defun)  +(do) in every defvar/defcustom form
        c-x c-e (eval-last-sexp)
        c-j
        sa-.
        a-x ielm (**)  (+auto-complete ??)
  ---- p70
    Repos + Packages
        (setq package-archives  [+addresses + eval-buffer]
    a-x package-list-packages
    a-x package-install
     a-x package-refresh-contents
    --  p164
    Installing Helm **
        (set elpa + melpa repos), a-x package-install helm Ent, (+restart/refresh) **


  ---- p73  (the 'Help/Man/Info/Describe'-system)
    Open Info ; c-h i
      node navig.   ]  [
                    l  r
      to parent node   u
                       space
      cycle xref /
        / links     tab
      search by name   m
         everyday use-tips for navig.   p74
    Apropos for the info manuals (=will crawl all manual-pages)  p254
                      a-x info-apropos
  ---- p75, p80
    c-h F       doc for cmd (=a function)
     c-h m
    c-h a -word$
               regex-search for cmd (=not function) for words
    Find Info. ab. Version Control **(*)
                   c-h i + emacs(=hyp.link), c-s 'version control' / c-h a ^vc-
     c-h v     variable
    c-h k / c key  (***)
     c-h d      search doc-string
     c-h f vc-dir
    --
    c-h C Ent   coding system in curr. buffer  p89
    c-h s


  ---- p80  some basic commands
    c-x b       switch buffer
    c-x k
    c-x o       (other buffer)
    c-x c-b     list buffers
     c-x c-c
    c-x c-w     save as *
    --
   go to first non-blank
     char. of line **       a-m   p113
   a-g a-g 50            go to line 50
   ---- p251  insert literal character
   insert literal esc char.   c-q Esc
   insert line feed (=not CR)   c-q c-j
   ----
   a-z c  (=zap to char. 'c')
  ---- p206
    character-info (ab. char. at point)   c-u c-x =
   ----
   move / recenter point (=to top / mid / bot) **   p177
      a-r
      c-l
        ca-l
  ---- p56
    a-0  c-0  ca-0   c_-  a_-  ca_-
    kill prev. word from point   a_- a_d
    -- p183
    kill to beg. of line   a-0 c-k
     Kill S-Express.   ca-k
    copy   a-w
    Append-Kill(!!) (+use for
      refactoring)   ca-w
    Tip: Cut three words
      to kill ring **(!)   a-d a-d a-d
                # +can then be pasted
                  as one chunk(!)
  ---- p210
    upcase word bef. point
  ---- p189  transposing
    char.      c-t
    words      a-t
    S-Expr.s *  ca-t
    lines      c-x c-t
     (+paragraphs / sentences)
    [+Emacs ignores some punct.char.s when word-moving(!!)]

  ---- p140  setting mark + switch/jump back
    c-space
    c-space c-space
    c-x c-x
     c-u c-space     = setting marks

  ---- p146  mark units (eg. words, paragraphs)
    a-h      next paragr.
    c-x h    whole buffer
    ca-h **  Next Defun (=function)
    a-@ **   Next Word
    ca-space   =NEXT S-EXPRESSION  (or ca-@)
    --
    Tip: Mark Three Words   a-@ a-@ a-@ // a-2 a-@

  
  ---- p93
    completion of buffer-names (=when buffer-switching)
        = ido/fido  (+Helm, Ivy  etc)     (+c-x o  (??))
          a-x customize-option Ent ido-mode Ent
          a-x customize-option Ent ido-enable-flex-matching Ent
          a-x customize-group ido
          a-x customize-group icomplete

  ---- p100
    saving + returning to past win.config
        winner-mode  + c-c left/right

  ---- p101
    Set/Bind Keyboard Shortcut: a-o = c-x o ****
        (global-set-key (kbd "M-o") 'other-window)

  ---- p105(+), p108
    tab bar mode
     tab line mode
    a-x customize-option tab-line-tabs-function


  ---- p110
    read manpage for readline ; a-x man Ent readline Ent


  ---- p116
    display line/column numbers *
        a-x display-line-numbers-mode
        (etc) (!!(**))
          column-number-mode
          line-number-mode

  ---- p115+(?), p196
    word/line wrapping in em. ; 'truncation' / 'fill column/paragraph'
        a-x toggle-truncate-lines
        --
        a-q
        c-x f 78
    set fill-prefix *(*)
        c-x .   #text up to point =fill prefix (next time using a-q)
    a-x auto-fill-mode
  ---- p198+
    Comment/Uncomment (line)
        a-;
        c-x a-;
        a-x comment-box    #=around region
        --
        a-j ca-j     #new line + comment
            (+some customization-options)

  ---- p123
    ca-f / ca-b         balanced s-expr. back/forw
     ca-k
     ca-n / ca-p        next / prev. balanced s-expr.
    ca-d / ca-u
    ca-u              # to string's opening quote
    a-}
    ca-a / ca-e       # to beg/end of function


  ---- p213
    Count Things
        a-x count-matches
        a-x count-words
        a-x count-words-region  /  a-=
    Del. Duplic. Lines
        a-x delete-duplicate-lines  (+versions with c-u)
    flush/keep
        a-x flush-lines
        a-x keep-lines
  ---- p216
    + blank lines | white-space
        c-o    insert blank line after point  (or split line)
        c-x c-o   del. all blank lines after point
        ca-o   split line after point + keep indentation **(*)
        join point-line w. line above   a-^
      Splitting / Joining with Fill Prefixes   ca-o (with fill prefix active)
        del. all but one space/tab
          left/right of point   a-space
        (+a-x whitespace-mode  , whitespace-report  etc)
  ----
  ---- sorting (!!)  p239


  ---- p136  (for files, dired-dirs, man-pages, org-mode,
                            DocView(=pdf), info man-pages
              [=saved in file in ~/.emacs.d/]
    Bookmarks: Set / List / Jump to *****
        c-x r m
        c-x r l
        c-x r b

  ---- p138  registers
    store point in register + jump back
        c-x r space,  c-x r j
          c-x r s,  c-x r i  #region to reg. + insert content at point


  ---- p149  Isearch (=incremental search)  c-s / c-r
    Recall Last Search     c-s c-s
     Case Folding       a-x customize-option case-fold-search Ent
     a-n / a-p
    TAB-COMPLETE STRING AGAINST
      PREV. ISEARCH-STRING   ca-i  (eg. 'complete-symbol')
    isearch word at point   c-w  #=add word at point to search-string
                            #+times several
                             (etc)
     a-s c    search case sensit.
     a-s r    regex-mode search
      + word-mode
        symbol-mode
        lax whitesp.matching   a-s space
        char.folding (**)
    isearch forw. for symbol at point (*)    a-s .


  ---- p158  Print/Edit lines (in buf.) matching regex (****(*))
    a-s o      occur mode   # a-x occur
    activate occur on curr.
        search-string (=inside isearch)    a-s o  (**(*))
    (+set context-lines)
    Jump to Match    Ent
    go to next / prev. match    a-n / a-p
    Revert occur.buffer / Refresh search-results     g
    Switch occur.buff. to Edit Mode **(*)   e
    --
    To next/prev. occur-match / error
      after a-x compile **(*)    a-g a-n // a-g a-p
    search sever. buf.s with multi-occur (eg. '\.py$' in all py-buffers) **
        a-x multi-occur-in-matching-buffers    p161
        a-x multi-occur
    Tip Using multi-occur (**)   e (for across multip. buf.s)
                                   + combine w. keyb.macros / search/replace
                                   + c-c c-c  (=commit)

  ---- p162
    search functions, class def.s etc (=when programming)
        Imenu    a-x imenu
    (+Tip: bind to a-i  (global-set-key (kbd "M-i") 'imenu) )
    --  Tip: Use Helm for Completion **
            =uses powerful 'filter-when-typing' + uses pow.ful fuzzy-searching **

  ---- p165  Helm
    Helm-Completions Prefix **    c-x c ....
      c-h a ^Helm-              c-x c c-h
    MOST IMPORTANT HELM-COMMANDS  p167
      primary action     Ent  #=jump to open +display candidate
      second.action     c-e
      tert.action       c-j
      switch to action-selector(?)   tab
      next/prev. candidate    c-n / c-p
        to end/beg. complet.list   a-< / sa-<
     --
      Resume last Helm command    c-x c b   p168
      c-x c /
      Complete 'a-x apropos'-results
           c-x c a
        (+MANY (MANY) MORE (**) ....)

  ---- p170  Helm Search vs Ido Search
    Helm
        in-depth search wh. not knowing what to look for
        + if requires addit. context-awareness of similar matches
    Ido
        seamless finding of files/dirs through the mini-buffer
       eg. for finding widgets.c     c-x b wc

  ---- p170  Ido/Fido 2(!!)
    set ido mode (=in init)
        (ido-mode 1)
        (setq ido-everywhere t)
        (setq ido-enable-flex-matching t)
    Ido shortcuts (etc)
        c-s / c-r
      tab
      Ent
      c-d        open a-x dired-buf in curr. buf
       //  go to root dir
       ~/  go to home dir

  ---- p173  using grep (from inside emacs)
    a-x grep  /  a-x grep-find
    lgrep  /  rgrep  /  rzgrep    #+highlighting
    Recursive grep-search for
      Symbol point is on ***    a-x rgrep Ent Ent
    (find + don't search cert. directories)
    jump to next/prev. match
      in emacs grep **    a-g a-n / a-g a-p
            (+using grep-mode (=major mode))

  
  ---- p201   Regex Search & Replace (**!)
    ca-%
      (+ space  .  !     ^  u U )
    ca-% hello  (+Case Folding (**))  p202
    give string for search & replace    a-%


  ---- KEYBOARD MACROS ******* p221
    record / stop recording    c-x (  /  c-x )
                               f3
    play last macro    c-x e
                       f4
    stop rec. macro    c-g
    stop rec. macro + play it   f4
    --
    Append-Record Macro (=to last)   c-u f3
    Play sec. to Last Macro   c-u f4
      set counter + rec. macro  c-3 f3
    play last macro 5 times   c-5 f4
    --
    Run Macro Until Done / Fails on Error   c-0 f4
     group of advanced cmds for macros **   the c-x c-k map
                                       (the map is called 'kmacro')
            *****  p223,p224
       (Query for user input--actions)
    cycle macro ring
    name last macro
    bind last macro to a key
    Edit Last Macro    c-x c-k e   p226

    Edit Lossage (=last 300 key-strokes)   c-x c-k l   p226
    INSERT MACRO (INTO BUFFER) AS ELISP   a-x insert-kbd-macro
    Save Macro to a File (=the init-file)
      - name macro
      - open init
      - insert macro as lisp
   create macro (+see what each entry in
    the macro string corresponds to (as a command))  a-x kmacro-edit-lossage
  TIP: EXTRACT MACRO FROM LAST 300 ACTIONS
    - print the lossage buffer (c-x c-k l)
    - edit (as though it were text)
    - commit the changes  c-c c-c

  ---- Abbrev. Expansion  (=Hippie Expand (+snip, hip, abbrev))
    c-x a:
      .
    a-\  ca-\

  ---- electric-indent-mode / 'interactive indentation mode'

  ---- Aligning  p242

  ---- aspell / ispell
  ---- Flycheck (+syntax check(!))

  ---- Xref (!)  p264
    a-.   find def. at point
    a-,   'pop marker and return'
      +Dumb Jump / RipGrep
    xref + dired: search/search+replace xrefs via dired **   A / Q
      .
    (highlight + updating)

  ---- Filter with Terminal (!!)
    a-!
    a-&    # filter asynchronously
            ((+may not be good for long-running processes
              =use a-x compile instead))
    --
    a-|    # filter + reinsert region(!!)

  ---- Compile / Recompile (**)  p294
    a-x compile
    a-x recompile
      a-g a-n / a-g a-p
    re-run last command  g  ***
    compile in the current project   c-x p c

  ---- emacs shells (=x3)  p295

  ---- VERSION CONTROL (**(!))  p253
    - c-h i
    - go to 'emacs' hyperlink
    - c-s (=search) + 'version' / 'version control'  (+c-s for next)
      --
    - find 'vc-' via docstring  //  c-h a ^vc- (=list all instances)
    -- -- p257
      c-x v +    vc-update
      c-x v =    vc-diff
      c-x v D    vc-root-diff
      c-x v G    vc-ignore
      c-x v I    vc-log-incoming
      c-x v L    vc-print-root-log
      c-x v O    vc-log-outgoing
      c-x v a    vc-update-change-log
      c-x v b    vc-switch-backend
  ---- Magit  p304 , p261,p262
  ---- Project Management (projectile, +newer Cedet(em 27+) (=based fr. version control)
  ---- DokView
  ---- nov  (=epub reader emacs)
    https://depp.brause.cc/nov.el/
  ---- presentation (mode)
    https://www.emacswiki.org/emacs/EmacsPresentation
      https://www.youtube.com/watch?v=vz9aLmxYJB0
        https://www.youtube.com/watch?v=1-dUkyn_fZA
  ---- Eww  p280
    a-x eww
    create new eww-buffer (if does not alr. exist)  c-u a-x eww
    a-x browse-url
    --
    +Browsing Keys (****(!))  p281
  ---- Dired (+ cross dir(ectories))  p282
    a-x dired
    c-d (=from ido wh. browsing when browsing w. c-x c-f etc)
      customize dired-listing-switches
    up one dir   ^
    n/p  c-n / c-p
    mark/unmark active  m/u
    unmark ev.thing   U
     flag for deletion   d
    [sign by marked files  '*']
      Exploring more   explore like before // M.Petersons 'Discover' package
    -- dired operations (=on marked or active objects)
      copy         C
      move/rename  R
      chown        O
      chgrp        G
      chmod(=perm.s)  M
      delete marked   D
      delete flagged  x
      visit files (=requires dired-x)  F | c-u F (p289)
      compress marked to a (zip) file        c
    -- more dired commands (=not marked files)
      refresh dired buffer  g
      create sub-dir        +
      toggle sorting by name/date   s
      jump to prev/next dir         < // >
      jump to file                j
      --
         #'g is the universal refresh key'
    -- search/replace in dired-files
      begin isearch       a-s a c-s
      xref search|replace regex(!!)        A||Q
      synchr./asynchr. shell command ***   !/&
    -- 'working across directories / collapse subdir.s'
      i  $
        +tip: find_wrapper-commands (replacing find + xargs)  p291-
         + find-lisp-find-dired
  ---- Tramp  p278(??)
    bookmark remote files   c-x r m



  ---- Hydra

}}}
Emacs (quicklists super-condensed**** 2021-03  (Mastering, +extending(='glickstein',)  ('+thoughtbot-elisp'(???)) ) {{{

            ~/legacy/gdrive-cleanlast-2021/transcribe_phonenotes_Emacs-Fmoviebox-AlltodoscriptNamingscheme/emacs1/curr/

    ~/gdrive/Doks/Emacs1.pdf

Marked (=Blue) Headers/Topics (***(!!)) -- -- -- -- -- {{{

  c-u 0  a-0  c-0  ca-0  (+neg.)
  CUSTOMIZE   +apply.save
  Eval. Elisp **  (+ielm (!!))
  Repos: =elpa, melpa  **
  more help|docs (**)  ++(=later)
  * Open File, Save, Buf.s (+switch), close
  * Save As, Save All, c-x b, c-x c-b
  CUSTOMIZE KEYS !!! (=bind)
  a-x python-mode
  (restructured text-mode (!!))
  sexpr         ca-f / b    ca-d / u   ca-k (??)
  c-u c-space  ;  jump back to mark  (+more =moves back in mark-ring)
  Bookmark tips (*) + !
  (registers (=point, numbers, text)
  [DIFFERENT RINGS]
  sexpr         ca-space
  Isearch     c-s / c-r
  Occur (=print/edit lines matching regex) **
  (e **!  + c-c c-c  =commit)
  multi buf.s + multi-occur(?)(=for multi-buf)
  Helm **
  imenu  (+search functions, class-def.s etc when programming(??)  + a-i (=bind))
  Helm <--> Ido:
  grep (**)  find w. em.grep  ='neg. dir-matches' ('*' (=??))
  a-r (goal column(?))  c-l  ca-l
  55 a-g a-g  (=line(!))
  =for refactoring etc (=picking fr. diff. places etc) (**!)
  a-d, a-d osv  **!  [+cases for building vs killing]
  Transpose
  line wrap = 'fill'
  comment     a-;
  S & Repl.
  Regex:  \|  \( |)  etc
  Upcase etc
  Count Matches
  Delete duplic. lines (+only adjac.)  etc
  Remove / Keep Flush
  ----
  insert blank line ; c-o
  c-x c-o
  ca-o
  a-^
  Split/Join (+Fill Prefixes)(*)
  m-space   Cycle-spacing  (wh.sp. mode  wh.sp.report)
  Macros (+why are macros so good) **
  Abbreviations:
  indent
  Sort
  zapping   a-z
  aspell, ispell
  flyspell mode (*)
  Version Control ; c-x v (+c-h)
  (Projectile +) Cedet  *!
  Xref   a-.
  tip: list lines matching patt = can be narrowed further w. occur *
  Highlighting
  Bookmarking remote Files ***
  Dired **(!)
  (Em.s find-wrapper cmd.s
  Call shell cmd     a-!
  a-x compile
  Magit **    p304
  LSP mode / EGlot

}}}

extended topics-list (=including Blue Headers) -- -- --

      evince -p 1 ~/gdrive/Doks/Emacs1.pdf &

    dumb jump
    rip
    svg, xpm etc (??=im)
    [perh. modeline etc]
    init.el (xdg)  [a-x + customize]
    'the extended cmd-functionality' (+interactive)
      region
      'font-locking', 'faces',   'font-lock faces'
      -q
        ((client-server))
      'key-sequence', 'complete key', 'prefix key'
      'key-maps'
    -----
    c-x #       f10 (??)
      'the c-modifyer'
      'truncation' (+filling / wrapping(??))
    ----
    a_- a-d  ;  upcase last word
  c-u 0  a-0  c-0  ca-0  (+neg.)
    ----
     (eg. c-x 8) c-h  ****
    info-apropos
    INFO NAVIG.-CMD.S * ( ']' etc)
    (INFO AB. VERSION CONTROL)
    [ a-x apropos Ent. hook
    Hippie Expand
  CUSTOMIZE   +apply.save
    [groups = packages]
    +"sub-commands"(*!)
    a-x customize-themes
    customize-option Ent global-....
    customize-group Ent display-line-numbers
      [[set Ido mode]]
      set FIDO (etc) via Customize
        FIDO, Helm, ivy, Selectrum, icicles,
          Icomplete
    +extra compl. options
  Eval. Elisp **  (+ielm (!!))
    (=  ca-x  c-x c-e  etc)
    a-:  c-u c-x c-e // c-j     #glickstein
    + Esc-Tab  (=completion ??)
            lisp interact. mode
  Repos: =elpa, melpa  **
    packages  = : list, install, (refresh)
     [install Helm]
    ----
    (eg. c-x 8) c-h  ****
  more help|docs (**)  ++(=later)
    c-h F
    c-h a  word-regex ^helm-
            (=package name as prefix)
    manual info  Describe
    [c-h b   =list key-bindings
         m
         f
         v
          d  (=apropos-search in docstrings)
                ( +'*'  =  [  )
     c-h k / c
    +Check maj.modes menus (*)
     c-h i m Emacs (++)
     c-u a-x apropos  (??  =glickst.)
     c-h s  =syntax table (for maj.mode etc)

    local / regional / global  movements
  * Open File, Save, Buf.s (+switch), close
            ('progr.loader directives')
          file local var.s
  * Save As, Save All, c-x b, c-x c-b
    'transient buffers'

      evince -p 2 ~/gdrive/Doks/Emacs1.pdf &

  CUSTOMIZE KEYS !!! (=bind)
    (MAPPING KEYS--SYNTAX) +Glickst. **
     +Glickstein **
    Check key for binding  -describe key  (**)

    WinCmds     tab-bar
    - tab-line
    - Only cycling w. same maj.mode **(!!)

    read manpage
    ----
    "10 c-n"
    a-m ......
      (line num.)
          ----
    a-f / a-b  (+concerning m.(inor?/ajor) modes)
  a-x python-mode
    subword-mode // superword-mode
            (glasses-mode)
  (restructured text-mode (!!))
    a-x text-mode
    ----
    ----
        (objects + movement)
  sexpr         ca-f / b    ca-d / u   ca-k (??)
    defun
    strings         ca-n / p
    sentence    a-a / e
    funct.      ca-a / e
    (page)
    paragraph
    buf
    word
  c-u c-space  ;  jump back to mark  (+more =moves back in mark-ring)
    jump betw. two marks  ;  c-x c-x

  Bookmark tips (*) + !
    + the bookmark file
    (bookmark-default-file)  + custom handlers
      =files, dirs, manual (**)
    c-x r m   (=set(??) bookmark)
          r
          b

  (registers (=point, numbers, text)
        c-x r
    c-x r space  c-x r j

  [DIFFERENT RINGS]
    (=mark ring, global mark ring, (etc))
  
    (objects: set mark for | mark)
  sexpr         ca-space
    defun       (or  a-@)
    strings
    sentence
    funct.
    (page)      c-x c-p
    paragraph   a-h
    buf         c-x h
    word        a-@
    --
    a-@, a-@ osv *** / (a-2 a-@)


      evince -p 3 ~/gdrive/Doks/Emacs1.pdf &


  Isearch     c-s / c-r
    " regex     ca-s / ca-r
    recall last search  ;  c-s c-s
      change direction
      start fr. beg. (again)
      Case insens. + Case Folding
    tab-complete against prev. search  ;  ca-i **(!!)
    a-n / a-p
    c-w *  ca-y  c-s c-e  *
      c-y
    add sever. words  ;  c-w, c-w, ....  (**)
    modes: a-s   c r w - space ' .
  Occur (=print/edit lines matching regex) **
    [a-x occur // a-s o  (+inside isearch) ]
      lmb / ent
      a-n / p
      < / >
        g [=refresh buffer *]
    next/prev. match in occur / after a-x compile  ;  a-g  a-n / a-p
    context-lines
        -- --
  (e **!  + c-c c-c  =commit)
  multi buf.s + multi-occur(?)(=for multi-buf)
    *** keyb. macros // search & replace
  Helm **
    find Helm-cmds w. apropos ; c-h a ^helm-
    c-x c  + c-h
     Helm <--> imenu ; fuzzy + filter directly <--> tab-style completion (!)
  imenu  (+search functions, class-def.s etc when programming(??)  + a-i (=bind))
    helm-apropos (**)
    MOST IMPORTANT HELM COMMANDS
    Ent  c-e  c-j  **   tab (etc)
    c-x c b (resume last)
    Complete a-x apropos w. Helm ; c-x c a  c-x c m
     c-x c i
           r
     c-x c h r          a-x info
             a-x
             a-s o      Occur (*(*))
             c-c g      google suggest
  Helm <--> Ido:
     - indepth (+more context)  - not knowing exactly wh. looking for  <-->  - seamless finding of files|dirs through minibuffer (eg. c-x b wc (=for 'widgets.c')
    (Set Ido mode)


      evince -p 4 ~/gdrive/Doks/Emacs1.pdf &


    +=Ido:  c-s/r  tab  c-d *   '//' '~/'  (+extra info)

  grep (**)  find w. em.grep  ='neg. dir-matches' ('*' (=??))
    a-g  a-n / a-p
    grep-mode (**)

  a-r (goal column(?))  c-l  ca-l
  55 a-g a-g  (=line(!))
    ((a-g tab))
    a-g c


     a-d  (c-bs)
     a-0 c-k
      a-k
      ca-k
     cs-bs  #kill current line
    --
    c-w   kill active region
    a-w
    ca-w
  =for refactoring etc (=picking fr. diff. places etc) (**!)
    a-y
    --
  a-d, a-d osv  **!  [+cases for building vs killing]
    ----
  Transpose
    char
    word        a-t
      + p192(??) =For Source Code (!!)
    sexpr       ca-t
    lines       c-x c-t
    paragr.
    sentence
  line wrap = 'fill'
    a-q
      c-x f
    c-u a-q
     c-x .   #fill-prefix *
    empty line + c-x ..
    autofill-mode
    ----
  comment     a-;
    c-x a-;
    comment-box
    a-j ca-j
     +Options (=customize)
    ----
  S & Repl.
    ca-%    #+can be run fr. w.in isearch
    +space (??)
     .
     ,
     Ent
     !          replace all
     ^          back to prev. match
     u / U      undo last / all(!) replaces
    Replace 'Hello' 'HEllo' 'hello'  etc
     (=uses case folding *) !!
  Regex:  \|  \( |)  etc
    [0-9]  #no \d or [:digit:]
     \<
    \_<  beg. of Symbol (**)
    \scode \Scode  (??)



      evince -p 5 ~/gdrive/Doks/Emacs1.pdf &



    regex SYNTAX CLASSES **!
    wh.sp.
    word constituents
    symbol constituents
    punct. char.s
    brackets
    string char.s
    comments
    ----
    show char. info (=blue highl.)  c-u c-x =
    \#1
    \#  increm. num.
    \?  prompt user
    \&
     \,(form ...)   eg. (upcase)  (**!)
    tip: Use keyb.macros most of the time (**)
    ----
    \`  \´      glickstein
    \=
    \b
    ----
  Upcase etc
    c-x c-u
    a-u
    UPCASE LAST WORD *
    ---
      Unicode  a-x describe  categories (??)
    ----
  Count Matches
  Delete duplic. lines (+only adjac.)  etc
  Remove / Keep Flush
  ----
  insert blank line ; c-o
  c-x c-o
  ca-o
  a-^
  Split/Join (+Fill Prefixes)(*)
  m-space   Cycle-spacing  (wh.sp. mode  wh.sp.report)


  Macros (+why are macros so good) **
    c-x (    f3 | f4
        +num.
    Append to last
        play sec. to last
    play 3 times
    Run until fails
     c-x c-k (=map)(!!)
    Counters
     Query for user input
    Recursive Editing
     ----
    Cycle  Name  Bind
      Edit last Macro ** ; c-x c-k e
    Edit Last 300 Keystrokes (='lossage')
    [INSERT MACROS AS ELISP **!!]
    Save Macro to init-file **!!
    [- Create macro (from lossage?) +
     Inspect the String's Corresp. Commands (!!)

    EXTRACT MACRO FR. LAST 300 ACTIONS (=if forgot to record) *



      evince -p 6 ~/gdrive/Doks/Emacs1.pdf &



  Abbreviations:
    Hippie(!!) expand   a-/     , skeletons, 
    YASnippet, Autoinsert
     --
    electric-indent-mode
    ---
  indent
    indent-tabs-mode
     tab (etc)
    num + indent
    c-x tab  =interactive indent-mode
    ---
  Sort
    sort-regexp-fields
    ----
    Aligning etc (=based on regex) 'sections'
    tip: Align py on '='
      (=em.s autom. alignm. tools)
    Regex Align Complex Mode (**)
    ----
  zapping   a-z
    ----
  aspell, ispell
    a-$   word at point
  flyspell mode (*)
        +for linting (*!(!))
     for Latex etc (=customize)
     +custom dict.s
    --
    c-q tab  =literal tab
    c-q c-j
  Version Control ; c-x v (+c-h)
    vc-update (etc)
      c-h f vc-dir (??)
  (Projectile +) Cedet  *!
    c-x p
  Xref   a-.
    pop marker   a-,
    classic tags files (=for larger proj.s)
    dumb-jump
    regex  a-? / ca-.   + searchres. cmds *
    [jump to def. for symb. under point
                dumb-jump + ripgrep (??)
    Xref + Dired  + S&R
      =A / Q
    --
    a-s o  (+flush/keep)
    ----
  tip: list lines matching patt = can be narrowed further w. occur *
  Highlighting
    ((autorevert-mode))



      evince -p 7 ~/gdrive/Doks/Emacs1.pdf &



    image-dired * **
    image-mode
    ----
    DocView  (+pdf-tools | org-pdftools) *   +options
      =pdf, Msoffice etc
      Reading List  - links format
      org-store link
      - store clip link
      annot.s (**)
      - search
      --
    Epub nov
    ----
    Presentation-mode
    ----
    tramp  (+autoparses ssh)
      ((invoke fr. root))
      helm-tramp
      rgrep
      multi-hops
    +sudo multihop
    ----
  Bookmarking remote Files ***
    ----
    Browser   EWW
      a-x eww
      a-x browse-url
      Browsing Keys   = b.m
        hist
        copy link
    ----
  Dired **(!)
    ^           m / u  U d
    ('*')       M.Petersons 'Discover-Package'
      +Extras(!)
    C   M
    R   D
    O   x(!!)
    G       visit
    (+more for not(!) marked)
    +(require 'dired-x)
    ----
    S&R in Dired-Files **
    ----
    collapse subdirs etc
    ----
  (Em.s find-wrapper cmd.s
    =replace find + xargs  (find-lisp-find-dired)
    ----
  Call shell cmd     a-!
    -- " --  +insert outp.    c-u a-!
     --
    -- " --  asynchr. + print    a-&    #or a-x compile
    -- " " " --    + insert    c-u a-&

    Pipe Region to Shell cmd *    a-|
    -- " --  +replace region    c-u a-|
    -----
  a-x compile
    // recompile
    - rerun last cmd
    - compile in the curr. proj. (**)



      evince -p 8 ~/gdrive/Doks/Emacs1.pdf &



    shell
    eshell
    ansi-term
     proced  + readline  (etc.)
    ----
  Magit **    p304
    ----
    multi cursors  (**)
  LSP mode / EGlot
    ----
    Build popup UI:s ; Hydra
    ----
    - +links to some blogs and resources
    ======
        Glickstein
    Define (+bind?) 'other-window-backward'

    parametrizing interactive (p, b,    optional
    ----
    nil (/t)   #+more
    if
    (some prop(ertie?)s of nil)

    CONDENSING CODE
    or
    common use of if
    and
     when

    defalias
     hook * (=like aucmds(?))
    predicates
    progn
     lambda f.s
    local vars = let
    yes-or-nop
     format
     Advice code =code attached to a lisp function
    
     (+macros)
    null <--> not (=one is an alias)
    defvar ((=shared var.s))
     eq
    "read inwards"
    Symbols (+put/get)
    (set-marker)
     while

    --
    "return last expr."    &rest
    defgroup
    dufcustom
    cons|setq
    load-file
    load-library
    autoload
    require
    provide
    inferring

    --
    a-x byte-compile
    eval after load
    eval
     ---
     lists
    cons
    reverse
    +Useful Functions
    setcar|setcdr
    "CAN BUILD ANY(!!) STRUCTS W. LISTS!"


}}}

Doks/Resources/searches {{{
http://xahlee.info/emacs/emacs/modernization.html

  https://www.youtube.com/watch?v=_14E7pDJJ_w  #my emacs workflow (as a software engineer and student)
Javascript: js-mode   https://www.emacswiki.org/emacs/JavaScriptMode

  ~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/
~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/Elisp-IntroTo.txt
  https://www.emacswiki.org/emacs/EmacsCommonLisp

  https://www.codementor.io/emacs-experts
https://www.markus-gattol.name/ws/emacs_notes_cheat_sheets.html#sec8

Good emacs init file structure
    https://emacs.stackexchange.com/questions/2520/organize-the-content-of-emacs-d-init-el-and-emacs-d  __ __ __ EMACS INIT.EL ORGANIZE *******
    https://www.emacswiki.org/emacs/DotEmacsStructuring

    https://jack-kelly.com/setting_up_emacs_for_python_development __ __ __  PYTHON EMACS

.. emacs pdf refcards {{{
    ~/Empire/Doks/Comp/emacs/emacs-refcard_long--HIGHLIGHTS_2021.pdf
    ~/Empire/Doks/Comp/emacs/emacs-refcard_long.pdf
    ----
     ~/Empire/Doks/Comp/emacs/emacsrefcard26_survival.pdf
    ~/Empire/Doks/Comp/emacs/emacsrefcard02.pdf  #very short (2p)
            ~/Empire/Doks/Comp/emacs/emacsrefcard01.pdf
            ~/Empire/Doks/Comp/emacs/emacsrefcard04.pdf
    ~/Empire/Doks/Comp/emacs/emacsrefcard03.pdf  #6p
    --
    ~/Empire/Doks/Comp/emacs/emacsrefcard26_dired.pdf
            ~/Empire/Doks/Comp/emacs/emacsrefcard26_calc.pdf
     ~/Empire/Doks/Comp/emacs/emacsrefcard26_org.pdf
    ~/Empire/Doks/Comp/emacs/emacsrefcard_org01.pdf
 }}}

emacs lsp {{{
    emacs lsp-mode
    https://emacs-lsp.github.io/lsp-mode/

    https://emacs-lsp.github.io/lsp-mode/tutorials/CPP-guide/
    emacs lsp tutorial
}}}

    systemcrafters (=videos) {{{

    Now playing
    System Crafters Live! - I'm Switching to FreeBSD
    2.9K viewsStreamed 1 day ago
    37:33

    Now playing
    System Crafters Live! - Writing Tools with Transient in Emacs (Part 4)
    1.5K viewsStreamed 2 weeks ago
    44:20

    Now playing
    System Crafters Live! - Writing Tools with Transient in Emacs (Part 3)
    1.4K viewsStreamed 2 weeks ago
    15:06

    Now playing
    System Crafters Live! - Writing Tools with Transient in Emacs (Part 2)
    1K viewsStreamed 2 weeks ago
    10:52

    Now playing
    System Crafters Live! - Writing Tools with Transient in Emacs
    1.5K viewsStreamed 2 weeks ago
    1:48:58

    Now playing
    System Crafters Live! - Reviewing Rational Emacs PRs
    1.6K viewsStreamed 3 weeks ago
    1:47:52

    Now playing
    System Crafters Live! - Trying New Emacs Packages by Minad
    3.6K viewsStreamed 1 month ago
    15:41

    Now playing
    The 6 Emacs Settings Every User Should Consider
    10K views1 month ago
    1:57:16

    Now playing
    System Crafters Live! - Live Crafting: Rational Emacs
    2.8K viewsStreamed 1 month ago
    1:54:29

    Now playing
    System Crafters Live! - Rational Emacs: A New Base Configuration
    5.8K viewsStreamed 1 month ago
    1:54:52

    Now playing
    System Crafters Live! - Configuring Emacs With Only the UI?
    2.9K viewsStreamed 1 month ago
    24:12

    Now playing
    The Basics of Emacs Configuration
    12K views2 months ago
    1:58:13

    Now playing
    System Crafters Live! - Planning the New Emacs From Scratch
    4.3K viewsStreamed 2 months ago
    1:07:27

    Now playing
    System Crafters Live! - Building the World's WORST Emacs Configuration (Part 2)
    1.6K viewsStreamed 2 months ago
    48:02

    Now playing
    System Crafters Live! - Building the World's WORST Emacs Configuration
    2K viewsStreamed 2 months ago
    1:50:59

    Now playing
    System Crafters Live! - Why Geeks Don't Use Guix
    4.6K viewsStreamed 2 months ago
    34:33

    Now playing
    5 Reasons to Try Guix in 2022
    53K views2 months ago
    2:02:43

    Now playing
    System Crafters Live - The Best of 2021!
    2.2K viewsStreamed 3 months ago
    2:07:39

    Now playing
    System Crafters Live! - The Hidden Value of Emacs' Tab Bar
    4K viewsStreamed 3 months ago
    55:03

    Now playing
    System Crafters Live! - Community Chat and Config Hacking (Part 2)
    1.1K viewsStreamed 3 months ago
    55:43

    Now playing
    System Crafters Live! - Community Chat and Config Hacking
    1.2K viewsStreamed 3 months ago
    2:02:24

    Now playing
    System Crafters Live! - Can StumpWM Replace EXWM?
    4.5K viewsStreamed 3 months ago
    1:59:11

    Now playing
    System Crafters Live - I'm Rewriting My Configuration... Again
    4.3K viewsStreamed 4 months ago
    1:55:46

    Now playing
    System Crafters Live! - Tools for Building a Lisp-Focused System
    4.6K viewsStreamed 4 months ago
    1:57:30

    Now playing
    System Crafters Live! - Editor Popularity: Does It Matter?
    2.5K viewsStreamed 4 months ago
    1:55:02

    Now playing
    System Crafters Live! - Catching Up With Emacs
    4.2K viewsStreamed 4 months ago
    1:56:43

    Now playing
    System Crafters Live! - The Many Uses of Embark
    5.4K viewsStreamed 5 months ago
    31:40

    Now playing
    Automated Org Mode Website Publishing with GitHub or SourceHut
    4.2K views5 months ago
    1:52:25

    Now playing
    System Crafters Live! - Comparing Project.el to Projectile
    3K viewsStreamed 5 months ago
    1:58:56

    Now playing
    Sharing Your Configuration with Guix Home - Hack Sessions
    1.6K viewsStreamed 5 months ago
    1:56:14

    Now playing
    System Crafters Live! - A First Look at Guix Home
    4K viewsStreamed 6 months ago
    43:29

    Now playing
    "Inverse Literate" Emacs Configurations (Part 2) - Hack Sessions
    952 viewsStreamed 6 months ago
    1:09:55

    Now playing
    "Inverse Literate" Emacs Configurations - Hack Sessions
    2.5K viewsStreamed 6 months ago
    30:40

    Now playing
    Build Your Website with Org Mode
    10K views6 months ago
    2:08:23

    Now playing
    System Crafters Live! - Investigating use-package Alternatives
    2.2K viewsStreamed 6 months ago
    16:34

    Now playing
    Give Your Dotfiles a Home with GNU Stow
    8.3K views6 months ago
    1:07:42

    Now playing
    System Crafters Live! - The Many Varieties of Emacs (Part 2)
    1.5K viewsStreamed 6 months ago
    48:27

    Now playing
    System Crafters Live! - The Many Varieties of Emacs
    2.5K viewsStreamed 6 months ago
    1:53:47

    Now playing
    Improving EXWM #3 // Hack Sessions
    1.5K viewsStreamed 6 months ago
    29:45

    Now playing
    5 Org Roam Hacks for Better Productivity in Emacs
    13K views6 months ago
    2:08:13

    Now playing
    System Crafters Live! - Integrating Nushell with Emacs
    3.2K viewsStreamed 6 months ago
    2:00:56

    Now playing
    System Crafters Live! - Emacs Package Potluck: The Sequel
    1.9K viewsStreamed 6 months ago
    2:01:07

    Now playing
    Improving EXWM #2 // Hack Sessions
    1.6K viewsStreamed 6 months ago
    25:45

    Now playing
    Fix Your Git Commits Like a Rebase Expert with Magit
    4.9K views6 months ago
    1:57:52

    Now playing
    System Crafters Live! - Exploring the Org Roam DB API
    2.8K viewsStreamed 6 months ago
    2:00:26

    Now playing
    Improving EXWM #1 // Hack Sessions
    2.9K viewsStreamed 7 months ago
    2:04:54

    Now playing
    System Crafters Live! - We Need to Talk About EXWM
    3.6K viewsStreamed 7 months ago
    16:50

    Now playing
    Org Roam: The Best Way to Keep a Journal in Emacs
    18K views7 months ago
    2:09:11

    Now playing
    System Crafters Live! - Can We Fix a Bug in Emacs?
    2.1K viewsStreamed 7 months ago
    2:02:23

    Now playing
    System Crafters Live! - Emacs Package Potluck (Trying Your Suggestions!)
    3K viewsStreamed 7 months ago
    31:06

    Now playing
    Capturing Notes Efficiently in Emacs with Org Roam
    19K views7 months ago
    1:59:04

    Now playing
    System Crafters Live! - Can You Apply Zettelkasten in Emacs?
    7K viewsStreamed 7 months ago

    Now playing
    Emacs Has a Built-in Pomodoro Timer?? #Shorts
    15K views8 months ago
    2:00:53

    Now playing
    System Crafters Live! - The Future of System Crafters
    2.5K viewsStreamed 8 months ago
    34:19

    Now playing
    Getting Started with Org Roam - Build a Second Brain in Emacs
    58K views8 months ago
    1:57:15

    Now playing
    System Crafters Live! - Is Emacs intimidating for beginners?
    3.5K viewsStreamed 8 months ago
    28:31

    Now playing
    Declutter Your Buffer Lists in Emacs with Perspective.el
    8.2K views8 months ago
    1:58:00

    Now playing
    System Crafters Live! - Do we really need use-package in Emacs?
    3.1K viewsStreamed 8 months ago
    56:39

    Now playing
    9 Techniques to Boost Your Git Workflow with Magit
    8.6K views8 months ago
    42:48

    Now playing
    straight.el: Advanced Emacs Package Management
    7K views9 months ago
    32:51

    Now playing
    An Introduction to the Ultimate Git Interface, Magit!
    15K views9 months ago
    2:00:39

    Now playing
    System Crafters Live! - Text Adventuring in Emacs
    2.3K viewsStreamed 9 months ago
    1:55:27

    Now playing
    System Crafters Live! - So you've installed GNU Guix, now what?
    3K viewsStreamed 9 months ago
    51:36

    Now playing
    Installing Guix as a Complete GNU/Linux System
    14K views9 months ago
    2:07:38

    Now playing
    System Crafters Live! - The Challenges of System Crafting
    2.3K viewsStreamed 9 months ago
    2:01:56

    Now playing
    System Crafters Live! - Improving the IRC Experience in ERC
    1.5K viewsStreamed 9 months ago
    24:49

    Now playing
    Chat Like the 90's in Emacs with ERC
    4.9K views10 months ago
    2:11:12

    Now playing
    System Crafters Live! - Taking a look at Magit 3.0 • Streaming with Emacs Lisp
    3K viewsStreamed 10 months ago
    25:37

    Now playing
    Doom Emacs or Spacemacs? Use both with Chemacs2!
    7.9K views10 months ago
    1:59:18

    Now playing
    System Crafters Live! - Replacing Ivy and Counsel with Vertico and Consult
    5.5K viewsStreamed 10 months ago
    18:55

    Now playing
    Streamline Your Emacs Completions with Vertico
    13K views10 months ago
    1:59:37

    Now playing
    System Crafters Live! - Building lsp-mode configurations • Emacs News
    2.7K viewsStreamed 10 months ago
    Using Package Channels in GNU Guix - Craft Your System with Guix #4
    2.8K views10 months ago
    System Crafters Live! - Should you use pre-made Emacs configs? • Emacs News
    2.2K viewsStreamed 10 months ago
    Everyday Package Management with GNU Guix
    5.3K views10 months ago
    System Crafters Live! - Trying New Emacs Packages: Vertico and Corfu • Emacs Lisp Hacking • Q&A
    3.7K viewsStreamed 11 months ago
    28:34

    Now playing
    Efficient Text Selection with Emacs Key Bindings - Emacs Essentials #3
    6.6K views11 months ago
    2:19:50

    Now playing
    System Crafters Live! - Lisp Compiler Progress • Live Lisp Hacking • Q&A
    2.1K viewsStreamed 11 months ago
    2:02:40

    Now playing
    System Crafters Live! - I'm creating a new Lisp • Emacs News • Q&A
    3.3K viewsStreamed 11 months ago
    50:20

    Now playing
    Creating Custom Minor Modes - Learning Emacs Lisp #7
    3.3K views11 months ago
    2:06:24

    Now playing
    System Crafters Live! - Ranking the Open Source Licenses • Live Hacking: Guile Scheme • Q&A
    1.9K viewsStreamed 11 months ago
    44:59

    Now playing
    Installing the GNU Guix Package Manager - Craft Your System with GNU Guix #2
    6.8K views11 months ago
    2:06:57

    Now playing
    System Crafters Live! - Dotfile Detective: tecosaur • Emacs News • Q&A
    2.5K viewsStreamed 1 year ago
    36:22

    Now playing
    Efficient Movement with Emacs Key Bindings - Emacs Essentials #2
    8.1K views1 year ago
    2:03:29

    Now playing
    System Crafters Live! - Gemini: The Hackers' Web • Dotfile Detective • Q&A
    2.4K viewsStreamed 1 year ago
    1:22:52

    Now playing
    Managing Files and Directories in Practice - Learning Emacs Lisp #6
    3.9K views1 year ago
    2:05:29

    Now playing
    System Crafters Live! - Static Websites with Emacs, Org Mode, and Sourcehut • Episode planning • Q&A
    2.9K viewsStreamed 1 year ago
    51:50

    Now playing
    An Introduction to GNU Guix
    24K views1 year ago
    1:55:46

    Now playing
    System Crafters Live! - What is GNU? • Is Sourcehut the future? • Q&A
    2.9K viewsStreamed 1 year ago
    1:11:56

    Now playing
    The Absolute Beginner's Guide to Emacs
    99K views1 year ago
    2:02:09

    Now playing
    System Crafters Live! - Emacs Native Comp will change *everything* • Trying out Eglot • Q&A
    8.8K viewsStreamed 1 year ago
    1:03:07

    Now playing
    Reading and Writing Buffers in Practice - Learning Emacs Lisp #5
    5.8K views1 year ago
    2:01:52

    Now playing
    System Crafters Live! - Should you do everything in Emacs? • Becoming a Lisp Ninja • Q&A
    3.4K viewsStreamed 1 year ago
    1:55:06

    Now playing
    System Crafters Live! - Is Lisp a dead language? • Emacs Lisp Hacking • Q&A
    3.7K viewsStreamed 1 year ago
    44:58

    Now playing
    Hey Emacs, Don't Move My Windows! - Customizing display-buffer's behavior
    5.6K views1 year ago
    58:14

    Now playing
    How to Cut Emacs Start Up Time in Half! - Emacs From Scratch #12
    6.7K views1 year ago
    1:57:58

    Now playing
    System Crafters Live! - Emacs Future in Danger?, Config Hacking, Q&A
    6.6K viewsStreamed 1 year ago
    18:27

    Now playing
    Keeping Your Emacs Packages Up To Date - Emacs From Scratch #11
    3.4K views1 year ago
    1:58:00

    Now playing
    System Crafters Live! - Emacs Startup Speed, Emacs News, Q&A
    3.6K viewsStreamed 1 year ago
    41:56

    Now playing
    Craft an Email Workflow with Org Mode
    4.6K views1 year ago
    59:37

    Now playing
    Defining Variables and Scopes - Learning Emacs Lisp #4
    5K viewsStreamed 1 year ago
    16:23

    Now playing
    How to Create a Dotfiles Folder
    7.6K views1 year ago
    29:13

    Now playing
    Enhance Your Email with Org Mode - Emacs Mail #4
    5.2K views1 year ago
    1:02:53

    Now playing
    Defining Functions and Commands - Learning Emacs Lisp #3
    7.9K viewsStreamed 1 year ago
    17:18

    Now playing
    The Basics of Dotfiles
    7K views1 year ago
    42:38

    Now playing
    Compose and Send Email with Emacs - Emacs Mail #3
    5.9K views1 year ago
    1:16:13

    Now playing
    Types, Conditionals, and Loops - Learning Emacs Lisp #2
    12K viewsStreamed 1 year ago
    26:31

    Now playing
    What is System Crafting?
    2.9K views1 year ago
    38:14

    Now playing
    How to Encrypt Your Passwords with Emacs
    6.3K views1 year ago
    39:52

    Now playing
    Introduction to Emacs Lisp - Learning Emacs Lisp #1
    30K viewsStreamed 1 year ago
    28:25

    Now playing
    Managing Multiple Email Accounts with mu4e and mbsync - Emacs Mail
    4.4K views1 year ago
    26:39

    Now playing
    5 Reasons to Learn Emacs in 2021
    60K views1 year ago
    1:01:53

    Now playing
    Streamline Your E-mail Management with mu4e - Emacs Mail
    15K viewsStreamed 1 year ago
    25:35

    Now playing
    Teach Emacs to Keep Your Folders Clean
    4.2K views1 year ago
    29:57

    Now playing
    Enabling Desktop Notifications with Dunst - Emacs Desktop Environment #6
    2.3K views1 year ago
    5:22

    Now playing
    Happy Holidays, and plans for 2021!
    871 views1 year ago
    32:45

    Now playing
    Give Emacs Psychic Completion Powers with prescient.el
    4.8K views1 year ago
    35:36

    Now playing
    Unlock the Power of the Daemon with emacsclient
    8K views1 year ago
    39:11

    Now playing
    The Perfect Panel: Integrating Polybar with Emacs - Emacs Desktop Environment #5
    5.9K viewsStreamed 1 year ago
    15:01

    Now playing
    Dynamic Tiling Windows like dwm in Emacs with Edwina
    4K views1 year ago
    19:00

    Now playing
    Organize Your Windows with the Tab Bar in Emacs 27
    8.2K views1 year ago
    40:23

    Now playing
    Using Multiple Monitors in EXWM - Emacs Desktop Environment #4
    2.5K viewsStreamed 1 year ago
    50:10

    Now playing
    How to Create and Manage Multiple Windows - Emacs Tips
    5.4K viewsStreamed 1 year ago
    52:28

    Now playing
    Optimizing Window Placement in EXWM - Emacs Desktop Environment #3
    3.3K viewsStreamed 1 year ago
    1:05:50

    Now playing
    Emacs IDE - Python Development Configuration
    27K viewsStreamed 1 year ago
    51:44

    Now playing
    Emacs Desktop Environment #2 - Improving the EXWM Experience
    6.4K viewsStreamed 1 year ago
    31:38

    Now playing
    Emacs Tips - How to Give Presentations with Org Mode
    14K viewsStreamed 1 year ago
    1:08:16

    Now playing
    Emacs Desktop Environment #1 - Getting Started with EXWM
    28K viewsStreamed 1 year ago
    50:00

    Now playing
    Emacs IDE - How to Debug Your Code with dap-mode
    18K viewsStreamed 1 year ago
    56:23

    Now playing
    Emacs From Scratch #10 - Effortless File Management with Dired
    17K viewsStreamed 1 year ago
    37:32

    Now playing
    Emacs Tips - How to Use File and Directory Local Variables
    3.6K viewsStreamed 1 year ago
    1:03:26

    Now playing
    Emacs From Scratch #9 - Learn to Love the Terminal Modes
    16K viewsStreamed 1 year ago
    Emacs Tips - How to Create Your Own Color Theme
    6.3K viewsStreamed 1 year ago
    Emacs From Scratch #8 - Build Your Own IDE with lsp-mode
    43K viewsStreamed 1 year ago
    Emacs Tips - How to Show Reminders for Org Mode Tasks
    6.7K viewsStreamed 1 year ago
    Emacs From Scratch #7 - Configure Everything with Org Babel
    18K viewsStreamed 1 year ago
    1:01:51

    Now playing
    Emacs From Scratch #6 - Organize Your Life with Org Mode
    31K viewsStreamed 1 year ago
    47:37

    Now playing
    Emacs From Scratch #5 - Org Mode Basics
    35K viewsStreamed 1 year ago
    1:01:25

    Now playing
    Emacs From Scratch #4 - Projectile and Magit
    25K viewsStreamed 1 year ago
    59:26

    Now playing
    Emacs From Scratch #3 - Key Bindings and Evil
    29K viewsStreamed 1 year ago
    54:42

    Now playing
    Emacs From Scratch #2 - Adding Helpful UI Improvements
    33K viewsStreamed 1 year ago
    58:30

    Now playing
    Emacs From Scratch #1 - Getting Started with a Basic Usable Configuration
    104K viewsStreamed 1 year ago
    1:06:38

    Now playing
    Stream Hacking: Creating a Live Chat Widget for our OBS Overlay
    900 viewsStreamed 1 year ago
    1:24:20

    Now playing
    Stream Hacking: Creating a Live Data Channel for Custom OBS Overlay
    905 viewsStreamed 1 year ago
    1:29:16

    Now playing
    Stream Hacking: Fetching Live Stream Details with YouTube Data API
    3.2K viewsStreamed 1 year ago
    1:01:01

    Now playing
    Stream Hacking: Custom OBS Overlay Server
    932 viewsStreamed 1 year ago
    1:14:03

    Now playing
    Live-Coding a BrowserSource Overlay Server for OBS
    1.8K viewsStreamed 1 year ago
    1:03:23

    Now playing
    Parsing Text with Combinators - F# Part 5 [Episode 005]
    13K views5 years ago
    26:33

    Now playing
    Functional Concurrency with the Actor Model - F# Part 4 [Episode 004]
    13K views5 years ago
    43:19

    Now playing
    Functional Game Logic with State Pipelines - F# Part 3 [Episode 003]
    24K views5 years ago
    17:45

    Now playing
    Records and Discriminated Unions - F# Part 2 [Episode 002]
    26K views5 years ago
    30:49

    https://www.youtube.com/c/SystemCrafters/videos (!!!!)
        tab + 'list' + l  (+s-tab)


    Introduction to Functional Programming with F# - Part 1 [Episode 001]
    https://www.youtube.com/watch?v=Teak30_pXHk
    110K views5 years ago

    }}}
    ~/dropbox-legacy/scripts/ALLTODOIST/aa_VIMEMACS.bash
    --
    ~/dropbox-legacy/emacs.orig.txt
    ~/dropbox-legacy/emacs.txt
  ~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/masteringemacs-v3.txt
  ~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/emacsmanual1.tags1.txt
  ~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/emacsextend.txt
  ~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/Em-Doks_Giraffeetc.txt
  ~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/Emacs01-Learning3_534.txt
}}}
.  install packages {{{
  https://www.emacswiki.org/emacs/ELPA
   https://melpa.org/#/getting-started
}}}

ptools {{{

Load color-scheme based on name
    a-x load-theme
List color-schemes + Click-select:
    a-x customize-themes

  eval. expression      c-x c-e
  word completion       sa-7  #a-/

pick {{{

evaluate el(isp) expressions (**!) ; (=in emacs lisp mode)  point after(!) expression + c-x c-e
area where messages/returns (eg. for evaluations) are printed ; mini buffer (or echo area)
simplest things in elisp (*) ; atoms (eg. numbers)  #=evaluates to themselves (in the repl)
example of builtin var. (**) ; path-separator  #=evaluates to ';'
set elisp mode in emacs ; a-x emacs-lisp-mode / edit .el-file(**)  #(+scratch-buffers are often in elisp-mode)
call function in elisp (***!) ; (fname arg1 arg2 ... )
(compiling elisp(?) ; =is possible  (=for speed etc(??)))
2 * 3 + 8 / 4  i (e)lisp (**) ; (+ (* 2 3),,   (/ 8 4))
print a text message in the mini buffer(*) ; (message "hello, minibuffer")  #='function that has the side effect of adding specified message to echo area'
(mode that acts like interact. lisp interpr (?) ; a-x ielm  #=no redirection etc (=use emacsshell for that) (?)
teterm: functions that take variable number of args (=like sum) (*) ; variadic functions
function that inserts text " TEXT" into buffer (**!) ; (insert " TEXT")  #=at point of cursor
quote list (1 2 3)  [2 ways] ; (quote (1 2 3))  //  '(1 2 3)  # ' ="stop evaluating from this point"(**!)
(teterm: single apostrophe when quoting list (eg. instead of (quote .... ; =syntactic sugar for (quote . . . .)) *
nested lists possible? ; yes, eg. '(1 2 (3 4 5) (6 (7)))

return head / first post of list (**!) ; (car '(1 2 3))  #'contents of address register'
return rest of list (=after head/first post) ; (cdr '(1 2 3))  #'contents of decrement register'
 [clojure version of car/cdr ; first / rest]
empty list in elisp ; '()
elisp none / false ; nil / ()
elisp true ; t  #=symbol for true (=used as otherwise in cond)**
true o false i elisp ; nil = false ,,  allt annat är truthy
build lists in elisp: build list (1 2 3)  from 1 and (2 3) ; (cons 1 '(2 3))  #"construct" =like pushing
 (recursive cons  (=for 1, 2, 3) ; thoughtbot elisp-intro  ca 18.15)
add items in list to "list1" (**) (=not as one sublist, as with cons) ** ; (append '(1 2) '(3 4))  #=argument 1 is a list
assign value (=list (1 2 3)) to global var (=symbol(!)) "some-list" (***!) ; (set 'some-list '(1 2 3))  (setq some-list '(1 2 3))
assign local var "a" to 1 (**) ; (let (a 1))  #+see more elisp-thoughtbot(**)_20:45ca(**)  #='let opens a new scope'
printf in elisp ; format  [ (let ((a 1) (b 5)) (format "a is %d and b is %d" a b)) ]
Define var b =Depending on var a (****!!) ; let*  (**)   (let* ((a 1) (b (+ a 5))) (format "a is  (OSV...)
paraphrase of let vs let* ; let defines vars in parallel (=cannot depend on eachother's values) ,, let* lets one define vars sequentially (**!)

define function say-hello (that prints "hello!") (***!!) ; (defun say-hello () (message "hello!"))
call defined function "say-hello" (=has no args) (**) ; (say-hello)
function with arg: define function square (=squares number) (**) ; (defun square (x) (* x x))  #+call: (square 2)
ex. of some predefined functions in elisp (*) ; square, sqrt
explain keyword 'when' in elisp (*/!!) ; =like if w.out else

Conditional: if(!?) 2+2=4, print "yes!"  (***!!) ; (when (= (+ 2 2) 4) (message "yes!"))
Conditional: def. funct. evens-or-odds (**!) ; (defun evens-or-odds (n) (if (= 0 (% n 2)),, "even!",, "odd!"))  #=no 'else' keyword (***)  (tbot-elisp_30:00)
variable number of args when defining elisp function (*!) ; &rest  #(or something)
Conditional: like case (**!!) ; (defun pick-a-word (n)  (cond  ((= 1) "a")  ((= 2) "b")  (t "blast!"))   (tbot-elisp_33:30)  (+kör med  (pick-a-word 2)  )
Recursion/"Calling itself"**: FACTORIAL W. ELISP (**!!) ; (defun factorial (n)  (if (< n 1)  1  [else](* n (factorial (- n 1))))    (tbot-elisp_37:50)
function literal/anon. funct.  (in elisp) ; =lambdas  ((lambda (x) (* x x x) 5)

Bind lambda-function to name =var (****!!) ; (fset 'cube (lambda (x) (* x x x)))  (tbot-elisp_45 ******!!!!)
'Apply function on Obj.s in List' (=eg. Upcase) (**(**)!!) ; (mapcar 'upcase '("foo" "bar" "baz"))
filtering with 'remove-if-not' ; eg. 'remove if not odd number'  (=oddp(redicate))
reduce in elisp ; (=??)
'THE qs-FUNCTION' (=implem. of quicksort) (**!) ;  (tbot-elisp_47:15+)
SET SHORTCUT KEY: a-# = call sort-lines(!!) (**!) ; (global-set-key (kbd "M-#") 'sort-lines)  #=in all(!) modes
Set local key-binding (*) ; local-set-key (??)
Add certain command runs ev. time entering C-mode (**!!) ; (add-hook 'c-mode-common-hook  (lambda ()  (local-set-key (kbd "<f5>") 'recompile)))


(tbot_55:00 ************* SEE MORE(!!))
Help about M-mode currently in (**!!) ; c-h m  #describe-mode  =hooks, enabled minor modes etc etc (**)  (tbot-elisp_54:30)
Help for keycommand c-c c-c ; c-h k / c-h c(??)  c-c c-c   (describe-key (kbd "C-h k"))
Search for commands w. "word" in name(or docstring) ; c-h a name   (apropos-command "region")
Show description of function "qs" ; c-h f qs(??)  (describe-function 'qs)
HELP ABOUT THE HELP COMMAND ; c-h c-h (**!)


MACROS (='Are Awesome(!!)') (=See More) ?????
}}}

  thoughtbot 'getting started w. elisp'
  builtin vars
  message   (=like echo and printf (**))
  ielm | eshell
  insert
   (append)
  format
  defun
   let*
  defun
   cond (=like case)
  ----
  fset
  mapcar
  reduce
  local-set-key
  add-hook
   Help *!

}}}
wishlist {{{
  Dotfiles-Project in Git

  indentation  (spaces, no tabs)
  Lilypond Mode
  syntax in textblocks (+'multi-syntax')
  organize init.el

    bongo
  Org Roam
    translate-shell emacs

  emacs latex
  markdown

  auto-draw included svg(etc) graphics files
  auto-insert image-links(!)
}}}
.  measure writing/typing speed {{{
        https://pavpanchekha.com/blog/emacs-keylogger.html  https://www.reddit.com/r/emacs/comments/2euqn7/emacs_extension_to_measure_typing_speed_in_the/
          https://github.com/candera/emacs/blob/master/candera/typing-speed.el  (**)

Sure, here is the modified measure-writing-speed function that starts the timer
when you enter insert mode and stops the timer when you exit insert mode:

Code snippet

(defun measure-writing-speed ()
  (interactive)
  (let ((start-time nil)
        (end-time nil))
    (add-hook 'evil-insert-mode-hook
               (lambda ()
                 (setq start-time (time-to-millisecond (current-time)))
                 (message "Timer started.")))
    (add-hook 'evil-insert-leaving-hook
               (lambda ()
                 (setq end-time (time-to-millisecond (current-time)))
                 (difference start-time end-time)
                 (message "Writing speed: %d characters per minute, %d words per minute."
                          (/ (length (buffer-string)) (/ (difference start-time end-time) 1000))
                          (/ (length (buffer-string)) (/ (difference start-time end-time) 60)))))
  )
)

To use this function, you would just call it without any arguments. When you
enter insert mode, the timer will start, and when you exit insert mode, the
timer will stop and the result will be echoed back to you.

Here is an example of how to use the function:

- Open a new Emacs buffer.
- Enter insert mode.
- Start typing some text.
- Exit insert mode.
- The result will be displayed in the minibuffer.

I hope this helps!

}}}
--
repeat {{{
  repeat complex command
  https://www.emacswiki.org/emacs/RepeatingComplexCommand
}}}
evil {{{
    https://github.com/emacs-evil/evil
  ~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/evilman1.tags.txt
  ~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/evilman1.txt
    http://cachestocaches.com/2016/12/vim-within-emacs-anecdotal-guide/

    ======
    https://readthedocs.org/projects/evil/downloads/pdf/latest/  #zzzz=chapter 3 - Key Maps (**!)
    ======  (+checkout aaron bieber  and  evil-leader)(!!)

https://github.com/cofi/evil-leader
    . +more ='mapping keys' (in evil)  +Aaron Bieber  {{{

emacs evil mode mapping keys:  emacs evil mode documentation
    https://github.com/emacs-evil/evil
    https://evil.readthedocs.io/en/latest/index.html  **!
        https://readthedocs.org/projects/evil/downloads/pdf/latest/
    ----
    https://emacs.stackexchange.com/questions/12175/instructions-on-how-to-work-with-evil-mode
     https://github.com/wasamasa/dotemacs/blob/master/init.org#evil
    http://blog.jenkster.com/2013/02/mapping-jk-in-emacs-evil-mode.html
        https://www.systutorials.com/keyboard-key-mapping-for-emacs-evil-mode-and-rearranging-alt-ctrl-and-win-keys/
        https://stackoverflow.com/questions/10313864/emacs-evil-mode-key-map
https://www.youtube.com/watch?v=JWD1Fpdd4Pc&t=1200s
------
https://blog.aaronbieber.com/2015/05/24/from-vim-to-emacs-in-fourteen-days.html
 https://web.archive.org/web/20161021043220/http://blog.aaronbieber.com/2016/01/30/dig-into-org-mode.html
https://blog.aaronbieber.com/2015/07/05/a-gentle-introduction-to-emacs-configuration.html
https://blog.aaronbieber.com/2016/08/07/getting-started-with-emacs-lisp.html
https://blog.aaronbieber.com/2015/08/04/authoring-emacs-packages.html
    https://github.com/aaronbieber

    }}}

.    (evil docs(?(*))) {{{
    3 inställningslägen (+senare merge/snabbinställn. mm):
     standard emacs(+ev enb. evil av)    #.emacs/.emacs.d_0base
    evil drs #fler colorschemes + path  #.emacs/.emacs.d_1drsevil       #=i dropbox-legacy + när ska anv.: rm .emacs, rm .emacs.d, ln -s ~/Dropbox/.emacs|.emacs.d      #+ev ol. alias för att kunna flytta mellan spacem. o em25
    emacs clojbrave                     #.emacs/.emacs.d_2clojbrav
    spacemacs (+python mm)              #.emacs/.emacs.d_3spacem
}}}

___Em1+evil/Org
~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/evilman1.tags.txt  #TT(T)@
EVIL: INSTALL + MANUAL 2020 ++ (****) {{{

    https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html#Top  ****  (+SÖK: EMACS LISP REFERENCE MANUAL)
            https://www.gnu.org/software/emacs/manual/html_mono/emacs.html
            https://www.gnu.org/software/emacs/manual/html_mono/elisp.html
        https://www.gnu.org/manual/manual.html


            https://github.com/emacs-evil/evil      #quickinstall 1 (**)
        https://bytebucket.org/lyro/evil/raw/default/doc/evil.pdf
         https://www.linode.com/docs/tools-reference/tools/emacs-evil-mode/
        https://www.emacswiki.org/emacs/Evil
          https://evil.readthedocs.io/en/latest/overview.html#installation-via-package-el  (**)
          https://melpa.org/#/getting-started       #add melpa-ref(??
        -----
        https://github.com/noctuid/evil-guide
            https://github.com/noctuid/evil-guide
        https://evil.readthedocs.io/en/latest/index.html
                https://readthedocs.org/projects/evil/downloads/pdf/latest/

                                https://www.emacswiki.org/emacs/Evil
                                https://bytebucket.org/lyro/evil/raw/default/doc/evil.pdf
                                https://www.linode.com/docs/tools-reference/tools/emacs-evil-mode/
                                https://github.com/emacs-evil/evil
                                 https://evil.readthedocs.io/en/latest/overview.html#installation-via-package-el
                                 https://melpa.org/#/getting-started
                                    https://www.linux.com/training-tutorials/vim-tips-folding-fun/
                                    https://learnvimscriptthehardway.stevelosh.com/chapters/49.html

}}}
TODO (inkl. installera Evil-mode) (**) {{{
    install + evil **   #flytta ev till 'programattinstallera'=install/tweak-indexet ***
        sudo apt-get install emacs
            sudo add-apt-repository ppa:kelleyk/emacs
            sudo apt-get update
            sudo apt-get install emacs25
            +remove {{{
                sudo apt remove emacs25 emacs25-nox && sudo apt autoremove
            }}}
        a-x invert-face Ent default     #eller a-x customize-themes
            https://stackoverflow.com/questions/5982572/how-to-install-emacs-colortheme
        skapa ~/.emacs  #~/.emacs.d skapas automatiskt **
        +infoga i .emacs-filen: {{{

            (require 'package)

            (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
            (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
            (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))

            (setq package-enable-at-startup nil)
            (package-initialize)

        }}}
        starta emacs + a-x package-list-packages Ent
        q (=quit när paketen uppdaterats färdigt)
        a-x package-install Ent evil Ent
        a-x evil-mode Ent
        insert into .emacs {{{
            (require 'evil)
            (evil-mode t)
        }}}
        a-x package-install Ent helm Ent

}}}
___Em1+evil/Org

}}}
Emacs Multilang Syntax Highlighting {{{
My understanding is that Emacs is a bit more nuanced than Vim can be about syntax-coding. Let's say I have a file containing both HTML and CSS. Would it be possible to have the code syntax-colored in both HTML and CSS so that each of the parts show up with their correct syntax-coloring (if you know what I mean), and in that case, how would I do that? (e.g. by using two different minor modes at the same time?)

Yes, Emacs' syntax highlighting capabilities are indeed more sophisticated than Vim's. It's possible to have the code syntax-colored in both HTML and CSS so that each of the parts show up with their correct syntax-coloring. Emacs can handle multiple minor modes at the same time, and this is how you would achieve syntax-coloring for both HTML and CSS in a file containing both languages.

Here's how you would do it:

Install the appropriate packages for syntax highlighting HTML and CSS. Emacs has packages for syntax highlighting a wide variety of languages, including HTML and CSS. You can install these packages using the M-x package-install command.

Enable the HTML mode and the CSS mode. Once you have installed the appropriate packages, you can enable the HTML mode and the CSS mode for the file containing both languages. You can do this by pressing M-x html-mode and then M-x css-mode.

Emacs will automatically detect that the file contains both HTML and CSS, and it will apply the appropriate syntax highlighting to each language. You should now be able to see the code syntax-colored in both HTML and CSS, so that each of the parts show up with their correct syntax-coloring.

Emacs' syntax highlighting capabilities are quite powerful, and it can handle a wide variety of programming languages and markup languages. With a little bit of configuration, you can set up Emacs to syntax-color your code in the way that you prefer.
}}}
emmet {{{
  https://github.com/rooney/zencoding
    https://github.com/smihica/emmet-mode
  https://www.emacswiki.org/emacs/ZenCoding
}}}
html mode {{{
  https://www.youtube.com/watch?v=CztlFGGRrpk
  https://www.gnu.org/software/emacs/manual/html_node/emacs/HTML-Mode.html
    https://www.emacswiki.org/emacs/HtmlMode
}}}
nxml mode (etc) {{{
      #tip: seems to work in evil mode
  https://www.inmotionhosting.com/support/edu/emacs/nxml-mode/
      complete tag (<head to <head></head>)                       c-c c-i
      complete tag + linebreak (<head to <head>\n\n</head>)       c-c c-b
  https://www.gnu.org/software/emacs/manual/html_mono/nxml-mode.html
  --
  https://www.gnu.org/software/emacs/manual/html_node/nxml-mode/Introduction.html


  Essential Editing Commands and Actions in Emacs nXML Mode

  Navigation:
  
  C-x C-f: Move to the beginning of the next XML element.
  C-x C-b: Move to the beginning of the previous XML element.
  C-x C-n: Move to the next XML tag.
  C-x C-p: Move to the previous XML tag.
  C-x C-e: Move to the end of the current XML element.
  C-x C-s: Move to the start of the current XML element.

  Editing:
  
  C-x C-w: Cut the current XML element.
  C-x C-y: Paste the cut XML element.
  C-x C-d: Delete the current XML element.
  C-x C-c: Comment out the current XML element.
  C-x C-u: Uncomment the current XML element.
  C-x C-q: Start quoting mode for entering special characters within XML attributes.

  Formatting:
  
  M-x nxml-indent-region: Indent the current region of XML code.
  M-x nxml-reformat-region: Reformat the current region of XML code.

  Validation:
  
  M-x nxml-validate-region: Validate the current region of XML code against a DTD or schema.

  Additional Commands:
  
  M-x nxml-find-tag: Find a specific XML tag.
  M-x nxml-insert-tag: Insert a new XML tag.
  M-x nxml-close-tag: Close the current XML tag.
  M-x nxml-check-balance: Check if the XML document is well-formed (balanced tags).

  Note: These are just a few examples of the many commands and actions available in Emacs nXML mode. You can explore the full list of commands by using C-h f and searching for commands related to XML.

}}}
'Em 1' {{{
  (=convert to quicklist 1 2022 (**(!)))
  ~/Dropbox/rsc/data/lists/learnqna/vanki/pick.legacy/em-mastext1.tagged.txt
}}}
Org [** __] {{{
  https://www.youtube.com/watch?v=VcgjTEa0kU4
  https://www.youtube.com/watch?v=PNE-mgkZ6HM
    Org Babel(??(**))  https://www.youtube.com/watch?v=kkqVTDbfYp4

  ~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/OrgmodeMan.tags1.txt
  ~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/OrgmodeMan.txt
    ~/Empire/Doks/Comp/editor/emacs/emacsrefcard_org01.pdf
orgman + org vanki-file(!!):   https://orgmode.org/
    ~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/OrgmodeMan.txt
    https://orgmode.org/org.html (in chrome)
    ~/Dropbox/rsc/data/lists/learnqna/vanki/orgman-emacs.vdeck.txt
emacs Org-Mode - Notes 1 2020-2021 {{{
___start

        evince -p 4 ~/gdrive/rsc/Doks/em.org.pdf &

     outliner
    research compendium

    activate / packag. system
     list-packages (!!)
    add-to-list + 'load-path  *
    [git]
      ----
            make help
    (font-lock via hook)  *
  ---- p13
    keybinding conventions (Elisp)
    [local var. Org (in non-org-file)] *
    org-submit-bug-report
  ---- p14
    start w. minimal config *  x2
            backtrace
    Org Syntactical Elements * (TODO etc)
      ****
  ---- p16

___start
Ch. 2 - Document Structure **
     org-cycle + Tab *
    Headlines (+  *, **, ***)
    16.4 Clean view  + Headline Numbers
    --
    Global / Local Cycling
        tab | s-tab
  ---- p17
      c-u (=num.) + s-tab *
    c-u c-u tab   c-u c-u c-u tab

    c-c c-r  "reveal"
    c-c c-k
    c-c tab
    c-c c-x b
    c-c c-x v
  ---- p18   init visib(!)
    
    2.3 Motion
     c-c c-u / c-p      next heading
         c-f / c-b
         c-n
         c-j
  ---- p19
    tab | return  (="down | up" (??))    /  n | p  ....
    2.4 Struct. Editing
    m-Ent   c-u | c-u c-u
    c-Ent
    ms-Ent  New TODO
    cs-Ret

    a-left|right  promote | demote heading
  ---- p20
    sa-left | right     promote | demote subtree *
    a-up | down
    c-c @   mark subtree
     kill | copy | paste  subtree
    (c-u c-y)

        evince -p 5 ~/gdrive/rsc/Doks/em.org.pdf &

  ---- p21
     Sorting *
    narrowing *
        promote to headline *
    2.5 Sparse trees  *!
     [c-c / ]
  ---- p22 (=12(?))
    keyb. access to specific Sp(??).trees
    
    2.6 Plain Lists (+checkboxes)

        descr.  ' :: '
  ---- p24
    sa-Ent  = Checkbox
      (+etc commands)
  ---- p25
    Drawers
      LogBook
    2.8 Blocks (including Code (clocking??) etc **!)
    a-tab  =  ca-i | esc-tab ****
  ---- p26 [16]
    3 = Tables
    c-c Ent
    c-c |       |vert

  ---- p27
    Column + Row Editing (*)
      a-up|down (etc) !
  ---- p28
    Sort table lines
        c-c ^
     [+by time | by function]
    --
    Region (eg. copy rect. region)
    split  a-Ent
  ---- p29
    Calculations
     c-c t
     s-Ent
    Misc (*)
        import file as table *
    c-c |(??)
        export *!
  ---- p30
     Align table
    shrink | expand
  ---- p31
    hover field (=preview)
        +remove on export
    orgtbl-mode (=minor)
        ="use in textmode, mail, etc" **
  ---- p32
    (+add-hook

        evince -p 6 ~/gdrive/rsc/Doks/em.org.pdf &
    
        Spreadsheet + Calc
    references
        c-c ? | c-c }
    ((B3)) @Row $Col
      $1  $+1  $-2
          $<
          $>>>
      @1   +3 -1
      @I    (=) first headerline
    ***
      @0  $0        +p33  Examples
    ----
    Ranges  $1 .. $3 (etc)
        +can be used w. Calc vector functions
    - - - -
    formula field coord.s
        @#  $#   etc
     +Ex  ((*))
  ---- p34
    Named Ref.s (pi etc)
    Remote ref.s  **
     remote(  )
    Calc formula Syntax
        constants.el
  ---- p35
    mode string  + semicolon
    p20  n3 s3 e2 f4
    D R
    F S
    T t U
    E*  N  L
        +printf + Ex. *
  ---- p36
        'logical operations' (*)
    Lisp Forms as formulas *
        (= string manipul. etc)
    '( ....
        + ;L -etc flags
  ---- p37
        +Ex.s *
    Durations and timeval.s
        ;t  *
    ----
    3.5.5 Field and Range formulas
        ' := '
    eg. assign formula into field *
        vsum(@II..III)
            +calculate
  ---- p38
    c-u c-c =
        TBLFM
    $2=
    @3=
    @1$2..@4$3  (*)
    $NAME
    ----
    Column Formulas *  =$1+$2
      c-c =

        evince -p 7 ~/gdrive/rsc/Doks/em.org.pdf &
    
  ---- p39
    Lookup Functions  (3 st)
    (eg. org-lookup-all)
    'These three functions can be used
     to implement assoc. arrays,
     count matching cells, rank results,
     group data, etc
    +Worg tutorial (*!)
    ----
    Edit + Debug formulas *
    ----  (SEE MORE)
  ---- p40
    
        shift reference
            c-c }
    remove formula (!)
  ---- p41
        multip. TBLFM *
    Debug Formulas (=in menu)
    Updating the table
        c-c *
        c-u c-c *
  ---- p42
    Advanced features
    c-#
        Students exam results example (*)       
  ---- p43
    !
    ~
    -
    #
    *
    /
     +Ex. *
    ---
    3.6  Org Plot
     gnuplot (=praph / ascii)
        c-c " g
  ---- p44
    Plot Options (*)
            file (outp.)
    script
  ---- p45
    ascii
        c-c ``
        c-u c-c * (update)
  ---- p46
    Ch. 4(??) - Hyperlinks *!
    [[LINK][DESCR.]]
        org-link-escape
    c-c c-l
  ---- p47
    Internal Links
    follow  c-c c-o
    [[#my-custom-id]]
        <<My Target>>
    (+NAME)
        linter *

        evince -p 8 ~/gdrive/rsc/Doks/em.org.pdf &

    orgs (link)  mark ring

    c-c &

        (link to Headers etc)
  ---- p48
    Radio Targets
     <<<My Target>>>
    - - Ext. Links - -  *!
    files, websites, messages (mail etc)
    BBDB-db:s, IRC conversations *

    file: attachment:, bbdb:,
      docview:, doi, elisp:,  **!
    ....
     help:, http(s):,
      id info irc  mailto news
     shell *
  ---- p50
        inline
    Handling Links
      org-stor-link  (+bind)
    [globally unique moveable links] *
  ---- p51
    Web Browsers
      ...
      ...
      ...  file types
    Agenda View
      c-c c-l  insert link

    link history *
        
        link abbrev.s *
    c-u (x3) c-c c-l  ('kup' in list)
  ---- p52
    Completion supp. for cert. file types

    c-u c-c c-l
    c-u c-l  (on existing link)
    c-u c-o  (+prefixes)
     Ret  lmb/rmb  mmb
    --
    c-c %  Push curr. pos. onto ring  *
  ---- p53
    c-c &  jump back
    c-c c-x c-n/p
      (+ bind to  a-n/p)
    
    Link Abbreviations  *!!

      Elisp   + EXAMPLES (**!)
  ---- p54
        define custom abbrev.s
    (+completion) *!

    +Search Options in FileLinks
      (= line no, internal links,
       headlines, ids search)

        evince -p 9 ~/gdrive/rsc/Doks/em.org.pdf &

  ---- p55
    (search the curr. file)

    Custom Searches (w. functions *)
      BibTex etc
  ---- p56
    5 - TODO Items (*)

    c-c c-t  rotate
    s-right/left  (t in agenda)
    'c-c/t'  View as Sparse tree
    'c-C/T'  Search *

  ---- p57
    Show All 'RDS'(??) fr. many files
    sa-Ent  new todo below curr.
        
        tags (??)
    --
    5.2.1  TODOs as workflow states

      "|"

      TODOs as types
  ---- p58
    tags [p69]
        (+Using Completion)
        [p243]

    'Multip. Keyw. Sets in one file(?)
    *(!!) (+setq and sequences)

    cs-left/right  Change
    s-right/left  sequences
  ---- p59
    * Fast access to TODO states (r, b, k etc) *

    Setup Keywords for indiv. files
     +complete w. esc-tab

     c-c c-c

  ---- p60
    custom faces

      TODO Dependencies (*) !

  ---- p61
    blocked = dimmed / checkboxes *
        org-depend.el
    
    5.3 ProgressLogging

    c-u  c-c c-t
        (or automatically) *
    
    closing Items (?)
        c-c c-t space  (?)
     ----
    Tracking TODO state changes

  ---- p62
    recommended drawer =LOGBOOK

    Wait Done Cancelled (etc)

        evince -p 10 ~/gdrive/rsc/Doks/em.org.pdf &

    "WAIT (w@/!)" etc

      logging pref.s local to buf.

    STARTUP Keywords

        Space vs c-u Space
            (w. point on drawer in agenda)

  ---- p63
    Track Habits *!*
        (+nudge)
     +  ++    +2d/3d
    
    (+consistency graph)

  ---- p64
        + colors *!
    (+grap(?)-options)

        c-u K
         K

    5.4 Priorities (wh. has many TODOs)
      [#A]  A B C
                ('cookies')
      [#1]
         ((<65))

  ---- p65
    c-c  ,          Space
    s-up/down

    Break down tasks into Subtasks *

    - = insert outline tree below
          the todo  (+ 33 % / 1/2)
    
    c-c c-c
            recursive etc

  ---- p66
    Function = make entry change
        to done wh. all children are done **!!

    5.6 Checkboxes **!*
      [ ]  -  x

        [2/4] - Cookies *

  ---- p67  Set, Toggle etc.

                (+ c-u / c-u x2)
    c-c c-c 
    c-c c-x c-b
    c-c c-x c-r     (radio button)
    sa-Ent
    c-c c-x o   (toggle ordered)
      ----
    (c-u) c-c #  update stat.s cookies

  ---- p69

    6 - Tags *

    :work:urgent: (etc)
        
        (subheadings inherits tags)

    'set tags that all entries in a file should inherit'
        (??????)

    Matching (*)
        (inheritance)

    6.2 Setting tags

    c-c c-q
        Enter new

        evince -p 11 ~/gdrive/rsc/Doks/em.org.pdf &

  ---- p70
        hardlist of tags
    Default tags etc *!
        
            **
    @work @home  etc

    fast tag Selection *
     (setq ........  *!!)

            \n

  ---- p71
    {@work(w) @home ...

    mutually exclusive tags

    [:start/endgroup !!]

        c-c c-c + sel.keys tag1, tag2 ...
     --
    tab Ent c-g q  !  c-c

  ---- p72
    +Examples  *
     ----
    Tag Hierarchy !!*
        [GTD : Control Persp]
    
        + {       }
    +Regexes **  {re}

    Searches

     c-c / m // c-c \

     org-agenda m
                M

        (Find / List urgents etc)


  ---- p74
    7 - Prop.s and / Columns

    - inst. of tags, eg. for diff. softw. releases *
    - eg. CD-db

    Convinient view for editing prop.s ; Column View

    prop.syntax
            :key: val  *

  ---- p75
    inheritance + preset val.s  *

    (prop.blocks)
        +adding etc *

    m-tab
    c-c c-x p
      insert-drawer
    c-c c-c
  ---- p76
        c-c S
    s-left/right
    c-c c-c d
            D
            --
            C
    
    Spec. prop.s  ('ALLTAGS' etc)
            **
    
    CLOCKSUM

    7.3 Prop. Searches (=create sparse ____(trees?) etc)

        evince -p 12 ~/gdrive/rsc/Doks/em.org.pdf &

  ---- p77
    = sparse tree / spec. lists cmds

    agenda etc

    'c-c / p'

        Inheritance (can be slow)
    
    moving subtrees

  ---- p78
    7.5 Column View
        s-tab s-tab

  ---- p79
    SUMMARY-TYPE *

    'est+'
        +Ex. *!

  ---- p81:2  ###

    Capture Col.View
    
     :id

     :match  *

  ---- p82
  
    :exclude-tags

    c-c c-c c-c  .......

    + formulas *

        Collect properties *

  ---- p83
    8 - Dates and Times
      
      =labeling TODO-items w. dates and times *

    => Causes entries to be shown on specif. dates of Agenda *

    <d a t e>
        +1w *

    +cal(?).expressions

  ---- p84
    %%(

  ---- p80(??)
    c-c c-x c-c
     r / r
    c-c c-c // q

    1-9 , 0
    n / p

  ---- p81(??)
    e(dit)
    c-c c-c
     v
     a
     <  //  >
     sa-left/right

        evince -p 13 ~/gdrive/rsc/Doks/em.org.pdf &

    inactive timestamps
    [ D a t e ]

    c-c .
    c-c !
    c-c c-c
    c-c .
    c-c < // > (!!)
    c-c c-o

  ---- p85(??)
    s-left/right
     -up/down
    c-c c-y

  ---- p86(??)
    relat. dates

  p87
    +Formats  etc

    sa-left
    (custom formats)

    Deadlines + Scheduling
        |
  ---- p88(??)
    =setting a date wh. y. want to
     start working on an action item

  ---- p89(??)
    Insert b:s or S:s

    c-c c-d
    c-c c-s
    c-c / d
    c-c / b
    c-c / s


    Repeated

  ---- p90

        DONE

    +mark repeater as done

  ---- p91
    Clocking Work Time *
        (+elisp)

    c-c c-x c-i

  ---- p92
    (effort estimates

    c-c c-x c-o
    c-c c-x c-x
    c-c c-x c-e
     ...
    cs-up/down

    
    p93
     sa-up/down
     c-c c-t
     c-c c-x c-q
     c-c c-x c-j
     c-c c-x c-d

    the clock-table

  ---- p94
    :scope *
    :block

      start
    
    :step/fileskip 0

        evince -p 14 ~/gdrive/rsc/Doks/em.org.pdf &

    |
    |
  ---- p96

    :formatter (*)
        
        +Examples

    - Resolve idle time *

  ---- p97
    k K  s S
      C
    - -  - -
    
    c-c c-x c-z(or 2)

        x11-idle

  ---- p98  Effort Estim.s

    c-c c-x e
    c-c c-x c-e
        (Columns)

  p99
     Narrowing down
    Relative timers!
                ++

  ---- p100
    9 - Refiling / Archiving
      + copying

  ---- p101
    Move proj.tree to other file **

    internal archiving
        (+key commands)

  ---- p103
    Capture (=new ideas and tasks)

    10 - +Attachm.
            (=assigns Ref.mat.
             with them)

    templates
      + c-c  c-c
    
    c-c c-w
    c-c c-k

  ---- p104
            =templates

    c-u  Capture

    c-u c-u  .....

    Capt.templates (elisp)

    define task fr. email. etc  +binding

  p105

    types

    target *
        (file .... (etc)  *

  ---- p106

        '(function  funct  ..... *

    properties  +++

  ---- p107

    Template Expansion *

    eg % [FILE]

        evince -p 15 ~/gdrive/rsc/Doks/em.org.pdf &

    p108
        %(EXP)
        %<Fu(nc?)t>
         etc
          .
          .
          .
          .
          .
        %^g

  ---- p109
        link (=file?)  types
    10.2 Attachm. *!

  ---- p110  defaults + dispatcher
    c-c c-a

  p111
    F  open w. dired

  ---- p113
    Autom. v-control w. git **!

    attach fr. dired  + elisp (*)

    rss feeds

  ----
  ---- p115
    11 - Agenda Views *
    
    Sorting, collecting and displaying
     scattered TODOS etc *

    TODO , ........

     ....   stuck (#)  etc
    
    Agenda Files (??)

    c-c  [  //  ]

  ---- p116

    c- '/,  (??)

    c-c c-x <

    <  //  >

    ----
    
    The Agenda Dispatcher

      a  m  / (!!)  <
      t  M  #   <<
      T  S (!!)  !    *----'sticky'
                    r / g

  ---- p117
  
    Agenda Views (builtin)

    weekly / daily

  ---- p118
    a-x org-agenda a  *

    Calender / Diary integration
        ( (setq ....

     c  (or C)

  ---- p119
    BBDB =for contacts

    see upcoming anniv.

    Appointm. Remainders

        evince -p 16 ~/gdrive/rsc/Doks/em.org.pdf &

  ---- p120
    The Global TODO-List

    org-agenda  t  //  T

    'if y. often need to search for a specific keyword'

        (scheduled / deadline)

  ---- p121
    Matching Tags & Prop.s

    'if y. often need a specif. search' *!

    TODO-keyw.s +(!) Tags *

    & // |   + -

    +work-boss (???)   **

    work + {^boss.*}  *
        
        (=regexes)

    Prop.s / Spec. Poop.s(????)
        
        SEE MORE

  ---- p122

        ********

    'Here is a complex example'

    comparisons (<= etc)

      +/- min.s etc

    <Date>

     {regex}

    Searching TODO tip = 'for typing speed'

    
    p123
        More Examples *
    
    Search-View **
        (=good for finding notes) *

    ] // [  // { // }
        =adjust search

    GTD Stuck proj.s

  ---- p124     #   !

    11.4 Pres. + Sorting Categories *

  p125
    timeofday-specif.s

    <    >--<    >

    sorting + priorities

  ---- p126
    Filtering / Limiting agenda items *

    \   <    =
    tag  categ.  regex

    custom filters

  ---- p127
    _    ^    /(!!)    | (=X)
    effort  headline

    Computed Tag filtering

  ---- p128
    (auto-exclude)   (+elisp)!!

    self-adapting filters

        evince -p 17 ~/gdrive/rsc/Doks/em.org.pdf &

  p128
        set limits for the Agenda
    
    Commands in the Agenda Buffer  p129
                            ****

    p132   remote editing
                    **

    p136
        Cal.commands + quit/exit


    Custom Agenda Views - store + qu.(??) access freq. used TODOs

  p137
    Storing Searches
        (setq .....  !**

  p138
    block agenda

    Setting Options for Custom Commands (+elisp *)

  p140
    Export Agenda Views
        html, ps, pdf, ical
    
    ps2pdf
    
    x  c-x c-w  (+elisp*) (x2)

  ---- p141
    emacs -eval '(......  **!

  ---- p142
    column view (in Agenda)


  ----
  ---- p143
    12 - Markup for Rich Content

    =org has lightweight lang for this (*)

    line
    ----
        \\
    ----
    line

    *bold*  /italic/
     _underlined*
        =verbatim=
            ~code~  *

  ---- p144
    sub / sup    _ / ^

    Latex-like   \alpha \sig  m-tab (=ma)(??)


  p145
    c-c c-x \

        toggle display as U8 chars

    Embedded Latex ***
        (+mathjax or im.s)
    
    \begin {eq .....
             (+options)

  p146
    Preview Latex fragm.s
        c-c c-x c-l
    
    cdlatex minor-mode *

  ---- p147
    c-c {     (*)
     tab   `
     ^     '
     -

        evince -p 18 ~/gdrive/rsc/Doks/em.org.pdf &

  ---- p147
    Literal Ex.s
    
    #+BEGIN_EXAMPLE
        ......

    #+BEGIN_SRC emacs-lisp -n 20
        ****

    (ref:name)

        [[ (name ]]  (+hover)

                    -r

            =remove labels

  ---- p149
    -l "((%s))"

    Image-links *

  ---- p150
    c-c c-x c-v
        toggle inline display of im.s
    
    #+CAPTION

    - - - - 

    Footnotes   [fn:1]

        + + +
    
    (+cmds)

  ----
  ---- p153
    13 - Exporting

    ascii, beamer, html, ical, latex, md, odt,
     org, texinfo, man
            (+install more)

    c-c c-e

  p153
      c-a
      c-b
      c-S(ubtree)
      c-v
    Export-Settings

  ---- p154
    AUTHOR, CREATOR ....
    DATE, Email
    SEL/EXCLUDE_TAGS
      .....
      .....
      .....
    '
    *
    _
    :
    <
    \n

  ---- p155
     .....
     .....
     .....

        incl. entities footn.
    
    H  num. of headl.s for exp.

      todo
    
     |

  p156  Table of Contents

  p157  Include(-)Files (*)
    example export scr

    +specif lines

        evince -p 19 ~/gdrive/rsc/Doks/em.org.pdf &
    
    ""three left curly brackets (!!)""


  ---- p159  + Predefined Macros
                 *
        (keyw, title etc)

  ---- p160  ' '#' '  =commented
    clean text --- export (ascii etc)
                    |
  ----
                width etc
  ----
  p162  Beamer exp. *!

  p165  Org Beamer Mode
         +c-c c-b

    'A Beamer Emample' *
  
  p166  HTML Export

    Doctype (etc)
        incl html5 *

  ---- p168
    preamble / postamble

  p170  Math formatting
  
  p171  text areas
    CSS support *!

  p172  + JS-support *!

  ---- p173  Latex / PDF Export  **

  p176  Quoting Latex Code **

    + tables
        im.s
      plain lists

  ---- p179
    Source Blocks *
  p180
    Example Blocks
     +special blocks (??)

  ---- p181  Markdown Export

    ODT Export *
      + Extending ODT Export

    (+doc, docx, rtf, pdf)

  ---- p183
    Converting + LOffice / Pandoc *

    +Custom Styles
        + Links
    
    Tables
        im.s

  ---- p185  Clickab. im.s (!!*)
    Math
    Latex
  
  p187  MathML / ODoc formulas

    literal examples

  ---- p188
    Advanc. Topics
    ODoc Style Files *
    'one off-styles'

    customize tables

        evince -p 20 ~/gdrive/rsc/Doks/em.org.pdf &

  ---- p192
    Validate ODoc
    Xml

    OrgExport
     ----
    TexInfo Export *

  ---- p193-194

    Info directory file

  p195  Quoting Texinfo Code **

  p196  Plain Lists
            
            tables
              im.s
            quotes
  p197
        Ex.s
    iCal Export     p199

  p200
    Advanc. Exp. Conf.

    hooks (=elisp*)
        |
  ---- p201
    Filters (**)

  p202
    extend existing backend

    p203  export to minimal HTML

  ----
  ---- p204
    14 - Publishing

        += convert files into pdf (*)

    sources + destinations

  p206  Options for the exporters
            (+for the diff formats)

  p210  'Publishing Links'
            (='create link fr. one org file to another')

  p211
    Generate a Sitemap *!!

  p212
    Generate an index
    
        +rsync/union ?
    
    (+Example Conf.s)

  ---- p214  Trigger the Public(ation(??))

  ----
  ---- p215
    15 - Working w. Source Code
        ((=CHECK/LISTEN MORE (!!!!!) ))
          ***!
    
      - uses appropr. maj mode
      - Can extract code +
         export to source files

    Compile the Code

  ---- p216
    Structure of Code Blocks *!!

  p217
    15.3 Using Header arguments *
          + (setq  | ..... |  *

  p218  Code block specif.
    
        evince -p 21 ~/gdrive/rsc/Doks/em.org.pdf &

    #+CALL:

    15.4 Environm. of a CodeBl.
            +passing arg.s
        v
        v
        v
        v
        v
        v
        v

  p224
    choosing a wdir (*!!)

  p225
    headers + footers (?)
        (=elisp*)
    
  15.5 Eval.ing Code Blocks
   *!  #+CALL: call_<name> **

  p227
    limit codeblock evaluation

    Cache results

  15.6 Results of Eval.  v
                         v
                         v
                         v
                         v
                         v
                         v
                        v
                       v
  p232
    Post-processing
            :post  (+Example

  p233
    Exporting Code blocks
        'code', results, both, none

  p234
    15.8 Extracting Source Code

  p236
    Supported Langs *!

  p237
    Edit Source Code *!

    c-c '
      c-x c-s

    <<Ref to o(ther(??)) Code blocks>>
        "noweb"

  p241
    15.12  Libr. of Babel
      = 'a collection of code blocks'

    Key bindings
      + useful functions *

    c-c c-c  (etc)

  ---- p242
    15.14 Batch Exec. (+elisp) *

  ----
  ---- p243
    16 - Misc. *

    esc-tab  cs-i  (*)

    Insert Template

        c-c c-,

     a
     c
     .
     .
     .
     .

  ----

    16.3  Speed Keys
            (=single keys in headers)

    16.4  A Cleaner Outline View

  p245  Org indent mode
    - hard indentation

        evince -p 22 ~/gdrive/rsc/Doks/em.org.pdf &
  
  p246
    16.5  c-c c-s  (etc) *

    16.6
      = org num min. mode  *
    
    (+ 'turn on globally for all org files)


    16.7
        c-c c-c  (!!)

    16.8   p247-250
        In Buf. Settings
            (=summary)

     #+ARCHIVE:  etc
         .
         .
         .
         .

        evince -p 23 ~/gdrive/rsc/Doks/em.org.pdf &

    16.9 Org Syntax
            (on Worg)

      a-:    ((= inspect syntax))  *

    16.10
      c-c c-x i

      Escape char.


      Code eval.  + secur.


    16.3  Packages that Org cooperates with

        calc.el
        constants.el
        cdlatex
         imenu
        speedbar
        tabk

        (+pack.s that conflict w. org)


}}}

}}}
Compiling/Working with Code {{{
Progr.Langs Plugins [***(!!)] {{{
  Python {{{
    search: emacs python code completion
    https://tkf.github.io/emacs-jedi/latest/
    https://realpython.com/account/signup/?intent=continue_reading&next=%2Femacs-the-best-python-editor%2F
    https://www.emacswiki.org/emacs/PythonProgrammingInEmacs
    https://steelkiwi.com/blog/emacs-configuration-working-python/
    https://pythonawesome.com/an-emacs-package-to-bring-powerful-python-editing-to-emacs/
    https://emacs.stackexchange.com/questions/9696/how-do-you-create-a-robust-python-ide-with-emacs-as-the-text-editor
  }}}
  Android {{{
    https://hypecyclist.org/post/tips-on-android-development-using-emacs/
    https://stackoverflow.com/questions/3644747/how-can-i-develop-for-android-in-emacs
    https://leeadams.dev/blog/i-use-emacs-for-android-development-ama
  }}}
}}}

code navigation:
  project-find-regexp
  c-x 0
  a-,
  a-.
  jump to iostream (=defs etc)    c-click iostream

a-x compile
a-x recompile
make (and g++)

https://stackoverflow.com/questions/740836/compiling-c-programs-with-emacs-on-windows
        https://www3.cs.stonybrook.edu/~alee/g++/g++on_emacs.html
    https://emacs.stackexchange.com/questions/38421/how-to-compile-and-run-a-c-file
    https://www.emacswiki.org/emacs/CompileCommand

https://www.emacswiki.org/emacs/FlyMake
  https://www.flycheck.org/en/latest/user/installation.html#use-package
https://www.emacswiki.org/emacs/CollectionOfEmacsDevelopmentEnvironmentTools
  https://www.emacswiki.org/emacs/CEDET_Quickstart
  https://cedet.sourceforge.net/

}}}
lsp-mode ide, tree-sitter(?? etc) {{{
  https://www.youtube.com/watch?v=E-NAM9U5JYE

      https://github.com/emacs-tree-sitter/elisp-tree-sitter
}}}
cscope {{{
  https://www.emacswiki.org/emacs/CScopeAndEmacs
    cscope alternatives
}}}
. csharp-mode {{{
  https://www.emacswiki.org/emacs/CSharpMode
    https://github.com/emacs-csharp/csharp-mode/issues/271
  https://0x85.org/csharp-emacs.html
}}}
Clojure dev(!!) {{{

Which plugins would be useful to install in Emacs for Clojure development?

Essential Plugins for Clojure Development in Emacs
Here are some highly recommended plugins for Clojure development in Emacs:

Core Plugins:
Cider: A comprehensive Clojure development environment for Emacs. It provides features like REPL integration, code completion, debugging, and more.
paredit: A mode for editing structured data in Emacs, which is particularly useful for working with Clojure's syntax.
flycheck: A linter that can help you identify errors and potential issues in your Clojure code.
Additional Plugins:
projectile: A project management plugin that provides features like project searching, file navigation, and buffer management.
undo-tree: A plugin that allows you to undo and redo changes in a more granular way.
helm: A powerful framework for searching and selecting items in Emacs, which can be used for various tasks like file navigation, buffer switching, and more.
dired: A file manager built into Emacs that provides a powerful way to interact with your filesystem.
Datomic-Specific Plugins (if applicable):
datomic-mode: A plugin specifically designed for working with Datomic in Emacs. It may provide features like query completion, schema visualization, and connection management.
Note: The specific plugins you may need will depend on your preferences and project requirements. You can explore the Emacs package archive (ELPA) to discover additional plugins that might be useful for your workflow.

Installation:

To install these plugins, you can use Emacs' built-in package manager. Open Emacs and press M-x list-packages. Use the C-s command to search for the desired plugin, then press Enter to install it.

By using these plugins, you can create a highly productive and efficient Clojure development environment in Emacs.

}}}
agrep, rg/ag/ack/grep {{{
  https://github.com/Wilfred/ag.el
    https://github.com/emacsorphanage/helm-ag
}}}
guile ide [__] {{{
  https://www.emacswiki.org/emacs/GuileIde
  https://ajnirp.github.io/Emacs-Guile-Primer/
https://www.reddit.com/r/guile/comments/ksbgpt/guile_hacker_handbook_emacs/
https://www.emacswiki.org/emacs/GuileEmacs
https://www.gnu.org/software/guile/manual/html_node/Using-Guile-in-Emacs.html
https://courses.cs.washington.edu/courses/cse341/01wi/linux-emacs/guile-emacs.html
}}}
eshell {{{
  https://www.masteringemacs.org/article/complete-guide-mastering-eshell
}}}
Elisp (including em28 builtin cheat-sheet) {{{
http://xahlee.info/emacs/emacs/modernization_of_elisp.html

    https://www.masteringemacs.org/article/emacs-builtin-elisp-cheat-sheet
M-x shortdoc-display-group

    https://github.com/bbatsov/emacs-lisp-style-guide
    https://www.emacswiki.org/emacs/CodingStyle
ELisp Cookbook, Style Guide, Nifty Tricks (etc) - Links {{{

https://masteringemacs.org/reading-guide        https://www.masteringemacs.org/article/evaluating-elisp-emacs

    https://github.com/p3r7/awesome-elisp
https://alhassy.github.io/ElispCheatSheet/
https://www.emacswiki.org/emacs/ElispCookbook
}}}
        https://7id.xray.aps.anl.gov/software/emacs/html/elisp_44.html
        https://www.gnu.org/software/emacs/manual/html_node/elisp/Tips.html
    --
https://www.emacswiki.org/emacs/EmacsNiftyTricks


  ~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/gnu_emacsman.txt

___ElispStartwith
~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/Elisp-IntroTo.txt
  ~/Empire/Doks/Comp/emacs/elisp_refman.pdf
      ~/Dropbox/rsc/Doks/elisprefman.annot.pdf
  https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html        #ELISP INTRO
    ~/Dropbox/rsc/data/lists/learnqna/vanki/comp/lang/elisp/
        elisp_refman.bmk01-02.txt
        elisp_refman.bmk03-04.txt
        elisp_refman.bmk05-06.txt
        elisp_refman.bmk07-08.txt
        elisp_refman.bmk09-10.txt
        elisp_refman.bmk10--12.txt
        elisp_refman.bmk12--14.txt
}}}
https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/cl-lib.el
gdb {{{
  https://undo.io/resources/gdb-watchpoint/using-gdb-emacs/
}}}
indentation {{{
setting level (+only spaces)

  https://www.emacswiki.org/emacs/NoTabs
      https://www.emacswiki.org/emacs/IndentationBasics
  https://stackoverflow.com/questions/69934/set-4-space-indent-in-emacs-in-text-mode
  https://home.cs.colorado.edu/~main/cs1300-old/cs1300/doc/emacs/emacs_24.html
          https://dougie.io/emacs/indentation/
}}}
code completion {{{
  https://superuser.com/questions/231384/how-to-get-code-completion-in-emacs [***]
}}}
Pdf-Tools (*(*)) {{{
https://github.com/mishoo/pdf-mode.el  [****]
  https://itexpertly.com/how-to-view-and-annotate-pdf-files-in-emacs/

em:pdf-tools(**!) {{{

james cash**:  https://www.youtube.com/watch?v=zqc-CWm4DGE
    https://github.com/politza/pdf-tools (****(!!))
http://pragmaticemacs.com/emacs/view-and-annotate-pdfs-in-emacs-with-pdf-tools/

c-c c-l         store cliplink (=in reading list(??))
--
c-c c-a h       highlight w. yellow
c-c c-a t       annot. w. text
c-c c-a o       strikethrough text
c-c c-a D       del. an annot.

}}}
.   Emacs Pdf-Tools****  (+Org-Mode) {{{
    https://github.com/politza/pdf-tools
      https://emacsnotes.wordpress.com/2018/08/09/222/  #=older docview
    https://github.com/politza/pdf-tools/tree/master/lisp
          (=clone down + search/extract all 'define-key' *****)
        eg. c-c c-c   commit, c-c c-q    abort, 
         c-c c-f, space
            l   list annots
            a   (dired?)
            (d   display annot.s)
            D   del
            t   add text annot
            m   markup annotation
            s   squiggly
            u   underline
            o   strikeout
            h   highlight
         +Menus (=change colors etc)
        annot **(*!)
            https://github.com/politza/pdf-tools/blob/master/lisp/pdf-annot.el
        cache
        dev
        history
        info
        isearch
        links
        loader
        misc
        occur
        outline
        sync
        tools
        util
        view
        virtual
    http://alberto.am/2020-04-11-pdf-tools-as-default-pdf-viewer.html
    --
    https://emacs.stackexchange.com/questions/19686/how-to-use-pdf-tools-pdf-view-mode-in-emacs
    https://www.emacswiki.org/emacs/PdfTools
     https://www.emacswiki.org/emacs/pdftools.el  (??)
----
edit (raw) pdf w. emacs
    https://emacs.stackexchange.com/questions/49/how-to-view-and-edit-pdf-files-in-emacs
    https://github.com/mishoo/pdf-mode.el
            http://qpdf.sourceforge.net/
}}}
https://github.com/vedang/pdf-tools  https://pdftools.wiki/555b4a2a

}}}
dired (+icicles) {{{
  https://www.youtube.com/watch?v=PMWwM8QJAtU

  https://www.opensourceforu.com/2015/09/the-basics-of-dired-mode-in-emacs/
        https://www.emacswiki.org/emacs/Icicles_-_Dired_Enhancements

open directory:
n p  c-n c-p
file-mark      %
! R Copy
&libreoffice   (open with external program)
q
? M Y

}}}
include/show images __ __ __!! {{{

To automatically load and display images in Emacs, you can use the image-mode package. This package provides functions for loading and displaying images within Emacs buffers.

Here's a step-by-step guide on how to automatically load and display images in Emacs:

Install the image-mode package:

If you haven't already, install the image-mode package using your preferred package manager. For example, if you're using package.el, you can add the following line to your ~/.emacs file:

Lisp
(package-install-from-url "https://melpa.org/packages/image-mode.el")

Add the following code to your ~/.emacs file:

Lisp
(require 'image-mode)

(add-hook 'after-file-read-hook 'image-display-inline-images)

This code will enable image display in Emacs buffers and ensure that images are automatically loaded and displayed when a file is opened.

Restart Emacs:

After saving the changes to your ~/.emacs file, restart Emacs for the changes to take effect.

Now, when you open a text file containing image links, Emacs will automatically load and display the images within the buffer. You should no longer need to click or press Enter on the image links.

Very nice! And I'm trying to find it, but could you remind me of the syntax in my text file for linking to the file.
The syntax for linking to an image file in an Emacs text file depends on the format you want to use. Here are two common options:

Using [[..]] links:

[[image file://path/to/image.png]]

This syntax uses Emacs's built-in link system. When you place your cursor on the link, Emacs will display a preview of the image. Click on the link to view the full-sized image.

Using org-image-link links:

[[image http://path/to/image.png]]

This syntax uses the org-mode package's image linking feature. This method allows you to embed images directly into the text, without the need for any additional clicking or hovering.

Both methods will automatically load and display the images in Emacs once you've enabled image display using the image-mode package and the after-file-read-hook.

    iimage.el (**)
        https://stackoverflow.com/questions/9780124/insert-image-into-text-buffer
        https://github.com/typester/emacs/blob/master/lisp/iimage.el
        https://aidan.codes/blog/2010/10/displaying-inline-images-in-emacs-org-mode/  **!
}}}
Emacs, Termux, Show Images (+folding) {{{

One of the features that will definitely enhance my workflow if I can get it setup properly would be to be able to have text-files with included paths or links to image-files that can then be shown directly as images 'embedded into the text-flow', which is one of the reasons I would really like to explore Emacs for Android, i.e. the program I most frequently have used for using text-files for planning all manner of things, writing flashcard-like functionality using folds (by jotting down questions and having the answer hidden until I tap the fold) has been a complete game-changer for me, but Vim cannot handle rendering image-files to screen as though 'embedded in the text-flow'

Ah, the ability to embed images directly within your text files in Emacs – that's a fantastic feature for enhancing your workflow! You're spot on; Vim doesn't handle inline image display in the same way Emacs can.

You'll be pleased to know that Emacs, especially with Org-mode, can indeed achieve this kind of "embedded image in text-flow" functionality on Android through Termux. Here's how it generally works and some things to keep in mind:

How Emacs Handles Inline Images:

Emacs relies on specific packages and configurations to render images within a buffer. The most common way to achieve this is through:

    Image Dired: While primarily for managing directories of images, Image Dired can also display images inline within a text buffer when you navigate through image files. This might not be exactly "embedded in the text-flow" in the sense you're thinking, but it's a related image-viewing capability.
    Specific Packages (like display-inline-images or functionality within Org-mode): These packages or features within Org-mode allow you to link to image files (using a specific syntax) and have Emacs render them directly in the buffer.

Org-mode and Inline Images:

Org-mode has excellent support for linking to and displaying images. You can typically embed an image using a link like this:
Code snippet

[[./path/to/your/image.png]]

When Emacs processes this link (often with a specific command or when the buffer is displayed), it can render the image inline.

Considerations for Android/Termux:

    Package Availability: You'll need to ensure that the necessary Emacs packages (if you choose to use one beyond Org-mode's built-in capabilities) can be installed and function correctly within the Termux environment. Generally, most Emacs Lisp packages work fine in Termux, but there might be occasional exceptions if a package has very specific dependencies on graphical libraries not readily available on Android.
    Image Format Support: Emacs typically supports common image formats like PNG, JPG/JPEG, and GIF. Ensure the images you want to embed are in a format that Emacs on Android can handle.
    Performance: Displaying many or very large images inline could potentially impact performance, especially on a less powerful device like your Samsung Galaxy A20. Emacs needs to decode and render these images, which can consume resources. Experimenting with a few images will give you a sense of the performance.
    File Paths: Ensure that the paths to your image files are correctly specified and accessible from within the Termux environment. If your images are stored in Android's internal storage or an SD card, you'll need to use the appropriate paths that Termux can access. Termux's file system is somewhat sandboxed, so you might need to navigate or link files accordingly.

How to Get Started:

    Install Emacs in Termux: If you haven't already, follow the instructions to install Emacs within your Termux environment.
    Explore Org-mode's Image Linking: Once Emacs is running, try creating a simple .org file and include a link to an image file that you have stored on your device (making sure the path is correct). See if Org-mode renders it inline. You might need to execute a specific command within Emacs (like C-c C-x C-v in Org-mode, which toggles inline image display) or have a specific configuration in your Emacs initialization file (.emacs or init.el).
    Consider display-inline-images (if needed): If Org-mode's built-in capabilities don't fully meet your needs, you can explore the display-inline-images package from GNU ELPA (Emacs Lisp Package Archive). You can install this from within Emacs using the package manager (M-x package-install RET display-inline-images RET). This package provides more general inline image display capabilities in Emacs buffers. You'll need to configure it to recognize the syntax you want to use for embedding images.

Regarding your flashcard-like functionality with folds: Org-mode excels at this! The folding capabilities (using TAB to show/hide content) combined with inline images could create a very powerful learning tool.

In summary, the "embedded image in text-flow" experience you're aiming for is definitely achievable with Emacs on Android, especially with Org-mode. You might need to do a bit of experimentation with file paths and potentially explore some Emacs packages to get it exactly how you want it. Starting with Org-mode's linking capabilities is a great first step.

Let me know how your exploration goes, and if you encounter any specific issues with image display in Termux Emacs, I'll do my best to help!

I'm thinking one way to speed up rendering of images would be to use vector-graphics instead of pixel-graphics, for which I know there is some support in Emacs, and I have all the relevant graphics in vector-format as well, so having the image-resources/the 'supply of vector-images'-problem is a problem solved.

That's a very insightful point! You're absolutely right; using vector graphics instead of pixel-based images could indeed lead to significant performance benefits, especially in terms of rendering speed and memory usage, particularly on a mobile device like your Samsung Galaxy A20.

Here's why using vector graphics in Emacs on Android via Termux could be advantageous:

    Scalability without quality loss: Vector graphics are defined by mathematical equations rather than a grid of pixels. This means they can be scaled to any size without becoming blurry or pixelated. This is excellent for viewing on different screen sizes and resolutions.
    Smaller file sizes (potentially): For many types of graphics (especially those with clean lines and shapes, like diagrams, logos, and illustrations), vector files (like SVG) can be significantly smaller than their pixel-based counterparts (like PNG or JPEG) at comparable visual complexity. Smaller file sizes mean less data to load and process, potentially leading to faster rendering and reduced memory footprint.
    Potentially faster rendering (in some cases): While the initial rendering of a complex vector graphic might involve some computation, once rendered, scaling and redrawing can be very efficient. For simpler vector graphics, the rendering overhead might be lower than decoding and displaying a large pixel image.

Emacs and Vector Graphics Support:

You're correct that Emacs has some support for vector graphics, primarily through the SVG (Scalable Vector Graphics) format. Here's how it generally works:

    Built-in Support: Recent versions of Emacs have built-in capabilities to display SVG images using libraries like librsvg (which might need to be available in your Termux environment).
    Image Modes: When Emacs encounters an SVG file (often linked in Org-mode or viewed directly), it should ideally render it using its internal image display mechanisms.
    Potential Need for Configuration: You might need to ensure that the necessary libraries (librsvg or similar) are installed within your Termux environment for Emacs to leverage them. This might involve using Termux's package manager (pkg install librsvg, for example). You might also need to configure Emacs to properly associate SVG files with the correct rendering backend.

How to Implement Vector Graphics in Your Workflow:

    Ensure SVG Support in Termux Emacs: After installing Emacs in Termux, check if you can already view SVG files directly (e.g., by opening an SVG file in Emacs). If not, investigate if you need to install any additional packages within Termux, like librsvg.

    Link SVG Files in Org-mode: Just as you would link to PNG or JPG files, try linking to your SVG files in your Org-mode documents:
    Code snippet

    [[./path/to/your/vector_image.svg]]

    Test Rendering: See if Emacs renders the SVG image inline. You might need to use the same commands as for raster images (like C-c C-x C-v in Org-mode).

    Configure Emacs (if necessary): If SVG rendering isn't working out of the box, you might need to add some configuration to your Emacs initialization file (.emacs or init.el) to explicitly enable SVG support or associate the .svg extension with the appropriate image handling. You might find relevant configuration snippets by searching online for "Emacs SVG support" or "display SVG in Emacs."

Considerations for Android/Termux with SVG:

    Library Availability: While librsvg is a common library for SVG rendering, its availability and proper functioning within the Termux environment are key.
    Performance: While generally efficient, rendering very complex SVG files with a large number of elements might still be computationally intensive, even on a more powerful Android device. Experimentation will be important.
    Battery Life: Increased processing for rendering (especially complex graphics) could potentially impact battery life, although the efficiency of vector graphics might mitigate this compared to repeatedly rendering large pixel images.

In conclusion, your idea to leverage vector graphics is excellent and holds significant potential for improving performance and scalability of embedded images in Emacs on your Android device. By focusing on SVG files and ensuring the necessary support is available in your Termux Emacs setup, you could have a much smoother and more efficient experience with inline images.

Do let me know if you encounter any specific challenges getting SVG rendering to work in your Termux Emacs environment – I'm happy to try and help troubleshoot!

And also, I wonder what the best solution for getting the 'showing questions but have the answers hidden by default' going would be. In Vim I've solved the issue by using folding, and the solutions I could see as viable on Emacs I guess would be the Vimish Folds-package, using some default functionality in Org-mode to tuck away the answers until I tap a particular fold or pocket that holds the hidden answer (or image, which is one of the real prices to be able to use), flashcard.el, org-drill.el, or something similar that I'm not aware of yet

You're on the right track! Emacs offers several excellent ways to achieve the "show question, hide answer" functionality, and your initial thoughts about Org-mode's built-in features and dedicated flashcard packages are spot on. Let's break down the options and discuss their suitability:

1. Org-mode's Built-in Folding:

This is likely the most straightforward and integrated approach if you're already planning to use Org-mode extensively (which seems to be the case given your interest in inline images).

    How it works: Org-mode allows you to create hierarchical structures using headings. You can then "fold" (collapse) these sections, hiding the content beneath a heading. You can use this to represent questions as headings and the corresponding answers as the content under those headings.

    Example:
    Code snippet

    * What is the capital of France?
    ** Paris
    * What is the chemical symbol for water?
    ** H2O
    * [[./images/periodic_table_excerpt.svg]]
    ** This image shows a part of the periodic table.

    In this example, the lines starting with a single * are the questions (headings level 1), and the lines starting with ** are the answers (headings level 2). You can use the TAB key to collapse and expand the content under each question heading, effectively hiding and revealing the answers (and even embedded images).

    Advantages:
        Built-in: No need to install extra packages if you're already using Org-mode.
        Simple to use: Folding is a fundamental Org-mode feature with intuitive keybindings.
        Versatile: You can include text, images, and even other Org-mode structures within the folded sections.
        Persistence: Fold states can often be saved with the file.

    Considerations: It's manual in the sense that you're explicitly folding and unfolding. It might not have the spaced repetition algorithms of dedicated flashcard software.

2. flashcard.el:

This is a dedicated Emacs package specifically designed for creating and reviewing flashcards.

    How it works: flashcard.el provides a specific syntax for defining flashcards (typically with a question and an answer separated by a delimiter). It often includes features like randomizing card order and potentially some basic review scheduling.
    Advantages:
        Purpose-built: Designed specifically for flashcard creation and review.
        Organized structure: Provides a clear way to define questions and answers.
        Review features: May include randomization and basic scheduling.
    Considerations:
        Separate package: Requires installation.
        Syntax: You'll need to learn the specific syntax used by flashcard.el to define your cards.
        Integration with images: You'll need to check how well it handles embedding image links within questions or answers.

3. org-drill.el:

Another popular Emacs package built on top of Org-mode, specifically for spaced repetition learning.

    How it works: org-drill.el allows you to create flashcards within your Org-mode files and then uses a spaced repetition algorithm to schedule reviews based on how well you recall the information.
    Advantages:
        Spaced repetition: Optimizes review times for better retention.
        Org-mode integration: Leverages Org-mode's structure and formatting.
        Active recall: Encourages active retrieval of information.
    Considerations:
        Separate package: Requires installation.
        Learning curve: Understanding and using spaced repetition concepts might take a bit of time.
        Image handling: Similar to flashcard.el, you'll need to ensure it handles image links within questions or answers as desired.

4. vimish-fold:

This package aims to bring Vim-like folding functionality to Emacs.

    How it works: It provides commands and keybindings similar to Vim's folding mechanism, allowing you to define folds based on indentation, markers, or other criteria.
    Advantages:
        Familiarity for Vim users: If you're coming from Vim and are comfortable with its folding, this might feel natural.
        Flexibility: Can be configured to fold based on various patterns.
    Considerations:
        Separate package: Requires installation.
        Integration with Org-mode: While it can fold Org-mode structures, it might not be as semantically aware of Org-mode elements as Org-mode's native folding.
        Image handling: Folding itself doesn't directly handle image embedding; that would still rely on Emacs's general image display capabilities within the folded regions.

Recommendation:

Given your existing positive experience with folding in Vim and your interest in embedding images, Org-mode's built-in folding is likely the best starting point for you.

    It's already integrated if you're using Org-mode.
    It's simple to use for creating question/answer pairs.
    It can readily accommodate links to image files within the answer sections. When the answer is unfolded, Emacs should render the image if it's configured to do so.

You can then explore org-drill.el if you want to add the benefit of spaced repetition to your learning. It also works within the Org-mode framework, so the transition might be smoother.

flashcard.el is also a viable option if you prefer a more dedicated flashcard structure, but you'll need to familiarize yourself with its specific syntax and ensure it meets your image embedding needs.

vimish-fold could be an option if you strongly prefer Vim's folding behavior, but for leveraging Org-mode's features and potential for image embedding, sticking with native Org-mode folding or an Org-mode-based flashcard package like org-drill.el might be more seamless.

Next Steps:

    Experiment with Org-mode folding: Try creating a simple .org file with questions as headings and answers (including image links) as sub-content. Use TAB to fold and unfold.
    Investigate org-drill.el: If you're interested in spaced repetition, look into installing and using org-drill.el with your Org-mode flashcards.
    Check image rendering within folded sections: Ensure that when you unfold an answer containing an image link, the image is displayed correctly in your Emacs on Android.

By starting with Org-mode's native folding, you can quickly get the "show question, hide answer" functionality working and see how well it integrates with your desire to embed images. Good luck!



Great. The first option sounds like the one I would possibly like to use. One of the reasons I did not use Anki but wrote my own simple text-based clone in Vim using folding, is that Anki is effective and very good, but as long as one could responsibly keep tabs of what material to prioritize (using tags and the like), Anki (at least in the beginning) becomes an almost untenable option, as too much time has gone into creating the repetition-algorithms and such, and if one wants to break the mold and e.g. rush through material to get a feel for it, in Anki that requires quite complex fiddling with Python-syntax and the like to tinker with the basic repetion-pattern. What I in effect found when trying to use Anki (although I'm pretty sure I will actually get back to using it some day in the future, because it IS very good), is that Anki can be such a complicated program to handle (and the daily workflow of it) that one would essentially need to know Anki (at fairly well) to be able to learn to use Anki well, i.e. a catch 22 or bootstrapping-problem.

That's a very insightful and well-articulated reason for preferring a simpler, text-based approach initially! You've perfectly captured the potential "bootstrapping problem" with powerful, feature-rich software like Anki. Sometimes, the overhead of learning the tool itself can detract from the primary goal – learning the material.

Your experience resonates with many who appreciate the directness and flexibility of plain text and simpler tools. Using Vim's folding to create your own flashcard system allowed you to focus immediately on your learning content without getting bogged down in complex software features or algorithms.

Given this, leveraging Org-mode's built-in folding within Emacs on Android seems like an even more ideal first step for you. It offers that same directness and text-based simplicity you appreciated in your Vim setup, while also opening the door to Emacs's rich ecosystem and features like inline image display when you're ready.

Here's why Org-mode folding aligns well with your preferences:

    Simplicity: Creating foldable sections in Org-mode is as easy as using asterisks (*) to define headings. The folding/unfolding with TAB is intuitive.
    Direct Focus on Content: You can immediately start writing your questions and answers in a plain text format, embedding image links as needed, without having to learn a specific flashcard syntax or database structure.
    Flexibility: You have complete control over how you organize your material. You can easily prioritize content using Org-mode's tagging and outlining features, just as you envisioned.
    Gradual Complexity: You can start with basic folding and gradually explore more advanced Org-mode features (like tagging, priorities, and even potentially integrating with packages like org-drill later on if you decide you want spaced repetition). This allows for a much smoother learning curve.
    Image Integration: As we discussed, Org-mode can handle links to images within the folded sections, addressing one of your key motivations for exploring Emacs.

Moving Forward with Org-mode Folding:

    Start Simple: Begin by creating a new .org file in Emacs on your Android device (via Termux).
    Structure with Headings: Use * for questions and ** for answers (or deeper levels for more complex answers).
    Embed Image Links: Include links to your vector graphics (or other image formats) within the answer sections.
    Use TAB for Folding: Experiment with using the TAB key while your cursor is on a heading to collapse and expand the content.
    Explore Tagging and Priorities: As your collection of flashcards grows, you can use Org-mode's tagging (:tag1:tag2:) and priority ([#A], [#B], [#C]) features to help you focus on specific material.

By taking this approach, you can recreate the essence of your text-based Vim flashcard system within Emacs, gaining the benefits of image embedding and the potential for future expansion into more structured learning tools within the Emacs ecosystem at your own pace.

It sounds like you have a clear understanding of your learning style and the kind of tool that works best for you in the initial stages. Org-mode's folding offers that balance of simplicity and power that could be a perfect fit! Let me know if you have any questions as you start experimenting with it.


}}}
image dired {{{

em:image-dired|dired-plus(**) {{{

https://ryanfaulhaber.com/posts/cool-emacs-dired/
    ~/Dropbox/rsc/aubooks/comp/image-dired.emacs.txt

. "L =" rotate, move around, resize, image(??) html gallery
- Run Imag.(dired?) on im. fr. w. in Em. (*(??))
- 'Info-goto-node .....   Image-Dired  (!/??)
(( - c-h k <f5> c-e  ???))

 -- --

- browse, organize, tag
- "You can read more about ..." + im-dired.el
      define-key--section (=past mid-file**)
- Bookm. Tags
- Features *!
   ...
   ...
   ...
     'dired-do-shell-command'
(- respect exif-orientation)
(- Gallery  + tags-links *!  + add CSS-file (=to style the gallery))

 -- -- --
 -- -- --

[=last section(!!)]

enter image-dired (*) ; m (=mark image-file)  + c-t d (=show marked as thumbs *)
a-x image-dired (+dir(ectory))

open larger image preview fr. thumbnail * ; Ent
(move around in (=image preview-)buffer (??(/*)) ; arrowkeys)
display next/prev. image ; space // del.

view im. in orig. size // w. external program ; c-u Ent // c-Ent

 -- --

del. image ; flag im. for deletion in dired (=d) + delete
del.(=remove?) thumbnail im. fr. thumbnail buffer ; c-d

[image-dired-db-file]
mark files for tagging *! ; m c-t t (=fr. dired buffer or thumbnail buffer)
view files marked w. cert. tag (??/!) ; c-t d

- tag / rm tag directly fr. thumbnail buffer ; t t / t r  *(*)
- enter comment for im. (=fr. thumbnail buffer / dired) **! ; c / c-t c
- Rotat. image left/right *  ("+jpegtran"(?)) * ; l / r  #"L/R"

}}}

  ~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/image-dired.emacs.txt

  http://ergoemacs.org/emacs/emacs_view_images.html
}}}
web browser: wowser, w3m etc {{{
  https://www.emacswiki.org/emacs/CategoryWebBrowser
  https://www.emacswiki.org/emacs/w3
  https://www.emacswiki.org/emacs/emacs-w3m
  https://github.com/emacs-w3m/emacs-w3m
    https://www.emacswiki.org/emacs/EmacsXWidgets
  https://en.wikipedia.org/wiki/Eww_(web_browser)

    emacs w3m
        https://emacs-w3m.github.io/
        https://www.emacswiki.org/emacs/emacs-w3m
                https://www.emacswiki.org/emacs/w3m
            https://github.com/emacs-w3m/emacs-w3m
}}}
Translate-Shell {{{
  https://github.com/xuchunyang/translate-shell.el
    https://www.emacswiki.org/emacs/GoTranslate
}}}
vimish fold {{{
Vim Folding In Evil (**) {{{
https://emacs.stackexchange.com/questions/14781/how-can-i-replicate-vims-code-folding
    https://github.com/magnars/fold-this.elttps://github.com/magnars/fold-this.el
https://github.com/matsievskiysv/vimish-fold @@ __
[ https://github.com/matsievskiysv/vimish-fold/blob/master/vimish-fold.el ]
}}}
    +Org Mode Vimish Fold
}}}
Org Roam {{{
  https://www.youtube.com/watch?v=AyhPmypHDEw

  https://www.orgroam.com/manual.html
}}}
'emacs anki' (=org drill) {{{

  Org-Drill
    https://orgmode.org/worg/org-contrib/org-drill.html
    https://github.com/louietan/org-drill
      https://numbersmithy.com/spaced-repetition-in-emacs-org-mode/
    search: anki like flashcards practice in emacs
      https://tools2study.com/en/learn/anki-alternatives/
    emacs anki
      https://github.com/aytung/emacs-anki/blob/master/emacs.el
}}}
emacspeak(!) {{{
  https://www.emacswiki.org/emacs/EmacSpeak

http://emacspeak.sourceforge.net/
https://www.emacswiki.org/emacs/EmacSpeak
https://github.com/tvraman/emacspeak
http://tvraman.github.io/emacspeak/manual/
}}}
draw svg/xpm(?) graphics {{{
}}}
Videos/Graphics in Emacs {{{
  https://github.com/emacs-eaf/emacs-application-framework [****]
}}}
markdown mode {{{
  https://jblevins.org/projects/markdown-mode/
    https://leanpub.com/markdown-mode [**]
}}}
irc {{{
irc in emacs
    https://www.emacswiki.org/emacs/ERC
}}}
.  latex/context {{{
  AUCTeX
  https://www.emacswiki.org/emacs/AUCTeX
}}}
texinfo {{{
  https://www.gnu.org/software/texinfo/manual/texinfo/texinfo.pdf
}}}
(ddoc ??) {{{
}}}
EXWM {{{
  https://wiki.archlinux.org/title/EXWM
  https://www.youtube.com/watch?v=f7xB2fFk1tQ&list=PLEoMzSkcN8oNPbEMYEtswOVTvq7CVddCS
}}}
. bongo (+amarok etc) {{{
https://www.emacswiki.org/emacs/BongoHacks
https://protesilaos.com/codelog/2020-08-06-emacs-bongo-extras/
    https://github.com/dbrock/bongo
https://robinst.github.io/taglib-ruby/

https://www.emacswiki.org/emacs/MusicPlayers
https://github.com/dbrock/bongo
https://github.com/dbrock/bongo/blob/master/bongo.el
https://www.emacswiki.org/emacs/Bongo
https://www.emacswiki.org/emacs/EMMS
  https://www.emacswiki.org/emacs/amarok.el
}}}


searches lifted from 'weblinks' {{{
https://github.com/Emacs-D-Mode-Maintainers/Emacs-D-Mode

https://www.gnu.org/software/emacs/manual/html_mono/cl.html

https://www.emacswiki.org/emacs/ElispCookbook
https://www.emacswiki.org/emacs/EmacsNiftyTricks
    https://www.emacswiki.org/emacs/EmacsCrashTips
https://wiki.call-cc.org/emacs emacs chicken-scheme
    https://www.inmotionhosting.com/support/edu/emacs/dired/

http://cl-cookbook.sourceforge.net/emacs-ide.html

emacs guile: paredit, geiser

vim|emacs as a python ide
https://rapphil.github.io/vim-python-ide/
        https://peach-melpa.org/themes/eziam-theme
https://realpython.com/emacs-the-best-python-editor/
Emacs Edit PHP (!!)
    https://github.com/emacs-php/php-mode
http://xahlee.info/emacs/emacs/emacs_init_index.html

http://paulgraham.com/avg.html  #about clisp
    Search: Emacs Lisp Cheat Sheet
    How to Learn Emacs: 2 Hand Drawn CheatSheets ***
        https://sachachua.com/blog/2013/05/how-to-learn-emacs-a-hand-drawn-one-pager-for-beginners/

.emacs lisp (ref, etc) {{{
    https://www.gnu.org/software/emacs/manual/html_mono/elisp.html
    https://www.gnu.org/software/emacs/manual/html_mono/elisp.html
    https://duckduckgo.com/?q=emacs+lisp+functions+reference+list&t=newext&atb=v332-1&ia=web
        https://www.math.utah.edu/docs/info/elisp_12.html
    https://stackoverflow.com/questions/559634/emacs-lisp-function-guide
    https://ftp.gnu.org/old-gnu/Manuals/elisp-manual-20-2.5/html_chapter/elisp_12.html
    https://www.math.utah.edu/docs/info/emacs-lisp-intro_8.html
    https://stackoverflow.com/questions/605785/how-do-i-get-a-list-of-emacs-lisp-non-interactive-functions
}}}
        https://www.newcomplexlight.org/emacs-lisp-nano-cheat-sheet/
    https://www.masteringemacs.org/article/emacs-builtin-elisp-cheat-sheet
        https://www.dunebook.com/best-emacs-plugins/
    http://xahlee.info/emacs/emacs/elisp_format.html

            --
                https://github.com/hlissner/doom-emacs
                https://github.com/hlissner/doom-emacs/blob/master/docs/getting_started.org

    https://www.emacswiki.org/emacs/ElispCookbook
https://www.emacswiki.org/emacs/SiteMap

    https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-lilypond.html  (***(!!))
                    https://www.emacswiki.org/emacs/AutoCompleteSources
Emacs: Evil Install(*), package-man,  insert image*, imagemode,  open file w. ext. progr, JS in Emacs(**), WebDev in Emacs,  dlang-mode, ly-mode! {{{

https://github.com/emacs-evil/evil
    https://www.emacswiki.org/emacs/ELPA
                        https://github.com/technomancy/package.el
    https://readthedocs.org/projects/evil/downloads/pdf/latest/
----
https://github.com/emacs-evil/evil-collection

SystemCrafters (=video list) {{{

    https://www.youtube.com/c/SystemCrafters/videos?view=0&sort=da&flow=grid

    ___start(=emacs(!!))

30:49
Now playing
Introduction to Functional Programming with F# - Part 1 [Episode 001]
102K views5 years ago

17:45
Now playing
Records and Discriminated Unions - F# Part 2 [Episode 002]
24K views5 years ago

43:19
Now playing
Functional Game Logic with State Pipelines - F# Part 3 [Episode 003]
23K views5 years ago

26:33
Now playing
Functional Concurrency with the Actor Model - F# Part 4 [Episode 004]
12K views5 years ago

1:03:23
Now playing
Parsing Text with Combinators - F# Part 5 [Episode 005]
12K views5 years ago

1:14:03
Now playing
Live-Coding a BrowserSource Overlay Server for OBS
1.4K viewsStreamed 1 year ago

1:01:01
Now playing
Stream Hacking: Custom OBS Overlay Server
749 viewsStreamed 1 year ago

1:29:16
Now playing
Stream Hacking: Fetching Live Stream Details with YouTube Data API
2.1K viewsStreamed 1 year ago

1:24:20
Now playing
Stream Hacking: Creating a Live Data Channel for Custom OBS Overlay
635 viewsStreamed 1 year ago

1:06:38
Now playing
Stream Hacking: Creating a Live Chat Widget for our OBS Overlay
786 viewsStreamed 1 year ago

    ___start

58:30
Now playing
Emacs From Scratch #1 - Getting Started with a Basic Usable Configuration
74K viewsStreamed 1 year ago
    https://www.youtube.com/watch?v=74zOY-vgkyw&t=253s
----
- systemcreated init-file for emacs:  ~/.emacs (=??)
- create clean init-file:  touch init.el
 - open clean emacs-session:  emacs -q -l init.el


54:42
Now playing
Emacs From Scratch #2 - Adding Helpful UI Improvements
24K viewsStreamed 1 year ago
    https://www.youtube.com/watch?v=IspAZtNTslY

59:26
Now playing
Emacs From Scratch #3 - Key Bindings and Evil
20K viewsStreamed 1 year ago

1:01:25
Now playing
Emacs From Scratch #4 - Projectile and Magit
18K viewsStreamed 1 year ago

47:37
Now playing
Emacs From Scratch #5 - Org Mode Basics
24K viewsStreamed 1 year ago

1:01:51
Now playing
Emacs From Scratch #6 - Organize Your Life with Org Mode
22K viewsStreamed 1 year ago

56:03
Now playing
Emacs From Scratch #7 - Configure Everything with Org Babel
13K viewsStreamed 11 months ago

48:30
Now playing
Emacs Tips - How to Show Reminders for Org Mode Tasks
4.9K viewsStreamed 11 months ago

1:04:44
Now playing
Emacs From Scratch #8 - Build Your Own IDE with lsp-mode
30K viewsStreamed 11 months ago

32:24
Now playing
Emacs Tips - How to Create Your Own Color Theme
4.4K viewsStreamed 11 months ago

1:03:26
Now playing
Emacs From Scratch #9 - Learn to Love the Terminal Modes
11K viewsStreamed 11 months ago

37:32
Now playing
Emacs Tips - How to Use File and Directory Local Variables
2.9K viewsStreamed 11 months ago

56:23
Now playing
Emacs From Scratch #10 - Effortless File Management with Dired
12K viewsStreamed 11 months ago

50:00
Now playing
Emacs IDE - How to Debug Your Code with dap-mode
13K viewsStreamed 11 months ago

1:08:16
Now playing
Emacs Desktop Environment #1 - Getting Started with EXWM
20K viewsStreamed 11 months ago

31:38
Now playing
Emacs Tips - How to Give Presentations with Org Mode
10K viewsStreamed 10 months ago

51:44
Now playing
Emacs Desktop Environment #2 - Improving the EXWM Experience
5.1K viewsStreamed 10 months ago
1:05:50
Now playing
Emacs IDE - Python Development Configuration
18K viewsStreamed 10 months ago

52:28
Now playing
Optimizing Window Placement in EXWM - Emacs Desktop Environment #3
2.6K viewsStreamed 10 months ago

50:10
Now playing
How to Create and Manage Multiple Windows - Emacs Tips
4K viewsStreamed 10 months ago

40:23
Now playing
Using Multiple Monitors in EXWM - Emacs Desktop Environment #4
1.9K viewsStreamed 10 months ago

19:00
Now playing
Organize Your Windows with the Tab Bar in Emacs 27
6K views10 months ago

15:01
Now playing
Dynamic Tiling Windows like dwm in Emacs with Edwina
3.4K views9 months ago

39:11
Now playing
The Perfect Panel: Integrating Polybar with Emacs - Emacs Desktop Environment #5
4.8K viewsStreamed 9 months ago

35:36
Now playing
Unlock the Power of the Daemon with emacsclient
4.9K views9 months ago

32:45
Now playing
Give Emacs Psychic Completion Powers with prescient.el
4K views9 months ago

5:22
Now playing
Happy Holidays, and plans for 2021!
850 views9 months ago

29:57
Now playing
Enabling Desktop Notifications with Dunst - Emacs Desktop Environment #6
1.9K views9 months ago

25:35
Now playing
Teach Emacs to Keep Your Folders Clean
3.3K views9 months ago

1:01:53
Now playing
Streamline Your E-mail Management with mu4e - Emacs Mail
10K viewsStreamed 9 months ago

26:39
Now playing
5 Reasons to Learn Emacs in 2021
44K views9 months ago

28:25
Now playing
Managing Multiple Email Accounts with mu4e and mbsync - Emacs Mail
3.2K views9 months ago

39:52
Now playing
Introduction to Emacs Lisp - Learning Emacs Lisp #1
20K viewsStreamed 9 months ago

38:14
Now playing
How to Encrypt Your Passwords with Emacs
4.7K views9 months ago

26:31
Now playing
What is System Crafting?
2.5K views9 months ago

1:16:13
Now playing
Types, Conditionals, and Loops - Learning Emacs Lisp #2
8.6K viewsStreamed 8 months ago

42:38
Now playing
Compose and Send Email with Emacs - Emacs Mail #3
4.3K views8 months ago

17:18
Now playing
The Basics of Dotfiles
5.1K views8 months ago

1:02:53
Now playing
Defining Functions and Commands - Learning Emacs Lisp #3
5.4K viewsStreamed 8 months ago

29:13
Now playing
Enhance Your Email with Org Mode - Emacs Mail #4
4.1K views8 months ago

16:23
Now playing
How to Create a Dotfiles Folder
4.6K views8 months ago

59:37
Now playing
Defining Variables and Scopes - Learning Emacs Lisp #4
3.4K viewsStreamed 8 months ago

41:56
Now playing
Craft an Email Workflow with Org Mode
3.7K views8 months ago

1:58:00
Now playing
System Crafters Live! - Emacs Startup Speed, Emacs News, Q&A
3.3K viewsStreamed 8 months ago

18:27
Now playing
Keeping Your Emacs Packages Up To Date - Emacs From Scratch #11
2.6K views8 months ago

1:57:58
Now playing
System Crafters Live! - Emacs Future in Danger?, Config Hacking, Q&A
5.7K viewsStreamed 8 months ago

58:14
Now playing
How to Cut Emacs Start Up Time in Half! - Emacs From Scratch #12
4.7K views7 months ago

44:58
Now playing
Hey Emacs, Don't Move My Windows! - Customizing display-buffer's behavior
4.1K views7 months ago

1:55:06
Now playing
System Crafters Live! - Is Lisp a dead language? • Emacs Lisp Hacking • Q&A
3.1K viewsStreamed 7 months ago

2:01:52
Now playing
System Crafters Live! - Should you do everything in Emacs? • Becoming a Lisp Ninja • Q&A
2.7K viewsStreamed 7 months ago

1:03:07
Now playing
Reading and Writing Buffers in Practice - Learning Emacs Lisp #5
4K views7 months ago

2:02:09
Now playing
System Crafters Live! - Emacs Native Comp will change *everything* • Trying out Eglot • Q&A
6K viewsStreamed 7 months ago

1:11:56
Now playing
The Absolute Beginner's Guide to Emacs
50K views7 months ago

1:55:46
Now playing
System Crafters Live! - What is GNU? • Is Sourcehut the future? • Q&A
2.7K viewsStreamed 7 months ago

51:50
Now playing
An Introduction to GNU Guix
16K views6 months ago

2:05:29
Now playing
System Crafters Live! - Static Websites with Emacs, Org Mode, and Sourcehut • Episode planning • Q&A
2.6K viewsStreamed 6 months ago

1:22:52
Now playing
Managing Files and Directories in Practice - Learning Emacs Lisp #6
2.9K views6 months ago

2:03:29
Now playing
System Crafters Live! - Gemini: The Hackers' Web • Dotfile Detective • Q&A
2.3K viewsStreamed 6 months ago

36:22
Now playing
Efficient Movement with Emacs Key Bindings - Emacs Essentials #2
5.5K views6 months ago

2:06:57
Now playing
System Crafters Live! - Dotfile Detective: tecosaur • Emacs News • Q&A
2.3K viewsStreamed 6 months ago

44:59
Now playing
Installing the GNU Guix Package Manager - Craft Your System with GNU Guix #2
4.3K views6 months ago

2:06:24
Now playing
System Crafters Live! - Ranking the Open Source Licenses • Live Hacking: Guile Scheme • Q&A
1.9K viewsStreamed 6 months ago

50:20
Now playing
Creating Custom Minor Modes - Learning Emacs Lisp #7
2.4K views6 months ago

2:02:40
Now playing
System Crafters Live! - I'm creating a new Lisp • Emacs News • Q&A
3.1K viewsStreamed 5 months ago

2:19:50
Now playing
System Crafters Live! - Lisp Compiler Progress • Live Lisp Hacking • Q&A
1.7K viewsStreamed 5 months ago

28:34
Now playing
Efficient Text Selection with Emacs Key Bindings - Emacs Essentials #3
4.7K views5 months ago

2:11:27
Now playing
System Crafters Live! - Trying New Emacs Packages: Vertico and Corfu • Emacs Lisp Hacking • Q&A
3.1K viewsStreamed 5 months ago

40:47
Now playing
Everyday Package Management with GNU Guix
3.1K views5 months ago

2:03:57
Now playing
System Crafters Live! - Should you use pre-made Emacs configs? • Emacs News
1.9K viewsStreamed 5 months ago

35:34
Now playing
Using Package Channels in GNU Guix - Craft Your System with Guix #4
1.7K views5 months ago

1:59:37
Now playing
System Crafters Live! - Building lsp-mode configurations • Emacs News
2.5K viewsStreamed 5 months ago

18:55
Now playing
Streamline Your Emacs Completions with Vertico
7.9K views4 months ago

25:37
Now playing
Doom Emacs or Spacemacs? Use both with Chemacs2!
5.2K views4 months ago

1:59:18
Now playing
System Crafters Live! - Replacing Ivy and Counsel with Vertico and Consult
3.3K viewsStreamed 4 months ago

2:11:12
Now playing
System Crafters Live! - Taking a look at Magit 3.0 • Streaming with Emacs Lisp
2.8K viewsStreamed 4 months ago

24:49
Now playing
Chat Like the 90's in Emacs with ERC
3.5K views4 months ago

2:01:56
Now playing
System Crafters Live! - Improving the IRC Experience in ERC
1.3K viewsStreamed 4 months ago

2:07:38
Now playing
System Crafters Live! - The Challenges of System Crafting
2.2K viewsStreamed 4 months ago

51:36
Now playing
Installing Guix as a Complete GNU/Linux System
7.3K views4 months ago

1:55:27
Now playing
System Crafters Live! - So you've installed GNU Guix, now what?
2.4K viewsStreamed 3 months ago

2:00:39
Now playing
System Crafters Live! - Text Adventuring in Emacs
2.2K viewsStreamed 3 months ago

32:51
Now playing
An Introduction to the Ultimate Git Interface, Magit!
11K views3 months ago

42:48
Now playing
straight.el: Advanced Emacs Package Management
4.7K views3 months ago

56:39
Now playing
9 Techniques to Boost Your Git Workflow with Magit
6.2K views3 months ago

1:58:00
Now playing
System Crafters Live! - Do we really need use-package in Emacs?
2.4K viewsStreamed 2 months ago

28:31
Now playing
Declutter Your Buffer Lists in Emacs with Perspective.el
5.4K views2 months ago

1:57:15
Now playing
System Crafters Live! - Is Emacs intimidating for beginners?
3.1K viewsStreamed 2 months ago

34:19
Now playing
Getting Started with Org Roam - Build a Second Brain in Emacs
32K views2 months ago

2:00:53
Now playing
System Crafters Live! - The Future of System Crafters
2.4K viewsStreamed 2 months ago

0:59
Now playing
Emacs Has a Built-in Pomodoro Timer?? #Shorts
8.5K views2 months ago

1:59:04
Now playing
System Crafters Live! - Can You Apply Zettelkasten in Emacs?
4.8K viewsStreamed 2 months ago

31:06
Now playing
Capturing Notes Efficiently in Emacs with Org Roam __
11K views2 months ago

2:02:23
Now playing
System Crafters Live! - Emacs Package Potluck (Trying Your Suggestions!)
2.6K viewsStreamed 2 months ago

2:09:11
Now playing
System Crafters Live! - Can We Fix a Bug in Emacs?
2K viewsStreamed 1 month ago

16:50
Now playing
Org Roam: The Best Way to Keep a Journal in Emacs
10K views1 month ago

2:04:54
Now playing
System Crafters Live! - We Need to Talk About EXWM
3.1K viewsStreamed 1 month ago

2:00:26
Now playing
Improving EXWM #1 // Hack Sessions
2.3K viewsStreamed 1 month ago

1:57:52
Now playing
System Crafters Live! - Exploring the Org Roam DB API
2.1K viewsStreamed 1 month ago

25:45
Now playing
Fix Your Git Commits Like a Rebase Expert with Magit
3.4K views1 month ago

2:01:07
Now playing
Improving EXWM #2 // Hack Sessions
1.3K viewsStreamed 1 month ago

2:00:56
Now playing
System Crafters Live! - Emacs Package Potluck: The Sequel
1.6K viewsStreamed 1 month ago

2:08:13
Now playing
System Crafters Live! - Integrating Nushell with Emacs
2.5K viewsStreamed 1 month ago

29:45
Now playing
5 Org Roam Hacks for Better Productivity in Emacs
6.4K views1 month ago

1:53:47
Now playing
Improving EXWM #3 // Hack Sessions
1.2K viewsStreamed 4 weeks ago

48:27
Now playing
System Crafters Live! - The Many Varieties of Emacs
2.2K viewsStreamed 3 weeks ago

1:07:42
Now playing
System Crafters Live! - The Many Varieties of Emacs (Part 2)
1.4K viewsStreamed 3 weeks ago

16:34
Now playing
Give Your Dotfiles a Home with GNU Stow
3.5K views3 weeks ago

2:08:23
Now playing
System Crafters Live! - Investigating use-package Alternatives
1.4K viewsStreamed 2 weeks ago

30:40
Now playing
Build Your Website with Org Mode
6K views2 weeks ago

1:09:55
Now playing
"Inverse Literate" Emacs Configurations - Hack Sessions
1.9K viewsStreamed 2 weeks ago

43:29
Now playing
"Inverse Literate" Emacs Configurations (Part 2) - Hack Sessions
781 viewsStreamed 2 weeks ago

1:56:14
Now playing
System Crafters Live! - A First Look at Guix Home
2.1K viewsStreamed 1 week ago

1:58:56
Now playing
Sharing Your Configuration with Guix Home - Hack Sessions
859 viewsStreamed 1 week ago

1:52:25
Now playing
System Crafters Live! - Comparing Project.el to Projectile
1.6K viewsStreamed 6 days ago

31:40
Now playing
Automated Org Mode Website Publishing with GitHub or SourceHut
1.7K views2 days ago

}}}
some nice col.schemes:  https://emacsair.me/2017/09/01/magit-walk-through/  +  peach melpa(!)
    https://github.com/abo-abo/swiper

image mode | insert image into text buffer emacs            https://stackoverflow.com/questions/9780124/insert-image-into-text-buffer#9783413
 --
'open pdf w. evince in emacs'       https://stackoverflow.com/questions/25109968/in-emacs-how-to-open-file-in-external-program-without-errors#25124808
        emacs webkit(!)     https://trac.webkit.org/wiki/WebKitGTK  (+search: xwidget emacs)
            https://trac.webkit.org/wiki/WebKitEmacsTips

https://www.dunebook.com/best-emacs-themes/
        
    https://masteringemacs.org/article/complete-guide-mastering-eshell
        https://www.gnu.org/software/emacs/manual/html_mono/eshell.html

https://orgmode.org/worg/org-tutorials/non-beamer-presentations.html#orgeda3a76

https://www.gnu.org/software/emacs/manual/html_mono/cl.html

        https://www.gnu.org/software/emms/manual/#Quickstart-Guide
https://www.quora.com/What-are-some-of-the-most-useful-extensions-for-Emacs?share=1

https://tess.oconnor.cx/2005/09/editing-javascript-in-emacs
    js2 mode
    https://steve-yegge.blogspot.com/2008/03/js2-mode-new-javascript-mode-for-emacs.html
https://www.emacswiki.org/emacs/Js2Mode
----
https://github.com/Emacs-D-Mode-Maintainers/Emacs-D-Mode/blob/master/d-mode.el

https://fransiska.github.io/emacs/2017/08/21/web-development-in-emacs
https://linuxhint.com/best-web-development-emacs-plugins/

}}}
        https://github.com/nsceaux/lyqi         http://www.geoffhorton.com/lilymacs.html        https://lilypond.org/doc/v2.21/Documentation/usage/text-editor-support.html
          https://github.com/mjago/Emacs/blob/master/lilypond/lilypond-mode.el  **
.((  (evil install  ))  + evil-man(!)) + Emacs|SystemCrafters(**)   mu4e {{{
https://github.com/emacs-evil/evil
https://readthedocs.org/projects/evil/downloads/pdf/latest/
https://melpa.org/#/getting-started
https://evil.readthedocs.io/en/latest/overview.html
https://www.emacswiki.org/emacs/Evil

    systemcrafters: emacs       https://www.youtube.com/c/SystemCrafters/videos
        ----
        emacs and evil          https://www.youtube.com/watch?v=xaZMwNELaJY&t=3004s
        a basic usable conf     https://www.youtube.com/watch?v=74zOY-vgkyw&t=2s
        get started w. org roam     https://www.youtube.com/watch?v=AyhPmypHDEw&t=488s

https://www.djcbsoftware.nl/code/mu/mu4e/index.html
    http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-/
            https://www.emacswiki.org/emacs/mu4e
https://matt.hackinghistory.ca/2016/11/18/sending-html-mail-with-mu4e/
https://learnings.desipenguin.com/post/sending-rich-text-emails-with-mu4e/
https://www.djcbsoftware.nl/code/mu/mu4e/Sending-mail.html
    https://www.djcbsoftware.nl/code/mu/mu4e/Writing-messages.html
    --
https://www.djcbsoftware.nl/code/mu/mu4e/Dired.html  (=attach files (**))

    search: emacs speech synthesis
        https://www.emacswiki.org/emacs/FestivalSpeechSynthesisSystem
        https://www.emacswiki.org/emacs/EmacSpeak
        https://github.com/gromnitsky/read-aloud.el
        https://darkshadow.io/2020/08/01/speech-synthesis-on-linux.html

}}}
https://www.emacswiki.org/emacs/ElispCookbook
        https://www.emacswiki.org/emacs/ExampleConfigurations
https://ftp.gnu.org/old-gnu/Manuals/emacs-20.7/html_node/emacs_toc.html     #EMACS MANUAL
                https://learnxinyminutes.com/docs/elisp/
    Elisp Tutorial part 1 Intro (etc) ***(*)        https://www.youtube.com/watch?v=CH0RUrO_oww
https://www.emacswiki.org/emacs/LearnEmacsLisp
    http://ergoemacs.org/emacs/elisp.html
    https://www.emacswiki.org/emacs/SiteMap
                    https://www.youtube.com/c/XahLee/videos

edi xml w. emacs|vim (+xmlhacks) {{{
    https://www.inmotionhosting.com/support/edu/emacs/nxml-mode/
    https://etutorials.org/XML/xml+hacks/Chapter+2.+Creating+XML+Documents/Hack+13+Edit+XML+with+Vim/
editing xml with vim emmet
xml hacks *****     https://www.amazon.com/XML-Hacks-Industrial-Strength-Tips-Tools-ebook-dp-B004D4YI8O/dp/B004D4YI8O/ref=mt_other?_encoding=UTF8&me=&qid=&asin=B004D4YI8O&revisionId=&format=2&depth=1
    https://www.openoffice.org/sl/ooobox/dokumentacija/Prednosti_formata_OOo.pdf
    https://www.oreilly.com/library/view/xml-hacks/0596007116/ch02s04.html
}}}

    ----
emacs as an ide     https://stackoverflow.com/questions/63421/using-emacs-as-an-ide
        org-ql **       search: top emacs tips,  https://www.systutorials.com/emacs-tips-and-howtos/
emacs outline mode      https://www.emacswiki.org/emacs/OutlineMode
    https://orgmode.org/worg/org-contrib/org-drill.html  #'anki in org-mode' **
cool emacs projects

https://github.com/emacs-tw/awesome-emacs


                    https://www.gnu.org/manual/
        https://www.gnu.org/software/gnusound/Documentation/

        https://github.com/atilaneves?tab=repositories
Emacs as C++ IDE
    https://irreal.org/blog/?p=4670
    https://github.com/atilaneves/cmake-ide
        https://nilsdeppe.com/posts/emacs-c++-ide

}}}


https://neovim.io/doc/user/channel.html
https://dev.to/mr_destructive/vim-for-competitive-programming-3ai8
  https://www.makeuseof.com/best-vim-plugins/
https://www.tabnine.com/blog/vim-code-completion-for-any-language/
https://mattermost.com/blog/how-to-install-and-set-up-neovim-for-code-editing/
  https://vonheikemen.github.io/devlog/tools/neovim-plugins-to-get-started/
https://github.com/neovim/neovim/wiki/Plugin-UI-architecture
  https://github.com/neovim/neovim/wiki/Plugin-UI-architecture

vim:fdm=marker:fdl=0:
