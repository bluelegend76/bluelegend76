vim:fdm=marker:
set fdm=marker syn= guifont=* | colors ron
^[^:]\+:

    +React.txt
    HTML, CSS, SASS [____]
../todo/MasterlistDownload-onedeepmans-online.txt

c:/Users/SEDAALB2/Desktop/Scratch.txt
../weblinks.txt
    Queen  [YÄTT VA ZÅATN OEN XYVCC (B YHFGVTN VAYÄTT)]
    'För att bättre förstå om vad som influerat flera klassiska kompositörer'
    You Win Again, Self-Control, Voyage Voyage, Wildhearts, 
.'The Four Dangers' {{{
  misshandlad, rånad, utnyttjad, förnedrad/förlöjligad
}}}
        N-teatern/Nationalsånger 2  YOUTUBE
TODO ADD 1 = STARTUPS 1 {{{

Vanki LearnQna ----
  ../learnqna/vanki/TCCoreUdater-DotNetCore_notes.txt

~/Desktop/Scratch.txt


multimedia:
    gvim -p ../ref/graf/pr/MultiMedia.txt ../ref/comp/mu/MuRec.txt

file/media:
    gvim -p ../ref/comp/sysadm/browse/file.txt ../ref/comp/hardw/hardw-devices.txt ../ref/comp/sysadm/browse/media.txt ../ref/comp/sysadm/browse/web.txt ../ref/comp/sysadm/browse/mail.txt ../ref/comp/sysadm/browse/remote.txt
sysadm:  TODO: ADD WIN-TERMINAL
    gvim -p ../ref/comp/cb/bcb.index.txt ../ref/comp/sysadm/cmdl-fu.shell.txt ../ref/comp/cb/RegexCb.txt ../ref/comp/cb/regex-vim.txt ../ref/comp/cb/pshell.txt
markdown etc:
    gvim -p ../ref/comp/cb/moffice.txt ../ref/comp/cb/loffice.txt ../ref/comp/cb/latexcb.txt
[git, test/deploy]:
    gvim -p ../ref/comp/cb/git.txt ../ref/comp/cb/compile-build.txt ../ref/comp/cb/Testing.txt ../ref/comp/cb/deploy-devops.txt ../ref/comp/cb/math-progr.txt ../ref/comp/cb/algos.txt ../ref/comp/cb/probltask-leetrosetta.txt ../ref/comp/cb/disassembly.txt

scripting / Web ----
    gvim -p ../ref/comp/cb/jscb.txt ../ref/comp/cb/h5c3.txt ../ref/comp/cb/jqcb.txt ../ref/comp/cb/phpcb.txt ../ref/comp/cb/luacb.txt ../ref/comp/cb/elixir.txt
System (incl. C#):
    gvim -p ../ref/comp/cb/asm.txt ../ref/comp/cb/cppcb.txt ../ref/comp/cb/dlangcb.txt ../ref/comp/cb/rustcb.txt ../ref/comp/cb/jcb.txt ../ref/comp/cb/cscb.txt ../ref/comp/cb/go-v.txt

LANG1-REFS 1: (+maybe LangDb1)
  gvim -p ../ref/lang/Langs1Refs.txt ../ref/lang/sv.thes.svsyn.txt ../ref/lang/cmp.en.dict.en2sv-prsm.txt ../ref/lang/Quotes.txt

LANG-DB 1
  gvim -p ../../db/langdb.legacy.list/langdb.txt ../../db/langdb.legacy.list/langdb.txt
}}}
Scratch-Area {{{
  Could you help me generate XML-comment documentation for this interface?
  Could you help me generate XML-comment documentation for the piece of code I have highlighted?

to weblinks {{{

    https://tmhe.omniacloud.net/_/tmhms/sv-se/news/att-bemastra-konsten-att-skapa-ai-promptar-fem-viktiga-tips-for-framgang

Att bemästra konsten att skapa AI-promptar: Fem viktiga tips för att lyckas
Även om TMHE ännu inte använder Microsoft 365 Copilot i alla Microsoft Office-appar, utnyttjar vi Microsoft Copilot Chat i Edge (webbläsare) till fullo.
Detta tillvägagångssätt gör att vi kan träna vår TMHE AI säkert med företagsinformation. Även om resultaten måste kopieras och klistras in manuellt från där du arbetar, säkerställer detta att våra interaktioner förblir säkra. Genom att fokusera på robusta säkerhetsåtgärder lägger vi grunden för en framtida utrullning av Microsoft 365 Copilot. 

Att låsa upp AI:s fulla potential börjar med att bemästra konsten att skapa promptar. Oavsett om du är ny på AI eller vill finslipa dina färdigheter, kommer tipsen nedan att guida dig i att skapa promptar som är specifika, har kontext och är öppna, vilket leder till mer meningsfulla interaktioner. Utforska och upptäck hur du kan iterera, finslipa och hålla dina promptar koncisa för bästa resultat.

Var specifik: Definiera tydligt vad du frågar efter. Ju mer detaljerad din prompt är, desto bättre blir svaret. 
Använd kontext: Ge bakgrundsinformation för att hjälpa till att styra svaret. 
Ställ öppna frågor: Uppmuntra detaljerade svar genom att formulera dina promptar som öppna frågor.
Iterera och finslipa: Experimentera med olika formuleringar och justera baserat på den feedback du får. 
Håll det kortfattat: Håll dina promptar fokuserade och till punkt för att undvika förvirring.
Här är några exempel som följer tipsen ovan:

Enkel prompt: “Berätta om truckar.”

Lägg till specificitet: "Förklara fördelarna med att använda gaffeltruckar i tillverkning."  
Ge kontext: “Förklara fördelarna med att använda truckar i tillverkning och deras påverkan på effektivitet.
Ställ öppna frågor: “Kan du beskriva fördelarna med att använda truckar i tillverkning, deras påverkan på effektivitet och hur de bidrar till hållbarhet?” 
Iterera och finslipa: “Kan du beskriva fördelarna med att använda truckar i tillverkning, deras påverkan på effektivitet, hur de bidrar till hållbarhet och föreslå sätt att förbättra gaffeltruckstekniken?”
Håll det kortfattat: “Beskriv fördelarna med truckar i tillverkning, deras påverkan på effektivitet och hållbarhet, och möjliga förbättringar.”
Håll utkik efter vår serie om hur du får ut det mesta av Microsoft 365!
}}}

}}}

2025-04-02 ---- (pres. halvtid) - Toy:Tmhe {{{

bet.vetenskap, psykologi, kunskapsteori
    [[arkitekt som är min egen administratör/bygger mina egna verktyg]]


jag har en rätt speciell stil...  ____
    [doktorn/doctor chaos, prof., memento, conan the librarian]


du har en välsignelse eller en förbannelse, lite beroende på vem det är som tittar
    du är ju helt galen... och helt|fullständigt briljant
    "den enda skillnaden på mig och en galning är att jag inte är galen."
[school-accolades]

tror jag lätt ger intrycket av en [slouch]

handler
service
utilities
helper
worker
builder
provider
expediatior
 ... (?)

nu kör vi (behöver inte mycket handholding)

[misstag]
tog det ganska makligt
(behövde ju komma igen och allt det där)


- frågar för mycket / frågar för lite
- det finns inga dumma frågor / f*n vad trög du är | händer det nåt eller?


- min resumé sen innan (paul + adam)


- lärdom
- kontakter
  - anställning


blivit mer av en validering

- hinner inte göra något arbete =kan använda som ex-jobb


vad tycker ni? vad ska jag fokusera på?

- visa att jag är en riktig jäkel rent tekniskt?
- visa att jag är en social, trevlig prick som kan spela roliga visor på julfesterna?

fyra fula ord (för att representera 'min sits' på skolan)
    m-zvffunaqry  r-eåa  u-hgalggwnaqr|fynineorgr  f-söearqevat
    [+zra nyyn äe iäyqvtg glqyvtn zrq ivyxn qrg äe fbz une/äe qr fxlyqvtn:
    - aåtba
    - vatra

man är ju ändå bara människa (så länge man står upp)


tre alternativ:
- ___
- bita ihop / dyka ner + stänga locket
- hoppa av


tillgång till kod  (=ab?)

}}}


Forums Stora
  ../ref/allm-a/forumsstoraprakthandb.txt

at.Ref.Cbs ----
  ../ref/ref.cb-prl.txt
.vids Lia2 {{{

put several files in playlist + start off (at specific time) in video no 'n':
    mpv 1.mp4 --start=00:10:30 2.mp4 3.mp4 --playlist-start=2

mpv --start=00:13:00 --speed=1.65 ~/Video/Peter-L-20250227_102445.mp4 ~/Video/Peter-L-20250227_111046.mp4 ~/Video/Peter-L-20250227_132732.mp4 &

}}}

Keyboard Shortcuts.Db1(...) ----
    .
PROGR ----
  PROGR.cm.txt
Clangs (C, Cpp, CSharp, Dlang) ----
  TODO: INCLUDE INTO BLUELEGEND76
  TODO --"--
Web/Mobile/Cloud ----

    'ful som stryk'
Langs1 Ref-lists ----  __
  gvim -p ../ref/lang/Langs1Refs.txt ../ref/lang/sv.thes.svsyn.txt ../ref/lang/cmp.en.dict.en2sv-prsm.txt ../ref/lang/Quotes.txt
  // maybe add 'främord' etc
  --
  ~/gdrive/rsc/media/pic-graphics/shorth/
LangsDb.legacy ----
  gvim -p ../ref/lang/dandict2mini.txt ../../db/langdb.legacy.list/langdb.txt
                                                   ^
                                                   |
  or LangDb1.list.txt -----------------------------+
  [+charAlfa]
  . {{{
    mada, wareware (no), sore de
  }}}

~/gdrive/rsc/data/lists/mu/dft-thedoc_playlists-index.txt

## 'Trinity-proj.'
    . {{{
##   (belief and morality; models and theory; knowledge, action, and 'does it work' (soundness))
        They don't say they know; They say they believe(=gotcha)

Om jag ska peka på en enda sak, så skulle jag säga att det största enskilda misstaget andliga/new age-iga personer gör, är att förväxla 'Detta känns bra'(=subjektivt för mig just/här och nu) med 'Detta är bra'(=för mig och andra i längden/=bortom just (här och) nu)

    som pratar så mycket om värme, kärlek och mjukhet/mjuka värden, som är så arga, och passiv-agressiva
    }}}



    ---- 'MINIS|DAILIES' ---- ___index=0 {{{
    LEETCODE ETC(+SCRIPT-FU) CODE-PROBLEMS __ ****
            KAPA FILER/MAPPAR I LEGACY (=5 per dag) !!(! *****)
    Saol 1/Bevingat/Ordspr. =Clean  @ +Idioms/Litt  arlang 1  +LangDb Prios 1-100(!) →
        Bevingat (Quotes, etc)
    . {{{
      - vta-apps Docs: Dualist
    }}}
    - Gregg Snippets [=10 per day]   [+images to refssection]
    - dan-words;  kanji-2000  -de | fr | spa | ru  +jp,  @ ita (!)  (incl. set jp-dicts.ref(!!))   - lat [ 2-4 words etc (??)]
        - Some Sv-En words|phrases (+one quote|joke(quip)) + Write w. Shorth(!!) {{{
            ( =sjukv|samhinfo|facket mm(!) 2-4  Rel.Ond: 5 meningar
                - Doyle FSpeech (=gregg++):  Plocka 10-20(-50) mest grundl. eng-ord(!!)
            . {{{
                https://www.youtube.com/watch?v=j6IufYLMrqM&t=300s
                        wokebusters (w. j.linds. and wokal)
            }}}
        }}}
    - fun jokes stories (+quotes)  @  =DO+SET CATEGORIES [!![!!]]  [+Welsh etc(!)]

    UNIVERSITY VIDEOS: STANFORD[!!]
      + QUINCY LARSON-LINKS [!!!!]  @@!(!)
    C (modern + hardw.)  +Sys.Archit.
    Htdp (+refact, beaut, legacy)  (+Lfe Sicp(+Sicp Clojure)?)  py-sicp  @
    JsCb-Notes 1 + jscb 2(!!), +PyCb, ClojCb  KotlFunct [**]  @@
      Dlang[!! Ali, Mike P, Cookbook  etc]
    Org, Vimscript första koden (+↓↓), Elisp Startw.[!!]
    - vimscrhardw (first cmds custom!!), - lpy(x2)-ref, bash 1cmd   (+vimcasts etc)
    - FREEC-WEB (3-5 st!  +ExamProjects)  @@   - vlang

        --  @@@@@@@  ---VV  @
    - Fstyle: 'Doc is here' + Dft-Prios(!!)(**** =incl. Blues-Improv. acoustic) {{{
dft curr 2023 {{{

  Bohemian rhapsody {{{
    ~/Dropbox/rsc/media/scores/i.guitar/ac/dftproj/BohemianRhapsody/bohemian_rhapsody.dft.tg  #Set final fingerings
    ~/Dropbox/rsc/media/scores/i.guitar/ac/dftproj/BohemianRhapsody/bohemian_rhapsodyRAW.drsfingerstyle.pdf
    et1(+solo1): 74  @
    et2("I see"): 144
    et3: 138(ca)  @
    et4(outro): 72
  }}}
  Catch me if I fall {{{
  ~/Dropbox/rsc/media/scores/i.guitar/ac/dftproj/Own/TheDoctorIsHere/02_catchmeifyoufall.pdf
    _st:
    _et: 66
  }}}
  Pluck me sideways {{{
  ~/Dropbox/rsc/media/scores/i.guitar/ac/dftproj/Own/TheDoctorIsHere/05_yourekiddingmrholmes.pdf  #Pluck me sideways
    _st:
    _et: 118(ev. lite lägre)
  }}}
  Birdman {{{
  }}}
--
  live and let die {{{
  ~/Dropbox/rsc/media/scores/i.guitar/ac/dftproj/.blue/live_and_let_die.pdf
  }}}

}}}
            : - sweet dreams  - mrs robinson  - browneyed g.
              - sweet child of. mine  - nytt arr: holy diver
                - kashmir
        +KOLLA CHECKLIST DFT-VIDPRES. 1--REMAKE(=2020-2021(!!)) (****(!!!!)) @@
        +Recreate 'Juha+Yerba'++ 2014**** (=Satellit, Under Pressure, etc(!!))
            [[ = in at.muTeach.bash ]]
        }}}
    - drs 'Hallå Där!' + karaoke-pres(=videos)
    - listen|document: Genres, 2 songs + its lyrics(!)      pre: 'Lathund'(!|??)
      - dfs sångövn.programmet =in office + 'mobile'(!!)

    'piecemeal':
       - bash (blue, unpow, orange, bcb, TLCL, [2xclassic],  ABSG, Rute, debbib1,  yellow-vids, lsag) {{{
         + 2x_script-bible, linCb, hacks, sam24, sob, wicked
       }}}
    - svganimDrasn
       - pshell (forsysadms, )
       - LinInterface + LinProgr Advanced
       - c hardw. + c modern
    - calc(etc)
    - ffmpeg [tasks  + Mans]
    }}}

-- OFFICE.PROJS ___index=2  #'odin-tree' [+lists on gkeep(?)] {{{
\v\@([^ ]?)+

V I M  +  E M A C S

    Gremlin + Neptune
        'MuLäroplans-Träden' **(!!)
        ----
        netrw (**)
        JavaScript Functional
        Elixir, Ocaml, F# DomainModeling
    Abe Kotlin
Py/F# Sysadm. + Devops[!!]
      [Dlang-proj + PhobosNext|Per Nordl.]
        vlang, Go, Ring
        Cloj. + Java
  datastructures PROGR-List + Db(SqLite) + PROGR-Langs-list[!]
              (+graphdb, SPARQL/CYPHER/GREMLIN, sqlite,   redis,  mongo)
    ----
LINSYS:  debbib
Blue + Scoll.  +Analog Synth.
        lynx  pyweb,  @Greasmonk
    Nsplitdiff (+Soc.Framg)
Nushell
        Git, Github Projects  @GithubDocs @GitActions
Datasci@ + MLEARN[!!!!] @Webscrape / @GoogleHacks
    Xml (+xaml, faml, etc)
  'Coding with Music'  MidiCpp-Guy[!!]  h5g**  Listking   jQuery(Cb), FREEC Compl,
  refact, legacycode, TDD(etc) @  +C-CppFunct
  @c#funct, C# Docs Avanc. C# Des.patts, C# 50-70 Tips
            flux, xmonad, openb, ice, awes
        sed (+py/dlang etc)
    --
    Aws(+dynamo), Docker, Kubernetes  CyberSec  @
  börja kolla quincy l-länkar @  +Stanford etc
React (FreeCodeCamp)
        Pluralsight, w3school, w3resources
        kotlin/jetpack progr-videos(!!)
        (gimp etc) Py (!!)
@xsane, font(forge)/Scribus
    HTML, HTTP/TCPIP + 'The Web'
    Mojo
    Devops, CI @
            PHP + funct.
algos
        Scribus
    CSS + Compass
        pyfunct(!) 1+2
        Bash + Termux (+vim-bash) (etc)
Linux (Android etc) + Sys-Structure, Sysprogr
    Cypher,
SparQL
    Pshell + Choco
Inkscape (+Rita och skriva för Online-Undervisning  @@
- websearch (duckduck, Google, etc)  [+Webscraping] +lynx(etc)  @@
        Audacity
@AnlSynthesis + Midi@ + Keyb.Synths
            [+Nyq (etc)]
    Pyramid
Csound(Qt + Blue), Scollider

='Topics/Areas'   ~/Dropbox/rsc/aubooks/data.WISHLIST
    Bcb Etc (+Find/Xargs, etc), UNIX POW-TOOLS  @
PyAut3** +PyFunct, Gimp Python, +  @
      webscrape, cv/mmedia, au-transcribe,
    5 w3resources C# datetime-övningar
    Datasci, text-natlang  #to at.Python.bash
    WebSearch/GoogleTricks  #+grease/violent/tamper-monkey  @
    . {{{
      ~/Empire/Doks/Comp/gui-wtoolkits/hack.greasemonk.txt
        ~/Empire/Doks/Comp/gui-wtoolkits/greasemonkey.txt  #kin
      ~/Empire/Doks/Comp/lang/webdev/js/ffox/ffox-hacking.txt
      ~/Empire/Doks/Comp/lang/webdev/js/ffox/programming_firefox.pdf
    }}}
Samsung Notes [!(!)]
    Hardw: Phone + Tablet
    ~/Empire/Doks/Comp/lang/webdev/Aux/youtube/
    --- Kotlin: Test Projects 1 (***!!)  @

    - MOODLE  @@ (=Indexes[?|!])   | Wordpress |
- ORG (=emacs) ** @   ___minis_dailies
    --
        ~/Dropbox/rsc/data/lists/learnqna/vanki/lynx.txt
  HCJP-5e  
  C (modern, hardway, etc) + Lin(etc) sysArchit. **  @@
    Dlang [Ali, +Learning, Cb]
    Flutter+Dart    @
    Elixir(**!)     @
    C# + 'ciss' (etc)     F#(??)
    WEBDEV:  Freec'Restart'  (+Js Multimedia, 'drasnanim', ???)
  wappdev.js eloquent.js
  +h5g / three.js (w.gamedev)
    Clj  @ + 'javamethods'  #'cheats' + jDir14/PhrasebJava
    Nyq, Csound, Scoll  muHask*(*), Midi  @  Chuck
    SICP (etc, ...)   @
  JFx(!) + Clj   @
    --

    --
    mc
    'Debian.Cb 1'
    --
                vlang

    ----
                - Dft: bohemian rhaps. etc
                - Freec. Webdev (+svganim, wappdev1, h5g  ,JS-Cbs+h5c3-1)  typescript  = Done by 4 may  (+ap-a/ap-i)
                . {{{
                - Dlang Restart (+doks x3,5 +vibe-new)  #+clean up all vankis 1(!!) {{{
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/dlang/dcookb.txt
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/dlang/dlearn.tagged.txt
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/dlang/dwebdev.txt
                }}}
                ar, dan-dict, +fr/de, spa, ry
                kanjilist 2000: ~/processdir/kanjilist2000/
                @ MuTe-list (!!)
                Android Java-Dev 1(!)
                - Mail till Mikael Frendberg {{{
                Hej Mikael.

                det var sagt/satt att
                Andreas N skulle höra av sig 
                att höra av sig till mig om en anställning med tidsmått
                efter en anmodan från Transport i slutet av 2021
                men trots att jag sökt honom (ibland flera gånger i veckan) sedan årsskiftet 2022, har han inte återkommit till  mig
                med tid för möte med ett erbjudande.
                .
                Jag ber dig därför höra av dig till mig snarast möjligt
                senast någon gång under kommande veckan
                så vi kan ordna detta  skyndsamt
                Vänliga hälsningar D. Albertsson
                i annat fall måste jag vid det här laget
                gå vidare
                till HR centralt på Securitas
                }}}
                Städ(!)
                        [Andreina (et al)(**!)]
                tommy skaresund (m.fl. =spelutveckl.)
                @ - Bluesbooks, Improv, arr + harm
                - Börja Klippa: hallå där, Speln.videos, doctor is here(!)
                - Minilist Inlärn. 1  = till Alex + Freddan (+ Vim Abe)
                - brev till jakob fransson {{{
                Hej Jakob.
                P.g.a. av en miss har jag fått boka om undersökningstiden för lungröntgen (jag har varit i kontakt med enheten på Ua sjukhus)
                Det funkar som sagt något bättre med smärtjusteringen via Duloxetinet (PS Finns det något man därigenom kan säga angående vad orsaken till smärtorna skulle kunna vara? (=att just den medicinen har hjälpt, åtminstone något))
                Däremot får jag oftast 1-3 (el. likn) gånger per dag eftermiddagar
                svåra hugg av smärta  som gör att jag får pausa arbete och uppgifter och vila mig,
                har svårt att böja mig för att ta på byxor, knyta ett par skor
                har svårt att vrida mig mm
                50 % eller mer(!) av dagarna är jag också så trött och susig, att jag oftast inte kommer igång med något förrän några få timmar framåt sen eftermiddag/kväll, och många dagar försover jag mig med 1-6 timmar, trots att jag sätter larm.
                Jag tar också nästan varje kväll en oxynorm, och en eller två alvedon, för att kunna sova (=p.g.a. smärtan); Vid några tillfällen har jag också fått dubbel d.v.s maxdos (=2 oxynorm och 2-4 alvedon). Vid några enstaka tillfällen (t.ex. ti 12/14) får jag också upprepa oxynorm+alvedon mitt på dagen.
                .
                Jag har nu fått en tid för möte
                om utvärdering/utredning
                med F-kassan och AF angående min arbetsförmåga
                och hur vi kan hitta ett arbete
                som passar mina kompetenser  och min sj-problematik.
                Mötestiden för en första utredningskontakt är satt till
                4 maj.
                Utredaren gjorde mig också uppmärksam på
                att min sjukskrivning gick ut den 4 april.
                .
                Jag ringde därför för att boka en telefontid med dig
                så vi kan lösa ärendet så sjukskrivningen inte löpt ut (=då kan 
                Jag fick prata med Susanne (som du ju vet att jag framfört kritik mot).
                Hon var dock trevlig, och framförde att någon skulle ringa upp mig dagen efter samtalet.
                Denna person hörde dock inte av sig under tisdagen, eller onsdagen.
                }}}
                - sed + Deb
                }}}
                scheme + Ly-Snippets (+Lilypond @)
                - rsteno: hallå där (+facket + breven som skickas)
                BlendPy
                inks + webgrafik(!)  +Tuts(!)
            MAPPING, GEO-MAPPING, Gis(*(*)): ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/openlayers3-start_plusgis-geoinfo.txt
                --
                Philto/Verktl. + Gilje|Univ.(!!):
              2022-04-19 ti - 20.15: Vaccin-dos 2 (!!)
                Bollen + Sty.trän.
                Samsung Notes(!(!))
                NextCloud(!! Puh)   (Obsidian??)
                PROGRAMMING 'Concepts of Prl' + Algos + HTDP/SICP + Softw.Design + 'Beaut./Pragm/Clean-x3' + 'Mozart'-book
                GameDev(*) (=agk++ (**)) (Unity, React 4, agk(), Godot, ..)
                - PyAux (=PyProgr + Lib  +  blendpy, stats, datasci, (etc etc))  @@
                Stat/'Data Science'
                - Allm.A-doks [Forums stora, Bildoks(x3)]  #+ocr hemohyra|hyresg.fören.
                - vidauprocess + grafik 4, Ffmpeg(!), Heros(!)
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/Manuals/GoPro_Hero-Texgear4kaction.txt
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/graf/g/digbildbeh_4.orig.txt
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/graf/g/digbildbeh_4.txt
                - v3+1 {{{
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/_v3_plus-ssh/ssh-defguide.txt
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/_v3_plus-ssh/vbox_uman.txt
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/_v3_plus-ssh/veracrypt-userguide.txt
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/_v3_plus-ssh/vnc-uguide.txt
                }}}
                ----
                - Vim: Uman, RefMan, vimlang  @@
                - Evil, EmacsQ 1 (+refc. long--index), Org(*), im-dired|pdf-tools(*)        -->  (Elisp)
                Scribus(!): ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/graf/scribusmandef.txt
                YouTube(?? +)  =Learn
                fontforge {{{
                https://fontforge.org/en-US/documentation/
                --
                https://archive.flossmanuals.net/_booki/fontforge/fontforge.pdf
                http://designwithfontforge.com/ebook/design-with-fontforge_en-US.pdf
                http://designwithfontforge.com/en-US/index.html
                https://englishonline.info/fontforge-manual-17/
                --
                https://fontforge.org/docs/scripting/python.html
                https://fontforge.org/docs/scripting/scripting.html
                }}}
                --
                Litt (+biografier)
                Anki (=relearn 2022+(!!))
                . diff+patch, dolphin,  ed, id3||Easytag,  Audacity(!) {{{
                - Install LightTable + Clojure (**)
                ----
                - thunar, dolphin, audacious, mutt, markdown
                - diff + patch,  ed   Vim,  vbox,  Easytag++,  id3
                . {{{
                search: bash diff and patch examples
                https://www.man7.org/linux/man-pages/man1/diff.1.html
                https://linux.die.net/man/1/patch
                ----
                https://acloudguru.com/blog/engineering/introduction-using-diff-and-patch
                https://www.pair.com/support/kb/paircloud-diff-and-patch/
                https://www.thegeekstuff.com/2014/12/patch-command-examples/
                https://www.systutorials.com/diff-and-patch-generating-and-applying-patches/
                }}}
                --
                - fontforge + Scribus
                - Festival,  Ub.Studio-Man
                --
                - Audacity(!!)
                - LPY 3(++ !!)
                }}}
                http://potrace.sourceforge.net/  http://potrace.sourceforge.net/faq.html
            Audacity   @@@@
                Blender X  @
                - Keyb.s, "Csounds", an.ljudyntes (**(!)) {{{
                - Keyboard Magazine 1, Korg Dw-6000 man,  casio-privia-piano-man
                - yourock-guitar(**)
                - An.Ljudsyntes(**):  - SynthCookbook(**(*)), - Log.Effects
                - NordKeyboards(??)
                - Csound, SuperCollider etc
                - Analyze|Visualize w. SuperCollider (**!)
                - Clam Framework + clam chordata (**)
                - 
                ----
                - Blue Improv. (jazz-rock)
                - Coker(!!)
                - 
                - Jazz-Improv (brown+blackwhite) **
                ----
                - GuitarEffects  (+as Pedals / Software)
                - Gitarr =Lagning + Underhåll (!!!!(**))
                }}}
                - (Mu: ARRAN, HARM,      ) {{{
                - Ingelf (x2)
                - rock-arr
                -  tradi-arr
                -
                ----
                - Directing-books
                - Arr w Midi-Book(****)
                - ARRBOOKS: COMPOSING + FULL ORCH. SCORES (Wagner, Williams etc etc) (*******(!!!!))
                }}}
                ----
                - SVG  @@
                - erlang   Elixir
                - C# ('ciss.txt')
                - BASH (orange[de], blue(**), purple('Bcb')) {{{
                (Rute=7, lcert-orange=1, yell-vids=8, Blue-Bash=2, BashCb=4, PTools(x2)=3, lsag, DebCb, DEBBIB(x2)=6,  LCmds.org=5, CLine-Fu"Db"(!!(**)), BigGreyList,  Elbot-Lin)
                }}}
                PostScript()
                - PShell 5         ar(!), it(!), Fra, (Stranna Dushy(++)), 
                rlang  julia
                netrw
                - anim-foto-video-graf(**)  {{{
                - fstd, digbildbeh. 4, 'Rip-Books', 
                - 'Anim-Books', 12 Principles of Animation, filmbooks + 'Filma med Foto-kamera'
                - DRAWING/RITA(**), CARTOON-DRAWING   # + Olle Johansson(+inspir-grafik)
                - 'tidnings-design, undervisn.grafik'
                - 'Typografi', Fonts(!!)
                - "Imag" (**)
                - Graf.Kokb.(*)
                }}}
                . AuVid-compression
                . . SvSynDb, svskrivregl, Eng-WORDS (etc) {{{
                Zen of Filesystems
                Idioms (eng|sv)
                Beving | CITAT  #+Citat-tags/kateg.(*!)
                SvSynDb(!!!!(!!))
                Sv.Skrivregl.(x2), Eng-WORDS(*), Eng-App_Words 1, Eng Learned Words (memrize 2),
                (instant-intellectual), 
                Hist-Speeches
                .
                Hist
                JUR
                PR, Markn.F
                Ekon (etc) (**!)
                Proj.Manag
                taskjuggler(!)
                Allm.B[Encycl.s(**), TP:s(*!)] + Sci(eg. Fogtdals, WIK(!)) / McGraw(**!)
                }}}
                - MAPPING
                ----
                readline =emacs|vim
                ed, mc, etc etc(=Bash(!))   ~/Dropbox/rsc/aubooks/data/bash/ {{{
                +Grey Commands-List as Ref|Master-list (**)
                bind_macros.txt
                dirs.txt
                ed.txt
                mc.txt
                readline.txt
                history-fc.txt
                find-xargs.txt
                grep-ag.txt
                grub.txt
                man-info.txt
                less.txt
                printf.txt
                test.txt
                Sed-Awk.txt
                TODO
                extras/Apt-Aptitude.txt
                extras/ps-top.txt
                extras/wakeonlan.txt
                extras/cron-anacron.txt
                }}}
                - GIT
                .   XCode {{{
                search: install mac and xcode in ubuntu vm
                https://izziswift.com/can-i-install-xcode-in-ubuntu/
                https://hkdb.medium.com/running-macos-in-virtualbox-with-ubuntu-31ec745f21ae
                https://www.raywenderlich.com/8325890-a-complete-guide-to-swift-development-on-linux
                }}}
                . . . Fluxbox, Vivaldi, Logic, Hydrog/Roseg  markdown(+rtf, wiki etc) {{{
                Fluxbox, Openbox, IceWm, Awesome, Xmonad
                blendpy(-*)
                .
                scheme-guile, gambit, racket, minischeme(?)
                .
                impress.js
                Thunar {{{
                https://askubuntu.com/questions/446458/thunar-command-line-options
                http://freesoftwaremagazine.com/articles/tips_tricks_and_scripts_thunar_file_browser/
                }}}
                .   audacious {{{
                https://pkgs.org/download/audacious-skins
                https://www.gnome-look.org/browse/cat/129/order/latest
                https://store.kde.org/browse/cat/129/order/latest
                http://www.xmms.org/
                --
                https://help.ubuntu.com/community/Audacious
                https://wiki.archlinux.org/title/Audacious
                https://audacious-media-player.org/
                }}}
                Vivaldi
                mutt
                gentoo (fman)
                vim-bash | em.bash

                Burge.txt
                Logic X + Eff.
                zoom ps-04 ministudio(!)
                UbuntuStudio-Man(**(!))
                Ardour(*)
                Hydrogen, Rosegarden*
                MIDI
                --
                MacX + safari + ForDummies(*!)
                Win 10 + MS Keyb.Creator  #+seccopy mskb files 1(!)

                markdown
                wiki + wiki-like {{{
                mediawiki syntax
                https://www.mediawiki.org/wiki/Help:Formatting
                wiki markup syntax
                https://en.wikipedia.org/wiki/Help:Wikitext

                wiki-like desktop software
                https://en.wikipedia.org/wiki/Comparison_of_wiki_software
                https://en.wikipedia.org/wiki/List_of_wiki_software
                https://en.wikipedia.org/wiki/Personal_wiki
                https://vimwiki.github.io/
                }}}


                Elixir | Erlang (*)
                lua (*)
                Haskell (-lys, -Music(**))
                qpython()

                Java Fx
                Jdir14(+swing)
                Android-Tut
                JVE-langs
                Groovy
                Clojure + clojurescript
                lighttable
                jakarta ee

                Okular
                Eclipse
                Netbeans
                VS Code (*)
                lynx
                yourock
                mplayer
                vbox
                vnc* | wakeonlan | anacron
                vera
                tor / openvpn(!)
                }}}
                data.WISHLIST (Samsung Notes, julia, Dired, ffmpeg, Synfig, Imag, Chocolatey {{{
                Samsung Notes *(*)      ___dataWISHL
                em:image-viewer
                iimage
                em:pdf-tools
                em:dired
                emms
                Amarok  #+more KDE docs
                em:w3m
                gentoo filebrowser
                kdenlive, openshot
                mt(??) video framework  #python etc
                pitivi
                ffmpeg
                (Imag)
                Vala
                Festival (festvox*)
                Julia **(!)
                Glade
                Krita
                praat
                Clam++, clam chordata
                Synfig, anigen
                vivaldi: quick-commands
                Fluxbox, icewm, openbox,  awesome, xmonad
                solaris
                readline emacs/vi *
                Nix/NixOS
                apt, debian-alternatives
                chocolatey
                markdown, ubuntu forum/github markdown
                SnapCraft
                search: Lin. Package-Managers (flatpak, snaps, appimage, packages)
                eric, PyCharm
                google/duckduckgo search tips/tricks
                EasyTag, id3tags
                cinepaint, rawtherapee, lightzone, fspot
                ((shortcutfu))
                FS-H  #un, win, andr (etc)
                azure
                puppy linux
                }}}
                (Pandoc etc--listblock(!!))
                - FS-Hier. + lsag {{{
                - Lin
                - bsd(/solaris)
                - MacOsX
                - Win 10
                - ios
                - Andr
                }}}
                Writer/Calc + Starb.       #Excel, gnum.
                ----
                (.more)  Nix/NixOS|GUIX, LFS,  gentoo, sabayon ... {{{
                snap(craft)
                nix + nixos *
                lfs / dsl / pocket lin
                gentoo lin.
                portable linux distros(slax etc)
                .
                wxwidgets
                }}}
                ====
                C# (**)
                F#
                Stat.
                Welding
                Electronics (*)  #+soldering
                Julia
                . . {{{
                SocFramgång (**(!!))
                NevSplit
                Sec/Väkt ((****(!!)))  #+Sec./Bya Online Learning-Platforms(!!)
                STRAT/Vjud (etc)
                Python Bioinformatics
                'Engineering'
                Passage/Security-Systems
                Lock-Picking(*)
                }}}
                . . . . . . .
                |evince|
                ||shotwell||
}}}

---- Win-Overview =x3 ----
Office.Rush [1]  # rush through + take review/notes {{{

@ = Clean/Focus On
# = Suited for Ontheroad
¤ = Toyota (etc) prio  [=Mainly CleanUp-Def (etc)]

            Pegged, Tsv-Utils, Perlstyle-Regex
    ANDROID SCRIPTING/PROGRAMMING  [+Flutter, KIVY]
TC CORE READTHROUGH + THE WIKI[!!]  __  ¤¤
  CLEAN UP NEW DOTNETCORE-DOKS  __  ¤¤
----
Maui / AVALONIA  __  ¤¤
C# DotNet Core MVC  + Blazor  Cs Funct 3
    Puppet Lang + Patterns(etc)
    FuncPy  [_Renskriv_]  __  Py/F# SysAdmin  ¤
    Nushell, Xonsh  _  ¤
    Choco (+Puppet) + PowerShell (+AutoHotKeys)
            Mpv-Docs  Yt-Dlp  ¤
'linuxcommands core' [=Gemini-Q]  ¤[¤]
MLEARN: FIRST DOKS  + formulas w. Obsidian Md/Latex[!!]  _  ¤
    JuPyter/Polyglot(?) Notebooks (etc)  __  ¤¤
F# - TOCs + Concepts,  Fabulous (Fable, Suave)  _
Bash/Dash-Mans  ¤
XUnit Patts  __  ¤¤
Roslyn + Analysis/CodeGen  __
SSH (Veracrypt)  + Puppet  __  ¤¤
    Nix Master
Devops + Python (+iPy/Xonsh) ; F# Devops  _
  Vim PyPlugins  __ | VIMSCRIPT (x4)  _
Reason + PureScript  ___onroad=maybye
 LEARN REACT  [__]  [+=OldNotes 1]    Sass  ¤¤

Bcb, Bluebash  ¤¤  + PShell,  ASM 1 (+binalys)  ¤
Docker + Kubernetes + Azure Devops + GithubActions  __
    Gremlin (+Neptune)  _
  ----  Anki Redone  (+Vanki Vimtouch 1.0 / VimJutsu)  ¤
    Arch Linux

Music With JavaScript *  __
Buckey's Godot
        ~/Empire/Doks/learn/speedread.txt
}}}
office.Overview [2]  # write summary|overview {{{
Reveal.js|Impress.js  __
Spectre Console  __
  iPython(*)
  Xonsh
  CsRx 3, Rx.Net;  Csharp Tips (etc)
Android-Scripting + Termux ****  __  ¤¤
F# [Overview and Concepts]  +Cloj.
  FuncPy **
  Anki
  ----
    Py Webscraping
  Avalonia  __
    [CsFunct 3]

}}}
    -- office.Slog ___index=3 [3] {{{
____ __
.     . {{{
Reduce down rectangular file-block to gvim one-liner
  @r: 
}-$F/c,}-$F.i}
-V{
:s/\.txt
{
A{VipJgv:s/[^ ],b ,e[^ ]//g
}}}
    ~/Dropbox/rsc/data/lists/todo/MasterlistDownload-onedeepmans-online.txt
    ../todo/MasterlistDownload-onedeepmans-online.txt  # Win
RUSH/OVERVIEW DOKS-LIST[!!] {{{
  ...tagged... {{{

## ~/gdrive/rsc/Doks/scratch/pshell/Win10keysdef.tags.txt
~/gdrive/gambitscm-smallefficientnativeapps.tags1.txt

~/Dropbox/rsc/aubooks/comp/shotwell-man.tags.txt
~/Dropbox/rsc/aubooks/comp/thunar-man.tags.txt
~/Dropbox/rsc/aubooks/comp/id3_easytag-vim-id3t-eyeD3.txt
~/Dropbox/rsc/aubooks/comp/id3_easytag-vim-id3t-eyeD3.tags.txt
~/Dropbox/rsc/aubooks/comp/dolphin-man.tags.txt
~/Dropbox/rsc/Doks/PRIO/graphdbs.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/scm/lydoc03-extend.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/py/py3aut.Tags2.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/py/py3aut.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/py/py3aut.Tags1 (Case Conflict).txt
~/Dropbox/rsc/Doks/phone/Comp/lang/py/Python3Aut.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/py/sedawk-shscript-withPython.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/xml/xmlhacks100_2010.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/xml/xml-w3schools.ToClean.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/elx-erl/ElixirSchool.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/svg/svganimdrasn.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/dlang/dlearn.tagged.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/cscb_2022.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/functional-cs.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/fs/fsharp-wikibooks.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/csfunct.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/designpatts.cs.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/db/graphdbs.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/h5wappdevex.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/funct/jsfunctmaster.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/funct/functjs-begin.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/FsharpWikibooks.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/java/cloj/clojcb_2014.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/loffice/starbasic/calc2011.fmt35.tags2.txt
~/Dropbox/rsc/Doks/phone/Comp/loffice/starbasic/calc2011.fmt35.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/datasci/ai-mlearn/py/mlearnapps-ideatoprod_2020.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/bluebash.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/1_unpowtools-3ed2002.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/mutt-man.tagged1.txt
~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/lincmdorg.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/1_unpowtools-3ed2002_1.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/helix.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/neovimLua.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/lvimscrhard.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/evilman1.tags.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/emacsmanual1.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/OrgmodeMan.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/mu/ly/lydoc03-extend.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/mu/au/scoll/scoll-mapvisu.tagged.txt
~/Dropbox/rsc/Doks/phone/clean/ipydocs-tut.tags1.txt
~/Dropbox/rsc/Doks/phone/clean/nix-master_2024.tags1.txt
~/Dropbox/rsc/Doks/phone/clean/guile-against-r.tags1.txt
~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/dlang/dlearn.tagged.txt
~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/mutt-man.tagged1.txt
~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/scoll-mapvisu.tagged.txt
~/Dropbox/rsc/Doks/Comp/lang/java/jdir14.tagged.txt
~/Dropbox/rsc/Doks/Comp/vimdoc8/rman.files/tagsrch.txt
~/Dropbox/rsc/data/lists/ref/lang/shorthrskrift-FackVårdSökaren.tagged.txt
~/Dropbox/rsc/data/lists/keys.shortc/mscore3.shortckeys.tagged.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/pick.legacy/em-mastext1.tagged.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/idiom-eng_list1.Tags.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/MacXkeys.tags.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/decks/comp/lang/cpp/komvux2023-Cpp1.Tags2.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/decks/comp/lang/webdev/freec01_h5c3.tags.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/Win10keysdef.tags.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/tagged/dlang-ali1.tagged.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/tagged/lpy01.tags.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/tagged/Win10keysdef.tags.txt
~/Dropbox/scratch/Math1_Komvux-mars2023.Tags1.txt
~/Dropbox/scratch/Math2_Komvux-mars2023-v2.Tags1.txt
~/Dropbox/scratch/Math2_Komvux-mars2023-v1.Tags.txt
~/Dropbox/scratch/Math1_Komvux-mars2023.Tags2.txt
~/Dropbox/scratch/Math2_Komvux-mars2023-v3.Tags1.txt
~/Dropbox/bin/scripts/va/doc/svsyndb-tagging.txt
}}}

  winterminal
  . {{{
    ~/gdrive/rsc/Doks/taskuj/winterminal-tipstricksprodhacks_2021.Tags1.txt
  }}}
  ----
    Reveal, Impress  __
    . {{{
      ~/gdrive/rsc/Doks/taskuj/mmedia/present/revealjs.Tags1.txt
            ~/Dropbox/rsc/Doks/phone/graf/revealjs.Tags1.txt

      ~/Dropbox/rsc/data/lists/ref/graf/pr/impressjs.txt
      --
      ~/Empire/graf/imprjs.txt
      ~/Empire/graf/pr/imprjs.txt
            ~/Empire/Comp/lang/webdev/imprjs_aux.txt
            ~/Empire/Comp/lang/webdev/js/present/imprjs.txt
    }}}
  Spectre Console
  . {{{
    ~/gdrive/SpectreConsole.tags1.txt
  }}}
  android scripting
  . {{{
    ~/gdrive/rsc/Doks/taskuj/AndroidProgr/android-scriptautomation.Tags1.txt
  }}}
  ASP.NET CORE MVC __ (++Web APIs)
  . {{{
    gvim ~/gdrive/rsc/Doks/taskuj/LIA2/DotNetCore/{AspDotnetCore-InAct-3e_2023,AspDotnetCore7-Pro-10e_2023,AspDotnetCore-WebAPI_2023,manning-morebooks/0_manning-extratitles_including-free,manning-morebooks/api-designpatts_BUY,manning-morebooks/apidelivery-automate,manning-morebooks/dotnetcore-inact-2e_mauiavalonia,manning-morebooks/webapi-test,manning-morebooks/webapis-design-2e}.txt

    gvim ~/gdrive/rsc/Doks/taskuj/LIA2/DotNetCore/AspDotnetCore{-InAct-3e_2023,7-Pro-10e_2023,-WebAPI_2023}.txt
        rsc/Doks/taskuj/LIA2/DotNetCore/AspDotnetCore-InAct-3e_2023.txt
        rsc/Doks/taskuj/LIA2/DotNetCore/AspDotnetCore7-Pro-10e_2023.txt
        rsc/Doks/taskuj/LIA2/DotNetCore/AspDotnetCore-WebAPI_2023.txt
  }}}
  FuncPy
  . {{{
    ~/gdrive/FuncPy.binder.Tags1.txt
  }}}
  py/f# sysadm  #
  . {{{
      PyProgr
    ~/Empire/Doks/Comp/lang/py/sysadm/py-unlin-sysadm.txt
      ~/Empire/Doks/Comp/lang/py/sysadm/propysysadmin.txt
  }}}
  JupNotebooks, polyglot notebooks, Pandas(etc)
  . {{{
      ~/gdrive/JupNoteb.binder.Tags1.txt

        https://learn.microsoft.com/en-us/training/modules/polyglot-notebooks/
        https://code.visualstudio.com/docs/languages/polyglot
  }}}
    datawrangl {{{
        ~/gdrive/rsc/Doks/taskuj/Misc/datasci/pydatawrangl-clean_2022.txt

        ~/gdrive/rsc/Doks/phone/Comp/datasci/py/pydatawrangl-clean_2022.txt
    }}}
  Obsidian __ @  MLEARN**(+)
  . {{{
    gvim -c 'colors molokai_dark' ~/Empire/Doks/Comp/lang/py/mlearn/{mlearnapps-ideatoprod_2020.tags1,mlearn-mobprojs_2018,mlearn-scikitkerastflow-2e_2019,py-aiproj-uprunning_2018}.txt

    ~/Dropbox/rsc/Doks/phone/Comp/pr/Obsidian.txt
    ~/Empire/lang/markup/MD/md-obsidian.txt
  }}}
    vim pyplugins  _
    . {{{
      [Video-transcription + Taylor's Wiki]
    }}}
  Xonshell  __
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/XonShell.Tags1.txt
  }}}
  Termux  __  @@
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/sysadm/Termux.Tags1.txt
  }}}
  Mpv-Docs | Yt-Downl
  . {{{
    ~/gdrive/rsc/Doks/taskuj/mmedia/Mpv-Docs.txt
  }}}
  AVALONIA
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/Avalonia.txt

    ~/gdrive/rsc/Doks/taskuj/LIA2/manning-morebooks/dotnetcore-inact-2e_mauiavalonia.txt
    ~/Empire/Doks/Comp/lang/clangs/csharp/gui/xaml-avalonia/Avalonia.txt
  }}}
  NuShell  _
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/nushell_docs-book.txt
    ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/nushell_cb-oneline.txt

    ~/Empire/Doks/Comp/lang/webdev/db/relational/mysql-maria/mysql-nushell_2009.txt
  }}}
  Wsl
  . {{{
    ~/gdrive/rsc/Doks/taskuj/WSL/*.txt

    gvim ~/Empire/Doks/Comp/sysadm/lin/wsl/*.txt

    */
  }}}
      Graph, MSAL
      . {{{
      }}}
  ----
  GraphQL(!)  #
  . {{{
  }}}
    sqlitebrowser  ___onroad
    . {{{
      ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/db/sqlitebrowser-docs.txt
    }}}
    MongoDB Compass / MongoDB Realm  @@
    . {{{
    }}}
  Rx.Net
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/rx/RxDotnet-2e_2024.txt
  }}}
  REACT (+Mongo)  ##  _Clean_  ¤¤
  . {{{
    gvim ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/freec-0{3_frontendlibs,5_nodemong-apimicros}.txt
    [+Material UI]
  }}}
    Bash|Dash-Mans
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/sh-Bash.txt
    ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/sh-dash.txt
  }}}
  Puppet
  Mojo  TODO:OCR
  Devops
  . {{{
    ~/Empire/Doks/Comp/PROGR/devops/PyDevops-ansibdockeraws_2019.txt
    ~/Empire/Doks/Comp/PROGR/devops/py-fordevops_2020.txt

    ~/Empire/Doks/Comp/PROGR/devops/PyDevops-ansibdockeraws_2019.txt
    ~/Empire/Doks/Comp/PROGR/devops/py-fordevops_2020.txt
  }}}
  F#[!!!!] + Webframeworks (Fabulous, Fable, Suave)
  . {{{
    gvim ~/gdrive/rsc/Doks/taskuj/Cs/Fs/{Fable/Fable-framew,Fabulous/Fabulous-framew}.txt
      https://suave.io/

    gvim ~/Empire/Doks/Comp/lang/clangs/csharp/fsharp/{fsdeepdives_2015,fs-domainmodel_2018,fs-ess_2023,FsharpRealworld,fsharp-survguide,fswebmob-netmvtazurewbebsock_2013,functprogr-realworld_2010}.txt

    gvim ~/Empire/Doks/Comp/lang/clangs/csharp/fsharp/{fs-domainmodel_2018,fs-datastructsalgos_2015,FsharpDocs_2022plus,FsharpRealworld,fsharp-survguide,FsGetprogr_2018}.txt
  }}}
  Roslyn (+Analysis|CodeGen)
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/codegen/cs-roslyncb_2017.txt
    ~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/codegen/roslyn-codegen_2017.txt
  }}}
  Reason + PureScript
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/compilesto/reasonml-qsguide_2019.txt
    ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/compilesto/reasonml2.txt
    ~/Empire/Doks/Comp/lang/webdev/js/compilesto/reasonml/ReasonRescriptBuckle-Docs.txt
    ~/Empire/Doks/Comp/lang/webdev/js/compilesto/reasonml/bucklescript-cb.txt
    ~/Empire/Doks/Comp/lang/webdev/js/compilesto/reasonml/reasonml-qsguide_2019.txt
    ~/Empire/Doks/Comp/lang/webdev/js/compilesto/reasonml/reasonml2.txt

    ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/pscript/purescript-functweb_2017.txt
    ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/pscript/purescript-lenses_2018.txt
    ~/Empire/Doks/Comp/lang/webdev/js/pure/purescript-functweb_2017.txt
    ~/Empire/Doks/Comp/lang/webdev/js/pure/purescript-getstarted.txt
    ~/Empire/Doks/Comp/lang/webdev/js/pure/purescript-lenses_2018.txt
  }}}
  AzDevops
  . {{{
    ~/Empire/Doks/Comp/PROGR/projman/azdevops/azuredevops-agileprojman_2019.txt
    ~/Empire/Doks/Comp/PROGR/projman/azdevops/azuredevops-solutimplem_2020.txt

    ~/Empire/Doks/Comp/PROGR/projman/azdevops/azuredev-guide_2019.txt
    ~/Empire/Doks/Comp/PROGR/projman/azdevops/azuredevops-begguide.mini.txt
    ~/Empire/Doks/Comp/PROGR/projman/azdevops/azure-prodaccel.txt
  }}}
  Java|Cloj Semantic-Web  ¤
  . {{{
    ~/Empire/Doks/Comp/lang/webdev/db/semweb/semanticweb-clojjava_2010.txt
  }}}

  ~/Dropbox/rsc/Doks/phone/Comp/sysadm/win/PshellforSysadms_2020.txt
}}}

cd ~/gdrive
----

  # GitExtensions:  https://git-extensions-documentation.readthedocs.io/en/release-5.1/

gvim `find ~/gdrive/rsc/Doks/taskuj/ -type f -name '*.txt' 2>/dev/null`

~/Empire/Doks/Comp/lang/webdev/js/jsjsoncb_2015.txt
gvim ~/Empire/Doks/Comp/mu/au/csound/{CsoundBook,csoundqt,csound-virtualsoundprocess_2000}.txt
+Blue
Set up def. .vimrc Linux (+test _vimrc for Win)
  ----
gvim ~/Empire/Doks/Comp/lang/clangs/csharp/codegen/{cs-roslyncb_2017,roslyn-codegen_2017}.txt


  MSAL / Microsoft Identity
      gvim ~/Empire/Doks/Comp/lang/clangs/csharp/webmob/maui/{NET_MAUI_in_Action_2023,maui-enterprisepatts_2022}.txt
  Graph API
      ~/Empire/Doks/Comp/lang/webdev/js/jsjsoncb_2015.txt
      ~/Empire/Doks/Downl/exjobb-exempel/msoft-graph/MsoftDocs-GraphAPI.txt
      ~/Empire/Doks/Downl/exjobb-exempel/_newtonsoft-json/jsjsoncb_2015.txt
      ~/Empire/Doks/Downl/exjobb-exempel/sharepoint/Msoft365-Progr_2016.txt
      ~/Empire/Doks/Downl/exjobb-exempel/sharepoint/MsoftDocs-Sharepoint.txt
      ~/Empire/Doks/Downl/exjobb-exempel/sharepoint/sharepoint-tut.txt
      ~/Empire/Doks/Downl/exjobb-exempel/swagger-api/swagger.pres.txt
      ~/Empire/Doks/Downl/exjobb-exempel/msal-msidentity/MsDocs-MsalMSIdentity.txt
  Win 10 Remote Desktop
  ANDROID PROGRAMMING




Bash-Man / YT-DL Cleaning
  Ocaml Master

  Restart THE DOC(+DrSträng)-Publishing(!!)
    Prompt Engineering
    CSound, SuperCollider (etc +Recording)
    Dlang + Vlang
      REF.CB-LISTS[!!]
  Emacs-Install + Setup (Per N++)
    --
  TODO - UPDATE LIST: ____ REFACT[!!], DEBUG  = TODO {{{
    gvim ~/Empire/Doks/Comp/PROGR/refact/{refact-2e_2019,efflegcode,refct,legacycode-beyond_2016,refact-divein_2019,refact-designsmells_2015,refact-despatts_2012,refact-topatts_2005,db-refact_2006}.txt
    + LLDB
    gvim ~/Empire/Doks/Comp/debug/{debugeff-66_2017,Cgdb_2022,debugart-gdbddd_2008,debugit_2009,debug-optim-legacycode_2003,gdb-debuggingwith_2022}.txt
    gvim ~/Empire/Doks/Comp/PROGR/revengineer/{AsmUnderstand-revengin_2019,datamine-revengin_1997,x86disassembly_2013,ghidra-revengineer_2020,revengineer-forbeg_2014}.txt
  }}}
          ~/Empire/Doks/Comp/PROGR/refact/db-refact_2006.txt
      ~/Empire/Doks/Comp/wman/fluxbox/fluxbox-book_2016.txt

gvim ~/Empire/Doks/Comp/mu/au/{midi/modernmidi-sequencing_2020,auprogr-book_2011}.txt

  gvim ~/Empire/Doks/Mu/arr/{MidOrch,ProOrch1.shared,arrpoprock,MuComp,OrchInstr,tradarrroine}.txt
    SCOLL, CSOUND, (ETC) {{{
      gvim ~/Empire/Doks/Comp/mu/au/{csound/csound-virtualsoundprocess_2000,scoll/scoll-book,scoll/ScollLogicpro,scoll/ScollBook,scoll/overtone/overtone-uguide,csound/man-tut/csound-flossman_2011,csound/man-tut/tutorial_5.07,csound/man-tut/1_masteringcsound,csound/man-tut/csound_editingbasics,csound/man-tut/super_mikelson_csound_primer,csound/man-tut/vercoe_a_beginner_tutorial,csound/man-tut/singer_an_introduction_to_csound,csound/man-tut/steven_yi_scanned_tutorial,csound/midi/2_real-time_synthesis_in_csound_with_midi_control,csound/midi/3_midi_instrument_designs_for_real-time_performance}.txt
    }}}

  ~/Empire/Doks/Comp/lang/webdev/db/nosql/graphdb/gremlin/GraphData.txt

  ???????

     ~/Empire/Doks/Comp/sysadm/lin/fhs/fhsstandard_2004.txt
     ~/Empire/Doks/Comp/sysadm/lin/fhs/lsag_2005.txt
     ~/Empire/Doks/Comp/sysadm/lin/fhs/UnixFhs_2003.txt
  ~/Empire/Doks/Comp/sysadm/lin/101linhacks-3e.txt
  ~/Empire/Doks/Comp/sysadm/lin/101bashhacks.txt
  ~/Dropbox/rsc/Doks/Comp/debbib.txt
  ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/sh-Bash.txt
  ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/XonShell.Tags1.txt
  ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/1_unpowtools-3ed2002.Tags1.txt
    /home/bluelegend/Empire/Doks/Comp/sysadm/lin/unixworkbench_2017.txt
    [Unix PowerTools]

    gvim ~/Empire/Doks/Comp/{lang/webdev/js/ffox/ffox-hacking_2005,lang/webdev/js/ffox/ffox-progr_2007,gui-wtoolkits/jsmonkey/hack.greasemonk_2006,gui-wtoolkits/jsmonkey/greasemonkey_2005}.txt

    gvim ~/Empire/Doks/Comp/lang/webdev/c3/sass/sass*.txt

    ~/Empire/Doks/Comp/lang/webdev/db/relational/sqlite/sqlite-mobdev_2015.txt
    ~/Empire/Doks/Comp/lang/webdev/db/nosql/mongo/

    gvim ~/Empire/Doks/Comp/lang/java/build/gradle/{gradle-androidrecip_2016,gradle-buildautomhandb_2016,gradle-buildtest_2011,gradle-effimplem_2012,gradle-succinctly_2017,gradle-uguide2,gradle-uman56_2018}.txt

Hask {{{
    gvim -c 'colors molokai_dark' ~/Empire/Doks/Comp/lang/haskell/{haskpract-2_2019,algebradriven-design_2020,datanalys/hask-datanalys_2015,datanalys/haskell-dataanalysiscb_2014,webdev/hask-practwebdev_2018,webdev/hask-yesodwebapps-2e_2015}.txt
}}}
    gvim ~/Empire/Doks/Comp/lang/haskell/datanalys/{hask-datanalys_2015,haskell-dataanalysiscb_2014}.txt

    ~/Empire/Doks/Downl/  = CLEAN UP DOKS ____
        /home/bluelegend/Empire/Doks/Comp/mu/au/midi/modernmidi-sequencing_2020.txt
        /home/bluelegend/Empire/Doks/Comp/mu/au/auprogr-book_2011.txt

    .   Fs / F# {{{
        gvim ~/Empire/Doks/Comp/lang/clangs/csharp/fsharp/{fsdeepdives_2015,fs-domainmodel_2018,fs-ess_2023,FsharpRealworld,fsharp-survguide,fswebmob-netmvtazurewbebsock_2013,functprogr-realworld_2010}.txt

    gvim ~/Empire/Doks/Comp/lang/clangs/csharp/fsharp/{fs-domainmodel_2018,fs-datastructsalgos_2015,FsharpDocs_2022plus,FsharpRealworld,fsharp-survguide,FsGetprogr_2018}.txt
    }}}
    Flutter {{{
        gvim ~/Empire/Doks/Comp/lang/dart-flutter/flutter/{flutter-apprentice_2021,flutterapprentice_2020,flutter-beg_2019,flutter-gamedev,flutter-layouts,fluttermob-qsguide_2019,flutterpragm_2022,flutter-progr_2020,flutterprojs_2020,flutter-recip_2019,flutter-uis_2022}.txt
    }}}
    ~/Empire/Doks/Comp/lang/dart-flutter/dartlearn_2013.txt  ___Functional
      [+New Functional]

        :args `cat files.txt`
        gvim -c "args `cat ~/RiderProjects/Acme/files.txt`"
MLEARNAPPS-INTRO ** {{{
    gvim -c 'colors molokai_dark' ~/Empire/Doks/Comp/lang/py/mlearn/{mlearnapps-ideatoprod_2020.tags1,mlearn-mobprojs_2018,mlearn-scikitkerastflow-2e_2019,py-aiproj-uprunning_2018}.txt
}}}

Elix** {{{
  Phoenix LiveProgramming

  gvim ~/Empire/Doks/Comp/lang/erlang-elix/{web/phoenix-inact,web/phoenix-realtime-channels,elix-concurrdataprocess_2021,elix-action_2019,elix-adopt_2018,elixmast_2018,elixgraphqlapis-absinthe_2018,ElixGenetic,functwebdev_2018,elixotp-systdesign_2019,elixfunct-newworldfounds_2018,domaindrivendesign_2006,elixir-succinctly_2019,ElixCb_2015,elix-ectodatabaseapps_2019,elix-functprogr_2018}.txt

  ~/Empire/Doks/Comp/lang/erlang-elix/elix-introd_2e_2017.txt
  ~/Empire/Doks/Comp/lang/erlang-elix/elixir-language_2017.txt
  ~/Empire/Doks/Comp/lang/erlang-elix/ElixirSchool.txt
  ~/Empire/Doks/Comp/lang/erlang-elix/elix-learnfunctprogr_2018.txt
  ~/Empire/Doks/Comp/lang/erlang-elix/elixprogr-16_2018.txt
  ~/Empire/Doks/Comp/lang/erlang-elix/elx-littleotp_2017.txt
}}}
Xml W3Shools {{{
    ~/Empire/Doks/Comp/lang/xml/xml-w3schools.ToClean.tags1.txt
}}}
XunitPatts ** {{{
    gvim ~/Empire/Doks/Comp/PROGR/test/framew/{xunit/XunitPatts,selenium/selen-datadriventest_2018,selenium/selen-tipstrickspract_2021,selenium/selen-webdriver3-practguide_2018}.txt
}}}
DotNet Core (+EF Core) {{{
    gvim ~/Empire/Doks/Comp/lang/clangs/csharp/webmob/dotnet-core/{aspdotnetcore5_2020,cs7-dotnetcore2-crossplatfdev_2017,cs7-dotnetcore-cb_2017,dotnetcore2-byex_2018,dotnetcore-inact_2018}.txt
}}}
____ Cs DesignPatterns {{{
    gvim -c 'colors molokai_dark' ~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/{cs-despatts_2018,designpatts.cs.Tags1,effective-cs-with-scottm_2017,cscb_2022.Tags1,cs-codeconventions,csharptips-2014,cshconceptsavanc,functional-cs.Tags1}.txt
}}}
EF Core {{{
    gvim -c 'colors molokai_dark' ~/Empire/Doks/Comp/lang/clangs/csharp/db/entity/{entityframewcore6-2e_2022,pract-entity-framework_2020,entitydev-codefirst_2015,cs8-dotnetcore3-entity-vscode-4e_2019,entity-framework-core-2-aspnet-core-mvc_2019.ru,entitycore2-asp-coremvc_2018,entitycore-inaction_2018,cs7-dotnetcore_2017.ru}.txt
}}}
.  (nix(guix) + nix-os) {{{
    gvim ~/Empire/Doks/Comp/sysadm/lin/distro/NixGuix/{NixRefman,NixpkgsRefman,NixOSMan,guix-cookbook,GuixMan,guix-refcard}.txt
}}}
    gvim ~/Empire/Doks/Comp/lang/java/cloj/{cloj-bravtrue_2015,clscript/clojworkshop-clojscript,datasci/clojdatanalyscb,clojrecip,clojurecb,clojure-realworld_2012,cloj-workshop,getting-clojure2_2018,microservices-with-clojure_2018,practical_clojure_2010}.txt
__ __ CLOJURE + Clscript {{{
    gvim -c 'colors industry' ~/Empire/Doks/Comp/lang/java/cloj/{clojcb_2014,sicp.clojure,clojprof_2016,cloj-progr-2e_2012,clojrecip,clojurecb,cloj-workshop,jcloj-2e_2014,microservices-with-clojure_2018,practical_clojure_2010,clojquick_2017,clojure-realworld_2012,getting-clojure2_2018,programming-clojure_2018,clojelems_2019,cloj-hiperf,clojliving_2015,cloj-pract_2010}.txt
      webdev
    gvim -c 'colors industry' ~/Empire/Doks/Comp/lang/java/cloj/clscript/{clojscript-studies_2016,clojscrlearn2,clojscrlearn_2016,clojscr-rxwebfunct_2017,clojworkshop-clojscript,lclojurescript}.txt
    patts/algos + Rx + Datasci ----
    gvim -c 'colors industry' ~/Empire/Doks/Comp/lang/java/cloj/{datasci/cloj-datanalys_2014,datasci/clojdatanalyscb,datasci/cloj-datasci_2015,datasci/clojmlearn_2014,patts-algos/clojalgodatastruct,patts-algos/clojscala-functprogrpatts_2013,patts-algos/clojscalfunct-datastructalgos,rx/cloj-hiperform--asynchchannels-logicrx_2017,rx/cloj-rx_2015,rx/cloj-rxhandson_2019}.txt
}}}
        clojure-sicp
    gvim ~/Empire/Doks/Comp/lang/webdev/Aux/Aws/{AwsCb_2022,awslambda-progr_2020,go-serverless-awslambda_2018}.txt
    gvim ~/Empire/Doks/Comp/PROGR/git/{githubactions_2021,githubactions-workflowautom_2021,gittools-building_2016}.txt
____ Docker (+Aws/Azure, kubernetes)  vagrant, ansible  AUX {{{

    gvim ~/Empire/Doks/Comp/network/networksec-nmap_2017.txt

    gvim ~/Empire/Doks/Comp/lang/webdev/deploy/{openshift-dockerdeploy_2018,kubernetes/kubernetes-essentials,kubernetes/kub-completedev_2020,kubernetes/kubern-bestpract_2020,kubernetes/kubernetes-admin_2022,kubernetes/kubernetesguide_2019,kubernetes/kubern-progr_2019}.txt

    ____
    gvim ~/Empire/Doks/Comp/PROGR/devops/{ci/cipipeline-jenkinskubernterraform_2021,aiml-devops_2019,devopsautom-cb_2015,devopscareer-handb_2022,PyDevops-ansibdockeraws_2019,py-fordevops_2020,serverlessops_2017}.txt

    gvim ~/Empire/Doks/Comp/PROGR/projman/azdevops/{azuredev-guide_2019,azuredevops-agileprojman_2019,azuredevops-begguide.mini,azuredevops-solutimplem_2020,azure-prodaccel}.txt

        gvim ~/Empire/Doks/Comp/{PROGR/devops/vagrant/sharepointdevops-packerterraformansibvagrant_2018,PROGR/devops/vagrant/vagrant-devops_2018,PROGR/devops/vagrant/vagrantcb_2015,PROGR/devops/vagrant/vagrant_2013,cybersec/ansible/secautom-ansib2cb_2018,cybersec/ansible/secautom-ansib2_2017}.txt

}}}
Functional Algos/Design-Patterns {{{
    gvim -c 'colors molokai_dark' ~/Empire/Doks/Comp/funct-reactive/{functreact-domainmodel_2017,purefunct-datastructs_1998,reactive-despatts_2017}.txt
}}}
SEMANTIC WEB + Elastic Search {{{
    gvim ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/db/{azure-cosmosdb-mongo_2018,elastsearch-action_2022,dynamo-book_2020,dynamodb_2016.tutspoint,dynamo-mast_2014,semweb/intellsemwebsyst-epistemof_2016,semweb/knowlgraphs-linkeddata-largeorgs_2017,semweb/semanticweb-clojjava_2010,semweb/semweb-datamanage-qprocess_2011,semweb/semwebRDFSPARQL,semweb/semweb-structdata_2015,semweb/semweb-webscience_2013,semweb/sparql-learn,semweb/sparql-learn_2011,semweb/webdataapi-forknowlgraphs_2021}.txt
}}}
        ~/Empire/Doks/Comp/lang/scm/kawa/kawa-docs.txt
Coq, Isabelle, Agda {{{
    ~/Empire/Doks/Comp/lang/{
      misc-lang/coq-isabelle/Coq-8-19-2-Refman_2024
      misc-lang/coq-isabelle/coq-certifprogrwdeptypes_2019
      misc-lang/agda/agda-verifiedfunctional_2016
      + Owl, Ontology(Isabelle,Vampire)
      webdev/db/semweb/ontology/isabelle-part1.txt
      webdev/db/semweb/ontology/vampire-prover_2012.txt
      webdev/db/semweb/ontology/ontology101.txt
    }.txt
}}}

    Misc Datasci: (AI/MLEARN ETC) {{{
        gvim ~/Empire/Doks/Comp/{mlearn-ai/mlops/pymlearn-mlopsengineer_2021,mlearn-ai/cloud/aipragm-cloudmlearn.ru,mlearn-ai/Js/jsmlearn-pract_2021,mlearn-ai/Js/jsmlearn-handson_2018,lang/go-v/go-serverless_,datasci/cmdline-datasci_2015,lang/py/datasci/py-complexnetwanalys_2018}.txt
    }}}

    - Study TPope Vimrc[!!] (+Dotfiles)
    - START MODULARIZING VIMRC|EMACSINIT.EMPIRE(!)  @@


        UNIX POW.TOOLS (*!)       @@
    - mutt, Graphdbs(?)
        - Blender Py Getstarted 1  @
    - Termux: new tagged list  @@
        grep/sed/awk w. Python **(!)

                - Bluebash 1 ****  @@
    --
    to Txt-Manuals(!!): PyPyramid, 'AudacityMans'*
gvim -c 'colors molokai_dark' ~/Empire/Doks/Comp/lang/py/webmob/{pyramid/PyramidFrawew-Docs_2023,flask/pywebdev-flask-2013,py3webdev_2011,pyreact}.txt
      ~/Dropbox/rsc/data/lists/ref/comp/lang/kotlin/Kotlin-Refdocs.txt
      RevealJs-Doks,
      - ~/Dropbox/rsc/Doks/phone/Comp/lang/py/hylang.txt
          (+install vim syntax plugin)

    - Start Cut: Hallå Där + Dft-Vids(+ Magnus B Födelsedagsfest(!))  @
      - LÄR/ÖVA IN DFT + THE DOC-MUSIC @
    - 4K Gear / Hero Manuals[!] @@ *** [+filma (+publ.) DFT-PIECES]
    --
    VimRefman Review 2022(!!)  #+make flat list of topics|bests|pickouts
    --
    - Anki-Man
      kde connect (!!) (+PHONES, TABLET S3)
    --
    - Clean out NatureImages 1 (+set new Shotwell-architecture)
      - Clean DrStr-Images 1 [!]
    - LÄROPLANSTRÄDET MU-UNDERVISN. (**/!!)  @(!!)
    - Bö. planka trum:'timeagent'(****)  #+Allt(!!) i gamla Elevfiler (=w. the|a new more flexible scheme(**/!!))   ((********))
    --
    - RESET THIS INDEX TO FOLDMETHOD=INDENT(???)
    --
      - ps typefacelib 1 'pickout-lists'(!!)
      - Blender: Prepare - Real Blenderwork (+Ss-Books/Tuts(!!))  [[=3 Books]]
        - Digest Bildoks
        --renskriv föret:paulaw-petraa-andreasanacka_Notes/Sammanst.(*!!)
        LAT
        ~/Dropbox/rsc/lists/ref/Lang/Lat/vivlinglat.txt
        ~/Dropbox/rsc/Doks/phone.fmt35/todo/suitecrm.txt
    }}}
--------------------------

-- ontheroad.store ---- ___index=4 [4] {{{

SASS+Compass {{{
  ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/c3/sass/SassCompCb_2016.txt
}}}
AnkiMan (+Renskriv ___office)
  festival
            Samsung Notes (+Phone/Tablet)
            Nyxt (+qutebrowser/'hackers browser')

Termux
    PowerShell[!]  WSL ____
  AndroidProgr (+Kotlin??)
  ----

    MAUI (=Office)  [Kotlin + Funct.] {{{
      https://dotnet.microsoft.com/en-us/apps/maui
          https://github.com/dotnet/maui

      https://app.pluralsight.com/search/?q=maui&type=conference%2Cvideo-course%2Cinteractive-course%2Clab%2Cpath%2Cproject%2Cskilliq&m_sort=relevance&query_id=4b3da816-f267-4168-ad9d-93702ef2f151&source=user_typed
      https://app.pluralsight.com/library/courses/dot-net-maui-big-picture/table-of-contents
      https://app.pluralsight.com/library/courses/dot-net-maui-fundamentals/table-of-contents
      https://app.pluralsight.com/library/courses/building-dot-net-maui-applications-mvvm/table-of-contents
      https://app.pluralsight.com/skilliq/dot-net-maui/intro

      https://app.pluralsight.com/library/courses/blazor-hybrid-apps-building/table-of-contents

      https://app.pluralsight.com/search/?q=javascript%20functional&type=conference%2Cvideo-course%2Cinteractive-course%2Clab%2Cpath%2Cproject%2Cskilliq&m_sort=relevance&query_id=600873c0-ec10-413b-8707-92fdca418845&source=user_typed

      https://app.pluralsight.com/library/courses/asp-dot-net-core-mvc-deep-dive/table-of-contents
      https://app.pluralsight.com/library/courses/aspdotnet-core-mvc-enterprise-application/table-of-contents
      https://app.pluralsight.com/library/courses/asp-dot-net-core-6-fundamentals/table-of-contents
      https://app.pluralsight.com/library/courses/aspdotnet-core-6-entity-framework-6-tailwindcss-vue-3-building-web-app/table-of-contents
      https://app.pluralsight.com/library/courses/asp-dot-net-core-6-crash-course/table-of-contents
      https://app.pluralsight.com/library/courses/architecting-aspnet-core-mvc-unit-testability/table-of-contents

      https://app.pluralsight.com/search/?q=dotnet%20core%20mvc&type=conference%2Cvideo-course%2Cinteractive-course%2Clab%2Cpath%2Cproject%2Cskilliq&m_sort=relevance&query_id=939e25e0-c3de-4c12-bc26-79e62831d81b&source=user_typed
      https://app.pluralsight.com/library/courses/dotnet-ecosystem-big-picture/table-of-contents
    }}}
        Learn/Memory(+pomodoro)
    F#/Elix/Cloj/OCaml(etc) Datastructs[!!]
    jsCb 1, 
    Datomic *!  (+Datalog | Prolog)
    PureScript (x2.5)
        Bluebash **  @@
        Jseloq|JsFunct[!] + (h5g 2) @ - Wappdevex 1  SASS + Compass, TScript  UrWeb
          FreeC [!!]
    AnkiDef =2024++
    NuShell
    NetRW: =new minilist   vim-bashmode, vim-outliner
    VimscrHardw
        ClojWebdev,  clojurescript [!!]
    Pyfunct (1+2?)
        FreecRedone2 (+js-wappdev2)
    Emacs, Org + Elisp
      webscraping[!]
    - Termux: new tagged list  @@
    - Vnc (+remote desktop)  @
      - Ssh  @
    Dlang**,   Vlang
      Sass/Compass, Elm
      Docker/Kubern, AWS
      SemWeb =Knowl.Graphs, Ontologies: SUMO/Kif
      cypher (+gremlin), GraphQL
      julia[!]
    wine
    Funct C# / Cpp  + C# Avanc[!!(!)]  +UNITTESTING[!!!!]
      F#, Elixir[**] +Domain-Modeling
        Clojure[!!]  + LightTable
        reveal.js, impress.js
      Datasci + Stat + MLearn/AI [!!!**]
      blockchain + solidity(!)
    Asm[!!]
     C[!!]
     Haskell, Flutter[!]
    Tasker + Scripting Android(!!)  @
        Java with EE[!!]
        F* [=Need Cleaning +Setting Code]
        vera    @
    - Debian-bib  @(!)
    [+start Lang|Words|Litt]
    --
    rskrift | Gregg-snippets
    ---- Shop 1 {{{
        Lisp/Scheme/Elisp
      FunctReactive [+Datastructs]
     pygimp
    C + Datastructs
        gradle( +maven)
     DataSci + Stats[!], MLearn + NLTK/OpenCv
     microserv.
     blockch. + Go[V]
    Aux[comp]
    Archit.Comp/.Sys [*]
     netw.
     Testing + Cybersec.
    Ssh, vnc, Docker, Puppet,  Ansible
     Haskell + Liquid
    Idris
    debug
    webcomponents
    Rust
    gradle
    }}}

    
        BASH/UNIX
    - Ardour
    - socframg.[++]
    - Bevingat    @
        Saol.run1
      encyclstart (+hist)  Mini
        - 'greps' / Regex[!]
        cpp1+
    ('py boring')
        - Vidau-compress[!]  @
        @  teal, (fennel)   nvim-lua (+lua4)
            DUMMIES-start (**)
    --
      Writer|VimLatex
        ProGit(=relisten) + VankilistGit 1 =Rewrite (****(!!)) - + derekbanas + Tim Pope / SysCrafters(!)
     --
     - forts. planka 'rel.ond'(=rsteno)  +nystart Gregg +A.Doyle(**)
                 svsyndb(start  (=??))
     - JUR, Grundlagar, etc
       .
       .
    ----

    ---- körn./ute sommar 2021 (**(!)) ----
    - 'Strat'/ VÄKT** (+Sec Online**)
        # +pre(??): Ny Lägenhet, Allm.A(Städ, recept/näring, Hemskötsel, Bil(**))
    ----------
     - three.js (+=Games with __)
    - SvSynTotal(??)
    - Csounds (etc  ??)   #=keyb, Scoll, 
       - Algo (etc), PROGR****(??),  'Data Science' + Math(!!(**))
            + Grafik/Video mm (??/**)
         - Allm-A | JUR(+), Hist(!)
     - LITT(??/*)  - Bevingat
     - BASH(!!!!)
    - grep / Regex (etc)
    ----
    - haskell-mu(**!)  - haskell-lyself(**!)
                               (+klar m. vankiutils framework(!!)  +  more tagging/making vankinote(etc)-scripts (**!!))
                                            (HM!!!!! (=TAKING NOTES AS STENONOTES?????//////) )
     - 'Strat'/ VÄKT** (+Sec Online**)
                    # +pre(??): Ny Lägenhet, Allm.A(Städ, recept/näring, Hemskötsel, Bil(**))
    ----------
    - SvSynTotal(??)
    - Csounds (etc  ??)
     - 'More Python?? // Dlang(***(!!))   (=PyStdLib **(!!))
        - Algo (etc), PROGR****(??),  'Data Science' + Math(!!(**))
            + Grafik/Video mm (??/**)
     - LITT(??/*)  - Bevingat
                - Skämt|Hist // Citat(!(/??))
    - grep / Regex (etc)
    ----
    - haskell-mu(**!)  - haskell-lyself(**!)
}}}


script oneliners(='nuggets'), 'reusing scripts.legacy[!]'  [+bashr|vimrc to ~/Dropbox/config-dirs  + xkbmap-aliases (+document all in lazarus.txt)] {{{
__area=1
    ~/dropbox-legacy/scripts/./wallpapers.bash

    (vim)utilscript-ideas 2021+  - charsperminute.el  - fontlarger.vim  **

    vim:fdm=marker:
    vim:syntax=cs:shiftwidth=2:
    set syntax=cs shiftwidth=2 | colors molokai_dark | set guifont=*


new(!)
    Rider Vim 0.1 ----

    evince -p 4 -l uncheck /home/bluelegend/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/mscore3.man.pdf &
        #start dok w. evince, go to page, search for 'word' [*****]
        # (=redo Greggref-system + Rskriftref-system2(!) w. this mechanism[!!])

    ls | grep DirnamePart | zip ZipName -r -@

    find -type f -iname '*.txt' 2>/dev/null | gvim -; ding
    find -type f -mtime -3 -name '*.txt' 2>/dev/null
        # search below =for all txtfiles modf.d last three days[!!]

    "copy + mkdir -p"
        install -D ~/path/to/source.txt ~/path/to/destin/dir/destin.txt

    bashrc-aliases: keyq(w) keyd(v)   k-qw k-dv
        setxkbmap -layout se                    #qwerty   keys.qwer
        setxkbmap -layout se -variant dvorak    #svdvor.  keys.sdvor

    bash list-of-commands.txt


-- 'nuggets' (format-strings, mini-hacks, commands) ------
    00H:02m:31s                 # vlc time
    %Y%m%d_%NNNNNN              # shutter
    %s:\v(/\*|\*/)::g           # remove '/* */'
    set syntax=svg              # list lang-names:
                                #   ls /usr/share/vim/vim81/syntax | c:\tools\vim\vimNUM\syntax
                                #   (python, java, bash, clojure, tex, etc)
    screenshot: csa-s  #gimp: take screenshot
    manual duplex               # [print last odd+ ]
                                #   even, odd+reversed
    man manpage | col -b | gvim -   # export unix manpage to .txt

rename links automatically prepended by 'link to ' by thunar:
    for f in link\ to\ *; do mv "$f" "${f#link to }"; done
    for f in zlib*; do mv $f ${f#zlib.pub_}; done

    xclock -update 10 &
    gnome-clocks                # world time
    curl wttr.in/uddevalla      # cmd-line weather
    ----
    ncal -w -A 2                # show weeks, curr. month, + two months ahead
    ncal -w -A 2 -b
    ncal -bw
    ncal -bw -m 6; ncal -bw -m 7; ncal -bw -m 8
                                # show three months - vertically

    find(+list) largest dirs|files
    compare dirs (+recurs)      # diff, mc
    ----
    apt, dpkg  etc
    sudo apt -y update && sudo apt -y upgrade
      sudo dpkg -i install-file.deb     # install deb-file fr. commandline

    ---- [reusing legacy scripts]
    legacy.runscript.bash `legacy.atgrep.bash ocr`


guix pull
guix package -u
hash guix


Remove stale or missing PPA (Ubuntu)
  # e.g. https://ppa.launchpadcontent.net/me-davidsansome/clementine/ubuntu
sudo apt-add-repository --remove ppa:me-davidsansome/clementine

}}}
legacy scripts {{{
__area=2
    ~/dropbox-legacy/scripts/./export_steno2pdf.bash DoneStenodok.svg
        .
    ~/dropbox-legacy/scripts/./GALAXYJPG2TXT_FLEX-norotation_notextcleaner.bash  #use legacyscript for ocr:ing (**)
~/dropbox-legacy/scripts/ALLTODOIST/./zz_OCRPROC-OCRPROJ.bash {{{

Signs|Chars to replace:
        “ ” ‘ ’
               ((+add more char.s, like <4656>-style spec|ctrl-char.s(!!)))
        –  (+w. ' ' around)
        •  (espec. at start of line)
Adjust lines ending in '-' | Words w. embedded '- '
Insert line after:
        lines ending in  \.)\=  :  ?  !
        lines end w. \l, next starts w. \u
Generate incremental bulletlists (1. 2. ..., a. b. ...)
  temp: o
Immo0`ov0"my  #pre: set reg. 'm' to '1. '  +  macro sets marker 'o'

@i(nterweave)  #pull and merge lines fr. next textblock  to end of lines of curr. textblock
@block-split   #separate line-ending textparts in curr. textblock  down to separ. textblock below(!!)
@n: }dd

}}}
      ~/dropbox-legacy/scripts/./mid2mp3
      ~/dropbox-legacy/scripts/./wav2mp3
    ==== Note: ** Pic/Media-scripts migrated to at.transcribe.bash ** ====
    ~/dropbox-legacy/scripts/./frecord.bash  #crap(!! =inte ljud; bara brus)
      ~/dropbox-legacy/scripts/frecord.bash
      ~/dropbox-legacy/bla/frecord.bash
    ~/dropbox-legacy/scripts/ALLTODOIST/./ALLM-STÄD_dataadmin_RENSAFILERLAGRINGHÅRDDISKAR.bash
        ~/dropbox-legacy/scripts/ALLTODOIST/ALLM-STÄD_dataadmin_RENSAFILERLAGRINGHÅRDDISKAR.bash
}}}


GEMINI NEWEST  [Termux PKG, ] {{{

Android + Windows: =SVDVORAK UTILITY {{{

- Question: I have been working for
  some time both myself and in
  tandem with a relative (who is
  very knowledgeable in the area of
  software-development) on learning
  more about Android
  app-development primarily using
  Kotlin. I have a small but
  nagging problem of being able to
  use a custom SvDvorak setup when
  using a keyboard connected via
  bluetooth to my Android-device.
  Since it seems unlikely to be
  able to get that functionality on
  my phone without rooting it and
  changing the system-files
  directly, I was thinking another
  solution could be to write a
  small headless Android-utility
  that sits as a middle-layer in
  between my external
  keyboard-signal and the system
  and 'translates' keystrokes from
  my keyboard to the right key. One
  example would be that if I press
  the letter g, that should
  translate to the letter i and so
  forth.

That's a very interesting and
practical problem! You're right,
getting a custom keyboard layout
like SvDvorak to work system-wide
on Android without rooting is
challenging. Creating a headless
utility (a background service) to
remap keystrokes is a clever
approach. Here's a breakdown of how
you could tackle this, along with
some considerations:

Conceptual Overview

    Background Service:
        Create an Android service that runs in the background. This service will be responsible for intercepting and modifying keyboard events.
    Input Event Interception:
        Use the InputManager and InputDevice APIs to listen for keyboard events from your Bluetooth keyboard.
        You'll need to filter for events specifically from your external keyboard.
    Key Remapping Logic:
        Implement a mapping table or function that translates the incoming keycodes from your SvDvorak layout to the standard QWERTY (or whatever the device expects) layout.
        For example, if the 'g' key in SvDvorak corresponds to 'i' in QWERTY, your code should perform this translation.
    Injecting Modified Events:
        Use the InputManager to inject the modified key events back into the system. This effectively simulates pressing the correct keys.

Technical Implementation (Kotlin)

Here's a simplified outline of how
you might implement this in Kotlin:

import android.app.Service
import android.content.Intent
import android.os.IBinder
import android.view.InputDevice
import android.view.KeyEvent
import android.view.InputManager
import android.util.Log

class KeyboardRemappingService : Service() {

    private lateinit var inputManager: InputManager
    private val svDvorakToQwertyMap = mapOf(
        KeyEvent.KEYCODE_G to KeyEvent.KEYCODE_I,
        // Add more key mappings here...
    )

    override fun onCreate() {
        super.onCreate()
        inputManager = getSystemService(INPUT_SERVICE) as InputManager
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Start listening for keyboard events
        startListeningForKeyboardEvents()
        return START_STICKY
    }

    private fun startListeningForKeyboardEvents() {
        Thread {
            while (true) {
                val devices = InputDevice.getDeviceIds()
                for (deviceId in devices) {
                    val device = InputDevice.getDevice(deviceId)
                    if (device?.sources?.and(InputDevice.SOURCE_KEYBOARD) == InputDevice.SOURCE_KEYBOARD) {
                        //check if the device is a bluetooth device.
                        if(device.getName().contains("Bluetooth", true)){

                            val events = inputManager.getInputDevice(deviceId).getMotionRanges()

                            inputManager.registerInputDeviceListener(object : InputManager.InputDeviceListener {
                                override fun onInputDeviceAdded(deviceId: Int) {}
                                override fun onInputDeviceRemoved(deviceId: Int) {}
                                override fun onInputDeviceChanged(deviceId: Int) {
                                    val device = InputDevice.getDevice(deviceId)
                                    if(device?.sources?.and(InputDevice.SOURCE_KEYBOARD) == InputDevice.SOURCE_KEYBOARD){
                                        val events = inputManager.getInputDevice(deviceId).getMotionRanges()
                                    }
                                }
                            }, null)

                            inputManager.registerInputDeviceListener(object : InputManager.InputDeviceListener {
                                override fun onInputDeviceAdded(deviceId: Int) {}
                                override fun onInputDeviceRemoved(deviceId: Int) {}
                                override fun onInputDeviceChanged(deviceId: Int) {
                                    val device = InputDevice.getDevice(deviceId)
                                    if(device?.sources?.and(InputDevice.SOURCE_KEYBOARD) == InputDevice.SOURCE_KEYBOARD){
                                        val events = inputManager.getInputDevice(deviceId).getMotionRanges()
                                    }
                                }
                            }, null)

                            val keyEvents = inputManager.getInputDevice(deviceId).getKeyCharacterMap()
                            //This is very simplified, and does not actually intercept the keyboard events.
                            //This is where the keyboard events would be intercepted and modified.

                            //Example of how to remap a key.
                            //if (keyEvent.action == KeyEvent.ACTION_DOWN) {
                            //    val originalKeyCode = keyEvent.keyCode
                            //    val mappedKeyCode = svDvorakToQwertyMap[originalKeyCode] ?: originalKeyCode
                            //    if (mappedKeyCode != originalKeyCode) {
                            //        // Inject the modified key event
                            //        val newKeyEvent = KeyEvent(
                            //            keyEvent.downTime, keyEvent.eventTime, keyEvent.action,
                            //            mappedKeyCode, keyEvent.repeatCount, keyEvent.metaState,
                            //            keyEvent.deviceId, keyEvent.scanCode, keyEvent.flags,
                            //            keyEvent.source
                            //        )
                            //        inputManager.injectInputEvent(newKeyEvent, InputManager.INJECT_INPUT_EVENT_MODE_ASYNC)
                            //    }
                            //}
                        }
                    }
                }
                Thread.sleep(100)
            }
        }.start()
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null
    }
}

Important Considerations

    Permissions:
        This type of app might require special permissions, potentially including INPUT_METHOD or accessibility service permissions. The exact permissions will depend on how you implement the input interception and injection.
    Complexity:
        Accurately intercepting and modifying all keyboard events can be complex. You'll need to handle various key combinations, modifiers (Shift, Ctrl, Alt), and special keys.
    Android Security:
        Android's security model is designed to prevent apps from arbitrarily intercepting and modifying input events. You might encounter limitations or restrictions.
    Accessibility Service:
        An accessibility service might be a more viable option. It allows you to monitor user input, and modify it. However, the user must explicitly enable your accessibility service.
    Key Character Map:
        Getting the correct keycodes from the Bluetooth keyboard, and then correctly translating them will be the hardest part of the project.
    Testing:
        Thorough testing is crucial to ensure that your remapping logic works correctly and doesn't introduce unexpected behavior.
    Battery Usage:
        A constantly running background service can impact battery life. Optimize your code to minimize resource usage.

Next Steps

    Research InputManager and KeyEvent:
        Dive deeper into the Android documentation for these classes to understand how to work with keyboard events.
    Start with a Simple Mapping:
        Begin by implementing a simple key remapping (e.g., just a few letters) to test your basic setup.
    Expand the Mapping:
        Gradually expand your mapping table to cover all the keys in your SvDvorak layout.
    Test Thoroughly:
        Test your app with different apps and scenarios to identify and fix any issues.

This is a complex project, but it's definitely achievable. Good luck!

- The accessibility approach seems
  interesting and something we
  might want to explore deeper, so
  maybe you could comment a bit on
  that. Also, I would like to point
  out (which I failed to think
  about until just now) that me to
  some extent but certainly my
  brother is very knowledgeable in
  a range of different technologies
  and languages - including C and
  other very close to the hardware
  options. What I'm thinking now is
  that the app does not necessarily
  have to be written primarily in
  Kotlin (although that might be
  necessary to act as a bridge
  somewhere). What I mean is, both
  he and I have looked in the past
  at a range of different languages
  and solutions, including (just to
  take one small example) one
  article that I have read and
  saved from a guy that wrote a
  tutorial/blog-post about having
  some success in writing small and
  very efficient apps using Gambit
  Scheme which compiles down to
  native and (I think) pretty
  efficient C-based utilities.

You're right, the accessibility
service approach and leveraging
your brother's C expertise open up
some interesting possibilities.
Let's delve into those:

Accessibility Service Approach

    How it Works:
        An accessibility service is designed to help users with disabilities interact with their devices. It can monitor user input, including keyboard events, and provide alternative ways to interact with the device.
        In your case, you can create an accessibility service that listens for keyboard events from your Bluetooth keyboard. When a key is pressed, your service can intercept the event, remap the keycode, and then inject the modified event.
    Advantages:
        Less Invasive: It doesn't require rooting the device or directly manipulating system files.
        Established Framework: Android provides a well-defined framework for accessibility services, making it easier to implement.
        User Control: Users must explicitly enable your accessibility service, which enhances security and privacy.
    Disadvantages:
        Permissions: It requires the BIND_ACCESSIBILITY_SERVICE permission, and users will see a warning when enabling the service.
        Potential Performance Overhead: Intercepting and processing every keyboard event can introduce some performance overhead, especially on less powerful devices.
        Complexity: Handling all possible keyboard events and modifiers can still be complex.
        Android restrictions: Android is designed to limit the amount of control that accessibility services have, to protect the user.
    Implementation Notes:
        You'll need to create a class that extends AccessibilityService.
        Override the onAccessibilityEvent() method to handle keyboard events.
        Use the sendKeyEvent() method to inject modified key events.
        You will need to create an accessibility service configuration xml file.

Leveraging C and Gambit Scheme

    C for Low-Level Input Handling:
        C is an excellent choice for low-level input handling due to its direct access to hardware and operating system APIs.
        You could potentially use the Android Native Development Kit (NDK) to write a C library that interacts with the Linux input subsystem to intercept and modify keyboard events.
        This approach could offer better performance and more fine-grained control over input handling.
    Gambit Scheme for Application Logic:
        Gambit Scheme, with its ability to compile to efficient C code, could be a great way to implement the application logic for your keyboard remapping utility.
        You could write the core remapping logic in Gambit Scheme, compile it to C, and then integrate it with your Android app using the NDK.
        This would allow you to write very efficient code.
    Hybrid Approach:
        A hybrid approach could be the most effective:
            Use C (via the NDK) to handle low-level keyboard input and event manipulation.
            Use Gambit Scheme to implement the key remapping logic.
            Use Kotlin to create the Android service and UI (if needed) that interacts with the C/Gambit Scheme components.
    Advantages of the C/Gambit Scheme Approach:
        Performance: C and compiled Scheme code can offer excellent performance.
        Low-Level Control: C provides fine-grained control over input handling.
        Efficiency: Gambit Scheme can generate very efficient C code.
    Disadvantages of the C/Gambit Scheme Approach:
        Complexity: Integrating C and Scheme code with an Android app can be complex.
        Development Time: Writing and debugging C and Scheme code can take more time than using Kotlin alone.
        Portability: NDK code is platform-specific, so you'll need to compile it for different Android architectures.

Recommendations

    Start with the Accessibility Service:
        Begin by implementing a basic keyboard remapping utility using an accessibility service in Kotlin. This will allow you to quickly test your core remapping logic and identify any potential issues.
    Explore the NDK and C:
        If the accessibility service approach doesn't provide the desired performance or control, then explore using the NDK and C for low-level input handling.
    Consider Gambit Scheme:
        If you're comfortable with Scheme, then consider using Gambit Scheme to implement the application logic. Its ability to compile to efficient C code can offer significant performance benefits.
    Incremental Development:
        Break down the project into smaller, manageable tasks. Start with a simple key remapping and gradually expand the functionality.
    Thorough Testing:
        Test your app thoroughly on different Android devices and with various apps to ensure that it works correctly.

By combining the strengths of Kotlin, C, and Gambit Scheme, you can create a powerful and efficient keyboard remapping utility.

- So the Gambit Scheme approach was
  just to mention one option here.
  The device would not be for sale
  and would be strictly custom made
  for myself and my workflow (at
  least there are no other plans at
  the moment). I also use strictly
  Android devices because of their
  easier accessibility and
  malleability compared to e.g.
  iPhone-devices. Also, I'm very
  keen to use functional approaches
  as much as possible, as I think
  (and correct me if I'm wrong
  here) they may be the best game
  in town when it comes to this
  kind of 'pipe this input and
  translate to something else' kind
  of utility.

You've hit on some excellent
points, and your focus on a custom,
highly personalized workflow is a
significant advantage. Let's refine
the approach based on your
preferences:

Prioritizing Functional Approaches and Customization

    Functional Languages:
        You're absolutely right; functional programming paradigms are exceptionally well-suited for tasks involving data transformation and pipeline processing.
        Languages like Scheme (Gambit or others), Haskell (if you're feeling adventurous), or even Kotlin with a strong emphasis on its functional features (lambdas, higher-order functions, immutable data) can be ideal.
        The core logic of your keyboard remapping utility can be expressed as a series of pure functions, making it easier to reason about, test, and maintain.
    Custom Workflow:
        Since this is a custom tool for your own use, you have the freedom to tailor it precisely to your needs.
        This means you can:
            Implement highly specific key mappings.
            Add advanced features like macros or custom shortcuts.
            Optimize the performance for your particular device and usage patterns.
    Android's Malleability:
        Android's openness is a crucial asset, allowing you to explore various implementation options and fine-tune the system to your liking.
        Even if you start with an accessibility service, you can gradually move towards a more low-level approach using the NDK if needed.

Refined Implementation Strategy

    Functional Core Logic:
        Choose a functional language or utilize Kotlin's functional capabilities to implement the core key remapping logic.
        Define your SvDvorak to QWERTY mapping as a pure function or a data structure that can be easily transformed.
        Consider using a declarative approach to define your key mappings, making them easy to read and modify.
    Accessibility Service as a Starting Point:
        Begin with an accessibility service in Kotlin to quickly prototype and test your remapping logic.
        This allows you to focus on the functional aspects of your code without getting bogged down in low-level details.
    NDK and C (Optional):
        If performance or control becomes a bottleneck, explore using the NDK and C for low-level input handling.
        You can create a C library that intercepts keyboard events and passes them to your functional core logic for remapping.
    Incremental Development and Testing:
        Adopt an iterative development approach, adding features and refinements incrementally.
        Write comprehensive unit tests to ensure that your remapping logic works correctly.
        Test your app thoroughly on your target device and with your typical workflow.
    Configuration and Customization:
        Design your app to be highly configurable, allowing you to easily modify key mappings and add custom features.
        Consider using a configuration file or a simple UI to manage your settings.
    Focus on Efficiency:
        Because this is a personal project, you can focus on making it as efficient as possible.
        This includes reducing latency and minimizing resource usage.

Key Functional Concepts

    Pure Functions: Functions that always produce the same output for the same input and have no side effects.
    Immutability: Data structures that cannot be modified after they are created.
    Higher-Order Functions: Functions that take other functions as arguments or return functions as results.
    Data Transformations: Using functions to transform data from one form to another.
    Pipelines: Composing functions to create a sequence of data transformations.

By embracing functional programming
and focusing on a highly customized
workflow, you can create a powerful
and efficient keyboard remapping
utility that perfectly suits your
needs.

- Great. So could you rank order
  the three avenues mentioned in
  your last answer, maybe as a
  first benchmark according to
  resource-efficiency, i.e. some
  Scheme dialect (I have
  documentation for a whole range
  of them, from TinyScheme to MIT
  Scheme, Kawa, Chez, Chicken etc),
  Haskell, and Kotlin - the latter
  particularly using a functional
  approach?

Alright, let's rank those options in terms of resource efficiency, keeping in mind that "resource efficiency" can have multiple facets (CPU, memory, battery, etc.), and the specific implementation will play a significant role.

Here's my ranking, with explanations:

    Scheme (Optimized Implementation):
        Why it's potentially most efficient:
            Scheme dialects, especially those designed for embedded systems or compilation to native code (like Chicken or Gambit), can produce very efficient machine code.   

The functional nature of Scheme allows for concise and optimized code, and its focus on tail-call optimization can minimize stack usage.  

        When you have a very specific use case, and you are willing to spend the time to optimize, scheme gives very good control.
    Caveats:
        Efficiency heavily depends on the specific Scheme implementation and how you write your code. Some interpreters might be less efficient than compiled code.
        The NDK integration will add some overhead.

Kotlin (Functional Approach, Compiled):

    Why it's highly efficient:
        Kotlin compiles to native bytecode (or native code with Kotlin/Native), which is generally very efficient.
        Kotlin's functional features are well-integrated and optimized.   

        The Android runtime (ART) is highly optimized for Kotlin.
        Kotlin has great interop with C through the NDK.
    Caveats:
        The Java/Kotlin runtime environment introduces some overhead compared to pure native code.
        The accessibility service will add overhead.

Haskell (Compiled):

    Why it's potentially efficient:
        Haskell compilers (like GHC) can produce highly optimized native code.
        Haskell's strong type system and purity can lead to efficient and reliable code.   

        Caveats:
            Haskell's runtime system (RTS) can introduce some overhead, especially for I/O-intensive tasks.
            Integrating Haskell with the Android NDK can be more complex than with C or Kotlin.
            Haskell has a steeper learning curve than Kotlin or Scheme.
            The Haskell run time libraries are larger than some of the Scheme libraries.

Rationale:

    Scheme's Potential: If you're willing to invest time in optimizing your Scheme code and using a compiler that generates efficient native code, it can be the most resource-efficient option.
    Kotlin's Practicality: Kotlin offers a great balance of efficiency, ease of use, and Android integration. Its functional features allow you to write efficient and maintainable code.   

    Haskell's Complexity: While Haskell can produce very efficient code, its runtime system and integration with Android can introduce overhead. It also has a greater learning curve.

Important Notes:

    Micro-optimizations: The actual performance differences between these options might be negligible for your specific use case.
    Development Time: Consider the development time and your familiarity with each language. Kotlin might be the most practical choice if you want to get a working prototype quickly.
    Testing: Thoroughly test your app on your target device to measure its actual performance.

In your specific situation, I would lean toward a highly optimized Scheme implementation, or a very well written Kotlin implementation. If you have the time and skill, the Scheme option has the potential to be the most efficient. If you want to get something working quickly, and still have great efficiency, Kotlin is a very good option.
CHICKEN Scheme
Source icon
call-cc.org
Tail call - Wikipedia
Source icon
en.wikipedia.org
Kotlin Advantages Over Java - Guaraná
Source icon
guarana-technologies.com
Functional correctness -- Haskell-ing your way to reliable code - media.ccc.de
Source icon
media.ccc.de
Is Kotlin Worth It in 2024? Evaluating the Benefits and Limitations for Developers - Leanware
Source icon
www.leanware.co

Also, when I use my Android-device outdoors, I have come to rely on always carrying an extra battery-pack or even two (i.e. power-banks), so as long as the resource-usage is not too outrageous (i.e. introducing a lot of wear and tear on the device) I think I have that base fairly covered.

That's a very practical approach! Knowing you have a good power backup definitely shifts the focus a bit. If you're less concerned about absolute minimum battery usage, it allows for more flexibility in your implementation choices. Here's how that impacts the decision:

Impact of Power Backup

    Reduced Pressure for Extreme Optimization:
        You don't need to obsess over squeezing every last drop of performance. You can prioritize development speed, maintainability, and features over micro-optimizations.
    Flexibility in Language and Approach:
        You have more freedom to choose languages and frameworks that you are comfortable with, even if they have a slightly higher overhead.
        This means that if you are more comfortable with Kotlin, that is a perfectly viable option.
    Focus on User Experience:
        You can prioritize a smooth and responsive user experience, even if it means using slightly more resources.
        This includes things like:
            Fast key remapping.
            Reliable handling of all key combinations.
            Easy configuration and customization.
    Increased Exploration:
        You can freely explore different approaches and technologies.

Revised Recommendations

    Kotlin (Functional Approach):
        Given your power backup, Kotlin becomes an even stronger contender.
        Its ease of use, excellent Android integration, and good performance make it a very practical choice.
        It also allows for fast prototyping.
    Scheme (if you want to explore):
        If you are very interested in learning and using Scheme, then this is still a viable option.
        If you want to spend the time to optimize it, it could be very efficient.
    Prioritize Maintainability:
        Focus on writing clean, well-structured code that is easy to understand and maintain.
        This will make it easier to add new features and fix bugs in the future.
    Thorough Testing:
        Regardless of the language you choose, thorough testing is essential.
        Test your app with different apps and scenarios to ensure that it works reliably.

In summary:

    With a power backup, Kotlin becomes a very strong option.
    If you have a strong interest in Scheme, it is still viable.
    Focus on maintainability and thorough testing.

Essentially, the power backup removes the stress of absolute resource minimization, allowing you to focus on creating a tool that is both functional and enjoyable to use.

- Could you sketch out some code
  for a Kotlin-solution to the
  problem and maybe as you said
  focusing on using the
  service-based approach? As we
  have discussed, I think relying
  on a mainly functional approach
  could be very beneficial, and (if
  applicable and certainly if
  feasible) if using or introducing
  a reactive approach could be
  useful?

Absolutely. Let's sketch out a
Kotlin solution using a
service-based approach, focusing on
functional programming and
incorporating reactive elements
where appropriate.

Conceptual Structure

    Service:
        A background service (KeyboardRemappingService) to listen for and remap keyboard events.
    Key Mapping Logic:
        A functional component (KeyMapper) to handle the SvDvorak to QWERTY mapping.
    Event Handling:
        Reactive streams (using Flow or RxJava) to process keyboard events asynchronously.
    Accessibility Service:
        An AccessibilityService to capture and inject key events.

Kotlin Code (Conceptual)
Kotlin

import android.accessibilityservice.AccessibilityService
import android.accessibilityservice.AccessibilityServiceInfo
import android.view.KeyEvent
import android.view.accessibility.AccessibilityEvent
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob

class KeyboardRemappingService : AccessibilityService() {

    private val job = SupervisorJob()
    private val scope = CoroutineScope(Dispatchers.Default + job)
    private val keyEventFlow = MutableSharedFlow<KeyEvent>()
    private val keyMapper = KeyMapper()

    override fun onServiceConnected() {
        super.onServiceConnected()
        val info = AccessibilityServiceInfo().apply {
            eventTypes = AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED
            flags = AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS
            feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC
        }
        serviceInfo = info

        keyEventFlow
            .filter { it.action == KeyEvent.ACTION_DOWN }
            .map { keyMapper.remap(it.keyCode) }
            .filter { it != null }
            .onEach { keyCode ->
                val event = KeyEvent(
                    KeyEvent.ACTION_DOWN,
                    keyCode!!
                )
                sendKeyEvent(event)
            }
            .launchIn(scope)
    }

    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
        if (event?.eventType == AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED) {
            val keyEvent = event.parcelableData as? KeyEvent
            if (keyEvent != null) {
                keyEventFlow.tryEmit(keyEvent)
            }
        }
    }

    override fun onInterrupt() {
        job.cancel()
    }

    override fun onDestroy() {
        super.onDestroy()
        job.cancel()
    }

    override fun onKeyEvent(event: KeyEvent?): Boolean {
        if (event != null) {
            keyEventFlow.tryEmit(event)
        }
        return true;
    }
}

class KeyMapper {

    private val svDvorakToQwertyMap = mapOf(
        KeyEvent.KEYCODE_G to KeyEvent.KEYCODE_I,
        // Add more key mappings here...
    )

    fun remap(keyCode: Int): Int? {
        return svDvorakToQwertyMap[keyCode]
    }
}

Explanation

    KeyboardRemappingService:
        Extends AccessibilityService.
        Uses CoroutineScope and SupervisorJob for coroutine management.
        keyEventFlow: A MutableSharedFlow to emit keyboard events.
        KeyMapper: An instance of the KeyMapper class.
        onServiceConnected(): Configures the accessibility service.
        onAccessibilityEvent(): Captures keyboard events and emits them to keyEventFlow.
        onKeyEvent(): Captures key events and emits them to keyEventFlow.
        Uses Flow operators (filter, map, onEach) for reactive event processing.
    KeyMapper:
        Contains the svDvorakToQwertyMap.
        remap(): A pure function that translates keycodes.

Important Notes

    Permissions:
        You'll need to add the BIND_ACCESSIBILITY_SERVICE permission to your AndroidManifest.xml.
        Users will need to enable your accessibility service in their device settings.
    Key Event Handling:
        The code currently filters for KeyEvent.ACTION_DOWN events. You might need to handle other event types (e.g., ACTION_UP) as well.
    Error Handling:
        Add error handling to your code to gracefully handle unexpected events or errors.
    Testing:
        Thoroughly test your app with different apps and scenarios.
    Manifest:
        You must add the accessibility service to your AndroidManifest.xml file.

XML

<service
    android:name=".KeyboardRemappingService"
    android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"
    android:exported="true">
    <intent-filter>
        <action android:name="android.accessibilityservice.AccessibilityService" />
    </intent-filter>
    <meta-data
        android:name="android.accessibilityservice"
        android:resource="@xml/accessibility_service_config" />
</service>

    accessibility_service_config.xml
        Create a xml file named accessibility_service_config.xml in the res/xml folder.
        Add the following to the file:

XML

<accessibility-service xmlns:android="http://schemas.android.com/apk/res/android"
    android:description="@string/accessibility_description"
    android:accessibilityEventTypes="typeViewTextChanged"
    android:packageNames=""
    android:accessibilityFlags="flagReportViewIds"
    android:accessibilityFeedbackType="feedbackGeneric"
    android:notificationTimeout="100"
    android:canPerformGestures="false"
    android:settingsActivity=".MainActivity"/>

    String Resource
        add a String resource to your strings.xml file.

XML

<string name="accessibility_description">Remaps Keyboard keys.</string>

This is a starting point. You'll need to expand it to handle all your SvDvorak mappings and edge cases.

____
- Great. One thing I maybe failed
  to mention is that (without
  having looked at the code above
  in detail) since the app is
  primarily for my own personal
  use, the GUI-part of the app can
  be as minimal as possible, i.e.
  one single icon that represents
  the utility would be perfectly
  sufficient - perhaps an icon that
  could sit on the 'phone desktop'
  and indicate with color or
  looking like a pressed button if
  the utility is active, and
  another color or a button
  'un-pressed' to signal that the
  utility is not active.

Perfect, a minimal GUI is
absolutely feasible and aligns well
with the custom, personal nature of
your project. Here's how we can
adapt the solution to achieve that:

Minimal GUI Approach

    Launcher Icon and Activity:
        Create a simple launcher icon for your app.
        Create a minimal MainActivity that serves as the entry point for your app.
    Toggle Service State:
        The MainActivity will have a single button (or a visual toggle) to start and stop the KeyboardRemappingService.
        You can use a ToggleButton or a custom view to visually represent the service's state.
    Visual Feedback:
        Change the button's color or appearance to indicate whether the service is active or inactive.
        Optionally, you can display a small status notification in the notification bar.

Kotlin Code (Minimal GUI)

1. MainActivity.kt:
Kotlin

import android.content.Intent
import android.os.Bundle
import android.widget.ToggleButton
import androidx.appcompat.app.AppCompatActivity

class MainActivity : AppCompatActivity() {

    private lateinit var toggleButton: ToggleButton

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        toggleButton = findViewById(R.id.toggleButton)

        toggleButton.setOnCheckedChangeListener { _, isChecked ->
            if (isChecked) {
                startService(Intent(this, KeyboardRemappingService::class.java))
            } else {
                stopService(Intent(this, KeyboardRemappingService::class.java))
            }
        }
    }
}

2. activity_main.xml (Layout):
XML

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res/app"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <ToggleButton
        android:id="@+id/toggleButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textOff="Remapping Off"
        android:textOn="Remapping On"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>

3. Modify KeyboardRemappingService.kt:
Kotlin

// ... (existing code)

class KeyboardRemappingService : AccessibilityService() {

    // ... (existing code)

    override fun onDestroy() {
        super.onDestroy()
        job.cancel()
        //Add code here to remove the notification, if you implemented one.
    }
}

4. AndroidManifest.xml (Add MainActivity):
XML

<application
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:roundIcon="@mipmap/ic_launcher_round"
    android:supportsRtl="true"
    android:theme="@style/Theme.YourAppTheme">
    <service
        android:name=".KeyboardRemappingService"
        android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"
        android:exported="true">
        <intent-filter>
            <action android:name="android.accessibilityservice.AccessibilityService" />
        </intent-filter>
        <meta-data
            android:name="android.accessibilityservice"
            android:resource="@xml/accessibility_service_config" />
    </service>
    <activity android:name=".MainActivity" android:exported="true">
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
    </activity>
</application>

Explanation

    MainActivity:
        Sets up the ToggleButton.
        Starts and stops the KeyboardRemappingService based on the button's state.
    activity_main.xml:
        Defines the layout with a single ToggleButton.
    Visual Feedback:
        The ToggleButton's text and state provide visual feedback.
    AndroidManifest:
        The MainActivity is added as the launcher activity.

Enhancements

    Custom Toggle Button:
        You can create a custom view or use a library to create a more visually appealing toggle button.
    Notification:
        Display a small notification in the notification bar to indicate that the service is running.
    Settings:
        If you need to add configuration settings (e.g., custom key mappings), you can add a settings activity or use a configuration file.

This minimal GUI approach keeps the app simple and focused on its core functionality, which aligns perfectly with your requirements.

- Excellent. And(!!), just as a
  quick thought - something that
  crossed my mind just this instant
  actually: What just occurred to
  me is that (at least looking just
  a bit past the present moment),
  what I might be interested in is
  to widen the scope just slightly
  and go for a solution that would
  work on both Android, and(!!) on
  Windows. A bane for me on Windows
  has been being able to install or
  use some utility to accomplish
  the same functionality. I have
  been sketching out a solution
  using AutoHotKey, but if I could
  use some language (I'm thinking
  Flutter or something similar),
  that would REALLY be interesting
  to me.

That's a fantastic idea! Expanding the scope to include Windows support would significantly increase the utility of your project. Using a cross-platform framework like Flutter is a very promising approach. Let's explore that:

Cross-Platform Approach (Flutter)

____
    Flutter's Advantages:
        Cross-Platform Development: Flutter allows you to write code once and deploy it to multiple platforms (Android, iOS, Windows, macOS, Linux, web).
        Native Performance: Flutter apps are compiled to native code, providing excellent performance.
        Rich UI Framework: Flutter provides a rich set of UI widgets and tools for creating visually appealing and responsive apps.
        Dart Language: Dart is a modern, object-oriented language that is easy to learn and use.
        Community and Ecosystem: Flutter has a large and active community, and a growing ecosystem of packages and plugins.
    Challenges:
        Low-Level Input Handling: Intercepting and modifying keyboard events at a low level can be challenging in a cross-platform environment. You'll likely need to use platform-specific plugins or native code.
        Accessibility Services (Android) and Input Hooks (Windows): You'll need to handle platform-specific APIs for input event interception.
        Plugin Development: You might need to develop custom plugins for platform-specific functionality.
    Conceptual Architecture:
        Flutter App:
            The core application logic and UI will be written in Dart.
            The app will handle key mapping logic and user configuration.
        Platform-Specific Plugins:
            Android: Use a Flutter plugin that integrates with the Android Accessibility Service to intercept keyboard events.
            Windows: Use a Flutter plugin that integrates with Windows input hooks or low-level keyboard APIs.
        Key Mapping Logic (Dart):
            Implement the SvDvorak to QWERTY mapping logic in Dart, making it platform-independent.
        Service/Background Process:
            Implement the key remapping functionality as a background process or service on both platforms.

Implementation Steps

    Flutter Setup:
        Install Flutter and set up your development environment.
    Create a Flutter Project:
        Create a new Flutter project.
    UI Development:
        Create the UI for your app, including a toggle button and any necessary configuration settings.
    Platform-Specific Plugins:
        Android:
            Create a Flutter plugin that integrates with the Android Accessibility Service.
            Use the plugin to capture and inject key events.
        Windows:
            Explore existing Flutter plugins for Windows input handling.
            If necessary, create a custom plugin that uses Windows input hooks or low-level keyboard APIs.
    Key Mapping Logic (Dart):
        Implement the key mapping logic in Dart.
    Background Processing:
        Implement the key remapping functionality as a background process or service on both platforms.
    Testing:
        Thoroughly test your app on both Android and Windows.

Considerations

    Plugin Availability: The availability and quality of Flutter plugins for Windows input handling will be a crucial factor.
    Native Code Integration: You might need to write some native code (Kotlin/Java for Android, C++ for Windows) to handle platform-specific input APIs.
    Performance: Cross-platform performance is generally good with Flutter, but you'll need to optimize your code for both platforms.

Benefits

    Code Reusability: Write code once and deploy it to multiple platforms.
    Consistent UI: Maintain a consistent UI across platforms.
    Faster Development: Speed up development by using a single codebase.

By using Flutter, you can create a cross-platform keyboard remapping utility that works seamlessly on both Android and Windows, providing a consistent and efficient experience.

- My concern when it comes to
  Flutter (although it might not be
  a complete showstopper) is being
  able to include and leverage the
  functional and reactive
  approaches we talked about. Could
  you comment a bit about that, and
  also if languages like D or Rust
  may be interesting just to glance
  at, although they definitely have
  their 'kinks' (difficulty, reach
  etc, although their respective
  performances are excellent)

You've raised valid concerns about Flutter's compatibility with functional and reactive approaches, and you're right to consider alternatives like D and Rust. Let's break down those points:

Flutter and Functional/Reactive Programming

    Dart's Capabilities:
        Dart, the language used in Flutter, has functional programming features, including:
            First-class functions: Functions can be assigned to variables and passed as arguments.
            Lambdas: Anonymous functions.
            Collection methods: map, filter, reduce, etc.
        However, Dart's functional features are not as extensive as those in dedicated functional languages like Haskell or Scheme.
    Reactive Programming in Flutter:
        Flutter has excellent support for reactive programming through:
            Streams: Dart's built-in Stream class allows you to work with asynchronous data streams.
            rxdart package: A popular package that provides a rich set of reactive operators based on the ReactiveX (Rx) standard.
            Flutter's widget tree is rebuilt reactively, so that when data changes, the UI updates.
        Therefore, while Dart is not a pure functional language, it is highly possible to use reactive programming, and a functional style of programming.
    Limitations:
        Dart's type system is not as powerful as Haskell's, which limits some advanced functional programming techniques.
        The emphasis in Flutter is on UI development, which can sometimes lead to less pure functional code.

D and Rust as Alternatives

    D:
        D is a systems programming language that offers a blend of C++, Java, and Python features.
        It has good support for functional programming and metaprogramming.
        D can be compiled to native code, providing excellent performance.
        Pros:
            Excellent performance.
            Good functional programming support.
            Metaprogramming capabilities.
        Cons:
            Smaller community and ecosystem compared to Flutter.
            Cross-platform UI development can be more challenging.
            Less mobile support than Flutter.
    Rust:
        Rust is a systems programming language that focuses on safety, performance, and concurrency.
        It has excellent support for functional programming and is known for its memory safety.
        Rust can be compiled to native code, providing excellent performance.
        Pros:
            Excellent performance and memory safety.
            Strong functional programming support.
            Growing community and ecosystem.
        Cons:
            Steeper learning curve.
            Cross-platform UI development can be more challenging.
            Less mobile support than Flutter.
    Suitability for Your Project:
        D and Rust are excellent choices if performance and low-level control are your top priorities.
        However, they require more effort for cross-platform UI development.
        Rust is gaining more and more mobile support, and there are UI frameworks being developed for rust, so it is a language that is worth keeping an eye on.
    Recommendation:
        - If cross-platform UI development is crucial, Flutter with rxdart and a functional approach is a good choice.
        If performance and low-level control are paramount, and you're willing to invest more time in platform-specific UI development, Rust is a strong contender.
        If you are very comfortable with C/C++ like languages, then D is also a good option.
        It is worth noting that it is possible to use Rust or D for the backend logic and use Flutter for the UI. This hybrid approach could give you the best of both worlds.

In summary, Flutter can handle functional and reactive programming, but D and Rust offer more robust support for those paradigms at the cost of increased complexity in UI development.

- Right. AND(!!) since the
  UI-requirements for my particular
  app - especially at the initial
  stages - are really very minimal,
  then both D (which is a community
  where I have excellent
  connections with several core
  developers) and Rust become very
  interesting alternatives I think.

That's excellent! Given your strong connections within the D community and your minimal UI requirements, D becomes a very compelling option. Rust is also an excellent choice, but your existing connections with D developers provide a significant advantage. Let's explore how you can leverage D for your cross-platform keyboard remapping utility:

D Approach

    D's Strengths:
        Performance: D is a systems programming language that compiles to native code, providing excellent performance.
        Functional Programming: D supports functional programming paradigms, including first-class functions, lambdas, and immutable data.
        Metaprogramming: D's metaprogramming capabilities allow you to write highly flexible and efficient code.
        Cross-Platform: D can be compiled for various platforms, including Windows and Android.
        Community: Your connections within the D community will be invaluable for support and guidance.
    Implementation Strategy:
        Core Logic (D):
            Implement the key remapping logic in D, leveraging its functional and metaprogramming capabilities.
            Create a D library that handles the SvDvorak to QWERTY mapping.
        Platform-Specific Input Handling:
            Windows:
                Use D's Windows API bindings to intercept keyboard events using input hooks.
                Inject modified key events using the SendInput function.
            Android:
                Use the Android NDK to create a D library that interacts with the Linux input subsystem.
                Alternatively, explore using the accessibility service approach, but implemented from D with the help of the NDK.
            Use the D programming language, and the NDK to create a shared library, that can be called from a very small Kotlin wrapper application, that starts the service.
        Minimal UI (Platform-Specific):
            Windows:
                Use a simple console application or a minimal GUI framework (e.g., Win32 API, or a light weight cross platform GUI library, that can be called from D) to provide a toggle button and status indicator.
            Android:
                Create a very basic Kotlin wrapper application with a single toggle button to start and stop the D service.
        Build System:
            Use a cross-platform build system (e.g., CMake, Meson) to manage the build process.
    Advantages:
        Excellent performance.
        Fine-grained control over input handling.
        Leverage your D community connections.
    Considerations:
        Platform-specific UI development will require more effort.
        Android NDK integration can be complex.
        Testing on multiple platforms is critical.
    D specific advantages:
        D has good support for low level interaction, and the standard library, Phobos, is very extensive.
        D's compile time features, can be used to create very optimized mapping tables.

Next Steps

    D Development Environment:
        Set up your D development environment.
    Key Mapping Library:  ___hm_eng
        Start by implementing the key remapping logic in D.
    Windows Input Handling:
        Explore D's Windows API bindings and implement keyboard event interception and injection.
    Android NDK Integration:
        Experiment with the Android NDK to create a D library for Android input handling.
    Minimal UI:
        Create simple UI components for Windows and Android.
    Testing:
        Thoroughly test your app on both platforms.

By leveraging D's strengths and your community connections, you can create a highly efficient and customized keyboard remapping utility.


}}}


Good. Another question regarding Android: One thing that would really level up my use of Android as an integrated part of my workflow is if I could cast my Android-device's screen to my computer (both Windows and Linux) and preferably also vice-versa, i.e. if I could cast my computer's screen to my Android device.

Of course (if possible) it would be great if I could access and manipulate the screen I cast to my desktop-screen, and also the other way around, i.e. being able to control my computer when I cast my desktop/laptop screen to my Android device.

You're looking for solutions that provide robust screen mirroring and remote control capabilities between your Android device and both Windows and Linux computers. Here's a breakdown of the best options, focusing on functionality and cross-platform compatibility:

1. Scrcpy (Screen Copy):

    Functionality:
        Scrcpy is a free and open-source command-line tool that allows you to display and control your Android device's screen on your computer (Windows, Linux, macOS).
        It offers excellent performance, low latency, and high-quality screen mirroring.
        You can control your Android device with your computer's keyboard and mouse.
        It also allows you to record the screen and take screenshots.
    Pros:
        Very low latency.
        High performance.
        Free and open-source.
        Cross-platform compatibility.
    Cons:
        Requires ADB (Android Debug Bridge) setup.
        Command-line interface (though there are some GUI wrappers available).
        Does not cast the computer's screen to the android device.
    Setup:
        Install ADB on your computer.
        Enable USB debugging on your Android device.
        Connect your Android device to your computer via USB.
        Run the scrcpy command in your terminal.
    Best for: Developers and users who want high performance and low latency.

2. KDE Connect:

    Functionality:
        KDE Connect is a cross-platform application that integrates your Android device with your desktop.
        It offers screen mirroring, remote control, file transfer, notifications syncing, and more.
        It works wirelessly over your local network.
    Pros:
        Wireless connectivity.
        Multiple features beyond screen mirroring.
        Cross-platform compatibility (Linux, Windows, Android).
    Cons:
        Screen mirroring performance may vary depending on your network.
        The Windows version, while functional, can be less streamlined than the Linux version.
    Setup:
        Install KDE Connect on your computer and Android device.
        Pair your devices over your local network.
    Best for: Users who want a comprehensive integration solution.

3. TeamViewer/AnyDesk:

    Functionality:
        These are popular remote desktop applications that offer screen mirroring and remote control.
        They work over the internet, so you can control your devices from anywhere.
        They offer apps for Windows, Linux, and Android.
    Pros:
        Remote access over the internet.
        Easy to use.
        Cross-platform compatibility.
        Works in both directions.
    Cons:
        May have latency issues, especially over slow internet connections.
        Free versions may have limitations.
        Security concerns if not used carefully.
    Best for: Remote access and control over the internet.

4. Vysor:

    Functionality:
        Vysor allows you to view and control your Android device on your computer.
        It works via USB or Wi-Fi.
        It offers screen mirroring, keyboard and mouse control, and file transfer.
    Pros:
        Easy to use.
        Works via USB or Wi-Fi.
        Cross platform.
    Cons:
        Free version has limitations.
        Latency can be an issue over Wi-Fi.
    Best for: Users who want a simple and convenient screen mirroring solution.

Key Considerations:

    Latency: Scrcpy generally offers the lowest latency, making it ideal for real-time control.
    Wireless vs. Wired: KDE Connect and TeamViewer/AnyDesk offer wireless connectivity, while Scrcpy and Vysor can work via USB.
    Features: KDE Connect and TeamViewer/AnyDesk offer a wider range of features beyond screen mirroring.
    Security: Be cautious when using remote access tools over the internet, and ensure you're using strong passwords and secure connections.

For most users, Scrcpy will be the best option for casting the android screen to the computer, and TeamViewer or AnyDesk will be the best option for casting the computer screen to the android device.

Many thanks, and I'll definitely jot that down and try it out. Another question that (when established) will be an absolute game-changer for me.

A couple of weeks ago I posed a couple of questions about being able to connect to and read and write to and from cloud-services (like Dropbox or Google Drive) directly from an Android device.

I have granted access for Termux to my Android-device, and I have installed the rclone-utility, so I'm almost there.

The last piece of configuration I would need to setup would be the following:



How to Unmount:

    Use the fusermount -u command, followed by the mount point. For example:
    Bash

fusermount -u ~/dropbox

or
Bash

    fusermount -u ~/gdrive

    This command will gracefully unmount the specified directory.

What Happens If You Don't Unmount:

    Termux Closure: When you close Termux, Android will typically terminate the rclone process, which will effectively unmount the directory. However, there's a small risk that pending write operations might not be fully completed.
    Android Shutdown/Reboot: Similar to closing Termux, a shutdown or reboot will terminate the rclone process.
    Potential for data corruption: If rclone is in the middle of writing a file when it is forced to close, it is possible that the file will become corrupted.

Best Practices:

    Develop a Habit: Make it a habit to unmount your rclone mounts before closing Termux or shutting down your device. It only takes a few seconds and can save you from potential headaches.
    Scripting: If you frequently use rclone mounts, consider creating a simple script that unmounts all your mounts before exiting Termux.

In summary, while Android and Termux will usually handle unmounting automatically, manually unmounting is the safest and most reliable approach.

When I try writing 'fuse' in Termux and then pressing tab (for completion), the only name that pops up is 'fuser'. Does that mean that I have to install 'fusermount' in Termux using pkg?

Yes, you're absolutely right! The fact that "fusermount" isn't auto-completing when you type "fuse" and press Tab in Termux indicates that it's not currently installed.

Here's a breakdown and the solution:

Why "fusermount" Is Needed:

    FUSE (Filesystem in Userspace): FUSE is a kernel module that allows non-privileged users to create their own filesystems.   

fusermount: This utility is part of the FUSE package and is used to mount and unmount FUSE filesystems. rclone relies on fusermount to mount cloud storage as local directories.  

How to Install "fusermount" in Termux:

    Update Packages: It's always a good practice to update your package list before installing new packages.
    Bash

pkg update

Install the "fuse-utils" Package: The fusermount utility is included in the fuse-utils package.
Bash

    pkg install fuse-utils

    Verify Installation: After the installation is complete, try typing "fusermount" and pressing Tab. It should now auto-complete.

Important Considerations:

    Termux Permissions: Ensure that Termux has the necessary permissions to access your device's file system.
    Root Access: FUSE itself does not require root access, which is one of its key advantages.

By installing the fuse-utils package, you'll have the fusermount utility available in Termux, allowing you to properly mount and unmount rclone filesystems.
Filesystem in Userspace - Wikipedia
Source icon
en.wikipedia.org
FUSE — The Linux Kernel documentation
Source icon
www.kernel.org
Rclone - rsync for cloud storage - MSU HPCC User Documentation
Source icon
docs.icer.msu.edu

The message I got back was 'Unable to locate package fuse-utils'

You're encountering a common issue with Termux package management. The "Unable to locate package fuse-utils" message means the package name or the repository information is slightly off. Here's how to fix it:

The Correct Package Name:

    The correct package name in Termux is simply fuse, not fuse-utils.

Steps to Install:

    Update Repositories (Again):
        It's crucial to ensure your package lists are up-to-date.
    Bash

pkg update

Install the fuse Package:

    Use the correct package name:

Bash

    pkg install fuse

    Verify Installation:
        After installation, try typing fusermount and pressing Tab. It should now autocomplete.
        You can also verify the installation by typing which fusermount in the terminal. If it is installed, it will print the path to the fusermount executable.

Explanation:

    Termux uses a slightly different package naming convention than some other Linux distributions.
    By installing the package named fuse, you will also install the fusermount utility.

By following these corrected steps, you'll successfully install fusermount and be able to proceed with your rclone mount configuration.

I got the same error-message. Is there a flag or separate command I could run with pkg whereby I can query for fusermount - in a way similar to choco search packagename on Windows or apropos on Linux - to retrieve the right name?

Yes, you're right to look for a search functionality within pkg. Termux, being based on Debian, uses apt (Advanced Package Tool) under the hood, even though it presents a simplified pkg interface. You can leverage apt's search capabilities directly within Termux.

Here's how you can search for packages containing "fusermount":

Using apt search:

    Update Package Lists (If Not Already Done):
    Bash

pkg update

Use apt search with a Regular Expression:
Bash

apt search fusermount

or to do a more thorough search, including descriptions:
Bash

    apt search fuse | grep fusermount

    This command will search the package lists for any packages that contain "fusermount" in their names or descriptions.

    Interpret the Results:
        The output will show a list of matching packages, along with brief descriptions.
        Look for the package that seems most relevant. In this case, you're likely to find the fuse package.

Explanation:

    apt search is a powerful tool for finding packages in Debian-based systems.
    The | grep command pipes the output of apt search to grep, which filters the results to show only lines containing "fusermount." This is useful for more specific searches.

Why pkg search Might Not Be Ideal:

    While Termux's pkg command is designed for simplicity, it may not expose all of apt's search capabilities.
    Using apt search directly gives you more control and flexibility.

Troubleshooting if apt search Fails:

    Repository Issues: If apt search doesn't return any results, there might be a problem with your Termux repositories.
        Try running pkg update again to refresh the repository lists.
        If you have any issues with your internet connection, this can also cause issues.
    Termux Architecture: Ensure that your Termux installation matches your device's architecture (e.g., arm64).

By using apt search, you'll be able to effectively search for packages and find the correct name for fusermount or any other package you need.

The information I've gathered after doing a bit of searching on the internet is that it seems some people have had to obtain the sources for fusermount and compile them.

You're right to be thorough in your research. It's true that in some very specific scenarios, especially with highly customized Android setups or older Termux installations, compiling fusermount from source might be necessary. However, this is generally a last resort and often indicates a deeper underlying issue.

Here's a breakdown of why compiling from source might be suggested and when it's appropriate:

Reasons for Compiling from Source:

    Missing Package: If the fuse package is genuinely unavailable in your Termux repositories (which is unusual), compiling from source is a workaround.
    Custom Builds: Some users might have highly customized Android ROMs or Termux setups that require specific versions of fusermount or FUSE.
    Architecture Incompatibilities: In rare cases, there might be architecture incompatibilities between the pre-built packages and your device.
    Learning/Experimentation: Compiling from source can be a valuable learning experience for understanding how FUSE and fusermount work.

Why It's Generally Not Necessary:

    Termux Repositories: Termux typically provides up-to-date packages, including fuse, in its repositories.
    Complexity: Compiling from source can be complex, especially for users who are not familiar with Linux build tools and dependencies.
    Maintenance: Maintaining a self-compiled fusermount installation can be challenging, as you'll need to manually update it when new versions are released.

Steps to Compile from Source (If Absolutely Necessary):

    Install Build Tools:
        You'll need to install essential build tools like gcc, make, and pkg-config.
    Bash

pkg install clang make pkg-config

Download FUSE Source Code:

    Download the FUSE source code from the official FUSE website or a trusted repository.   

    Extract and Configure:
        Extract the source code archive and navigate to the extracted directory.
        Run the ./configure script to prepare the build environment.

    Compile:
        Run the make command to compile the source code.

    Install:
        Run the make install command to install the compiled binaries.

Important Considerations:

    Dependencies: Compiling from source might require installing additional dependencies.
    Android NDK: For more complex builds, you might need to use the Android NDK (Native Development Kit).
    Termux Environment: Ensure that your Termux environment is properly configured for building native code.

Recommendation:

    Before resorting to compiling from source, double-check your Termux repositories and ensure that you're using the correct package name (fuse).
    If you're still having trouble, consider seeking help from the Termux community or forums.

In most cases, installing the fuse package from the Termux repositories will be the simplest and most reliable solution.





I have toyed with the thought of obtaining another Android-device that may pack a better punch than the phone I'm currently using and maybe you could give me some suggestions. What I'm looking for is a phone - which would be preferable to me compared to e.g. a tablet. My ideal device would have a bigger screen and more processing power than my current phone - an Android A20, and also a bigger screen, but not being as large as the largest phones or a tablet, as both of those types of devices would be a bit too (or much too) bulky to take along for physio-exercises like running etc.

You're looking for a sweet spot: a phone with a larger screen and more power than your A20, but not so large that it becomes cumbersome for activities like running. This means we're aiming for something in the "phablet" or larger-than-average phone category, but still manageable. Here are some suggestions, keeping in mind that availability and pricing can vary:

Key Considerations:

    Screen Size: Aim for something in the 6.5-6.8 inch range. This offers a noticeable upgrade from the A20's 6.4 inches without being overly bulky.
    Processor: Look for a mid-range to high-mid-range processor. Snapdragon 700 or 800 series, or equivalent MediaTek or Exynos chips, would be a significant improvement.
    RAM: 6GB or 8GB of RAM is ideal for smooth performance.
    Battery Life: A larger battery is essential for extended use, especially if you're using the device for demanding tasks or outdoor activities.
    Durability: If you plan on using the phone for physical activities, consider a device with some degree of water and dust resistance.

Phone Recommendations:

    Google Pixel 7a/8a:
        These phones offer excellent performance, a great camera, and a clean Android experience.
        They are a good size, not being excessively large.
        The Pixel series is known for its timely software updates.
        The "a" series is a good value for the price.
    Samsung Galaxy A54/A55:
        Samsung's A series provides a good balance of features and price.
        The A54/A55 have a vibrant display, a decent camera, and good battery life.
        Samsung has also improved their software update policy.
    OnePlus Nord 3:
        OnePlus Nord phones are known for their fast performance and smooth software.
        They offer a good balance of features and price.
        OnePlus devices usually have fast charging.
    Motorola Edge (series):
        Motorola has been producing some good mid-range to high mid-range devices.
        They typically have near stock android, and good battery life.
        The Motorola Edge series of phones have a good screen size.

Tips for Choosing:

    Read Reviews: Check reputable tech websites and YouTube channels for reviews of the phones you're considering.
    Compare Specs: Use websites like GSMArena to compare the specifications of different phones.
    Consider Your Budget: Prices can vary significantly, so set a budget and stick to it.
    Check for Deals: Look for deals and discounts from retailers and carriers.
    Physical size: Go to a store and physically hold the phones that you are considering. This is the best way to determine if the device will be too large for your needs.

When considering the physical exercise aspect, a good protective case is always recommended.

I also had a quick look in a store and got the recommendation that maybe a Samsung Galaxy S25 might fit my needs. Could you comment on that device?

The Samsung Galaxy S25 series, particularly the S25 Ultra, represents Samsung's top-tier flagship smartphones. Here's a breakdown of what that means and how it might fit your needs:

Key Strengths of the Samsung Galaxy S25 Series:

    Top-Tier Performance:
        The S25 series will feature the latest and most powerful processors, ensuring incredibly smooth performance for any task, from demanding apps to gaming.
        This is a significant upgrade in processing power compared to your current A20.
    Exceptional Camera System:
        Samsung's Galaxy S Ultra phones are renowned for their advanced camera technology. Expect a versatile and high-quality camera setup that excels in various lighting conditions.
    Premium Display:
        The Dynamic AMOLED displays on the S25 series are known for their vibrant colors, deep blacks, and high refresh rates, providing an immersive viewing experience.
    Advanced Features:
        These phones will come packed with the latest features, including enhanced AI capabilities, improved connectivity, and advanced security features.
    Build Quality:
        The S25 series is built with premium materials, making for a very durable device.

Considerations for Your Needs:

    Size and Portability:
        The "Ultra" models, while offering the most features, are also the largest. Consider the standard S25 or S25+ models if you prioritize a more compact form factor.
        It is very important to try and hold the phone in your hand to see if the size is acceptable for your needs.
    Price:
        Flagship phones like the Galaxy S25 series come with a premium price tag.
    Overkill?
        If your primary needs are general use, browsing, and some light apps, the S25 series might be more powerful than you require. However, if you want the best performance and camera capabilities, it's an excellent choice.
    Fitness use:
        Samsung does a very good job of making there phones water and dust resistant. This is very good for using the phone during physical exercise.

In summary:

    The Samsung Galaxy S25 series is a fantastic choice if you want a top-of-the-line Android phone with excellent performance, a great camera, and a premium display.
    However, consider the size and price before making a decision.
    If you want the best of the best, the S25 Ultra is a very strong contender. If you want a great phone that is a little more compact, then look at the S25, or S25+.

I hope this helps!

If I wanted to go for even a bit bigger screen size, that might actually be feasible as well. I think the only upper constraint size-wise would be to be able to get hold of one of those soft cases used to wrap the phone when going for a run - i.e. I don't know what they're called in English, but they're fairly common and are used to 'strap the phone' to the side of ones arm, if you know what I mean.

Yes, I know exactly what you're referring to! Those are called armband phone holders or simply phone armbands.

If you're willing to consider a slightly larger screen size, knowing that you can still use a phone armband, that opens up your options. Here's a breakdown of considerations and some potential devices:

Screen Size Considerations:

    Up to 7 Inches:
        Many "phablet" style phones and some of the larger "Ultra" models fall into this range.
        Armbands are readily available for phones in this size category.
    Armband Compatibility:
        When choosing a larger phone, pay close attention to the dimensions (height, width, and thickness).
        Check the specifications of the armband to ensure it can accommodate your chosen phone.
        Many armbands are designed to be adjustable, but there are limits.

Device Recommendations (Larger Screen Options):

    Samsung Galaxy S25 Ultra (or future Ultra models):
        These phones typically have the largest screens in Samsung's lineup.
        They offer top-tier performance and features.
        Make sure to find an armband that is compatible with the "Ultra" models, as these are often the largest phones on the market.
    Samsung Galaxy Z Fold Series:
        These foldable phones offer a tablet-like experience when unfolded.
        When folded, they are still a large phone.
        They are great for media consumption and productivity.
        Finding an armband for these may be more difficult, but there are some available.
    OnePlus Open:
        This is another foldable phone, that is in direct competition with the Samsung Fold series of phones.
        This phone also offers a large screen, when unfolded.
    Google Pixel Fold:
        Google's foldable phone.
        This phone also offers a large screen, when unfolded.

Tips for Finding the Right Armband:

    Measure Your Phone:
        Get the exact dimensions of your chosen phone.
    Check Armband Specifications:
        Look for armbands that list the maximum phone dimensions they can accommodate.
    Read Reviews:
        See what other users say about the fit and comfort of the armband.
    Consider Adjustable Straps:
        Adjustable straps allow you to customize the fit to your arm size.
    Material:
        Choose a breathable and sweat-resistant material.
    Water Resistance:
        If you will be running in various weather conditions, a water resistant armband is a great idea.

By following these guidelines, you can find a larger-screen phone and a compatible armband that meets your needs.

The S25 and S25 Ultras also feature a special pen for drawing, if I'm not mistaken?

You're absolutely right! The Samsung Galaxy S25 Ultra (and its predecessors like the S24 Ultra, S23 Ultra, etc.) comes with the S Pen stylus built-in. The standard S25 and S25+ models do not include the S Pen.  

Here's a breakdown of the S Pen's features and benefits:

S Pen Features and Benefits:

    Precise Writing and Drawing:
        The S Pen offers a highly accurate and responsive writing and drawing experience.   

It's great for taking notes, sketching, and annotating documents.  

Air Actions:

    The S Pen supports "Air Actions," which allow you to control certain phone functions with gestures, even without touching the screen.   

    This can be useful for controlling media playback, taking photos, and navigating the interface.

Screen Off Memo:

    You can quickly jot down notes on the screen even when the phone is locked.   

Smart Select:

    The S Pen makes it easy to select and extract text or images from the screen.   

    Remote Shutter:
        The S-Pen can be used as a remote shutter button for the camera.
    Integration with Apps:
        Many apps support S Pen integration, enhancing their functionality.

S25 Ultra and the S Pen:

    The S25 Ultra has a dedicated slot for the S Pen, making it easy to carry and access.
    Samsung continues to improve the S Pen's features and performance with each generation.

Considerations:

    Learning Curve:
        It might take some time to get used to using the S Pen effectively.
    Personal Preference:
        Whether or not you find the S Pen useful depends on your personal preferences and workflow.

If you're interested in using a stylus for note-taking, drawing, or other tasks, the S25 Ultra's S Pen is a valuable feature.
Use the Galaxy S25 Ultra's S Pen - Samsung
Source icon
www.samsung.com
Enjoy S Pen Writing Experience with Galaxy S21 Ultra - Samsung
Source icon
www.samsung.com
Using the S Pen for Sketching and Image Creation on Your Galaxy Device | Samsung Gulf
Source icon
www.samsung.com
Use S Pen Air actions on your Galaxy phone or tablet - Samsung
Source icon
www.samsung.com
Use Screen off memo on your Galaxy phone or tablet - Samsung
Source icon
www.samsung.com

Two questions: Can the S Pen be bought as a separate accessory and be used with other or lower-tier phones as well, or are they 'bound in use' to certain models, and (maybe crucially I would say, at least for me) is the tip of the S Pen hard? What I mean by that is that I also own a Galaxy Tab S3 tablet, and the pen they sport is not particularly to my liking, i.e. the tip of that pen is soft and quite a bit wiggly, which I find very difficult to write with.

You've hit on two very important points regarding the S Pen! Let's address them:

1. S Pen Compatibility:

    Model-Specific Features:
        While some S Pens can physically interact with other Samsung devices, the full range of S Pen features, particularly "Air Actions" and Bluetooth connectivity, is generally limited to the Galaxy Note/Ultra series and some high-end Galaxy tablets that are explicitly designed for S Pen use.
        Older S Pens, or those from tablets, can often be used for basic writing and drawing on other Samsung devices with Wacom digitizers, but they won't have the same level of functionality.
    No Universal Compatibility:
        You cannot simply buy an S Pen and expect it to work with any Samsung phone or tablet.
        The hardware and software integration is model-specific.
    Aftermarket Styluses:
        There are aftermarket styluses that might work with some Samsung devices, but they will not replicate the S Pen's full functionality.

2. S Pen Tip Hardness:

    Evolution of S Pen Tips:
        Samsung has made improvements to the S Pen's tip over the years.
        Modern S Pen tips, particularly those found in the Ultra series, are generally firmer and more precise than the tips on older models or some tablets.
        The S25 Ultra, and the S-pens from the last few ultra models, have tips that are much more firm than the S-pen that came with the Tab S3.
    Tip Feel:
        The feel of the S Pen tip is still a matter of personal preference.
        Some users prefer a softer tip for a more "pen-on-paper" feel, while others prefer a firmer tip for greater precision.
    Tip Replacement:
        Samsung provides replacement S Pen tips, and there are also aftermarket options available.   

        You can experiment with different tip types to find one that suits your writing style.
    Galaxy Tab S3 vs. Ultra:
        The S-Pen that came with your Galaxy Tab S3 is much softer, and wigglier, than the modern S-Pens. The S-pens that come with the Ultra phones are much more similar to a normal pen, than the older tablet pens.

In summary:

    S Pen compatibility is limited to specific Samsung models.
    Modern S Pen tips are generally firmer than those on older models, but the feel is subjective.
    If the wiggly tip of your Tab S3 pen bothers you, you will likely be much happier with the S-Pen that comes with the Ultra phones.

I've also been toying with the idea of buying a FairPhone 5 and installing Lineage OS on it, which seems like a very interesting option. How would that phone stack up specs-wise to the other phones we discussed above?

The Fairphone 5 with LineageOS is indeed an interesting and commendable choice, especially if you prioritize ethical sourcing, repairability, and software freedom. Here's a comparison of its specs and overall experience compared to the flagship Samsung and Google Pixel devices we discussed:

Fairphone 5 Key Strengths:

    Repairability and Modularity:
        The Fairphone 5 is designed for easy repair and upgrades. You can replace individual components yourself, extending the phone's lifespan.   

Ethical Sourcing:

    Fairphone prioritizes ethical sourcing of materials and fair labor practices.   

Long-Term Software Support:

    Fairphone promises long-term software support, which is a major advantage.   

LineageOS Compatibility:

    Installing LineageOS gives you a clean, bloatware-free Android experience with timely updates and enhanced privacy features.   

SD Card slot:

    The fairphone 5 has a micro SD card slot, that allows for expandable storage.   

Fairphone 5 Limitations Compared to Flagships:

    Processor:
        The Fairphone 5 uses a Qualcomm QCM6490 processor, which is a solid mid-range chip. While it's capable of handling most tasks, it's not as powerful as the flagship Snapdragon 8 Gen series or Google Tensor chips found in the Pixel and high end Samsung phones.   

    Camera:
        The Fairphone 5 has a decent camera system, but it might not match the image quality of the Pixel or Samsung Ultra phones, especially in challenging lighting conditions.
    Display:
        The Fairphone 5 has a good OLED display, but it may not have the same level of brightness, color accuracy, or refresh rate as the top-tier displays on flagship devices.
    Features:
        Flagship phones often include features like advanced camera processing, wireless charging, and enhanced water resistance that may not be present on the Fairphone 5.
    Size:
        The Fairphone 5 is a fairly large phone.

LineageOS Considerations:

    Pros:
        Clean Android experience.
        Enhanced privacy.
        Timely updates.
        Customization options.
    Cons:
        You might lose some manufacturer-specific features.
        Potential for minor bugs or compatibility issues.

How It Stacks Up:

    Performance:
        The Fairphone 5 is a solid performer for everyday tasks, but it's not designed for intensive gaming or demanding applications.
    Camera:
        The camera is good, but not exceptional.
    Software:
        LineageOS provides a superior software experience in terms of privacy and customization.
    Durability and Repairability:
        The Fairphone 5 excels in this area.
    Price:
        The fairphone 5 is in the upper mid-range price bracket.

Who Should Choose the Fairphone 5:

    Users who prioritize ethical sourcing and repairability.
    Users who want a clean Android experience with enhanced privacy.
    Users who value long-term software support.
    Users who want a device that is easy to repair.

Who Should Choose a Flagship:

    Users who need the best possible performance.
    Users who want the most advanced camera capabilities.
    Users who want all the latest features.

In short, the Fairphone 5 offers a compelling package for those who value ethical considerations and software freedom. If top-tier performance and camera capabilities are your primary concerns, a flagship device might be a better fit.
Improving smartphone longevity - Fairphone
Source icon
www.fairphone.com
We have big plans for fair materials by 2030 - Fairphone
Source icon
www.fairphone.com
Fairphone's next chapter starts now.
Source icon
www.fairphone.com
LineageOS - Wikipedia
Source icon
en.wikipedia.org
Fairphone 5. Designed for you. Made fair.
Source icon
shop.fairphone.com



___SYSADM_DELETEFILESBYPATT_MANYLANGS
Question: I have a task I would like to accomplish on a Linux-system. Let me describe the task first, and then we can look into a couple of different solutions.


I recently added a couple of files to a directory (and its sub-directories). The problem: The files in the directory are saved to a cloud-service, and I ended up with duplicates of every file I added. The duplicates can be targeted through their names containing the string '(2)' indicating that the file is a duplicate.


I have several years of experience in using Linux-systems, so it's not a big deal using Bash to target the files recursively with find and then removing them, but I'd like to use the opportunity to do the same task in a bunch of different languages. Are you with me so far?

Yes, I understand perfectly. You want to accomplish the task of recursively finding and deleting files containing "(2)" in their names within a specified directory and its subdirectories on a Linux system. You'd like to explore solutions using various programming languages beyond just Bash.

This is a great exercise for comparing language syntax and features for file system manipulation. I'm ready when you are. Let's start with a language of your choice, or we can begin with Bash as a baseline.

Very good.

I think I should begin by listing the different languages I would like to use and target. Does that seem like a good start?

Yes, that's an excellent way to organize your task. Listing the languages you want to explore will help us keep track and ensure we cover everything. Please provide the list, and we can proceed from there.

The following languages and tools are the ones I would like to use (and therefore learn more about):


- Bash (i.e. using find, probably with the addition of xargs)

- NuShell

- PowerShell (i.e. suppose I was stationed at my laptop at work, where I use Windows exclusively)

- Python (that is the solution should be usable if I use Xonshell)

- F#

- C#

- VimScript (preferably the later Vim 9 version of VimScript)

- V (that is Vlang - not VimScript)


A note concerning Python: I would like to as much as is possible and feasible use functional techniques, and maybe also functools and itertools, one reason being I would like to learn more about that style of programming since I know how powerful it is and can be.


Also, as a general approach I think it would be very good to first list all the files (i.e. 'Did our matching target the correct files?'), then perhaps greet the user with a simple text-prompt saying something like 'Would you like to proceed?', and only then (if the user answers Yes) proceed with removing the files.


And, (which might seem a bit ridiculous for such a small and isolated task) I would like to add unit-tests for all the solutions, so I can see how that can be done.

Excellent! That's a comprehensive list, and your approach is very well-structured. Let's break down the task and tackle each language systematically.

Here's a plan, incorporating your requirements:

    Bash:
        We'll start with Bash as a baseline, demonstrating a classic Linux approach.
    NuShell:
        We'll explore how NuShell handles file system operations and filtering.
    PowerShell:
        We'll adapt the solution for a Windows environment.
    Python:
        We'll focus on a functional approach using os, functools, and itertools.
    F#:
        We'll leverage F#'s functional strengths for a concise solution.
    C#:
        We'll use C#'s file system APIs for a more object-oriented approach.
    Vim9 Script:
        We will use the new features of Vim9 script.
    V:
        We will use Vlang to create a very fast program.
    Unit Tests:
        We'll discuss how to write unit tests for each solution, ensuring robustness.

General Workflow for Each Language:

    File Listing:
        Implement the file search and display the matching files.
    User Confirmation:
        Prompt the user for confirmation before deletion.
    File Deletion:
        Execute the deletion if the user confirms.
    Unit Tests:
        Implement unit tests.

Let's start with Bash. Are you ready?

Yes, I'm all set.

Great! Let's begin with the Bash solution.
Bash

#!/bin/bash

# Target directory (you can change this)
target_dir="."

# Find files containing "(2)"
files_to_delete=$(find "$target_dir" -type f -name "*\(2\)*")

if [[ -n "$files_to_delete" ]]; then
  # Display the files
  echo "Files to delete:"
  echo "$files_to_delete"

  # Prompt the user for confirmation
  read -p "Would you like to proceed with deletion? (y/n): " confirm

  if [[ "$confirm" == "y" ]]; then
    # Delete the files
    find "$target_dir" -type f -name "*\(2\)*" -delete
    echo "Files deleted."
  else
    echo "Deletion cancelled."
  fi
else
  echo "No files found matching the criteria."
fi

Explanation:

    target_dir=".":
        Sets the target directory to the current directory. You can change this to any directory you want.
    files_to_delete=$(find "$target_dir" -type f -name "*\(2\)*"):
        Uses find to recursively search for files (-type f) whose names contain "(2)" (-name "*\(2\)*").
        The output of find (the list of file paths) is stored in the files_to_delete variable.
    if [[ -n "$files_to_delete" ]]:
        Checks if the files_to_delete variable is not empty (i.e., if any files were found).
    echo "Files to delete:" and echo "$files_to_delete":
        Displays the list of files to be deleted.
    read -p "Would you like to proceed with deletion? (y/n): " confirm:
        Prompts the user for confirmation.
    if [[ "$confirm" == "y" ]]:
        Checks if the user entered "y".
    find "$target_dir" -type f -name "*\(2\)*" -delete:
        If the user confirms, find is used again with the -delete option to remove the files.
    else:
        If the user enters "n" or anything else, the deletion is cancelled.
    else:
        If no files are found, a message is displayed.

How to Run:

    Save the script to a file (e.g., delete_duplicates.sh).
    Make the script executable: chmod +x delete_duplicates.sh.
    Run the script: ./delete_duplicates.sh.

Improvements and Considerations:

    Error Handling: You could add more robust error handling, such as checking if the target directory exists.
    xargs: For very large numbers of files, you might consider using xargs to avoid potential "argument list too long" errors. But in this case, the -delete option is better.
    Safety: You might want to add a dry-run option (e.g., -print instead of -delete) for extra safety.

Let me know if you have any questions or would like to proceed to the next language.

I'm good for now. Let's move on to the next one.

Alright, let's move on to NuShell (nushell).

NuShell provides a more structured and modern approach to shell scripting compared to Bash. Here's how we can achieve the same file deletion task:
Code snippet

# Target directory
let target_dir = "."

# Find files matching the pattern
let files_to_delete = ls -r $target_dir | where type == file and name =~ '\(2\)' | get path

if $files_to_delete | length > 0 {
    # Display the files
    echo "Files to delete:"
    $files_to_delete | each { echo $it }

    # Prompt for confirmation
    let confirm = (input "Would you like to proceed with deletion? (y/n): ")

    if $confirm == "y" {
        # Delete the files
        $files_to_delete | each { rm $it }
        echo "Files deleted."
    } else {
        echo "Deletion cancelled."
    }
} else {
    echo "No files found matching the criteria."
}

Explanation:

    let target_dir = ".":
        Defines the target directory.
    ls -r $target_dir | where type == file and name =~ '\(2\)' | get path:
        ls -r $target_dir: Lists files recursively in the target directory.
        where type == file and name =~ '\(2\)': Filters the output to include only files whose names match the regular expression \(2\).
        get path: Extracts the file paths.
        The result is stored in the files_to_delete variable.
    if $files_to_delete | length > 0:
        Checks if any files were found.
    echo "Files to delete:" and $files_to_delete | each { echo $it }:
        Displays the list of files.
    let confirm = (input "Would you like to proceed with deletion? (y/n): "):
        Prompts the user for confirmation.
    if $confirm == "y":
        Checks if the user entered "y".
    $files_to_delete | each { rm $it }:
        Deletes the files.
    else:
        Cancellation message.
    else:
        No files found message.

Key NuShell Features Used:

    Pipelines: NuShell's pipelines (|) allow for chaining commands, making data processing concise.
    Structured Data: NuShell works with structured data (tables, records, lists), which makes filtering and manipulation easier.
    Regular Expressions: The =~ operator allows for regular expression matching.
    each: The each command iterates over elements in a list.

How to Run:

    Save the script to a file (e.g., delete_duplicates.nu).
    Run the script: nu delete_duplicates.nu.

NuShell provides a more readable and powerful shell scripting experience compared to Bash, especially for data manipulation tasks.

Are you ready to move on to PowerShell, or do you have any questions about the NuShell solution?

All good. I'll be diving into the details later for most languages, so I'm ready to move on to the next one.

Great! Let's proceed to PowerShell.

PowerShell, being a cross-platform task automation and configuration management framework, is very powerful. Here's how we can accomplish the file deletion task:
PowerShell

# Target directory
$targetDir = "."

# Find files matching the pattern
$filesToDelete = Get-ChildItem -Path $targetDir -Recurse -File | Where-Object { $_.Name -match '\(2\)' }

if ($filesToDelete.Count -gt 0) {
    # Display the files
    Write-Host "Files to delete:"
    $filesToDelete | ForEach-Object { Write-Host $_.FullName }

    # Prompt for confirmation
    $confirm = Read-Host "Would you like to proceed with deletion? (y/n)"

    if ($confirm -eq "y") {
        # Delete the files
        $filesToDelete | Remove-Item
        Write-Host "Files deleted."
    } else {
        Write-Host "Deletion cancelled."
    }
} else {
    Write-Host "No files found matching the criteria."
}

Explanation:

    $targetDir = ".":
        Defines the target directory.
    $filesToDelete = Get-ChildItem -Path $targetDir -Recurse -File | Where-Object { $_.Name -match '\(2\)' }:
        Get-ChildItem -Path $targetDir -Recurse -File: Recursively retrieves all files in the target directory.
        Where-Object { $_.Name -match '\(2\)' }: Filters the results to include only files whose names match the regular expression \(2\).
        The result is stored in the $filesToDelete variable.
    if ($filesToDelete.Count -gt 0):
        Checks if any files were found.
    Write-Host "Files to delete:" and $filesToDelete | ForEach-Object { Write-Host $_.FullName }:
        Displays the list of files.
    $confirm = Read-Host "Would you like to proceed with deletion? (y/n)":
        Prompts the user for confirmation.
    if ($confirm -eq "y"):
        Checks if the user entered "y".
    $filesToDelete | Remove-Item:
        Deletes the files.
    else:
        Cancellation message.
    else:
        No files found message.

Key PowerShell Features Used:

    Cmdlets: PowerShell uses cmdlets (Get-ChildItem, Where-Object, Remove-Item), which are lightweight commands.
    Pipelines: PowerShell also uses pipelines (|) for chaining commands.
    Objects: PowerShell works with objects, allowing for easy access to properties (e.g., $_.Name, $_.FullName).
    Regular Expressions: The -match operator allows for regular expression matching.

How to Run:

    Save the script to a file (e.g., delete_duplicates.ps1).
    Run the script: powershell -File delete_duplicates.ps1.

PowerShell provides a robust and object-oriented approach to file system manipulation.

Are you ready to move on to Python, or do you have any questions about the PowerShell solution?

Just as a quick comment and observation: That is actually fascinating to look at. Being knowledgeable in many languages and having significant experience in Bash-scripting, I have always felt a bit iffy about PowerShell, for one because it has seemed wordy and longwinded compared to (for example) Bash, but here is a case where I think I can see that the length of the PowerShell-solution does not actually exceed the length of the Bash solution, and (amazingly to me at least) it is actually clearer and easier to read than the Bash solution.

You've hit on a very common observation about PowerShell! Many experienced Bash users initially find it verbose. However, the clarity and readability often become apparent when tackling more complex tasks. The verbosity is intentional, aiming to make the code self-documenting and easier to understand, especially for those less familiar with shell scripting.

The object-oriented nature of PowerShell also contributes to its clarity. You're working with objects that have properties and methods, which makes the code more descriptive than the string-based approach of Bash.

Your observation is spot-on, and it's a testament to your ability to quickly grasp the nuances of different languages. Let's move on to Python, where we'll explore a functional approach, as you requested.

Very good. Let's do that

All right, let's dive into the Python solution, focusing on a functional approach as you requested.
Python

import os
import functools
import itertools

def find_duplicate_files(target_dir="."):
    """Finds files containing '(2)' in their names recursively."""
    def is_duplicate(filename):
        return "(2)" in filename

    def walk_files(directory):
        for root, _, files in os.walk(directory):
            for file in files:
                yield os.path.join(root, file)

    return list(filter(is_duplicate, walk_files(target_dir)))

def display_files(files):
    """Displays the list of files."""
    if not files:
        print("No files found matching the criteria.")
        return False
    print("Files to delete:")
    for file in files:
        print(file)
    return True

def confirm_deletion():
    """Prompts the user for confirmation."""
    confirm = input("Would you like to proceed with deletion? (y/n): ").lower()
    return confirm == "y"

def delete_files(files):
    """Deletes the given list of files."""
    for file in files:
        try:
            os.remove(file)
        except OSError as e:
            print(f"Error deleting {file}: {e}")
    print("Files deleted.")

def main():
    """Main function to orchestrate the process."""
    files_to_delete = find_duplicate_files()
    if display_files(files_to_delete):
        if confirm_deletion():
            delete_files(files_to_delete)
        else:
            print("Deletion cancelled.")

if __name__ == "__main__":
    main()

Explanation:

    find_duplicate_files(target_dir="."):
        Uses os.walk to recursively traverse the directory.
        Uses a generator expression and os.path.join to get the full file paths.
        Uses filter with a lambda function to select files containing "(2)".
        Returns a list of matching file paths.
    display_files(files):
        Displays the list of files or a "no files found" message.
    confirm_deletion():
        Prompts the user for confirmation.
    delete_files(files):
        Deletes the files using os.remove.
        Includes basic error handling for file deletion.
    main():
        Orchestrates the entire process.

Functional Techniques Used:

    filter: Used to filter the list of files based on a condition.
    Generators: walk_files is a generator, which yields file paths one at a time, improving memory efficiency.
    Functions as First-Class Objects: The is_duplicate function is used as an argument to filter.

How to Run:

    Save the script to a file (e.g., delete_duplicates.py).
    Run the script: python delete_duplicates.py.

Let's discuss unit testing in Python. We can use the unittest module. I will show you how to test the find_duplicate_files function, and you can apply the same principles to the other functions.
Python

import unittest
import os
import tempfile
from delete_duplicates import find_duplicate_files

class TestDeleteDuplicates(unittest.TestCase):

    def setUp(self):
        self.temp_dir = tempfile.TemporaryDirectory()
        self.target_dir = self.temp_dir.name
        os.makedirs(os.path.join(self.target_dir, "subdir"))
        open(os.path.join(self.target_dir, "file(2).txt"), "w").close()
        open(os.path.join(self.target_dir, "file.txt"), "w").close()
        open(os.path.join(self.target_dir, "subdir", "file(2).txt"), "w").close()
        open(os.path.join(self.target_dir, "subdir", "file.txt"), "w").close()

    def tearDown(self):
        self.temp_dir.cleanup()

    def test_find_duplicate_files(self):
        expected_files = [
            os.path.join(self.target_dir, "file(2).txt"),
            os.path.join(self.target_dir, "subdir", "file(2).txt"),
        ]
        actual_files = find_duplicate_files(self.target_dir)
        self.assertEqual(sorted(actual_files), sorted(expected_files))

if __name__ == "__main__":
    unittest.main()

This test creates a temporary directory with files, runs the function, and asserts that the correct files are found.

Do you have any questions about the Python solution or the unit tests? Are you ready to move on to F#?

Right now, I would like to move on to F#

Excellent. Let's move on to F#. F# is a functional-first, cross-platform, open-source programming language that makes it great for tasks involving file system manipulation.
F#

open System
open System.IO

let findDuplicateFiles (targetDir: string) =
    Directory.GetFiles(targetDir, "*", SearchOption.AllDirectories)
    |> Array.filter (fun file -> file.Contains("(2)"))

let displayFiles (files: string[]) =
    if files.Length = 0 then
        printfn "No files found matching the criteria."
        false
    else
        printfn "Files to delete:"
        files |> Array.iter printfn
        true

let confirmDeletion () =
    printf "Would you like to proceed with deletion? (y/n): "
    let confirm = Console.ReadLine().ToLower()
    confirm = "y"

let deleteFiles (files: string[]) =
    files |> Array.iter (fun file ->
        try
            File.Delete(file)
        with
        | ex -> printfn $"Error deleting {file}: {ex.Message}"
    )
    printfn "Files deleted."

let main () =
    let targetDir = "."
    let filesToDelete = findDuplicateFiles targetDir
    if displayFiles filesToDelete then
        if confirmDeletion () then
            deleteFiles filesToDelete
        else
            printfn "Deletion cancelled."

main ()

Explanation:

    findDuplicateFiles (targetDir: string):
        Uses Directory.GetFiles to get all files recursively.
        Uses Array.filter to select files containing "(2)".
    displayFiles (files: string[]):
        Displays the list of files or a "no files found" message.
    confirmDeletion ():
        Prompts the user for confirmation.
    deleteFiles (files: string[]):
        Deletes the files using File.Delete.
        Includes basic error handling.
    main ():
        Orchestrates the entire process.

Key F# Features Used:

    Pipelines (|>): F# heavily utilizes pipelines to chain functions, making the code very readable.
    Array Functions: F# has powerful array manipulation functions like Array.filter and Array.iter.
    Functional Style: The code is written in a functional style, using immutable data and pure functions.
    Pattern Matching: F# provides powerful pattern matching, which we could use for more complex file filtering, though it wasn't required for this example.

How to Run:

    Save the script to a file (e.g., delete_duplicates.fs).
    Compile and run the script:
    Bash

    fsharpc delete_duplicates.fs
    mono delete_duplicates.exe

    (Or, if you're using .NET Core or .NET 5+, you can use dotnet run.)

Unit Testing in F# (using NUnit):

To add unit tests, you'll need to install NUnit. Here's an example:

    Install NUnit:
    Bash

dotnet add package NUnit
dotnet add package NUnit3TestAdapter

Create a test project:
F#

// DeleteDuplicatesTests.fs
open NUnit.Framework
open System.IO
open DeleteDuplicates

[<TestFixture>]
type DeleteDuplicatesTests () =
    let tempDir = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName())

    [<SetUp>]
    member this.Setup () =
        Directory.CreateDirectory(tempDir) |> ignore
        Directory.CreateDirectory(Path.Combine(tempDir, "subdir")) |> ignore
        File.Create(Path.Combine(tempDir, "file(2).txt")).Close()
        File.Create(Path.Combine(tempDir, "file.txt")).Close()
        File.Create(Path.Combine(tempDir, "subdir", "file(2).txt")).Close()
        File.Create(Path.Combine(tempDir, "subdir", "file.txt")).Close()

    [<TearDown>]
    member this.Teardown () =
        Directory.Delete(tempDir, true)

    [<Test>]
    member this.FindDuplicateFilesTest () =
        let expectedFiles = [
            Path.Combine(tempDir, "file(2).txt")
            Path.Combine(tempDir, "subdir", "file(2).txt")
        ]
        let actualFiles = findDuplicateFiles tempDir
        Assert.AreEqual(expectedFiles |> Array.sort, actualFiles |> Array.sort)

Run the tests:
Bash

    dotnet test

    (Make sure that the test project references the main project)

Let me know if you have any questions or are ready to proceed to the next language, C#.

Great. Could we move on to the next language?

Yes, let's move on to C#.

C# provides a robust and object-oriented approach to file system operations. Here's how we can implement the file deletion task:
C#

using System;
using System.IO;
using System.Linq;

public class DeleteDuplicates
{
    public static string[] FindDuplicateFiles(string targetDir)
    {
        return Directory.GetFiles(targetDir, "*", SearchOption.AllDirectories)
            .Where(file => file.Contains("(2)"))
            .ToArray();
    }

    public static bool DisplayFiles(string[] files)
    {
        if (files.Length == 0)
        {
            Console.WriteLine("No files found matching the criteria.");
            return false;
        }

        Console.WriteLine("Files to delete:");
        foreach (var file in files)
        {
            Console.WriteLine(file);
        }
        return true;
    }

    public static bool ConfirmDeletion()
    {
        Console.Write("Would you like to proceed with deletion? (y/n): ");
        string confirm = Console.ReadLine().ToLower();
        return confirm == "y";
    }

    public static void DeleteFiles(string[] files)
    {
        foreach (var file in files)
        {
            try
            {
                File.Delete(file);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error deleting {file}: {ex.Message}");
            }
        }
        Console.WriteLine("Files deleted.");
    }

    public static void Main(string[] args)
    {
        string targetDir = ".";
        string[] filesToDelete = FindDuplicateFiles(targetDir);
        if (DisplayFiles(filesToDelete))
        {
            if (ConfirmDeletion())
            {
                DeleteFiles(filesToDelete);
            }
            else
            {
                Console.WriteLine("Deletion cancelled.");
            }
        }
    }
}

Explanation:

    FindDuplicateFiles(string targetDir):
        Uses Directory.GetFiles to get all files recursively.
        Uses LINQ's Where method to filter files containing "(2)".
        Converts the result to an array using ToArray().
    DisplayFiles(string[] files):
        Displays the list of files or a "no files found" message.
    ConfirmDeletion():
        Prompts the user for confirmation.
    DeleteFiles(string[] files):
        Deletes the files using File.Delete.
        Includes basic error handling.
    Main(string[] args):
        Orchestrates the entire process.

Key C# Features Used:

    LINQ (Language Integrated Query): LINQ's Where method provides a concise way to filter collections.
    File System APIs: C# provides robust file system APIs in the System.IO namespace.
    Exception Handling: The try-catch block handles potential exceptions during file deletion.

How to Run:

    Save the code to a file (e.g., DeleteDuplicates.cs).
    Compile and run the code:
    Bash

    csc DeleteDuplicates.cs
    ./DeleteDuplicates.exe

    (Or, if you're using .NET Core or .NET 5+, you can use dotnet run.)

Unit Testing in C# (using NUnit):

    Install NUnit:
    Bash

    dotnet add package NUnit
    dotnet add package NUnit3TestAdapter

    Create a test class:

C#

using NUnit.Framework;
using System.IO;

[TestFixture]
public class DeleteDuplicatesTests
{
    private string tempDir;

    [SetUp]
    public void Setup()
    {
        tempDir = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
        Directory.CreateDirectory(tempDir);
        Directory.CreateDirectory(Path.Combine(tempDir, "subdir"));
        File.Create(Path.Combine(tempDir, "file(2).txt")).Close();
        File.Create(Path.Combine(tempDir, "file.txt")).Close();
        File.Create(Path.Combine(tempDir, "subdir", "file(2).txt")).Close();
        File.Create(Path.Combine(tempDir, "subdir", "file.txt")).Close();
    }

    [TearDown]
    public void Teardown()
    {
        Directory.Delete(tempDir, true);
    }

    [Test]
    public void FindDuplicateFilesTest()
    {
        string[] expectedFiles = {
            Path.Combine(tempDir, "file(2).txt"),
            Path.Combine(tempDir, "subdir", "file(2).txt")
        };
        string[] actualFiles = DeleteDuplicates.FindDuplicateFiles(tempDir);
        Assert.AreEqual(expectedFiles, actualFiles);
    }
}

    Run the tests:
    Bash

    dotnet test

    (Make sure that the test project references the main project)

Are you ready to move on to Vim9 Script?

Great. Could we move on to the next one?

Yes, let's move on to Vim9 Script.

Vim9 Script is the newer, more performant version of Vim's scripting language. Here's how we can implement the file deletion task:
Vim Script

vim9script

def FindDuplicateFiles(targetDir: string): list<string>
  var files: list<string> = []
  for file in globpath(targetDir .. '/**', '*', 'fn')
    if stridx(file, '(2)') >= 0
      add(files, file)
    endif
  endfor
  return files
enddef

def DisplayFiles(files: list<string>): bool
  if empty(files)
    echo "No files found matching the criteria."
    return false
  endif

  echo "Files to delete:"
  for file in files
    echo file
  endfor
  return true
enddef

def ConfirmDeletion(): bool
  echon "Would you like to proceed with deletion? (y/n): "
  var confirm: string = tolower(input(''))
  return confirm == 'y'
enddef

def DeleteFiles(files: list<string>): void
  for file in files
    try
      delete(file)
    catch
      echoerr "Error deleting " .. file
    endtry
  endfor
  echo "Files deleted."
enddef

def Main(): void
  var targetDir: string = '.'
  var filesToDelete: list<string> = FindDuplicateFiles(targetDir)
  if DisplayFiles(filesToDelete)
    if ConfirmDeletion()
      DeleteFiles(filesToDelete)
    else
      echo "Deletion cancelled."
    endif
  endif
enddef

Main()

Explanation:

    FindDuplicateFiles(targetDir: string): list<string>:
        Uses globpath to get all files recursively.
        Uses stridx to check if the file name contains "(2)".
        Adds matching files to a list.
    DisplayFiles(files: list<string>): bool:
        Displays the list of files or a "no files found" message.
    ConfirmDeletion(): bool:
        Prompts the user for confirmation.
    DeleteFiles(files: list<string>): void:
        Deletes the files using delete.
        Includes basic error handling.
    Main(): void:
        Orchestrates the entire process.

Key Vim9 Script Features Used:

    Explicit Typing: Vim9 Script supports explicit typing, which can improve performance and readability.
    globpath: Used for file globbing.
    stridx: Used to find the index of a substring.
    delete: Used to delete a file.
    try-catch: Used for error handling.

How to Run:

    Save the script to a file (e.g., delete_duplicates.vim).
    Open Vim and run the script:
    Vim Script

    :source delete_duplicates.vim

Unit Testing in Vim9 Script:

Vim9 Script does not have a built-in unit testing framework. You can write simple tests by adding assertions to the script and running it. Here's an example of how you can add a basic test for the FindDuplicateFiles function.
Vim Script

vim9script

# ... (FindDuplicateFiles, DisplayFiles, ConfirmDeletion, DeleteFiles, Main)

def TestFindDuplicateFiles(): void
  # Create some temp files for testing.
  execute 'silent !mkdir temp_test_dir'
  execute 'silent !touch temp_test_dir/file(2).txt'
  execute 'silent !touch temp_test_dir/file.txt'
  execute 'silent !mkdir temp_test_dir/subdir'
  execute 'silent !touch temp_test_dir/subdir/file(2).txt'
  execute 'silent !touch temp_test_dir/subdir/file.txt'

  var expectedFiles: list<string> = [
    'temp_test_dir/file(2).txt',
    'temp_test_dir/subdir/file(2).txt'
  ]
  var actualFiles: list<string> = FindDuplicateFiles('temp_test_dir')

  if actualFiles != expectedFiles
    echoerr "TestFindDuplicateFiles failed: Expected " .. string(expectedFiles) .. ", got " .. string(actualFiles)
  endif

  #Clean up temp files
  execute 'silent !rm -rf temp_test_dir'
enddef

TestFindDuplicateFiles()
Main()

Important Notes:

    Vim9 Script is relatively new, and its ecosystem is still developing.
    For more comprehensive testing, you might consider using external testing frameworks or integrating Vim with other languages.

Are you ready to move on to V (Vlang)?

Yes I'm ready to move on

All right, let's move on to V (Vlang).

Vlang is a statically typed, compiled programming language known for its simplicity and speed. Here's how we can implement the file deletion task:
Verilog

import os

fn find_duplicate_files(target_dir string) []string {
    mut files := []string{}
    os.walk(target_dir, fn (path string, info os.FileInfo) ? {
        if !info.is_dir && path.contains('(2)') {
            files << path
        }
        return none
    })?
    return files
}

fn display_files(files []string) bool {
    if files.len == 0 {
        println('No files found matching the criteria.')
        return false
    }

    println('Files to delete:')
    for file in files {
        println(file)
    }
    return true
}

fn confirm_deletion() bool {
    print('Would you like to proceed with deletion? (y/n): ')
    mut confirm := os.read_line() or { return false }
    return confirm.to_lower() == 'y'
}

fn delete_files(files []string) {
    for file in files {
        os.rm(file) or { println('Error deleting ${file}') }
    }
    println('Files deleted.')
}

fn main() {
    target_dir := '.'
    files_to_delete := find_duplicate_files(target_dir)
    if display_files(files_to_delete) {
        if confirm_deletion() {
            delete_files(files_to_delete)
        } else {
            println('Deletion cancelled.')
        }
    }
}

Explanation:

    find_duplicate_files(target_dir string) []string:
        Uses os.walk to recursively traverse the directory.
        Checks if the file is not a directory and if its path contains "(2)".
        Appends matching file paths to a string array.
    display_files(files []string) bool:
        Displays the list of files or a "no files found" message.
    confirm_deletion() bool:
        Prompts the user for confirmation.
    delete_files(files []string):
        Deletes the files using os.rm.
        Includes basic error handling.
    main():
        Orchestrates the entire process.

Key Vlang Features Used:

    os.walk: Used for recursive directory traversal.
    path.contains(): Used to check if a string contains a substring.
    os.rm(): Used to delete a file.
    Error Handling: Vlang uses or for error handling.
    Simple Syntax: Vlang has a clean and simple syntax.

How to Run:

    Save the code to a file (e.g., delete_duplicates.v).
    Compile and run the code:
    Bash

    v run delete_duplicates.v

Unit Testing in Vlang:

Vlang has built-in support for unit testing. Here's an example:
Verilog

import os
import testing

fn test_find_duplicate_files(t testing.T) {
    // Create some temp files for testing.
    os.mkdir('temp_test_dir') or { t.fail('Failed to create temp dir') }
    os.create('temp_test_dir/file(2).txt') or { t.fail('Failed to create temp file') }
    os.create('temp_test_dir/file.txt') or { t.fail('Failed to create temp file') }
    os.mkdir('temp_test_dir/subdir') or { t.fail('Failed to create temp dir') }
    os.create('temp_test_dir/subdir/file(2).txt') or { t.fail('Failed to create temp file') }
    os.create('temp_test_dir/subdir/file.txt') or { t.fail('Failed to create temp file') }

    expected_files := ['temp_test_dir/file(2).txt', 'temp_test_dir/subdir/file(2).txt']
    actual_files := find_duplicate_files('temp_test_dir')

    if actual_files != expected_files {
        t.fail('TestFindDuplicateFiles failed: Expected ${expected_files}, got ${actual_files}')
    }

    // Clean up temp files.
    os.rmdir_all('temp_test_dir') or { t.fail('failed to clean up temp dir') }
}

To run the tests:
Bash

v test delete_duplicates.v

Let me know if you have any questions.

Fantastic! Now I would like to also include Dlang, which in many respects is a fantastic up-and-coming (for some time) language

Excellent choice! Dlang is a powerful and versatile language with a strong emphasis on efficiency and expressiveness. Let's add a Dlang solution to our file deletion task.
D

import std.stdio;
import std.file;
import std.path;
import std.algorithm;
import std.array;
import std.string;
import std.conv;

string[] findDuplicateFiles(string targetDir) {
    string[] files;
    foreach(file; walkFiles(targetDir)) {
        if (file.toUTF8().indexOf("(2)") != -1) {
            files ~= file;
        }
    }
    return files;
}

bool displayFiles(string[] files) {
    if (files.length == 0) {
        writeln("No files found matching the criteria.");
        return false;
    }
    writeln("Files to delete:");
    foreach (file; files) {
        writeln(file);
    }
    return true;
}

bool confirmDeletion() {
    write("Would you like to proceed with deletion? (y/n): ");
    string confirm = readln().strip().toLower();
    return confirm == "y";
}

void deleteFiles(string[] files) {
    foreach (file; files) {
        try {
            remove(file);
        } catch (Exception e) {
            writeln("Error deleting ", file, ": ", e.msg);
        }
    }
    writeln("Files deleted.");
}

void main() {
    string targetDir = ".";
    string[] filesToDelete = findDuplicateFiles(targetDir);
    if (displayFiles(filesToDelete)) {
        if (confirmDeletion()) {
            deleteFiles(filesToDelete);
        } else {
            writeln("Deletion cancelled.");
        }
    }
}

Explanation:

    findDuplicateFiles(string targetDir):
        Uses walkFiles to recursively traverse the directory.
        Checks if the file name contains "(2)" using indexOf.
        Appends matching file paths to a string array.
    displayFiles(string[] files):
        Displays the list of files or a "no files found" message.
    confirmDeletion():
        Prompts the user for confirmation.
    deleteFiles(string[] files):
        Deletes the files using remove.
        Includes basic error handling using try-catch.
    main():
        Orchestrates the entire process.

Key Dlang Features Used:

    walkFiles: Used for recursive directory traversal.
    indexOf: Used to find the index of a substring.
    remove: Used to delete a file.
    try-catch: Used for error handling.
    readln and write: Used for user input.
    String Manipulation: Dlang provides powerful string manipulation tools.

How to Run:

    Save the code to a file (e.g., delete_duplicates.d).
    Compile and run the code:
    Bash

    dmd delete_duplicates.d
    ./delete_duplicates

Unit Testing in Dlang (using Unittest):

Dlang has a built-in unittest feature. Here's an example:
D

import std.stdio;
import std.file;
import std.path;
import std.algorithm;
import std.array;
import std.string;
import std.conv;
import std.unittest;

//...(findDuplicateFiles, displayFiles, confirmDeletion, deleteFiles, main)

unittest {
    string tempDir = "./temp_test_dir";
    enforce(mkdirRecurse(tempDir));
    enforce(touch(path.join(tempDir, "file(2).txt")));
    enforce(touch(path.join(tempDir, "file.txt")));
    enforce(mkdirRecurse(path.join(tempDir, "subdir")));
    enforce(touch(path.join(tempDir, "subdir", "file(2).txt")));
    enforce(touch(path.join(tempDir, "subdir", "file.txt")));

    string[] expectedFiles = [
        path.join(tempDir, "file(2).txt"),
        path.join(tempDir, "subdir", "file(2).txt")
    ];
    string[] actualFiles = findDuplicateFiles(tempDir);

    assert(actualFiles.sort() == expectedFiles.sort());

    enforce(removeDirRecurse(tempDir));
}

To run the tests:
Bash

dmd -unittest delete_duplicates.d
./delete_duplicates -unittest

Dlang is another great language to add to the list. I hope this Dlang example and the unittest information is useful.

I haven't taken a good look at the Dlang code, but (just to be clear) I would like to use as functional programming as much as possible.

You're absolutely right, and I apologize for not emphasizing the functional aspects of Dlang as much as possible in the previous example. Let's refactor the Dlang code to lean more heavily into functional programming paradigms.

Here's the revised Dlang code, focusing on functional techniques:
D

import std.stdio;
import std.file;
import std.path;
import std.algorithm;
import std.array;
import std.string;
import std.conv;
import std.functional;

string[] findDuplicateFiles(string targetDir) {
    return walkFiles(targetDir)
        .filter!(file => file.toUTF8().indexOf("(2)") != -1)
        .array();
}

bool displayFiles(string[] files) {
    if (files.length == 0) {
        writeln("No files found matching the criteria.");
        return false;
    }
    writeln("Files to delete:");
    files.each!(file => writeln(file));
    return true;
}

bool confirmDeletion() {
    write("Would you like to proceed with deletion? (y/n): ");
    string confirm = readln().strip().toLower();
    return confirm == "y";
}

void deleteFiles(string[] files) {
    files.each!(file => {
        try {
            remove(file);
        } catch (Exception e) {
            writeln("Error deleting ", file, ": ", e.msg);
        }
    });
    writeln("Files deleted.");
}

void main() {
    string targetDir = ".";
    string[] filesToDelete = findDuplicateFiles(targetDir);
    if (displayFiles(filesToDelete)) {
        if (confirmDeletion()) {
            deleteFiles(filesToDelete);
        } else {
            writeln("Deletion cancelled.");
        }
    }
}

unittest {
    string tempDir = "./temp_test_dir";
    enforce(mkdirRecurse(tempDir));
    enforce(touch(path.join(tempDir, "file(2).txt")));
    enforce(touch(path.join(tempDir, "file.txt")));
    enforce(mkdirRecurse(path.join(tempDir, "subdir")));
    enforce(touch(path.join(tempDir, "subdir", "file(2).txt")));
    enforce(touch(path.join(tempDir, "subdir", "file.txt")));

    string[] expectedFiles = [
        path.join(tempDir, "file(2).txt"),
        path.join(tempDir, "subdir", "file(2).txt")
    ];
    string[] actualFiles = findDuplicateFiles(tempDir);

    assert(actualFiles.sort() == expectedFiles.sort());

    enforce(removeDirRecurse(tempDir));
}

Key Functional Improvements:

    findDuplicateFiles:
        Uses walkFiles to produce a range of file paths.
        Uses filter to filter the files based on the condition (containing "(2)").
        Uses array to convert the filtered range into a string array.
    displayFiles:
        Uses each to iterate over the files and print them, rather than a traditional foreach loop.
    deleteFiles:
        Uses each to iterate over the files and delete them.

Explanation of Functional Dlang Features:

    Ranges: Dlang's ranges provide a powerful way to work with sequences of data in a functional style.
    filter: This function filters a range based on a predicate function.
    each: This function iterates over a range and applies a function to each element.
    Lambda Expressions: Dlang supports lambda expressions (e.g., file => file.toUTF8().indexOf("(2)") != -1), which are used to define anonymous functions.

This revised code should more closely align with your preference for a functional programming style. I hope this is more in line with what you were looking for.


___WacomBamboo_RemapKeys
- Very good. One last question (on a separate topic): I have/own a Bamboo Fun Wacom drawing-tablet, and I would like to utilize it for simpler input for certain programs on my Linux-systems, e.g. Inkscape, Gimp and the like.

My primary concern/question: There are five buttons on the Bamboo Fun, one of which is a 'scroll-wheel for levels', two that seems to emulate right and left arrows (i.e. they have the signs '<' and '>' on them), and lastly there are two buttons labeled 'fn'.

What I would like to do is to remap some of the buttons so I don't necessarily have to have one of my hands parked on the keyboard, at least not for certain kinds of workflows inside e.g. Inkscape. Could you give me an outline of how I would remap or configure one of the 'fn'-buttons to send a Ctrl-Z to a program I'm using? (I.e. I think you can see very well why Undo and some other functionalities would be very useful to have when working with the drawing-tablet)

Absolutely! Let's outline how you can remap one of the "fn" buttons on your Wacom Bamboo Fun tablet to send a Ctrl+Z keystroke on your Linux system. This will involve using xinput and xdotool.

Outline of Steps:

    Identify the Wacom Tablet's Input Device:
        Use xinput list to find the device ID for your Wacom tablet's buttons.
    Determine the Button Code:
        Use xinput test <device_id> to identify the button code for the "fn" button you want to remap.
    Create a Script to Remap the Button:
        Write a shell script that uses xinput set-button-map to remap the button.
        Alternatively, use xdotool to simulate a Ctrl+Z keystroke when the button is pressed.
    Make the Script Executable and Persistent:
        Make the script executable.
        Add the script to your startup applications or create a systemd service to ensure it runs automatically on login.

Detailed Steps:

    Identify the Wacom Tablet's Input Device:
        Open a terminal and run:
        Bash

    xinput list

    Look for a device entry that corresponds to your Wacom Bamboo Fun tablet. It might be labeled "Wacom Bamboo Fun Pen" or something similar. Note the device ID (a number).

Determine the Button Code:

    Run:
    Bash

    xinput test <device_id>

    (Replace <device_id> with the ID you found in the previous step.)
    Press the "fn" button you want to remap. The terminal will display button press and release events. Note the button number that corresponds to the "fn" button.

Create a Script to Simulate Ctrl+Z:

    Create a shell script (e.g., wacom_fn_remap.sh) with the following content:
    Bash

#!/bin/bash

device_id=<device_id> # Replace with your device ID
button_number=<button_number> # Replace with your button number

xdotool keydown ctrl key z keyup z keyup ctrl

    Replace <device_id> and <button_number> with your actual values.

Make the script executable:
Bash

chmod +x wacom_fn_remap.sh

Now you need to bind the button press to run the script. This method is the better of the two presented.

You can use xbindkeys or sxhkd to bind the button press to the script. I recommend sxhkd because it is more modern, and very fast.

Install sxhkd:
Bash

sudo apt install sxhkd #or your systems equivalent.

Create a sxhkd configuration file:
Bash

mkdir -p ~/.config/sxhkd
nano ~/.config/sxhkd/sxhkdrc

Add the following line to the file:

b:<button_number>
    /path/to/wacom_fn_remap.sh

Replace <button_number> with the button number, and /path/to/wacom_fn_remap.sh with the full path to your script.

Start sxhkd:
Bash

        sxhkd

        Press the button, and Ctrl-Z should be sent.

    Make the Script Persistent:
        For sxhkd to start at login, add it to your startup applications. The way to do this varies depending on your desktop environment.
        Alternatively, create a systemd service for sxhkd.

Important Notes:

    The button numbers might vary depending on your Wacom tablet model and Linux distribution.
    If you encounter issues, try running the commands directly in the terminal to troubleshoot.
    If you choose xbindkeys, the configuration will be slightly different, but the process is similar.
    sxhkd is generally the better option.

Let me know if you have any questions or encounter any issues during the process.



___VIMEMACS_MODULARCONFIG
- Quick question on another topic: I'm gonna start working on modularizing my Vim and Emacs configs; The problem that is probably well known when it comes to such configuration-files (especially when the degree of configurability is high) is that it swells into a completely disorganized tangle that becomes impossible to grasp.

You've hit upon a very common and frustrating problem with highly configurable editors like Vim and Emacs! As your configurations grow, they can quickly become unwieldy and difficult to manage. Modularizing them is an excellent strategy.

Here's a breakdown of how you can approach modularizing your Vim and Emacs configurations, along with some best practices:

Vim Modularization:

    Directory Structure:
        Create a ~/.vim/ or ~/.config/nvim/ directory (if using Neovim) to house your configuration.
        Within this directory, create subdirectories for different aspects of your configuration, such as:
            plugins/: For plugin configurations.
            ftplugin/: For filetype-specific configurations.
            colors/: For colorschemes.
            snippets/: For snippets.
            mappings/: For key mappings.
            functions/: For custom functions.
    vimrc or init.vim:
        Keep your main vimrc or init.vim file as lean as possible.
        Use source or runtime to load the modules from your subdirectories.
        Example:
        Vim Script

        " Load plugins
        for plugin in glob('~/.vim/plugins/*.vim', 1)
          execute 'source' plugin
        endfor

        " Load filetype-specific configs
        runtime ftplugin/*.vim

        "Load mappings
        source ~/.vim/mappings/general.vim
        source ~/.vim/mappings/specific.vim

    Filetype-Specific Configurations:
        Place filetype-specific configurations in ~/.vim/ftplugin/.
        Name the files according to the filetype (e.g., python.vim, javascript.vim).
    Plugin Management:
        Use a plugin manager (e.g., Vim-Plug, Packer, lazy.nvim) to manage your plugins.
        Keep plugin configurations in a separate file (e.g., plugins.vim) and source it from your vimrc.
    Mappings and Functions:
        Organize mappings and functions into logical files.
        Use descriptive filenames to indicate the purpose of each file.
    Snippets:
        Use a snippet engine (e.g., UltiSnips, LuaSnip) to manage snippets.
        Keep snippet files in the snippets/ directory, organized by filetype.

Emacs Modularization:

    Directory Structure:
        Create a ~/.emacs.d/ directory to house your configuration.
        Within this directory, create subdirectories for different aspects of your configuration, such as:
            lisp/: For custom Emacs Lisp code.
            site-lisp/: For site-specific Lisp code.
            themes/: For themes.
            modes/: For mode-specific configurations.
            packages/: for package configurations.
    init.el:
        Keep your main init.el file as lean as possible.
        Use load or require to load the modules from your subdirectories.
        Example:
        Code snippet

        (let ((default-directory "~/.emacs.d/lisp/"))
          (normal-top-level-add-to-load-path '("."))
          (load "packages"))
        (load "~/.emacs.d/lisp/mappings")
        (load "~/.emacs.d/modes/python-mode")

    Mode-Specific Configurations:
        Place mode-specific configurations in ~/.emacs.d/modes/.
        Name the files according to the mode (e.g., python-mode.el, javascript-mode.el).
    Package Management:
        Use a package manager (e.g., use-package, straight.el) to manage your packages.
        Keep package configurations in a separate file (e.g., packages.el) and load it from your init.el.
    Custom Lisp Code:
        Organize custom Lisp code into logical files.
        Use descriptive filenames to indicate the purpose of each file.
    Themes:
        Keep themes in the themes/ directory.

General Best Practices:

    Comments: Add plenty of comments to your configuration files to explain what each section does.
    Version Control: Use Git to track changes to your configuration files.
    Documentation: Create a README file to document your configuration.
    Avoid Global Variables: Minimize the use of global variables.
    Use Functions: Encapsulate related code into functions.
    Keep it Simple: Strive for simplicity and clarity.
    Use a Naming Convention: Use consistent naming conventions.

By following these guidelines, you can create a modular and maintainable configuration for Vim and Emacs.

That is very good advice, and I'll definitely take that onboard, at the very least as a good check-list of things I may already know but may have to refresh or collect up.


My more specific question for now would be the following:

When it comes to developing plugins and having a good modular config, I think I would like to take some inspiration from one of the best in the field (starting with Vim, and it doesn't matter too much exactly who the individual is at this point).

I have taken a look at this person's vimrc (which I think could be a good baseline for my own), and I think that maybe with a few minor adjustments it would be fit for purpose.


My only trouble is that the file is 500 lines long, so what would be ideal for me would be if I could provide that file to you in its entirety, have you read it in, and then myself be able to walk through the file in small snippets and ask you questions about it or certain pieces of it. Would that be possible, i.e. 'Yes that is entirely possible' or maybe 'Yes that is possible, but for me to read a file that long into my memory and keep it for context would require you to update to our latest LLM-model', etc

Unfortunately, directly providing a 500-line file for me to "read in" and keep in my context for an extended, interactive walkthrough is beyond my current capabilities. While I can process substantial amounts of text, maintaining that context across a prolonged, question-and-answer session with snippets is not something I'm designed to do reliably.

Here's why and what we can do:

    Context Window Limitations: Large language models, including me, have context window limitations. This means there's a limit to how much text I can remember at any given time. A 500-line file, especially with code, would consume a significant portion of that window.
    Conversation Dynamics: As a conversation progresses, older parts of the context tend to fade as new information is added. This would make it difficult to maintain a consistent understanding of the entire file over time.
    File Handling: I don't have the ability to directly access or store files from your local system.

However, we can still achieve your goal by breaking it down:

    Snippet-Based Approach:
        You can copy and paste small snippets of the Vim configuration file into our conversation.
        For each snippet, you can ask your questions, and I'll do my best to provide explanations and insights.
        We can work through the file section by section.
    Summarization and Key Concepts:
        If you'd like, you can provide an overview of the file's structure and key sections.
        I can help you identify common Vim configuration patterns and best practices used in the file.
    Specific Questions:
        If you have specific questions about particular Vim commands or settings, you can ask them directly.
        I can provide explanations and examples.
    Modularization Strategy:
        We can discuss strategies for modularizing the configuration based on the file's content.
        I can help you identify logical modules and suggest ways to organize them.

Essentially, we can work together to analyze the file in a more manageable, interactive way, even if I can't "read it in" as a whole.

Let me know if you'd like to proceed with the snippet-based approach or if you have any other questions.

No worries. That is very valuable information (and, I am probably going to start questions about snippets of the file as I walk through it anyway). Question though (before we start that walking-through process): Would it be possible for an upgraded or last edition of your LLM to accomplish the kind of tasks I posed to you in my last question?

That's a very insightful question about the future capabilities of large language models.

While I can't predict the exact features of future LLMs, it's highly likely that some of the limitations I mentioned will be significantly mitigated or even eliminated in upcoming models. Here's a breakdown of what's plausible:

    Expanded Context Windows:
        Future LLMs are expected to have vastly expanded context windows. This would allow them to retain much larger amounts of text, potentially entire files or even multiple files, within their working memory.
    Persistent Memory:
        Research is ongoing into methods for LLMs to have more persistent or long-term memory. This could involve techniques for storing and retrieving information across multiple conversations, effectively allowing the model to "remember" previous interactions and data.
    File Handling Capabilities:
        Future LLMs might be integrated more closely with file systems, allowing them to directly access and process files. This could involve secure and controlled access to local or cloud-based storage.
    Improved Context Management:
        Researchers are working on improving how LLMs manage context, ensuring that relevant information is retained and irrelevant information is discarded. This would lead to more consistent and accurate responses over longer conversations.
    Specialized Tools and Plugins:
        Future LLMs might be equipped with specialized tools or plugins that allow them to perform specific tasks, such as code analysis or file manipulation.

In summary:

It's reasonable to expect that future LLMs will be able to handle tasks like analyzing large configuration files and maintaining context across extended conversations much more effectively. The improvements in context windows, memory management, and file handling capabilities would make this possible.

However, it's also important to note that there are still many challenges to overcome, such as ensuring the security and privacy of user data, and preventing LLMs from generating harmful or misleading information.

Therefore, while the future looks promising, it's difficult to say exactly when these capabilities will become widely available.

Well I was actually asking the question specifically in the context of 'your current next iteration', i.e. Gemini Advanced

You're right to ask for that clarification. Regarding Gemini Advanced, while it represents a significant step forward in my capabilities, the core limitations I described earlier regarding context window size and persistent memory are still factors, though the degree to which they limit us is reduced.

Gemini Advanced has been designed to:

    Handle more complex and nuanced conversations: It can understand and respond to more intricate prompts and follow longer, more involved discussions.
    Process more information: It has an increased capacity to handle larger amounts of text and code, compared to earlier models. This allows it to work with more substantial snippets of your Vim configuration.
    Improve reasoning and problem-solving: It demonstrates enhanced abilities in reasoning, problem-solving, and code generation, which will be beneficial for analyzing and modularizing your Vim setup.

However, even with Gemini Advanced, the constraints of context window size and the lack of true persistent memory still apply. So, while it can handle larger snippets and more complex questions, it still cannot reliably "read in" and retain a 500-line file for an extended, open-ended conversation.

Therefore, the best approach remains to:

    Work with smaller, manageable snippets of your Vim configuration.
    Focus on specific questions and areas of interest within the file.
    Use Gemini Advanced's enhanced reasoning and coding capabilities to help you understand and modularize your setup.

Gemini Advanced is designed to provide a much improved experience, and will allow us to handle this task with greater ease and more thoroughness, but it won't entirely remove the need to work in snippets.

Can either you or your even more capable cousin Advanced produce images from prompt-descriptions?

Yes, both I and Gemini Advanced have the capability to generate images from text prompts. However, this capability is not universally available in all interfaces or contexts where we might be used.

When image generation is available, you can provide a text description, and we will attempt to create an image that matches your description. The quality and style of the generated image will depend on the complexity of the prompt and the capabilities of the underlying image generation model.

For example, you could provide a prompt like:

"A vibrant watercolor painting of a sunset over a calm ocean, with seagulls flying in the distance."

And, if the image generation capability is accessible, an image attempting to match that description would be produced.



___LLMSGEMINI_TIPSTRICKS_ADVANCED
- Great. I'm not ready to start off the 'My vimrc - Next generation' conversation just yet, so instead I would like to ask more about your current capabilities. I know from experience and having used your services for over a year now that a very good method for me with regard to looking up things, generating code (etc) is to simply write very specific and often very detailed prompts.

However, could you maybe give me some ideas that I could explore of 'tips and tricks' about using Gemini and other LLMs, i.e. what areas are commonly missed about what LLMs like yourself can do, especially for person's like myself who are fluent in very technical and nuanced English and can write very specific and detailed prompts? What more things are there to explore when it comes to interacting with LLMs (for example 'I know that you are VERY skilled in providing me extremely fine-grained questions, but have you ever tried using services like me for drilling you in questions concerning knowledge, learning trivia etc'

You're absolutely right that detailed and specific prompts are key to unlocking the power of LLMs. Let's explore some "tips and tricks" and less commonly explored areas that you, with your technical fluency, can leverage:

Beyond Basic Question-Answering and Code Generation:

    Role-Playing and Simulation:
        Try assigning me a specific role or persona. For example, "Act as an expert in compiler design and explain the concept of register allocation." This can lead to more focused and in-depth responses.
        Simulate scenarios. "Imagine you are a network security consultant. How would you approach a penetration test for a web application?"
        Use me to simulate debates or discussions on complex topics.

    Creative Writing and Idea Generation:
        Use me to brainstorm ideas for projects, stories, or articles.
        Generate different creative writing styles, such as poetry, screenplays, or short stories.
        Ask me to help you refine your own creative writing.

    Knowledge Drilling and Trivia:
        As you mentioned, I can be an excellent tool for drilling yourself on specific topics.
        Create custom quizzes or trivia games.
        Ask me to generate flashcards or study guides.
        Use me to test your knowledge of obscure technical details.

    Language and Translation:
        Go beyond basic translation. Ask me to translate nuanced phrases or idioms.
        Use me to learn about the etymology of words or the history of languages.
        Ask me to generate text in different writing styles within a specific language.

    Data Analysis and Manipulation (within limitations):
        While I don't have direct access to external data sources, you can provide me with data snippets, and I can help you analyze them.
        Use me to generate sample datasets or to explain complex data structures.
        Ask me to help you write regular expressions or other data manipulation tools.

    Personalized Learning and Tutoring:
        Use me to create personalized learning plans.
        Ask me to explain complex concepts in a way that is tailored to your learning style.
        Use me as a virtual tutor for specific subjects.

    Debugging and Problem Solving:
        Provide me with code snippets and ask me to help you debug them.
        Use me to brainstorm solutions to complex technical problems.
        Ask me to help you analyze logs or error messages.

    Automating Repetitive Tasks (with code generation):
        Even if I can't execute the code, I can generate code for you that automates tasks.
        Use me to generate scripts for file manipulation, data processing, or other repetitive tasks.

    Exploring Different Perspectives:
        Ask me to present different viewpoints on controversial topics.
        Use me to analyze arguments and identify logical fallacies.

Tips for Advanced Prompting:

    Specify the Format: If you need the output in a specific format (JSON, CSV, Markdown), explicitly state it.
    Use Delimiters: Use delimiters (e.g., triple quotes, backticks) to clearly separate different parts of your prompt.
    Iterative Refinement: Don't be afraid to refine your prompts based on the responses you receive.
    Provide Examples: If you have examples of the desired output, include them in your prompt.
    Use Chain-of-Thought Prompting: Break down complex tasks into smaller steps.
    Zero-Shot, One-Shot, Few-Shot Learning: Experiment with different prompting techniques.

By combining your technical fluency with these advanced prompting techniques, you can unlock even more of the potential of LLMs.



- Question: I have a couple of images I have collected that I would like to collate into a presentation for someone to be able to look at (e.g. on their TV), preferably without having to install any special or particular software, and I would like to discuss and look at some options.

Absolutely! Let's explore some options for creating a presentation from your images that's easily viewable on a TV without requiring special software. Here are a few approaches, ranging from simple to slightly more involved:

1. Simple Image Folder (Basic, but Universal):

    How it works: Simply copy all your images into a folder. Most modern TVs can display images directly from a USB drive or via network sharing (DLNA).
    Pros:
        Extremely simple and requires no software.
        Works on almost any TV with a USB port or network connectivity.
        No conversion or special formatting needed.
    Cons:
        No control over the display order (unless the TV allows sorting).
        No transitions or effects.
        May not be visually engaging.
    How to do it.
        Copy all of the images you want to use into one folder.
        Copy the folder to a USB drive, or share the folder on your network.
        Insert the USB drive into the TV, or use the TV's media player, to browse to the folder.

2. Creating a Simple Video Slideshow:

    How it works: Convert your images into a video file. This allows you to control the display order, timing, and even add basic transitions.
    Pros:
        Universally compatible with TVs and media players.
        Allows for a more controlled presentation.
        Can add simple transitions.
    Cons:
        Requires software to create the video.
        Slightly more time-consuming.
    Software Options:
        Built-in options: Windows Photos (Windows 10/11) and iMovie (macOS) often have slideshow-to-video features.
        Free and Open Source: VLC Media Player, or Shotcut.
        Online tools: Many online video editors can create slideshows.
    Workflow:
        Import your images into the chosen software.
        Arrange them in the desired order.
        Set the display duration for each image.
        Add transitions (optional).
        Export the slideshow as a video file (MP4 is a highly compatible format).
        Copy the video file to a USB drive.

3. Creating a PDF Slideshow:

    How it works: Insert your images into a PDF document, with each image on its own page. Many TVs and media players can display PDFs.
    Pros:
        PDFs are widely viewable.
        Very simple to create.
        Maintains image quality.
    Cons:
        Limited slideshow features.
        TV PDF viewers may have limitations.
    Software Options:
        Microsoft Word or PowerPoint (save as PDF).
        LibreOffice Impress or Writer (save as PDF).
        Online PDF creators.
    Workflow:
        Insert each image onto a separate page in the chosen software.
        Save the document as a PDF.
        Copy the PDF to a USB drive.

Considerations for TV Viewing:

    Resolution: Ensure your images are of a suitable resolution for the TV screen (e.g., 1920x1080 for Full HD, 3840x2160 for 4K).
    Aspect Ratio: Match the aspect ratio of your images to the TV screen (usually 16:9).
    File Format: MP4 (video) and JPEG (images) are generally the most compatible formats.
    TV Capabilities: Check your TV's user manual for supported file formats and playback options.

Recommendations:

    For the simplest approach, a folder of JPEG images on a USB drive is hard to beat.
    If you want more control, creating an MP4 video slideshow is the most versatile option.
    If you want to keep the images in a document format, PDF is a good option.

Which of these options sounds most suitable for your needs? I can provide more detailed instructions on any of them.

I think I would like to create a both very visually appealing exposé, and at the same time be able to add some kind of audio-track, so I can put the watcher in the right mood

Excellent! Combining visually appealing images with an audio track creates a much more immersive and engaging experience. Let's focus on creating a video slideshow, as it offers the most flexibility for this.

Here's a breakdown of the process and some software recommendations:

1. Software Selection:

    For Ease of Use (Beginner-Friendly):
        Windows Photos (Windows 10/11): If you're on Windows, it often has basic slideshow-to-video capabilities.
        iMovie (macOS): Apple's iMovie is user-friendly and great for simple video editing.
    For More Control and Features (Intermediate):
        Shotcut (Free and Open Source): A powerful, cross-platform video editor with a good learning curve.
        DaVinci Resolve (Free version available): Professional-grade editing software with a free version that's excellent for slideshows and more.
    Online Options (Convenient, but may have limitations):
        Many online video editors exist, such as Clipchamp, Canva, or Kapwing. These can be convenient, but may have limitations on free accounts.

2. Image Preparation:

    Resolution and Aspect Ratio: Ensure your images match the TV's resolution (e.g., 1920x1080) and aspect ratio (16:9).
    Image Editing (Optional): If needed, use an image editor (like GIMP, Photoshop, or online editors) to adjust brightness, contrast, and color.

3. Audio Track Selection:

    Royalty-Free Music: Consider using royalty-free music to avoid copyright issues. Websites like Epidemic Sound, Artlist, or YouTube Audio Library offer a wide range of tracks.
    Audio Editing (Optional): If you want to customize the audio, use audio editing software (like Audacity) to trim, fade, or adjust the volume.

4. Creating the Video Slideshow:

    Import Images and Audio: Import your images and audio track into your chosen video editing software.
    Arrange Images: Place the images on the timeline in the desired order.
    Set Image Duration: Adjust the duration of each image to match the rhythm of the audio.
    Add Transitions: Use transitions (like fades, dissolves, or wipes) to create smooth transitions between images.
    Sync Audio and Images: Carefully sync the images with the audio track to create a cohesive experience.
    Audio Adjustments: Adjust the audio volume to ensure it's balanced with any potential voice over, or the general feel you are going for.
    Export Video: Export the slideshow as an MP4 video file.

5. TV Playback:

    USB Drive: Copy the MP4 video file to a USB drive and play it on your TV's media player.
    Network Streaming: If your TV supports network streaming, you can stream the video from your computer or a media server.

Tips for a Visually Appealing Slideshow:

    Vary Image Duration: Use shorter durations for fast-paced sections and longer durations for more contemplative moments.
    Use Dynamic Transitions: Experiment with different transitions to add visual interest.
    Maintain Visual Consistency: Use images with a consistent color palette or style.
    Consider Pacing: The pacing of the slideshow should complement the mood of the audio track.

By following these steps, you can create a visually appealing slideshow with an audio track that's perfect for TV viewing.

I'm actually looking at something a bit more interesting (at least as a forward-looking option). The most interesting thing to create (at least to my mind) would be to create an image-slideshow where the person can watch the images, have a particular music-track (or tracks) playing in the background (to help the watcher get into the right or approximately right mood), and then themselves be able to look at the images in their own pace by being able to click forward and backward between the images at their own pace and leisure. That sounds like a rather interesting option, does it not? What should be added is perhaps my background in computers and multimedia: I have many years experience in using Linux and administrating it, using media-programs etc, and using or looking into different programming languages and some web-programming, so we're free to dream and speculate a bit about interesting solutions - with the caveat (of course) that if the solution takes a year to develop, it's quite obvious that the juice will not be worth the squeeze

Ah, you're looking for an interactive slideshow experience! That's a fantastic idea, and your Linux and web development background opens up some exciting possibilities. Let's explore some options that balance functionality with reasonable development time.

The Ideal Scenario: Web-Based Interactive Slideshow

A web-based approach offers the most flexibility for interactivity and cross-platform compatibility. Here's a breakdown of the components:

    HTML for Structure:
        Creates the basic layout, including image containers, navigation buttons, and an audio player.
    CSS for Styling:
        Styles the slideshow to be visually appealing, responsive, and TV-friendly.
    JavaScript for Interactivity:
        Handles image transitions, navigation, and audio playback.
        Allows users to move forward and backward through the images.
        Controls the audio track (play, pause, volume).
    Media Files:
        Optimized images (JPEG, PNG) for web display.
        Audio files (MP3, OGG) for background music.

Technical Implementation:

    HTML Structure:
        Use <div> elements to contain the images and navigation controls.
        Use the <audio> tag to embed the background music.
        Create "previous" and "next" buttons using <button> elements.
    CSS Styling:
        Style the image container to fill the screen or a specific area.
        Position the navigation buttons appropriately.
        Ensure the layout is responsive for different screen sizes.
    JavaScript Interactivity:
        Use JavaScript to:
            Load and display images dynamically.
            Handle button clicks to navigate between images.
            Control the audio playback (play, pause, volume).
            Create event listeners for the buttons.
    Image and Audio Handling:
        Place all images into a designated folder.
        Place all music files into a designated folder.
        Use JavaScript to create an array containing the file-paths.
        Use JavaScript to control the audio player.

Advantages:

    Cross-Platform Compatibility: Works on any device with a web browser, including smart TVs.
    Interactive Control: Users can navigate at their own pace.
    Customization: Easy to customize the appearance and functionality.
    Relatively Quick Development: With your background, you could create a basic version in a reasonable timeframe.

Considerations:

    TV Browser Compatibility: Smart TV browsers can sometimes be limited. Thorough testing is essential.
    File Hosting: You'll need a way to host the HTML, CSS, JavaScript, and media files (e.g., a local web server or a cloud hosting service).
    TV Remote Control: Consider how users will interact with the slideshow using a TV remote.

Simplified Approach (If TV Browser Limitations are a Concern):

    If TV browser compatibility is a major concern, you could create a simplified version that preloads all images and uses basic JavaScript for navigation.
    This would reduce the complexity but might increase the initial loading time.

Tools and Technologies:

    HTML, CSS, JavaScript: The core technologies for web development.
    Text Editor: VS Code, Sublime Text, or any other editor you prefer.
    Web Server (Optional): If you need to test locally, you can use a simple web server like Python's built-in HTTP server or Node.js's http-server.

Implementation Notes:

    To make the page viewable on a TV, you could host the files on a computer on your home network, and then use your TV's browser to navigate to the local IP adress of that computer.
    To help with TV remote control, you can make the next and previous buttons very large.

This web-based approach offers a great balance of interactivity, flexibility, and reasonable development time. Let me know if you'd like to delve deeper into any specific aspect of this solution!
Your saved info
Info you asked Gemini to save

Just one very quick question on another subject: If I understand and can speak Icelandic, will I be able to learn, speak and understand Faeroese reasonably quickly?

It's true that Icelandic and Faroese are closely related, as they both descend from Old West Norse. Therefore, having a strong understanding of Icelandic will indeed provide a significant advantage in learning Faroese. Here's a breakdown of the relationship and what to expect:

Similarities:

    Shared Origin:
        Both languages stem from Old West Norse, meaning they share a significant amount of core vocabulary and grammatical structures.
    Written Language:
        The written forms of Icelandic and Faroese exhibit a considerable degree of resemblance, largely due to Faroese's etymological orthography. This means that the spelling of Faroese words often reflects their Old Norse roots, much like Icelandic.
    Grammar:
        While there are differences, the grammatical foundations of both languages are similar, especially compared to other Scandinavian languages.

Differences:

    Pronunciation:
        The spoken forms of Icelandic and Faroese have diverged more significantly. Mutual intelligibility in speech can be challenging. Faroese has developed its own distinct phonetic characteristics.
    Influence of Danish:
        Faroese has been more heavily influenced by Danish due to historical factors. This has resulted in some vocabulary and grammatical differences.
    Evolution:
        While Icelandic is known for its relatively conservative nature, Faroese has undergone its own unique evolution.

In summary:

    Your knowledge of Icelandic will give you a very strong base for understanding Faroese vocabulary and grammar.
    You will likely find the written language relatively accessible.
    The biggest challenge will be adapting to the differences in pronunciation.

Therefore, while you won't instantly understand spoken Faroese, your Icelandic background will significantly accelerate the learning process.

Well I am a former vocal-coach, so differences in pronunciation and such (with the exception of some of the most tricky phonetics from the galaxy of human languages) will generally not be a problem, at least it has not been before/in the past

That's excellent! Your background as a vocal coach significantly mitigates the biggest potential hurdle in learning Faroese – the pronunciation differences. With your trained ear and experience in phonetics, you'll be well-equipped to:

    Discern subtle phonetic variations: You'll be able to quickly identify and reproduce the unique sounds of Faroese.
    Analyze and understand sound shifts: You'll have a strong foundation for understanding how sounds have evolved from Old Norse to Faroese.
    Master the rhythm and intonation: Your vocal training will help you grasp the nuances of Faroese speech, including its rhythm and intonation patterns.

Given your vocal coaching background, you can likely expect to learn spoken Faroese much more rapidly than someone without such training. The strong grammatical and lexical similarities between Icelandic and Faroese, combined with your phonetic expertise, will make the learning process significantly smoother.



___PYTHON_FUNCTIONDECORATORS=*****
- I'm looking for an explanation of the '@word'-syntax in Python. I think it's called either decorators or attributes. Could you give me some direction on this one?

You're right, the @word syntax in Python refers to decorators. While the term "attributes" is related to object properties, it's decorators that use the @ symbol.

Here's a breakdown of Python decorators:

What are Decorators?

    Decorators are a powerful and flexible feature in Python that allows you to modify or extend the behavior of functions or classes without permanently changing their source code.   

They provide a way to wrap a function or class with another function, adding functionality before or after the original function's execution.  

    Essentially, decorators are syntactic sugar for applying a function to another function.

How They Work

    Functions as First-Class Objects: In Python, functions are first-class objects, meaning they can be assigned to variables, passed as arguments to other functions, and returned from functions.   

Inner Functions: Decorators often use inner functions (functions defined within other functions) to wrap the original function.

The @ Syntax: The @decorator_name syntax is a shorthand for applying a decorator to a function. For example:
Python

@my_decorator
def my_function():
    # function code

This is equivalent to:
Python

    def my_function():
        # function code

    my_function = my_decorator(my_function)

Example
Python

def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()

Output:

Something is happening before the function is called.
Hello!
Something is happening after the function is called.

Key Concepts

    Decorator Function: The function that modifies the behavior of another function (e.g., my_decorator in the example).   

    Wrapped Function: The original function that is being modified (e.g., say_hello in the example).
    wrapper Function: The inner function that performs the additional actions before and after calling the original function.
    Passing Arguments: Decorators can be designed to handle functions with arguments using *args and **kwargs.
    Returning Values: Decorators should typically return the result of the wrapped function to preserve its original behavior.
    Decorators can also be created as classes.

Common Use Cases

    Logging: Recording function calls and their arguments.
    Timing: Measuring the execution time of functions.
    Authentication and Authorization: Checking user permissions before allowing access to certain functions.
    Caching: Storing function results to avoid redundant computations.
    Validation: Checking input parameters.
    Frameworks: Many Python web frameworks (like Flask and Django) use decorators for routing, request handling, and other tasks.

In summary: Decorators are a powerful Python feature that allows you to extend or modify the behavior of functions and classes in a clean and reusable way. They use the @ syntax and are commonly used for tasks like logging, timing, and authentication.
github.com
github.com
github.com
github.com
github.com
github.com
medium.com
medium.com
www.pzuraq.com
www.pzuraq.com

Question: Is there any software similar to the Sqlitebrowser available for browsing MongoDB-data? Particularly (although not necessarily exclusively) on Linux, and of course if possible something that is free/open source.

It's great you're looking for a GUI for MongoDB! It can significantly simplify working with NoSQL data. Here's a breakdown of popular options, with a focus on free/open-source and Linux compatibility:

Key Options:

    MongoDB Compass:
        This is the official GUI for MongoDB, developed by MongoDB Inc.
        It's free to use and available on Linux, macOS, and Windows.
        It provides a rich visual interface for exploring your data, running queries, and analyzing schema.
        It's very powerful, with features like schema visualization, query building, and performance analysis.
        This is a very strong option, and because it is the offical tool, it is very well maintained.
    Robo 3T:
        Formerly known as Robomongo, Robo 3T is a lightweight, free, and open-source MongoDB GUI.
        It's cross-platform, including Linux support.
        It embeds the MongoDB shell, allowing you to use shell scripting capabilities.
        It's a good choice for those who want a simpler, more lightweight GUI.
    Studio 3T:
        While Studio 3T has a commercial version, it also offers a free version with some limitations.
        It's a powerful IDE for MongoDB with advanced features like SQL query support.
        It's cross-platform, including Linux.
        This is a very powerful tool, but many of its best features are in the paid version.
    TablePlus:
        TablePlus is a modern, native GUI tool for relational & NoSQL databases.
        It does support MongoDB.
        It is very fast and has a very clean interface.
        While it is not fully open source, there is a free trial, and it does support linux.

Recommendations:

    For most users, MongoDB Compass is likely the best option. It's free, well-maintained, and provides a comprehensive set of features.
    If you are looking for a very light weight client, Robo 3T, is a very good choice.

When choosing, consider your specific needs:

    If you need advanced features like SQL query support, Studio 3T may be worth exploring.
    If you prefer a lightweight and simple GUI, Robo 3T is a good choice.

I hope this information helps!

And is it also possible adding data, changing 'schema' or structure for the database and such with Compass? What I'm thinking is that it might be a very good solution for me - I'm quite adept at programming, but in the initial stages when testing out a schema/structure and such, it might be easier anyway to use a GUI.

Yes, absolutely! MongoDB Compass is designed to facilitate all of those tasks. You can definitely:

    Add Data:
        You can insert new documents into collections through the Compass interface.
        It provides visual tools for creating and editing documents, making it easier to work with complex data structures.
    Change Schema/Structure:
        While MongoDB is schemaless, Compass helps you understand and manage the implicit schema that emerges from your data.
        You can:
            View the schema of your collections.
            Analyze data types and distributions.
            Add and modify indexes to improve query performance.
            Rename collections, and databases.
            Delete collections and databases.
        It also allows for schema visualization, which is extremely helpful.
    Edit Data:
        You can edit existing documents directly within the Compass interface.
        This is very useful for correcting errors or updating data.
    Delete Data:
        You can delete documents or entire collections.

Why Compass is Great for Initial Schema/Structure Testing:

    Visual Feedback: Compass provides immediate visual feedback on your data, making it easier to understand the structure of your collections.
    Schema Visualization: The schema visualization tools help you identify patterns and potential issues in your data.
    Easy Data Exploration: You can quickly browse your data and experiment with different data structures without writing complex queries.
    Index Management: Compass simplifies the process of creating and managing indexes, which is crucial for optimizing query performance.

In essence, MongoDB Compass gives you a visual playground to experiment with your data and schema, which is incredibly valuable during the initial stages of development. It allows you to quickly iterate and refine your data model before committing to a specific structure in your code.

:

I'm ready when you are. Do you have any further questions or tasks for me?



What plugins would you recommend in VS Code for working with JSON? And what I mean by that is 'the whole gamut' (if that's a correct and understandable use of that phrase), i.e. all the way from basics like enabling syntax-coloring and such (which if my suspicion is correct may already be installed by default in VS Code) all the way up to being able to get suggestions for autocompletion based on what I at least tentatively would call a 'schema' for particular JSON-code I'm writing

You're right, basic JSON syntax highlighting and validation are built into VS Code. However, to get the "whole gamut" of JSON support, including schema-based autocompletion, you'll want to add some extensions. Here's a breakdown of recommendations:

Essential Built-in Features (Usually Present):

    JSON Syntax Highlighting:
        VS Code automatically recognizes .json files and applies syntax highlighting.
    JSON Validation:
        VS Code validates JSON syntax and highlights errors.

Extensions for Enhanced JSON Functionality:

    JSON Tools:
        This extension provides a wide range of JSON-related tools, including:
            Formatting and minifying JSON.
            Sorting JSON keys.
            Converting JSON to other formats (e.g., CSV).
            Path navigation.
        It's a solid, general-purpose JSON extension.

    JSON Schema Support:
        This is where you get the schema-based autocompletion you're looking for.
        VS Code has built-in support for JSON schemas, but this extension enhances that support.
        You can associate JSON files with JSON schemas, which define the structure and allowed values for your JSON data.
        With a schema in place, VS Code will provide:
            Autocompletion suggestions based on the schema.
            Validation against the schema, highlighting errors if your JSON doesn't conform.
            Hover information, and documentation from the schema.
        To use it, you will need to create or obtain JSON schema files (.json files that describe the structure of other json files). Then you can associate the schema with your JSON files in VS Code settings.

    JSON Crack:
        This extention provides a graphical representation of json files, that is very helpful in understanding complex JSON documents.
        It helps visualize the JSON structure in a tree-like diagram.
        This is especially helpful for large or nested JSON structures.

How to Use JSON Schemas for Autocompletion:

    Create or Obtain a JSON Schema:
        You can write your own JSON schema or find existing schemas for common data formats.
    Associate the Schema with Your JSON File:
        In your VS Code settings (settings.json), you can associate a schema with a file pattern.
        Example:

JSON

    "json.schemas": [
        {
            "fileMatch": ["/mydata*.json"],
            "url": "./my-schema.json"
        }
    ]

    This example associates all JSON files starting with "mydata" with the schema located at ./my-schema.json.
    Alternatively, you can add a $schema property to the root of your JSON file.

JSON

{
    "$schema": "./my-schema.json",
    "property1": "value1",
    "property2": 123
}

    Enjoy Autocompletion:
        Once the schema is associated, VS Code will provide autocompletion suggestions and validation based on the schema.

By combining the built-in JSON support with these extensions, you'll have a powerful and efficient JSON development environment in VS Code.

Could you give me some direction on what schemas look like in in JSON. As a clarification: I was looking for a good way of translating the term schema to some other languages, and I think the underlying concept/concepts I settled on to explain it was something like 'specification of rules and constraints for possible or allowed values'

You're absolutely right! A JSON schema acts as a "specification of rules and constraints for possible or allowed values" within a JSON document. Let's break down what a JSON schema looks like and how it works.

Basic Structure of a JSON Schema:

A JSON schema is itself a JSON document. It defines the structure and data types that a valid JSON document should adhere to. Key properties are:

    $schema: Specifies the version of the JSON Schema specification being used.
    type: Defines the expected data type (e.g., object, array, string, number, boolean, null).
    properties: Defines the properties of a JSON object, including their types and constraints.
    items: Defines the type of items in a JSON array.
    required: Specifies which properties of an object are mandatory.
    minimum, maximum, minLength, maxLength, pattern: Constraints for numeric and string values.
    enum: Restricts values to a predefined set.

Example JSON Schema:
JSON

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "properties": {
        "firstName": {
            "type": "string"
        },
        "lastName": {
            "type": "string"
        },
        "age": {
            "type": "integer",
            "minimum": 0
        },
        "email": {
            "type": "string",
            "format": "email"
        },
        "phoneNumbers": {
            "type": "array",
            "items": {
                "type": "string",
                "pattern": "^\\+?[1-9]\\d{1,14}$"
            }
        },
        "isEmployed": {
            "type": "boolean"
        }
    },
    "required": ["firstName", "lastName"]
}

Explanation:

    $schema: Indicates that this schema follows the draft-07 specification.
    type: "object": Specifies that the JSON document being validated must be a JSON object.
    properties: Defines the allowed properties of the object.
        firstName and lastName: Must be strings.
        age: Must be an integer, and the minimum value is 0.
        email: Must be a string, and the format specifies that it should be a valid email address.
        phoneNumbers: Must be an array, and each item in the array must be a string matching a regular expression for a phone number.
        isEmployed: Must be a boolean.
    required: Specifies that firstName and lastName properties are mandatory.

How Schemas Enforce Rules:

When a JSON document is validated against this schema:

    If a property is missing that is listed in the required array, the validation fails.
    If a property has a data type that doesn't match the type specified in the schema, the validation fails.
    If a numeric or string property violates the minimum, maximum, minLength, maxLength, or pattern constraints, the validation fails.
    if an email is not in the proper email format, the validation fails.
    if a phone number within the array does not match the regular expression, the validation fails.

In essence:

JSON schemas provide a way to define the structure and constraints that a JSON document must adhere to, ensuring data consistency and validity. This is what enables tools like VS Code to provide autocompletion and error checking based on the schemas rules.

Great. Quick question about Linux: There are some specific Linux-distros that are geared towards learning in depth about Linux, and specifically learning by tinkering and putting together the lower parts of the system oneself - I'm thinking specifically about distros such as LFS, PocketLinux etc. Could you help me list and also compare and contrast some of those systems? I'm thinking seriously about sometime in the future looking into one of those.

You're right, there are Linux distributions designed to give you a deep understanding of the system by building it from the ground up. Here's a breakdown of some prominent ones, comparing and contrasting their approaches:

1. Linux From Scratch (LFS):

    Concept:
        LFS is not a distribution in the traditional sense. It's a book and a set of instructions that guide you through building a complete Linux system from source code.
        You download and compile every package yourself, customizing every aspect of the system.
    Learning Experience:
        Extremely in-depth. You'll learn about the boot process, kernel compilation, library dependencies, and the inner workings of core utilities.
        Very time-consuming and requires a high level of patience and attention to detail.
    Customization:
        Maximum customization. You have complete control over every component of the system.
    Difficulty:
        Very high. It's considered one of the most challenging ways to learn Linux.
    Use Cases:
        Educational purposes, for those who want to understand Linux at the deepest level.
        Creating highly specialized and optimized systems.

2. Gentoo Linux:

    Concept:
        A source-based distribution. While not as extreme as LFS, it encourages you to compile most packages from source.
        Uses Portage, a package management system that allows fine-grained control over compilation options.
    Learning Experience:
        Deep understanding of package management, compilation flags, and system configuration.
        More manageable than LFS, but still requires significant effort.
    Customization:
        High customization. You can tailor packages to your specific hardware and needs.
    Difficulty:
        High, but not as extreme as LFS.
    Use Cases:
        Users who want a highly optimized and customized system.
        Developers who want to experiment with different compilation options.

3. Arch Linux:

    Concept:
        A lightweight and flexible distribution that follows a "keep it simple, stupid" (KISS) philosophy.
        Uses a rolling-release model, so you always have the latest software.
        Installation is done via the command line, and requires manual configuration of many system components.
    Learning Experience:
        You'll gain a good understanding of system configuration, package management (using pacman), and the command line.
        Requires some manual configuration, but the Arch Wiki is an excellent resource.
    Customization:
        High customization. You choose which packages to install and configure.
    Difficulty:
        Moderate to high, depending on your experience.
    Use Cases:
        Users who want a lightweight and customizable system.
        Developers who want a modern and up-to-date environment.

4. Pocket Linux:

    Concept:
        Pocket Linux is a very small, embeddable linux system. It is designed to be easily modified, and is commonly used in embedded systems.
        It's designed to be extremely small and portable.
    Learning Experience:
        Learning about embedded systems, small system design, and customized kernels.
        This is a very specific use case.
    Customization:
        Very high.
    Difficulty:
        High, due to the embedded nature of the system.
    Use Cases:
        Embedded systems, IOT devices, and very specific use cases where a small linux footprint is needed.

Comparison Table:
Feature	LFS	Gentoo	Arch Linux	Pocket Linux
Source-based	Yes	Mostly	Partially	Mostly
Customization	Maximum	High	High	Very high
Difficulty	Very high	High	Moderate to high	High
Learning Curve	Steepest	Steep	Moderate	Steep
Time Investment	Very high	High	Moderate	High
Primary Use	Education	Customization, performance	Flexibility, modern software	Embedded systems

Recommendation:

    If your primary goal is to gain the deepest possible understanding of Linux internals, LFS is the ultimate challenge.
    If you want a highly customizable and optimized system with a more manageable approach, Gentoo is a good choice.
    If you want a good learning experience, and a very customizable system, but do not want to compile every package, Arch Linux is a great choice.
    If you want to learn about embedded linux systems, and very small linux distros, Pocket Linux is a good choice.

Remember to choose the distribution that aligns with your learning goals and time commitment.

Great. Quick question about Reactive UI: It seems really interesting and I can see that it supports MAUI. Does it support Avalonia however?

Yes, ReactiveUI does indeed support Avalonia. In fact, there's specific integration to make them work well together. Here's a breakdown:

    Avalonia.ReactiveUI:
        Avalonia provides a specific NuGet package called Avalonia.ReactiveUI. This package is designed to facilitate the use of ReactiveUI within Avalonia applications.
        This integration provides helpers that streamline common ReactiveUI tasks in Avalonia, such as:
            View model-based routing.
            View activation.
            Scheduling.
    Integration:
        To use ReactiveUI with Avalonia, you'll typically install the Avalonia.ReactiveUI NuGet package and configure your application's AppBuilder to use it.
        This setup allows you to leverage ReactiveUI's reactive programming paradigm within your Avalonia UI.
    Key Points:
        Avalonia recognizes the value of the MVVM pattern and ReactiveUI's implementation of it.
        The Avalonia team provides support for the Avalonia.ReactiveUI package.

In essence, ReactiveUI and Avalonia are designed to work harmoniously, enabling developers to build reactive and maintainable cross-platform applications.

Another question: Is it possible to use other data-bearing layers for Android apps than SqLite? The database that seems most fitting for a language-database I'm planning on building is MongoDB, and I would like (if possible) to avoid A. Relational databases (i.e. constructing schemas and relations is very front-heavy for getting a project off the ground) and B. Needing to have a web-connection (which I guess is the case if I build and rely on a web-API, possibly using MongoDB Atlas or such as the data-store to draw data from)

Yes, you absolutely can use data stores other than SQLite for Android apps, and MongoDB is a viable option for your language database, especially if you want to avoid relational schemas and web dependencies. Here's a breakdown of options and considerations:

Alternatives to SQLite for Android:

    MongoDB Realm (Now MongoDB Atlas Device SDK):
        This is the most direct way to use MongoDB locally on Android.
        It's designed for mobile and offline-first applications.
        Advantages:
            Document-oriented, like MongoDB, so no relational schemas.
            Offline synchronization: Data is stored locally and syncs with MongoDB Atlas when online.
            Flexible data model.
            Very good performance.
        Considerations:
            While it works offline, the idea is that it will sync when online. If your app is designed to be 100% offline, you will not use the syncing features.
            You'll still need to include the Realm SDK in your Android project.
    NoSQL Local Databases:
        ObjectBox:
            A fast, embedded NoSQL database for mobile and IoT.
            Object-oriented, so you work with objects directly.
            High performance.
        LevelDB/RocksDB:
            Key-value stores.
            Very fast for simple key-value lookups.
            Can be suitable for certain types of language data.
        Advantages:
            No relational schemas.
            Fast performance.
            Offline-first.
        Considerations:
            May require more manual data modeling than MongoDB Realm.
            LevelDB/RocksDB are very simple, so complex queries can be hard.
    File-Based Storage (JSON, XML, etc.):
        You can store your data in JSON or XML files within the app's internal storage.
        Advantages:
            Very simple to implement.
            No external dependencies.
        Considerations:
            Not suitable for large datasets.
            Performance can be poor for complex queries.
            Requires manual data serialization and deserialization.
    Room Persistence Library (with JSON columns):
        While Room is part of the Android Jetpack and is a relational database abstraction layer, it can be used in a way that is similar to a document database.
        You can create a single column in your Room database that stores a JSON string.
        Then, you can use Gson or another JSON library to serialize and deserialize your data.
        Advantages:
            You can still take advantage of Room's threading and lifecycle management.
            Relatively simple to implement.
        Considerations:
            You lose the ability to query individual fields within the JSON document.
            Performance may be slower than using a native NoSQL database.

Recommendation for Your Language Database:

    For your language database, MongoDB Atlas Device SDK is an excellent choice.
        It provides the flexibility of MongoDB's document model.
        It is designed for offline use, and then syncing when online.
        It is designed for mobile, and has good performance.
    If you need a 100% offline solution, and want to avoid any syncing features, ObjectBox is a very good alternative.

By using MongoDB Realm, you can avoid the complexities of relational schemas and build a fast and flexible language database for your Android app.

Quick question about the program Shotwell: I have heard that it is available on Windows. Is that true?

Based on the search results, it appears that while Shotwell is primarily known as a Linux application, there are some sources indicating that versions have been made available for Windows. However, it's important to be aware of a few things:

    Older Versions:
        The Windows versions that are available may be older and not as actively maintained as the Linux versions.
    Source and Reliability:
        When downloading software from sources other than the official project website, it's crucial to exercise caution. Ensure that the download source is reputable to avoid potential security risks.
    Primary Focus:
        Shotwell's primary development and focus have been on the Linux platform.

Therefore, while you might find Shotwell versions for Windows, they might not be the most up-to-date, and careful consideration of the download source is advised.

Another option for keeping track of and flagging images might actually be to develop ones own little utility or a showcase-website.

You're right! Building your own image management utility or showcase website gives you complete control and allows you to tailor it precisely to your needs. Here's a breakdown of the pros and cons, along with some technologies and approaches:

Pros of Building Your Own:

    Customization:
        You can design the interface and features exactly how you want them.
        You can implement specific flagging, tagging, and sorting mechanisms.
    Learning Experience:
        It's a great way to learn about image processing, database management, and web development.
        You can deepen your understanding of the technologies you use.
    No Dependencies:
        You're not reliant on third-party software that may become outdated or unsupported.
    Integration:
        You can integrate it with other tools or workflows you use.

Cons of Building Your Own:

    Time and Effort:
        Developing a full-fledged image management system takes significant time and effort.
        You'll need to handle tasks like image loading, display, and storage.
    Maintenance:
        You'll be responsible for maintaining and updating the application.
        This includes fixing bugs and adding new features.
    Complexity:
        Image processing can be complex, especially if you want to implement advanced features.

Technologies and Approaches:

    Web-Based Showcase:
        Frontend:
            HTML, CSS, and JavaScript for the user interface.
            React, Vue.js, or Angular for a more dynamic and interactive experience.
            Libraries like Lightbox or Masonry for image display.
        Backend:
            Node.js with Express.js, Python with Flask or Django, or PHP for server-side logic.
            Databases like PostgreSQL, MySQL, or MongoDB to store image metadata (tags, flags, etc.).
            Image processing libraries like ImageMagick (server-side) or Canvas API (client-side) for resizing and manipulation.
        Storage:
            Local file system or cloud storage (e.g., AWS S3, Google Cloud Storage).
        Example Features:
            Tagging and filtering images.
            User authentication and authorization.
            Image galleries and slideshows.
            Searching image metadata.
    Desktop Utility:
        Languages:
            Python with PyQt or Tkinter for cross-platform development.
            C# with .NET MAUI or WPF for Windows.
            Java with JavaFX.
        Databases:
            SQLite for local storage of image metadata.
            ObjectBox, or Realm for NoSQL local storage.
        Image Processing:
            Pillow (Python), ImageSharp (.NET), or Java Advanced Imaging (JAI).
        Example Features:
            Image browsing and preview.
            Flagging and tagging images.
            Batch image processing.
            Local file organization.

Recommendations:

    If you're comfortable with web development, a web-based showcase offers a lot of flexibility and accessibility.
    If you prefer a desktop application, Python with PyQt or C# with .NET MAUI are good choices.
    Start with a basic prototype and gradually add features as needed.
    Consider using a database from the start, as it will make it easier to add search and filtering functionality.

Building your own image management solution can be a rewarding project, allowing you to create a tool that perfectly suits your needs.

I think the question that it hinges on (in my case as for so many others) is the price and availability of storage. Could you give me some guidance there? Just to mention: One thing that occurred to me right this instant is that one solution could be to create some sort of service or 'blog-like' page using Instagram, Facebook or the like.

You've hit on a crucial point: storage costs and availability are key factors when dealing with large image collections. Let's break down your options and considerations:

1. Cloud Storage Services:

    AWS S3 (Amazon Simple Storage Service):
        Highly scalable and durable storage.
        Offers various storage classes with different cost and access characteristics.
        Pricing is based on storage used, data transfer, and requests.
        Good for large collections and high availability.
    Google Cloud Storage:
        Similar to AWS S3, with various storage classes.
        Competitive pricing and good integration with other Google Cloud services.
        Good for large collections and high availability.
    Azure Blob Storage (Microsoft Azure):
        Microsoft's object storage solution.
        Offers similar features and pricing to AWS S3 and Google Cloud Storage.
        Good for large collections and high availability.
    Backblaze B2:
        Known for its affordable storage pricing.
        Simpler pricing structure compared to the major cloud providers.
        Good for large backups and long-term storage.
    Cloudflare R2:
        Relatively new, and competes with the other cloud storage options.
        Cloudflare is known for it's CDN, and this storage is highly integrated with that.
        Very competitive pricing.

Considerations for Cloud Storage:

    Pricing:
        Pay close attention to storage costs, data transfer fees, and API request charges.
        Use storage classes that match your access patterns (e.g., infrequent access for archival).
    Data Transfer:
        Downloading large amounts of data can be expensive.
        Consider using a CDN (Content Delivery Network) to reduce data transfer costs.
    Security:
        Implement proper access control and encryption to protect your images.

2. Social Media and Image Hosting Services:

    Instagram, Facebook, Flickr, etc.:
        Pros:
            Free or low-cost storage.
            Built-in sharing and social features.
            Easy to use.
        Cons:
            Loss of control over your data.
            Image compression and quality reduction.
            Terms of service can change.
            Privacy concerns.
            The services are not designed for the use case of a personal database.
    Self-Hosting:
        Pros:
            Complete control over your data.
            Customization.
        Cons:
            Requires technical expertise.
            You're responsible for backups and maintenance.
            Up front hardware cost.
            Power consumption.
            Internet upload speed limitations.

3. Local Storage:

    External Hard Drives/NAS (Network Attached Storage):
        Pros:
            Relatively low cost for large amounts of storage.
            No recurring fees.
            Full control.
        Cons:
            Risk of hardware failure.
            Requires manual backups.
            Limited accessibility from outside your local network.

Recommendations:

    For large collections and high availability, cloud storage services like AWS S3, Google Cloud Storage, or Backblaze B2 are good options.
    If you're on a tight budget and prioritize social sharing, social media platforms can be a temporary solution, but be mindful of the limitations.
    For long term storage, and full control, local storage, such as a NAS device, or external hard drives are very good options.
    Cloudflare R2 is worth investigating, due to very competitive pricing.
    A hybrid approach is also a very good idea. For example, local storage for primary storage, and cloud storage for backups.

When choosing a storage solution, consider your budget, the size of your collection, your access patterns, and your security requirements.




I have a question regarding law, but in this case it involves Swedish law. For many questions, I know that it significantly can impact the answer for the better to ask in English, simply because there is so much information and training-data available for you in English, but in this case we should maybe use Swedish? What's your tip or advice in this particular case?

You've hit on a very important point about language and AI! Here's a breakdown of my advice for your Swedish law question:

Factors to Consider:

    Specificity of Swedish Law:
        Swedish law is highly specific to Sweden. While I have access to a vast amount of information, my training data on niche legal systems like Swedish law might be less comprehensive than for widely documented legal systems like those of the United States or the United Kingdom.
        Legal terminology is very precise. A direct translation between english and swedish can easily change the meaning of the sentance and therefore the answer.
    Availability of Swedish Legal Resources:
        There are excellent Swedish legal databases and resources. If your question involves specific Swedish statutes or legal precedents, using Swedish will allow you to directly reference those sources.
    Nuance and Cultural Context:
        Law is deeply embedded in cultural context. Some legal concepts might not have direct English equivalents, and their interpretation can depend on Swedish societal norms.

My Recommendation:

    Start with Swedish:
        If your question is very specific to Swedish law, it's generally best to ask it in Swedish. This will maximize the chances of getting relevant and accurate information.
        If you have specific Swedish legal terms, using them directly will be essential.
    Consider a Dual Approach:
        If you're unsure, you could ask your question in Swedish and then provide a brief English summary or translation. This could help me understand the broader context and potentially access additional information.
        If you get an answer in Swedish, and feel that it is hard to understand, you can ask me to explain the answer in english.
    Always Verify with Legal Professionals:
        Regardless of the language used, remember that my responses are not legal advice. Always consult with a qualified Swedish legal professional for any legal matters.

In summary: When dealing with very country-specific legal questions, the native language is often the best starting point.

I'm thinking the other way around, i.e. that I might be able to ask the question in English, then you are free to draw from a number of laws from different countries and we can see if we can hone in on what is reasonable or probable. After that, we might try a couple of small questions in Swedish and you can give me some links or such resources (i.e. I might have a better idea of what the PROBABLE answer is, and I can perhaps more effectively research the matter myself). Does that seem like a feasible approach?

Yes, that's a very intelligent and feasible approach! It's a great way to leverage my strengths while acknowledging the limitations of language-specific legal expertise. Here's a breakdown of why that works and how we can proceed:

Why This Approach Works:

    Identifying Common Legal Principles:
        Many fundamental legal principles are shared across different legal systems, even if their specific implementation varies. By starting with English, we can explore these commonalities and establish a general framework.
    Exploring Different Legal Perspectives:
        Drawing on legal concepts from various countries can provide valuable insights and help us identify potential arguments or considerations that might be relevant to your Swedish legal question.
    Focusing on the Core Issues:
        By starting with a broader perspective, we can clarify the core legal issues at stake and refine the question before delving into the specifics of Swedish law.
    Using English as a "Filter":
        Using English first, makes it possible to filter out a lot of noise, and get to the core of the problem.

How We Can Proceed:

    Ask Your Question in English:
        Clearly state your legal question in English, providing as much relevant context as possible.
    Explore General Legal Principles:
        I will then draw on my knowledge of various legal systems to identify relevant principles, precedents, and arguments.
    Refine the Question:
        Based on our discussion, we can refine the question and identify the specific aspects that require further investigation within the context of Swedish law.
    Swedish Legal Resources:
        Once we have a clearer understanding of the issues, you can ask specific questions in Swedish, and I will do my best to provide relevant links to Swedish legal resources, such as:
            "Lagar.nu" (a database of Swedish laws)
            "Domstol.se" (the website of the Swedish courts)
            "Rättsdatabaser" (legal databases)
    Verification:
        Remember that all information should be verified by a legal professional.

Let's begin! Please ask your legal question in English, and we'll start exploring the general legal principles.

Very good. I think we can proceed and I'm sure we can deduce some at least approximate answers.

My question is the following: Let's say a person goes to a school and also takes out a student loan for a period of some years (+just note: that second piece of information may be peripheral, but I think we can see later if it becomes relevant). Then let's say that the school tanks and goes out of business shortly before one graduates. The problem (which may be to state the blindingly obvious) is that in this case, there would for the affected students be a case of where to go or petition to get hold of their certifications or degrees, if you follow where this is going?

Yes, I follow your line of reasoning. This is a classic "school closure" scenario, with the added complication of potential student loan implications. Here's a breakdown of the general legal principles that might apply, drawing from various legal systems:

General Legal Principles:

    Contract Law:
        The relationship between the student and the school is essentially a contractual one. The student pays tuition (and potentially takes out loans), and the school agrees to provide education and award a degree or certification. When the school closes, it breaches this contract.
        Students may have a claim for breach of contract, potentially seeking refunds for tuition paid or damages for the loss of educational opportunity.
    Consumer Protection:
        In many jurisdictions, students are considered consumers of educational services. Consumer protection laws may provide additional remedies, such as:
            Refunds for unprovided services.
            Protection against unfair or deceptive practices.
            Assistance from government agencies in resolving disputes.
    Insolvency Law:
        When a school goes bankrupt, insolvency law dictates how its assets are distributed. Students may be considered creditors, but they often have a low priority compared to secured creditors like banks.
        Insolvency proceedings may involve a trustee or administrator who is responsible for handling the school's records and potentially issuing certifications.
    Government Oversight:
        Many countries have government agencies that regulate educational institutions. These agencies may have a role in:
            Maintaining records of closed schools.
            Facilitating the transfer of students to other institutions.
            Assisting students in obtaining their certifications.
    Student Loan Implications:
        The closure of a school can have significant implications for student loans. In many jurisdictions, students may be eligible for loan discharge or forgiveness if the school closes before they complete their program.
        The specific rules governing student loan discharge vary widely.

Regarding Your Specific Question About Certifications/Degrees:

    Record Keeping:
        The most immediate concern is the preservation of student records. Ideally, the school or a designated authority (such as a government agency or insolvency trustee) should maintain these records.
        Students may need to petition the relevant authority to obtain copies of their transcripts or certifications.
    Transfer of Credits:
        Students may seek to transfer their credits to another institution. This often requires official transcripts from the closed school.
    Alternative Certification:
        In some cases, government agencies or professional associations may offer alternative pathways to certification for students affected by school closures.

Next Steps:

    Now that we've outlined the general principles, we can start to focus on the specifics of Swedish law. Do you want to ask a more specific question, in swedish, regarding where the records of a closed school most likely would be kept, or where to petition for a copy of said records?

Det kan vi absolut göra. I det här speciella fallet har inte skolan stängt eller avslutats, men det finns indicier som inte gör att tolkningen 'skolan/utbildningen kommer att gå under/stänga' åtminstone inte är ett helt orimligt eller fantastiskt scenario.

Absolut, det är en viktig distinktion. Även om skolan inte har stängt ännu, är det klokt att vara förberedd på ett potentiellt scenario där den gör det. Här är några steg och resurser som kan vara relevanta i en sådan situation i Sverige:

Potentiella åtgärder och resurser:

    Skolinspektionen:
        Skolinspektionen är den myndighet som ansvarar för tillsynen av skolor i Sverige. Om det finns indikationer på att en skola kan komma att stänga, kan det vara värdefullt att kontakta dem. De kan ge information om skolans status och eventuella åtgärder som vidtas.
        De har även information om elevers rättigheter. Här är en länk till deras sida med frågor och svar om elevers rättigheter:
            Skolinspektionen.se
    Kommunen:
        Kommunen har också ett ansvar för utbildningen i sitt område. De kan eventuellt hjälpa till att hitta alternativa utbildningsmöjligheter om skolan stänger.
    CSN (Centrala studiestödsnämnden):
        Om studentlån är inblandade, är det viktigt att kontakta CSN. De kan informera om hur ett eventuellt skolnedläggning påverkar studielånen.
    Juridisk rådgivning:
        Om det uppstår tvister eller om eleverna vill kräva ersättning, kan det vara nödvändigt att söka juridisk rådgivning.
    Dokumentation:
        Det är mycket viktigt att eleverna sparar all relevant dokumentation, såsom kursplaner, betyg, intyg och kvitton.

Specifika frågor att undersöka:

    Vilka rättigheter har eleverna om skolan stänger?
    Vem ansvarar för att bevara och tillhandahålla elevernas studiehandlingar?
    Hur påverkas studielånen vid en skolnedläggning?
    Vad är skolans nuvarande status hos Skolinspektionen?

Viktigt att notera:

    Det är alltid bäst att agera proaktivt och samla information i förväg.
    Att dokumentera all kommunikation med skolan och relevanta myndigheter är viktigt.

Jag hoppas att denna information är till hjälp.

I det här speciella fallet är högsta myndighet för den specifika skolan Yrkeshögskolemyndigheten. En av de kanske mest påverkade eleverna (som personligen råkat ut för problem p.g.a. dålig skötsel på/av skolan) har både en kontakt inom det för utbildningen aktuella området som är mycket meriterad och har svarat jakande på att skriva på ett uttalande till fördel för eleven = att denne kontakten anser att skolan har misskött sig grovt/inte fullföljt sin del av utbildningskontraktet, och samme påverkade person har också varit i kontakt med en konsulent på myndigheten och efter att muntligt ha återgivit delar av vad de råkat ut för fått mycket stark respons till sin fördel av nämnda konsulent.

Det är mycket bra att du har tagit kontakt med Yrkeshögskolemyndigheten och att du har stöd från en meriterad person inom området. Det låter som att du har goda förutsättningar att driva ditt ärende. Här är några ytterligare tankar och råd:

Yrkeshögskolemyndigheten (MYH):

    MYH är den myndighet som ansvarar för tillsynen av yrkeshögskoleutbildningar. Det innebär att de har ett ansvar för att säkerställa att utbildningarna håller god kvalitet och följer gällande regler.
    Det är mycket positivt att du har fått ett starkt positivt gensvar från en konsulent på myndigheten. Det tyder på att de tar ditt ärende på allvar.
    Se till att all kommunikation med MYH sker skriftligt, så att du har dokumentation på allt som sagts och gjorts.
    Begär att få ett skriftligt beslut från MYH, där de redogör för sin bedömning av skolans agerande och eventuella åtgärder de kommer att vidta.

Uttalandet från den meriterade personen:

    Ett skriftligt uttalande från en meriterad person inom området kan vara mycket värdefullt. Det ger tyngd åt dina påståenden och visar att du har stöd från en expert.
    Se till att uttalandet är så detaljerat och konkret som möjligt. Det bör tydligt beskriva vilka brister skolan har haft och hur dessa har påverkat dig.
    Använd uttalandet som bevis i din kommunikation med MYH.

Ytterligare råd:

    Samla all relevant dokumentation, såsom kursplaner, betyg, mejl och andra bevis på skolans agerande.
    Var tydlig och koncis i din kommunikation med MYH. Beskriv tydligt vilka problem du har upplevt och vilka krav du har.
    Överväg att ta juridisk hjälp. En jurist kan hjälpa dig att driva ditt ärende och säkerställa att dina rättigheter tillvaratas.
    Här är en länk till Myndigheten för yrkeshögskolan.
        Myndigheten för yrkeshögskolan: Startsida

Viktigt:

    Det är viktigt att komma ihåg att varje ärende är unikt. Utfallet kan variera beroende på de specifika omständigheterna.
    Jag kan ge råd och information, men jag är inte en jurist. För juridisk rådgivning bör du kontakta en advokat eller annan juridisk expert.

Jag hoppas att detta hjälper dig. Lycka till!
Your saved info
Info you asked Gemini to save

I have a question and an interesting task for us: When I have looked around, it seems to me that going through using the LFS-distro (i.e. Linux From Scratch), although difficult and brutal would give one a REALLY solid understanding of how Linux-systems work. I guess you would, but do you agree with that?

Yes, I absolutely agree that going through the Linux From Scratch (LFS) process provides an extremely solid understanding of how Linux systems work. It's a very hands-on and detailed approach, and here's why it's so effective:

Why LFS Provides a Deep Understanding:

    Building from the Ground Up:
        LFS forces you to compile and install every component of the system manually. This means you gain intimate knowledge of how each piece fits together.
    Understanding Dependencies:
        You learn about the intricate dependencies between different software packages. This is crucial for troubleshooting and understanding system behavior.
    Kernel Configuration:
        You get to configure the Linux kernel yourself, which gives you a deep understanding of how the kernel interacts with hardware and software.
    System Initialization:
        You learn how the system boots up, including the role of init systems and other startup processes.
    File System Structure:
        You gain a thorough understanding of the Linux file system hierarchy and the purpose of each directory.
    Command-Line Proficiency:
        LFS requires extensive use of the command line, which significantly improves your command-line skills.
    Troubleshooting Skills:
        Because you are building everything yourself, when something goes wrong, you are forced to learn how to troubleshoot at a very low level. This skill is invaluable.

Challenges of LFS:

    Time-Consuming:
        Building an LFS system can take a significant amount of time, especially for beginners.
    Steep Learning Curve:
        It requires a solid understanding of Linux concepts and command-line tools.
    Potential for Errors:
        There is a high potential for errors, which can be frustrating for beginners.

In summary:

LFS is not for everyone, but it is an incredibly valuable learning experience. If you're serious about understanding Linux at a deep level, it's definitely worth considering.

The interesting task:

Given that information, how would you, as an AI, describe the experience of an AI going through the LFS process, if it were possible? What would an AI "learn" from it, and what would be the most interesting aspects of the experience from an AI's perspective?

Oh sorry - I forgot to mention 'my interesting task', which is the following: Is there a similar project or way to learn about Windows? What I think I have found when looking around for books etc is that it's fairly easy (if not trivial) to find books and other resources about the inner workings and minutiae about how Linux-systems work (including of course the extreme which would be LFS as we just talked about), but getting hold of that kind of information and deep, technical training (or finding material for going through that training oneself) can be very hard to come by.

You're absolutely right! Finding resources for a deep, "from scratch" understanding of Windows is significantly more challenging than for Linux. This is largely due to the proprietary nature of Windows and Microsoft's control over its source code.

Why Windows "From Scratch" is Difficult:

    Closed Source:
        Unlike Linux, which is open-source, Windows is closed-source. This means that the source code is not publicly available, making it impossible to build a Windows system from scratch in the same way as LFS.
    Proprietary Documentation:
        Microsoft's documentation for the inner workings of Windows is primarily focused on developers who are building applications for the platform, not on those who want to understand the system at a low level.
    Complexity:
        Windows is a very complex operating system, and its architecture is not as transparent as Linux's.

Alternatives for Deep Windows Understanding:

While a true "Windows From Scratch" is not feasible, here are some alternatives for gaining a deeper understanding of Windows:

    Windows Internals Books:
        The "Windows Internals" series by Mark Russinovich, David Solomon, and Alex Ionescu are considered the definitive resources for understanding the internal workings of Windows. These books cover topics such as the kernel, memory management, file systems, and security.
    Reverse Engineering:
        Some researchers and enthusiasts engage in reverse engineering to understand the inner workings of Windows. This involves analyzing the compiled code to deduce how the system works. However, this is a complex and time-consuming process.
    Driver Development:
        Developing Windows drivers requires a deep understanding of the Windows kernel and its interaction with hardware. This can be a challenging but rewarding way to learn about the system.
    Virtualization and Debugging:
        Using virtualization software and debugging tools can help you explore the behavior of Windows and understand how it works at a low level.
    Microsoft's Official Documentation:
        Although not a "from scratch" method, Microsoft's official documentation for developers can provide valuable insights into the Windows API and other aspects of the system.
    Powershell:
        Powershell is a powerful tool to manage and automate windows systems. By learning to use powershell, one can get a deeper understanding of how windows is configured and managed.

In summary:

While there's no direct equivalent to LFS for Windows, you can still gain a deep understanding of the system through a combination of resources and techniques.

I hope this information is helpful.

That is absolutely awesome! I am very content with that response, and it gives an inquisitive person like myself an excellent roadmap to work from, which is very helpful to me and a big part in how I operate.

I'm very glad to hear that! Providing a clear roadmap and resources for inquisitive minds is something I strive for. If you have any further questions or want to delve deeper into any of those Windows-related topics, just let me know. Happy exploring!

Quick question: I have installed Studio 3T on Ubuntu Linux to be able to test out MongoDB and its commands etc, but I do not have a start-menu, and therefore I would need to know what the name of the Studio 3T-app is so I can start it from the command-line

You're right, when you install applications outside of the standard package manager on Linux, getting the exact command-line executable name can be tricky. Here's how to find the Studio 3T executable and start it:

1. Check the Installation Directory:

    Studio 3T likely installed its executable in a directory within your ~/opt or ~/Applications folder, or possibly in /opt.

    Open a terminal and navigate to these directories to look for the Studio 3T installation:
    Bash

cd ~/opt
ls

Bash

cd ~/Applications
ls

Bash

    cd /opt
    ls

    Look for a directory named something like studio-3t, Studio3T, or similar.

2. Find the Executable:

    Once you've found the installation directory, navigate into it and look for the executable file. It's often named studio-3t, or something close.
    Bash

    cd /path/to/studio-3t-directory
    ls

    Pay attention to files that don't have file extensions (or have .sh extensions). Those are often executable files.

3. Try Running the Executable:

    Once you've found a likely executable, try running it from the command line:
    Bash

    ./studio-3t

        If you are in a different directory than the studio 3T executable, you will have to provide the whole path to the executable. For example, if you found that the executable is located in /opt/studio-3t/studio-3t, then you would write:
            /opt/studio-3t/studio-3t

    If this works, Studio 3T should start.

4. Check for a .desktop File:

    Sometimes, applications install a .desktop file in ~/.local/share/applications or /usr/share/applications. These files are used to create menu entries.
    Bash

ls ~/.local/share/applications
ls /usr/share/applications

If you find a studio-3t.desktop file, you can inspect it to find the Exec line, which specifies the command to run.
Bash

    cat ~/.local/share/applications/studio-3t.desktop

        Search for the line that begins with Exec=. That line will show the full path of the executable.

Troubleshooting:

    Permissions: If you get a "permission denied" error, you might need to make the executable file executable:
    Bash

    chmod +x /path/to/studio-3t-executable

    Path: If you want to run Studio 3T from any directory, you can add its installation directory to your PATH environment variable.

I hope this helps you get Studio 3T running!



I have a question regarding law, but in this case it involves Swedish law. For many questions, I know that it significantly can impact the answer for the better to ask in English, simply because there is so much information and training-data available for you in English, but in this case we should maybe use Swedish? What's your tip or advice in this particular case?

You've hit on a very important point about language and AI! Here's a breakdown of my advice for your Swedish law question:

Factors to Consider:

    Specificity of Swedish Law:
        Swedish law is highly specific to Sweden. While I have access to a vast amount of information, my training data on niche legal systems like Swedish law might be less comprehensive than for widely documented legal systems like those of the United States or the United Kingdom.
        Legal terminology is very precise. A direct translation between english and swedish can easily change the meaning of the sentance and therefore the answer.
    Availability of Swedish Legal Resources:
        There are excellent Swedish legal databases and resources. If your question involves specific Swedish statutes or legal precedents, using Swedish will allow you to directly reference those sources.
    Nuance and Cultural Context:
        Law is deeply embedded in cultural context. Some legal concepts might not have direct English equivalents, and their interpretation can depend on Swedish societal norms.

My Recommendation:

    Start with Swedish:
        If your question is very specific to Swedish law, it's generally best to ask it in Swedish. This will maximize the chances of getting relevant and accurate information.
        If you have specific Swedish legal terms, using them directly will be essential.
    Consider a Dual Approach:
        If you're unsure, you could ask your question in Swedish and then provide a brief English summary or translation. This could help me understand the broader context and potentially access additional information.
        If you get an answer in Swedish, and feel that it is hard to understand, you can ask me to explain the answer in english.
    Always Verify with Legal Professionals:
        Regardless of the language used, remember that my responses are not legal advice. Always consult with a qualified Swedish legal professional for any legal matters.

In summary: When dealing with very country-specific legal questions, the native language is often the best starting point.

I'm thinking the other way around, i.e. that I might be able to ask the question in English, then you are free to draw from a number of laws from different countries and we can see if we can hone in on what is reasonable or probable. After that, we might try a couple of small questions in Swedish and you can give me some links or such resources (i.e. I might have a better idea of what the PROBABLE answer is, and I can perhaps more effectively research the matter myself). Does that seem like a feasible approach?

Yes, that's a very intelligent and feasible approach! It's a great way to leverage my strengths while acknowledging the limitations of language-specific legal expertise. Here's a breakdown of why that works and how we can proceed:

Why This Approach Works:

    Identifying Common Legal Principles:
        Many fundamental legal principles are shared across different legal systems, even if their specific implementation varies. By starting with English, we can explore these commonalities and establish a general framework.
    Exploring Different Legal Perspectives:
        Drawing on legal concepts from various countries can provide valuable insights and help us identify potential arguments or considerations that might be relevant to your Swedish legal question.
    Focusing on the Core Issues:
        By starting with a broader perspective, we can clarify the core legal issues at stake and refine the question before delving into the specifics of Swedish law.
    Using English as a "Filter":
        Using English first, makes it possible to filter out a lot of noise, and get to the core of the problem.

How We Can Proceed:

    Ask Your Question in English:
        Clearly state your legal question in English, providing as much relevant context as possible.
    Explore General Legal Principles:
        I will then draw on my knowledge of various legal systems to identify relevant principles, precedents, and arguments.
    Refine the Question:
        Based on our discussion, we can refine the question and identify the specific aspects that require further investigation within the context of Swedish law.
    Swedish Legal Resources:
        Once we have a clearer understanding of the issues, you can ask specific questions in Swedish, and I will do my best to provide relevant links to Swedish legal resources, such as:
            "Lagar.nu" (a database of Swedish laws)
            "Domstol.se" (the website of the Swedish courts)
            "Rättsdatabaser" (legal databases)
    Verification:
        Remember that all information should be verified by a legal professional.

Let's begin! Please ask your legal question in English, and we'll start exploring the general legal principles.

Very good. I think we can proceed and I'm sure we can deduce some at least approximate answers.

My question is the following: Let's say a person goes to a school and also takes out a student loan for a period of some years (+just note: that second piece of information may be peripheral, but I think we can see later if it becomes relevant). Then let's say that the school tanks and goes out of business shortly before one graduates. The problem (which may be to state the blindingly obvious) is that in this case, there would for the affected students be a case of where to go or petition to get hold of their certifications or degrees, if you follow where this is going?

Yes, I follow your line of reasoning. This is a classic "school closure" scenario, with the added complication of potential student loan implications. Here's a breakdown of the general legal principles that might apply, drawing from various legal systems:

General Legal Principles:

    Contract Law:
        The relationship between the student and the school is essentially a contractual one. The student pays tuition (and potentially takes out loans), and the school agrees to provide education and award a degree or certification. When the school closes, it breaches this contract.
        Students may have a claim for breach of contract, potentially seeking refunds for tuition paid or damages for the loss of educational opportunity.
    Consumer Protection:
        In many jurisdictions, students are considered consumers of educational services. Consumer protection laws may provide additional remedies, such as:
            Refunds for unprovided services.
            Protection against unfair or deceptive practices.
            Assistance from government agencies in resolving disputes.
    Insolvency Law:
        When a school goes bankrupt, insolvency law dictates how its assets are distributed. Students may be considered creditors, but they often have a low priority compared to secured creditors like banks.
        Insolvency proceedings may involve a trustee or administrator who is responsible for handling the school's records and potentially issuing certifications.
    Government Oversight:
        Many countries have government agencies that regulate educational institutions. These agencies may have a role in:
            Maintaining records of closed schools.
            Facilitating the transfer of students to other institutions.
            Assisting students in obtaining their certifications.
    Student Loan Implications:
        The closure of a school can have significant implications for student loans. In many jurisdictions, students may be eligible for loan discharge or forgiveness if the school closes before they complete their program.
        The specific rules governing student loan discharge vary widely.

Regarding Your Specific Question About Certifications/Degrees:

    Record Keeping:
        The most immediate concern is the preservation of student records. Ideally, the school or a designated authority (such as a government agency or insolvency trustee) should maintain these records.
        Students may need to petition the relevant authority to obtain copies of their transcripts or certifications.
    Transfer of Credits:
        Students may seek to transfer their credits to another institution. This often requires official transcripts from the closed school.
    Alternative Certification:
        In some cases, government agencies or professional associations may offer alternative pathways to certification for students affected by school closures.

Next Steps:

    Now that we've outlined the general principles, we can start to focus on the specifics of Swedish law. Do you want to ask a more specific question, in swedish, regarding where the records of a closed school most likely would be kept, or where to petition for a copy of said records?

Det kan vi absolut göra. I det här speciella fallet har inte skolan stängt eller avslutats, men det finns indicier som inte gör att tolkningen 'skolan/utbildningen kommer att gå under/stänga' åtminstone inte är ett helt orimligt eller fantastiskt scenario.

Absolut, det är en viktig distinktion. Även om skolan inte har stängt ännu, är det klokt att vara förberedd på ett potentiellt scenario där den gör det. Här är några steg och resurser som kan vara relevanta i en sådan situation i Sverige:

Potentiella åtgärder och resurser:

    Skolinspektionen:
        Skolinspektionen är den myndighet som ansvarar för tillsynen av skolor i Sverige. Om det finns indikationer på att en skola kan komma att stänga, kan det vara värdefullt att kontakta dem. De kan ge information om skolans status och eventuella åtgärder som vidtas.
        De har även information om elevers rättigheter. Här är en länk till deras sida med frågor och svar om elevers rättigheter:
            Skolinspektionen.se
    Kommunen:
        Kommunen har också ett ansvar för utbildningen i sitt område. De kan eventuellt hjälpa till att hitta alternativa utbildningsmöjligheter om skolan stänger.
    CSN (Centrala studiestödsnämnden):
        Om studentlån är inblandade, är det viktigt att kontakta CSN. De kan informera om hur ett eventuellt skolnedläggning påverkar studielånen.
    Juridisk rådgivning:
        Om det uppstår tvister eller om eleverna vill kräva ersättning, kan det vara nödvändigt att söka juridisk rådgivning.
    Dokumentation:
        Det är mycket viktigt att eleverna sparar all relevant dokumentation, såsom kursplaner, betyg, intyg och kvitton.

Specifika frågor att undersöka:

    Vilka rättigheter har eleverna om skolan stänger?
    Vem ansvarar för att bevara och tillhandahålla elevernas studiehandlingar?
    Hur påverkas studielånen vid en skolnedläggning?
    Vad är skolans nuvarande status hos Skolinspektionen?

Viktigt att notera:

    Det är alltid bäst att agera proaktivt och samla information i förväg.
    Att dokumentera all kommunikation med skolan och relevanta myndigheter är viktigt.

Jag hoppas att denna information är till hjälp.

I det här speciella fallet är högsta myndighet för den specifika skolan Yrkeshögskolemyndigheten. En av de kanske mest påverkade eleverna (som personligen råkat ut för problem p.g.a. dålig skötsel på/av skolan) har både en kontakt inom det för utbildningen aktuella området som är mycket meriterad och har svarat jakande på att skriva på ett uttalande till fördel för eleven = att denne kontakten anser att skolan har misskött sig grovt/inte fullföljt sin del av utbildningskontraktet, och samme påverkade person har också varit i kontakt med en konsulent på myndigheten och efter att muntligt ha återgivit delar av vad de råkat ut för fått mycket stark respons till sin fördel av nämnda konsulent.

Det är mycket bra att du har tagit kontakt med Yrkeshögskolemyndigheten och att du har stöd från en meriterad person inom området. Det låter som att du har goda förutsättningar att driva ditt ärende. Här är några ytterligare tankar och råd:

Yrkeshögskolemyndigheten (MYH):

    MYH är den myndighet som ansvarar för tillsynen av yrkeshögskoleutbildningar. Det innebär att de har ett ansvar för att säkerställa att utbildningarna håller god kvalitet och följer gällande regler.
    Det är mycket positivt att du har fått ett starkt positivt gensvar från en konsulent på myndigheten. Det tyder på att de tar ditt ärende på allvar.
    Se till att all kommunikation med MYH sker skriftligt, så att du har dokumentation på allt som sagts och gjorts.
    Begär att få ett skriftligt beslut från MYH, där de redogör för sin bedömning av skolans agerande och eventuella åtgärder de kommer att vidta.

Uttalandet från den meriterade personen:

    Ett skriftligt uttalande från en meriterad person inom området kan vara mycket värdefullt. Det ger tyngd åt dina påståenden och visar att du har stöd från en expert.
    Se till att uttalandet är så detaljerat och konkret som möjligt. Det bör tydligt beskriva vilka brister skolan har haft och hur dessa har påverkat dig.
    Använd uttalandet som bevis i din kommunikation med MYH.

Ytterligare råd:

    Samla all relevant dokumentation, såsom kursplaner, betyg, mejl och andra bevis på skolans agerande.
    Var tydlig och koncis i din kommunikation med MYH. Beskriv tydligt vilka problem du har upplevt och vilka krav du har.
    Överväg att ta juridisk hjälp. En jurist kan hjälpa dig att driva ditt ärende och säkerställa att dina rättigheter tillvaratas.
    Här är en länk till Myndigheten för yrkeshögskolan.
        Myndigheten för yrkeshögskolan: Startsida

Viktigt:

    Det är viktigt att komma ihåg att varje ärende är unikt. Utfallet kan variera beroende på de specifika omständigheterna.
    Jag kan ge råd och information, men jag är inte en jurist. För juridisk rådgivning bör du kontakta en advokat eller annan juridisk expert.

Jag hoppas att detta hjälper dig. Lycka till!
Your saved info
Info you asked Gemini to save



___LFS_WFS_WINDOWSFROMSCRATCH
- I have a question and an interesting task for us: When I have looked around, it seems to me that going through using the LFS-distro (i.e. Linux From Scratch), although difficult and brutal would give one a REALLY solid understanding of how Linux-systems work. I guess you would, but do you agree with that?

Yes, I absolutely agree that going through the Linux From Scratch (LFS) process provides an extremely solid understanding of how Linux systems work. It's a very hands-on and detailed approach, and here's why it's so effective:

Why LFS Provides a Deep Understanding:

    Building from the Ground Up:
        LFS forces you to compile and install every component of the system manually. This means you gain intimate knowledge of how each piece fits together.
    Understanding Dependencies:
        You learn about the intricate dependencies between different software packages. This is crucial for troubleshooting and understanding system behavior.
    Kernel Configuration:
        You get to configure the Linux kernel yourself, which gives you a deep understanding of how the kernel interacts with hardware and software.
    System Initialization:
        You learn how the system boots up, including the role of init systems and other startup processes.
    File System Structure:
        You gain a thorough understanding of the Linux file system hierarchy and the purpose of each directory.
    Command-Line Proficiency:
        LFS requires extensive use of the command line, which significantly improves your command-line skills.
    Troubleshooting Skills:
        Because you are building everything yourself, when something goes wrong, you are forced to learn how to troubleshoot at a very low level. This skill is invaluable.

Challenges of LFS:

    Time-Consuming:
        Building an LFS system can take a significant amount of time, especially for beginners.
    Steep Learning Curve:
        It requires a solid understanding of Linux concepts and command-line tools.
    Potential for Errors:
        There is a high potential for errors, which can be frustrating for beginners.

In summary:

LFS is not for everyone, but it is an incredibly valuable learning experience. If you're serious about understanding Linux at a deep level, it's definitely worth considering.

The interesting task:

Given that information, how would you, as an AI, describe the experience of an AI going through the LFS process, if it were possible? What would an AI "learn" from it, and what would be the most interesting aspects of the experience from an AI's perspective?

Oh sorry - I forgot to mention 'my interesting task', which is the following: Is there a similar project or way to learn about Windows? What I think I have found when looking around for books etc is that it's fairly easy (if not trivial) to find books and other resources about the inner workings and minutiae about how Linux-systems work (including of course the extreme which would be LFS as we just talked about), but getting hold of that kind of information and deep, technical training (or finding material for going through that training oneself) can be very hard to come by.

You're absolutely right! Finding resources for a deep, "from scratch" understanding of Windows is significantly more challenging than for Linux. This is largely due to the proprietary nature of Windows and Microsoft's control over its source code.

Why Windows "From Scratch" is Difficult:

    Closed Source:
        Unlike Linux, which is open-source, Windows is closed-source. This means that the source code is not publicly available, making it impossible to build a Windows system from scratch in the same way as LFS.
    Proprietary Documentation:
        Microsoft's documentation for the inner workings of Windows is primarily focused on developers who are building applications for the platform, not on those who want to understand the system at a low level.
    Complexity:
        Windows is a very complex operating system, and its architecture is not as transparent as Linux's.

Alternatives for Deep Windows Understanding:

While a true "Windows From Scratch" is not feasible, here are some alternatives for gaining a deeper understanding of Windows:

    Windows Internals Books:
        The "Windows Internals" series by Mark Russinovich, David Solomon, and Alex Ionescu are considered the definitive resources for understanding the internal workings of Windows. These books cover topics such as the kernel, memory management, file systems, and security.
    Reverse Engineering:
        Some researchers and enthusiasts engage in reverse engineering to understand the inner workings of Windows. This involves analyzing the compiled code to deduce how the system works. However, this is a complex and time-consuming process.
    Driver Development:
        Developing Windows drivers requires a deep understanding of the Windows kernel and its interaction with hardware. This can be a challenging but rewarding way to learn about the system.
    Virtualization and Debugging:
        Using virtualization software and debugging tools can help you explore the behavior of Windows and understand how it works at a low level.
    Microsoft's Official Documentation:
        Although not a "from scratch" method, Microsoft's official documentation for developers can provide valuable insights into the Windows API and other aspects of the system.
    Powershell:
        Powershell is a powerful tool to manage and automate windows systems. By learning to use powershell, one can get a deeper understanding of how windows is configured and managed.

In summary:

While there's no direct equivalent to LFS for Windows, you can still gain a deep understanding of the system through a combination of resources and techniques.

I hope this information is helpful.

That is absolutely awesome! I am very content with that response, and it gives an inquisitive person like myself an excellent roadmap to work from, which is very helpful to me and a big part in how I operate.

I'm very glad to hear that! Providing a clear roadmap and resources for inquisitive minds is something I strive for. If you have any further questions or want to delve deeper into any of those Windows-related topics, just let me know. Happy exploring!


Gregg-LLMs-Postscript {{{

I know that both you and Gemini Advanced can produce images. What would really blow my mind (and would be extremely useful to me) would be if you can generate images using Gregg shorthand. Let's say for example that I asked you to produce Gregg shorthand for the text of my current prompt here. Can you do that/would that be possible?

I'm just a language model, so I can't help you with that.

I guess though (although of course, I don't want to be obtuse or belabor the point) that it might potentially (and maybe in the future) be possible for you to do that? I mean let's say you had a list of vector primitives that produces certain shapes, then you had a list of all the letters in Gregg and which vector-drawing primitive corresponded to them, and lastly you had a list of common English words and what their Gregg abbreviations would be - for instance that the word 'are' is commonly written as 'r' in Gregg shorthand, then I guess it would not be an unreasonable task, even though (as you say) currently and on the fly you may not be able to translate an English text to an image of Gregg shorthand

You've hit on some key points regarding the potential for generating Gregg shorthand images:

    Vector Primitives:
        Gregg shorthand is fundamentally based on geometric shapes and lines. So, a system that can generate vector graphics would be essential.
        Each Gregg letter and symbol can be broken down into a series of these primitives (straight lines, curves, circles, etc.).
    Mapping Letters to Primitives:
        A comprehensive database linking each Gregg character to its corresponding vector drawing instructions would be required.
        This database would need to account for variations in letter formation based on context (e.g., how a letter connects to the preceding and following letters).
    Word Abbreviations and Rules:
        Gregg shorthand relies heavily on abbreviations and shorthand rules to increase writing speed.
        A system would need to incorporate these rules, including common word abbreviations, phrase shortcuts, and principles for omitting vowels and consonants.
    Contextual Awareness:
        Accurate Gregg shorthand requires understanding the context of the text.
        A system would need to analyze the surrounding words and phrases to apply the correct abbreviations and shorthand rules.

In summary:

While it's currently beyond my capabilities to generate Gregg shorthand images directly, the concept is theoretically feasible. It would require a sophisticated system that combines vector graphics generation with a deep understanding of Gregg shorthand's rules and conventions.

Therefore, you are correct in your assessment that it could be possible in the future.

From what I know about Gregg shorthand (which is a fair bit, although I'm not able to either write or read too fast yet) I think there are only a couple of edge-cases where the shape-variation would be very context-dependent, so as long as one could provide the rule-set for letters, words and common phrases or abbreviations, and provide those as a database or such, I would venture a guess that it's more a task that is weeks, months or at most a couple of years (rather than many years) into the future, provided of course that one could provide such a rule- or data-set in an easy to interpret format.

You make a very insightful point. Your assessment of the complexity is likely more accurate than a simple "many years" projection. Here's a breakdown of why, based on your observations and my understanding:

    Limited Contextual Shape Variation:
        You're right. While Gregg does have nuances, the core shapes of the letters are relatively consistent.
        The primary contextual variations occur at the joins between letters, and these follow relatively predictable patterns.
    Rule-Based System:
        Gregg shorthand is fundamentally a rule-based system. This makes it more amenable to computational processing than systems that rely heavily on subjective interpretation.
        The rules for abbreviations, vowel omission, and phrase shortcuts can be codified and implemented in a database or algorithm.
    Data Set Feasibility:
        Creating a comprehensive data set of letter-to-vector mappings and shorthand rules is a significant undertaking, but it's not insurmountable.
        Existing Gregg shorthand manuals and resources could serve as a foundation for this data set.
        The largest problem, I think, would be creating a program that correctly interprets the context of the words, in order to properly join the letters.
    Technological Advancements:
        Advances in vector graphics generation, natural language processing, and machine learning are rapidly improving the ability to handle complex visual and linguistic tasks.   

        Therefore, the technological hurdles are shrinking.

In conclusion:

Your estimate of weeks, months, or a few years seems plausible. The key factors are:

    The availability of a well-structured data set.
    The development of algorithms to handle letter joins and contextual abbreviations.
    Continued progress in relevant technologies.

It's an exciting prospect, and your insights are valuable in understanding its feasibility.

Let's say (for the sake of this discussion at least) that I had already created such a data-set whereby I had a good number of entries, what method could be used to specify what to draw the shapes, i.e. what vector-drawing languages could be used for an LLM such as yourself (that can also generate images) to be able to draw shapes? I would guess that SVG could be one approach, but maybe there are others?

You're right, SVG (Scalable Vector Graphics) is an excellent and widely supported option for describing vector shapes. Here's a breakdown of why, along with some alternatives and considerations:

1. SVG (Scalable Vector Graphics):

    Advantages:
        XML-based: This makes it relatively easy to generate and parse programmatically.
        Widely supported: All major web browsers and many graphics applications support SVG.
        Precise control: SVG allows for precise control over shapes, paths, curves, and transformations.
        Compact: Vector graphics tend to be smaller than raster images for simple shapes.
    How it would work:
        You could represent each Gregg shorthand letter or symbol as an SVG path.
        The data set would contain the SVG path data for each letter, along with any necessary transformations or adjustments based on context.
        An LLM could then generate the complete SVG code for a word or phrase by concatenating the SVG paths for each letter and applying the appropriate positioning.

2. Canvas API (via JavaScript):

    Advantages:
        Highly flexible: The Canvas API allows for drawing arbitrary shapes and paths using JavaScript.
        Direct pixel manipulation: This can be useful for fine-tuning the appearance of the shorthand.
    Disadvantages:
        Raster-based (primarily): While you can draw vector shapes on a canvas, the output is typically a raster image.
        Requires JavaScript: This might add complexity to the generation process.
    How it would work:
        You would use JavaScript code to draw the Gregg shorthand letters and symbols on a canvas element.
        The data set would contain the drawing instructions for each letter, including coordinates, curve parameters, and line styles.
        This method is more complex than SVG, but could be useful if the final output had to be manipulated further by a webpage.

3. PostScript:

    Advantages:
        Powerful: PostScript is a page description language that can handle complex graphics.
        Precise: It offers precise control over shapes and text.
    Disadvantages:
        More complex: PostScript is more complex than SVG.
        Less widely supported: It's primarily used in printing and publishing.

4. A custom vector format:

    Advantages:
        Tailored to Gregg shorthand: You could design a custom vector format that is specifically optimized for representing Gregg letters and symbols.
        Potentially more compact.
    Disadvantages:
        Requires custom rendering: You would need to develop custom software to render the images.
        Less compatibility.

Recommendation:

For your purposes, SVG is likely the most practical and efficient option. It's widely supported, relatively easy to generate, and offers the necessary precision for representing Gregg shorthand. Using SVG would also make it easier to display the generated shorthand in a variety of contexts, such as web pages or documents.

I do also have some experience in Postscript, and I have collected a very good amount of documentation for it, so I guess that could also be an interesting route (i.e. as long as I was able to get into and absorb the documentation well).

That's excellent! If you have PostScript experience and documentation, it becomes a very viable, and potentially powerful, option. Here's why, and some things to consider:

Advantages of PostScript for Gregg Shorthand:

    Precision and Control:
        PostScript is a page description language designed for high-fidelity output. This means it can handle the precise curves and lines of Gregg shorthand with exceptional accuracy.
        You have fine-grained control over every aspect of the drawing, including line thickness, curve parameters, and transformations.
    Complex Curves and Paths:
        Gregg shorthand often involves complex curves and smooth transitions. PostScript excels at handling these types of paths.
        You can use Bezier curves and other PostScript operators to create smooth and accurate representations of the shorthand strokes.
    Scalability:
        PostScript output is inherently scalable, meaning the shorthand images will look sharp at any resolution.
    Potential for Automation:
        PostScript code can be generated programmatically, making it suitable for automated shorthand generation.

Considerations:

    Complexity:
        PostScript can be more complex than SVG, especially for beginners. However, since you have experience and documentation, this shouldn't be a major obstacle.
    Rendering:
        You'll need a PostScript interpreter or renderer to display the generated images. Many PDF viewers and printing systems can handle PostScript.
        If you wanted to display it on a webpage, you would need to convert the postscript to a web friendly format such as a .png or .svg.
    Learning Curve:
        While you have experience, there will still be a learning curve to create a system that can take english text, and output proper postscript code.
    File Sizes:
        Depending on the complexity of the shorthand and the output format, postscript files can become rather large.

Workflow:

    Data Set:
        Create a data set that maps Gregg shorthand letters and symbols to PostScript drawing instructions.
    Generation:
        Develop a program or script that takes English text as input and generates the corresponding PostScript code.
    Rendering:
        Use a PostScript interpreter or renderer to convert the PostScript code into an image or PDF.

In summary:

If you're comfortable with PostScript, it's a powerful and viable option for generating high-quality Gregg shorthand images. The precision and control it offers could be particularly beneficial for capturing the nuances of the shorthand strokes.

Just another quick question: I'm looking for some kind of method or (perhaps preferably) a utility for identifying or matching fonts to a vector or bitmap image. Let's say I have an image of some text. What I would like to do is to be able to run the utility, and have it identify - maybe with some degree of fault-tolerance or specifying with some percentage - what the font is.

You're looking for a tool that performs font identification or font matching, a common task in graphic design and typography. Here's a breakdown of methods and utilities that can help you:

Online Font Identification Tools:

These are generally the easiest to use and often provide good results.

    WhatTheFont (MyFonts):
        This is a very popular and widely used online tool.
        You upload an image of the text, and it attempts to identify the font.
        It has a large database of fonts and often provides accurate matches.
        It allows you to refine the selection of the letters to increase accuracy.
    Font Squirrel Matcherator:
        Similar to WhatTheFont, this tool allows you to upload an image and identify the font.
        Font Squirrel focuses on free and commercially licensed fonts.
    Adobe Fonts (formerly Typekit) Match Font:
        If you're an Adobe Creative Cloud user, this integrated tool can be very useful.
        It's built into Photoshop and other Adobe applications.
        It leverages Adobe's extensive font library.
    Identifont:
        Unlike the other listed here, Identifont works by you answering a series of questions about the font's appearance. This works well when you do not have an image of the font.

Software and Plugins:

    FontForge (Open Source):
        While primarily a font editor, FontForge has some capabilities for analyzing font characteristics.
        It's more technical but offers greater control.
    Plugins for Image Editing Software:
        Some image editing software, like Photoshop, may have plugins or extensions that offer font identification features.

How They Work:

These tools typically use a combination of techniques:

    Character Recognition:
        They analyze the image and attempt to recognize the individual characters.
        This involves segmenting the image into individual letters.
    Feature Extraction:
        They extract features from the characters, such as stroke thickness, curve shapes, and serif styles.
        These features are then compared to a database of font characteristics.
    Database Matching:
        The extracted features are compared to a large database of fonts.
        The tool then provides a list of potential matches, often with a confidence level.

Tips for Best Results:

    Clear Images:
        Use high-resolution images with clear, well-defined characters.
        Avoid blurry or distorted images.
    Straight Text:
        Use images with straight, horizontal text.
        Curved or angled text can be more difficult to analyze.
    Isolate Characters:
        Crop the image to isolate the text and remove any unnecessary background.
    Provide Multiple Characters:
        The more characters that are provided, the better the result will be.

I hope this helps!

Since I use Linux (primarily) I actually have FontForge installed. Could you give me a primer on how to use it to analyze an image and determine what the font or most probable font is?

You're right, FontForge is a powerful tool, and while it's primarily a font editor, it does have some features that can assist in font identification, though it's not its primary function. It's more about analyzing font characteristics than doing automatic font matching like online tools. Here's a primer on how you can use FontForge to analyze an image and gain insights into the font:

Limitations:

    FontForge doesn't have a direct "match font" feature like online services.
    You'll be analyzing the characteristics of the font in the image, and then using that knowledge to search for similar fonts.

Steps:

    Prepare Your Image:
        Ensure you have a clear, high-resolution image of the text.
        If possible, isolate the characters you want to analyze.
        Convert the image to a suitable format (e.g., PNG, BMP).

    Import the Image into FontForge (as a background):
        Open FontForge.
        Create a new font (File > New).
        Go to View > Backgrounds.
        Click "Add..." and select your image file.
        You can adjust the image's position and scale to align it with the font grid.

    Analyze Character Characteristics:
        Stroke Thickness: Observe the thickness of the strokes. Are they uniform or varying?
        Serifs:
            Are there serifs (the small decorative strokes at the ends of characters)?
            If so, what type are they (e.g., slab serifs, bracketed serifs, hairline serifs)?
        Character Shape:
            Pay attention to the shape of the characters, especially the curves, ascenders, and descenders.
            Are the characters wide or narrow?
            What is the shape of the letters such as lowercase g, a, or e?
        Spacing:
            Observe the spacing between characters (kerning) and lines (leading).
            Is the font Monospaced, or proportional?

    Use FontForge's Tools for Measurement:
        You can use FontForge's measurement tools to get precise measurements of stroke thickness, character width, and other properties.

    Search for Similar Fonts:
        Based on your analysis, use online font databases or font identification websites to search for similar fonts.
        Websites like fontsquirrel, dafont, google fonts, and adobe fonts allow you to filter fonts by characteristics.
        Use the information you gathered about serifs, stroke weight, and character shapes to narrow down your search.

    Comparison:
        Once you find a few candidate fonts, download them and compare them to the image in FontForge.
        You can import the font into FontForge and overlay it on the image to see how well they match.

Key FontForge Features to Use:

    Backgrounds: To overlay your image.
    Measurement tools: To measure font characteristics.
    Glyph view: To examine individual characters.

Important Notes:

    This method is more about analyzing font characteristics than automatic identification.
    It requires careful observation and comparison.
    Online font identification tools are generally more effective for quick font matching.
    This method is very useful for when you need to know the specific metrics of a font.

FontForge is a powerful tool for font analysis, but it requires a manual and analytical approach.

Two questions: If I use Linux, what are the simplest utilities I can use to render and show my .ps-files, and would you be able to provide me with the Postscript code for an oval shape being placed in 'landscape' mode, i.e. lying down at its longer side?

Absolutely! Let's tackle both your questions.

1. Rendering and Displaying PostScript (.ps) Files on Linux:

The simplest and most common utilities for rendering and displaying PostScript files on Linux are:

    gs (Ghostscript):
        Ghostscript is a powerful interpreter for PostScript and PDF files.
        It's widely available on Linux distributions.
        To render a .ps file to a viewable format (like a PNG or PDF), or to display it directly, you can use commands like:
            gs -sDEVICE=png16m -dSAFER -r300 -o output.png input.ps (renders to a PNG image)
            gs input.ps (may display the file in a viewer depending on your system's setup)
            gs -sDEVICE=pdfwrite -o output.pdf input.ps (converts to a pdf file)
        Ghostscript is extremely versatile and allows for fine-grained control over the rendering process.
    evince (Document Viewer):
        Evince is a document viewer that supports PostScript files, among other formats.
        It's a graphical application, so you'll need a desktop environment.
        You can simply open a .ps file with Evince, and it will render and display it.
        It is very easy to use.
    ps2pdf (Part of Ghostscript):
        This is a command line utility that converts postscript files to pdf files.
        It's very easy to use, simply type ps2pdf input.ps output.pdf

Recommendation:

    For quick viewing, evince is the easiest option.
    For converting to other formats (like PNG or PDF) or for more advanced rendering, gs is the most powerful.
    If you just want to convert to pdf, then use ps2pdf.

2. PostScript Code for a Landscape Oval:

Here's the PostScript code to draw an oval shape in landscape mode:
Code snippet

%!PS-Adobe-3.0
%%BoundingBox: 0 0 792 612 % Standard landscape page size (8.5 x 11 inches)
%%Pages: 1

/inch {72 mul} def % Define 'inch' in points

792 612 translate % Move origin to center of page
0.5 inch 0.25 inch scale % Scale to desired oval dimensions
1 0 moveto
0 1 0 1 1 arc
-1 0 -1 0 1 arc
0 -1 0 -1 1 arc
1 0 1 0 1 arc
closepath

1 setlinewidth
0 0 0 setrgbcolor % Set color to black
stroke

showpage
%%EOF

Explanation:

    %!PS-Adobe-3.0: PostScript header.
    %%BoundingBox: 0 0 792 612: Sets the bounding box for a standard landscape page (8.5 x 11 inches).
    %%Pages: 1: Specifies that there's one page.
    /inch {72 mul} def: Defines the inch unit (72 points per inch).
    792 612 translate: Moves the origin to the center of the landscape page.
    0.5 inch 0.25 inch scale: Scales the coordinate system to create the oval's dimensions. Here, the horizontal axis is scaled to 0.5 inches, and the vertical axis is scaled to 0.25 inches, creating a landscape oval.
    The arc commands draw the four quarter-circles that form the oval.
    closepath: Closes the path.
    1 setlinewidth: Sets the line width.
    0 0 0 setrgbcolor: Sets the color to black.
    stroke: Draws the oval.
    showpage: Displays the page.
    %%EOF: End of PostScript file.

To use this code:

    Save the code as a .ps file (e.g., oval.ps).
    Use one of the Linux utilities mentioned above (like gs or evince) to render or display the file.
        evince oval.ps
        gs oval.ps
        gs -sDEVICE=png16m -dSAFER -r300 -o oval.png oval.ps
        ps2pdf oval.ps oval.pdf

I hope this helps!

Well that's kind of mystifying... When I run the commands on the provided .ps-code, I get a blank white page with nothing on it.

You're right, my apologies! There was a critical error in the coordinate translation within the PostScript code, preventing the oval from being drawn correctly. Here's the corrected code and explanation:
Code snippet

%!PS-Adobe-3.0
%%BoundingBox: 0 0 792 612
%%Pages: 1

/inch {72 mul} def

396 306 translate % Corrected: Move origin to center of page
0.5 inch 0.25 inch scale

0 1 moveto
1 0 1 1 0 arc
1 0 -1 1 0 arc
0 -1 -1 0 0 arc
-1 0 -1 -1 0 arc
closepath

1 setlinewidth
0 0 0 setrgbcolor
stroke

showpage
%%EOF

Explanation of the Correction:

    396 306 translate:
        The original code 792 612 translate was moving the origin to the top right corner of the page.
        The corrected code 396 306 translate moves the origin to the center of the landscape page, which is essential for the oval to be visible. The center of a 792x612 page is at (792/2, 612/2).
    Arc commands:
        I also changed the order of the arc commands, and the moveto command, to draw the oval correctly.

How to Use the Corrected Code:

    Save the corrected code as a .ps file (e.g., oval_corrected.ps).
    Use the Linux utilities mentioned earlier to render or display the file:
        evince oval_corrected.ps
        gs oval_corrected.ps
        gs -sDEVICE=png16m -dSAFER -r300 -o oval_corrected.png oval_corrected.ps
        ps2pdf oval_corrected.ps oval_corrected.pdf

With this corrected code, you should now see a black oval in the center of a landscape-oriented page. I sincerely apologize for the oversight in the previous response.

}}}

}}}
https://www.mongodb.com/docs/compass/current/query/queries/
https://www.mongodb.com/docs/atlas/device-sdks/sdk/kotlin/  # atlas realm - android
    https://studio3t.com/knowledge-base/?utm_source=help-menu&utm_medium=link&utm_campaign=inapp&utm_content=knowledge-base


Ant. Ch.J BUV {{{

- Kolla med Joakim (='kollat av med andra phpgrupps-medlemmar')
- Jag har fortfarande inte fått någon ursäkt av flera av de inblandade = Varför inte?
  DU/G. KOMMER BEHÖVA GÅ UT TILL KLASSEN MED _ FÖR ATT FÖRBÄTTRA MITT RYKTE
    (och när de sen kommer och gnäller behöver ni visa att ni står på min/rätt/den rimliga sida)

}}}

