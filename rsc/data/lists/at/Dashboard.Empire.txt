vim:fdm=marker:
set fdm=marker syn= guifont=* | colors ron

../todo/MasterlistDownload-onedeepmans-online.txt
c:/Users/SEDAALB2/Desktop/Scratch.txt
../weblinks.txt
    Queen  [Y√ÑTT VA Z√ÖATN OEN XYVCC (B YHFGVTN VAY√ÑTT)]
    'F√∂r att b√§ttre f√∂rst√• om vad som influerat flera klassiska komposit√∂rer'
    You Win Again, Self-Control, Voyage Voyage, Wildhearts, 
.'MIN TAGGIGA STOL' {{{
  Vad som h√§nt √§r att jag har blivit - misshandlad, r√•nad, utnyttjad och f√∂rnedrad (av - skolan, klassen, utb.f√∂retaget)  (+Varf√∂r h√•ller du p√• och √§ltar det d√§r? Bara sl√§pp det.)
}}}
        N-teatern/Nationals√•nger 2  YOUTUBE
TODO ADD 1 = STARTUPS 1 {{{

Vanki LearnQna ----
  ../learnqna/vanki/TCCoreUdater-DotNetCore_notes.txt

~/Desktop/Scratch.txt

^[^:]\+:


multimedia:
    gvim -p ../ref/graf/pr/MultiMedia.txt ../ref/comp/mu/MuRec.txt

file/media:
    gvim -p ../ref/comp/sysadm/browse/file.txt ../ref/comp/hardw/hardw-devices.txt ../ref/comp/sysadm/browse/media.txt ../ref/comp/sysadm/browse/web.txt ../ref/comp/sysadm/browse/mail.txt ../ref/comp/sysadm/browse/remote.txt
sysadm:  TODO: ADD WIN-TERMINAL
    gvim -p ../ref/comp/cb/bcb.index.txt ../ref/comp/sysadm/cmdl-fu.shell.txt ../ref/comp/cb/RegexCb.txt ../ref/comp/cb/regex-vim.txt ../ref/comp/cb/pshell.txt
markdown etc:
    gvim -p ../ref/comp/cb/moffice.txt ../ref/comp/cb/loffice.txt ../ref/comp/cb/latexcb.txt
[git, test/deploy]:
    gvim -p ../ref/comp/cb/git.txt ../ref/comp/cb/compile-build.txt ../ref/comp/cb/Testing.txt ../ref/comp/cb/deploy-devops.txt ../ref/comp/cb/math-progr.txt ../ref/comp/cb/algos.txt ../ref/comp/cb/probltask-leetrosetta.txt ../ref/comp/cb/disassembly.txt

System (incl. C#):
    gvim -p ../ref/comp/cb/asm.txt ../ref/comp/cb/cppcb.txt ../ref/comp/cb/dlangcb.txt ../ref/comp/cb/rustcb.txt ../ref/comp/cb/jcb.txt ../ref/comp/cb/cscb.txt ../ref/comp/cb/go-v.txt

LANG1-REFS 1: (+maybe LangDb1)
  gvim -p ../ref/lang/Langs1Refs.txt ../ref/lang/sv.thes.svsyn.txt ../ref/lang/cmp.en.dict.en2sv-prsm.txt ../ref/lang/Quotes.txt

LANG-DB 1
  gvim -p ../../db/langdb.legacy.list/langdb.txt ../../db/langdb.legacy.list/langdb.txt
}}}
Scratch-Area {{{
  Could you help me generate XML-comment documentation for this interface?
  Could you help me generate XML-comment documentation for the piece of code I have highlighted?

to weblinks {{{

    https://tmhe.omniacloud.net/_/tmhms/sv-se/news/att-bemastra-konsten-att-skapa-ai-promptar-fem-viktiga-tips-for-framgang

Att bem√§stra konsten att skapa AI-promptar: Fem viktiga tips f√∂r att lyckas
√Ñven om TMHE √§nnu inte anv√§nder Microsoft 365 Copilot i alla Microsoft Office-appar, utnyttjar vi Microsoft Copilot Chat i Edge (webbl√§sare) till fullo.
Detta tillv√§gag√•ngss√§tt g√∂r att vi kan tr√§na v√•r TMHE AI s√§kert med f√∂retagsinformation. √Ñven om resultaten m√•ste kopieras och klistras in manuellt fr√•n d√§r du arbetar, s√§kerst√§ller detta att v√•ra interaktioner f√∂rblir s√§kra. Genom att fokusera p√• robusta s√§kerhets√•tg√§rder l√§gger vi grunden f√∂r en framtida utrullning av Microsoft 365 Copilot. 

Att l√•sa upp AI:s fulla potential b√∂rjar med att bem√§stra konsten att skapa promptar. Oavsett om du √§r ny p√• AI eller vill finslipa dina f√§rdigheter, kommer tipsen nedan att guida dig i att skapa promptar som √§r specifika, har kontext och √§r √∂ppna, vilket leder till mer meningsfulla interaktioner. Utforska och uppt√§ck hur du kan iterera, finslipa och h√•lla dina promptar koncisa f√∂r b√§sta resultat.

Var specifik: Definiera tydligt vad du fr√•gar efter. Ju mer detaljerad din prompt √§r, desto b√§ttre blir svaret. 
Anv√§nd kontext: Ge bakgrundsinformation f√∂r att hj√§lpa till att styra svaret. 
St√§ll √∂ppna fr√•gor: Uppmuntra detaljerade svar genom att formulera dina promptar som √∂ppna fr√•gor.
Iterera och finslipa: Experimentera med olika formuleringar och justera baserat p√• den feedback du f√•r. 
H√•ll det kortfattat: H√•ll dina promptar fokuserade och till punkt f√∂r att undvika f√∂rvirring.
H√§r √§r n√•gra exempel som f√∂ljer tipsen ovan:

Enkel prompt: ‚ÄúBer√§tta om truckar.‚Äù

L√§gg till specificitet: "F√∂rklara f√∂rdelarna med att anv√§nda gaffeltruckar i tillverkning."  
Ge kontext: ‚ÄúF√∂rklara f√∂rdelarna med att anv√§nda truckar i tillverkning och deras p√•verkan p√• effektivitet.
St√§ll √∂ppna fr√•gor: ‚ÄúKan du beskriva f√∂rdelarna med att anv√§nda truckar i tillverkning, deras p√•verkan p√• effektivitet och hur de bidrar till h√•llbarhet?‚Äù 
Iterera och finslipa: ‚ÄúKan du beskriva f√∂rdelarna med att anv√§nda truckar i tillverkning, deras p√•verkan p√• effektivitet, hur de bidrar till h√•llbarhet och f√∂resl√• s√§tt att f√∂rb√§ttra gaffeltruckstekniken?‚Äù
H√•ll det kortfattat: ‚ÄúBeskriv f√∂rdelarna med truckar i tillverkning, deras p√•verkan p√• effektivitet och h√•llbarhet, och m√∂jliga f√∂rb√§ttringar.‚Äù
H√•ll utkik efter v√•r serie om hur du f√•r ut det mesta av Microsoft 365!
}}}

}}}



Forums Stora
  ../ref/allm-a/forumsstoraprakthandb.txt

at.Ref.Cbs ----
  ../ref/ref.cb-prl.txt
.vids Lia2 {{{

put several files in playlist + start off (at specific time) in video no 'n':
    mpv 1.mp4 --start=00:10:30 2.mp4 3.mp4 --playlist-start=2

mpv --start=00:13:00 --speed=1.65 ~/Video/Peter-L-20250227_102445.mp4 ~/Video/Peter-L-20250227_111046.mp4 ~/Video/Peter-L-20250227_132732.mp4 &

}}}

Keyboard Shortcuts.Db1(...) ----
    .
PROGR ----
  PROGR.cm.txt
Clangs (C, Cpp, CSharp, Dlang) ----
  TODO: INCLUDE INTO BLUELEGEND76
Web/Mobile/Cloud ----
  TODO --"--

    'ful som stryk'
Langs1 Ref-lists ----  __
  gvim -p ../ref/lang/Langs1Refs.txt ../ref/lang/sv.thes.svsyn.txt ../ref/lang/cmp.en.dict.en2sv-prsm.txt ../ref/lang/Quotes.txt
  // maybe add 'fr√§mord' etc
  --
  ~/gdrive/rsc/media/pic-graphics/shorth/
LangsDb.legacy ----
  ../../db/langdb.legacy.list/langdb.txt  # or LangDb1.list.txt
  [+charAlfa]
  . {{{
    mada, wareware (no), sore de
  }}}

~/gdrive/rsc/data/lists/mu/dft-thedoc_playlists-index.txt

## 'Trinity-proj.'
    . {{{
##   (belief and morality; models and theory; knowledge, action, and 'does it work' (soundness))
        They don't say they know; They say they believe(=gotcha)

Om jag ska peka p√• en enda sak, s√• skulle jag s√§ga att det st√∂rsta enskilda misstaget andliga/new age-iga personer g√∂r, √§r att f√∂rv√§xla 'Detta k√§nns bra'(=subjektivt f√∂r mig just/h√§r och nu) med 'Detta √§r bra'(=f√∂r mig och andra i l√§ngden/=bortom just (h√§r och) nu)

    som pratar s√• mycket om v√§rme, k√§rlek och mjukhet/mjuka v√§rden, som √§r s√• arga, och passiv-agressiva
    }}}



    ---- 'MINIS|DAILIES' ---- ___index=0 {{{
    LEETCODE ETC(+SCRIPT-FU) CODE-PROBLEMS __ ****
            KAPA FILER/MAPPAR I LEGACY (=5 per dag) !!(! *****)
    Saol 1/Bevingat/Ordspr. =Clean  @ +Idioms/Litt  arlang 1  +LangDb Prios 1-100(!) ‚Üí
        Bevingat (Quotes, etc)
    . {{{
      - vta-apps Docs: Dualist
    }}}
    - Gregg Snippets [=10 per day]   [+images to refssection]
    - dan-words;  kanji-2000  -de | fr | spa | ru  +jp,  @ ita (!)  (incl. set jp-dicts.ref(!!))   - lat [ 2-4 words etc (??)]
        - Some Sv-En words|phrases (+one quote|joke(quip)) + Write w. Shorth(!!) {{{
            ( =sjukv|samhinfo|facket mm(!) 2-4  Rel.Ond: 5 meningar
                - Doyle FSpeech (=gregg++):  Plocka 10-20(-50) mest grundl. eng-ord(!!)
            . {{{
                https://www.youtube.com/watch?v=j6IufYLMrqM&t=300s
                        wokebusters (w. j.linds. and wokal)
            }}}
        }}}
    - fun jokes stories (+quotes)  @  =DO+SET CATEGORIES [!![!!]]  [+Welsh etc(!)]

    UNIVERSITY VIDEOS: STANFORD[!!]
      + QUINCY LARSON-LINKS [!!!!]  @@!(!)
    C (modern + hardw.)  +Sys.Archit.
    Htdp (+refact, beaut, legacy)  (+Lfe Sicp(+Sicp Clojure)?)  py-sicp  @
    JsCb-Notes 1 + jscb 2(!!), +PyCb, ClojCb  KotlFunct [**]  @@
      Dlang[!! Ali, Mike P, Cookbook  etc]
    Org, Vimscript f√∂rsta koden (+‚Üì‚Üì), Elisp Startw.[!!]
    - vimscrhardw (first cmds custom!!), - lpy(x2)-ref, bash 1cmd   (+vimcasts etc)
    - FREEC-WEB (3-5 st!  +ExamProjects)  @@   - vlang

        --  @@@@@@@  ---VV  @
    - Fstyle: 'Doc is here' + Dft-Prios(!!)(**** =incl. Blues-Improv. acoustic) {{{
dft curr 2023 {{{

  Bohemian rhapsody {{{
    ~/Dropbox/rsc/media/scores/i.guitar/ac/dftproj/BohemianRhapsody/bohemian_rhapsody.dft.tg  #Set final fingerings
    ~/Dropbox/rsc/media/scores/i.guitar/ac/dftproj/BohemianRhapsody/bohemian_rhapsodyRAW.drsfingerstyle.pdf
    et1(+solo1): 74  @
    et2("I see"): 144
    et3: 138(ca)  @
    et4(outro): 72
  }}}
  Catch me if I fall {{{
  ~/Dropbox/rsc/media/scores/i.guitar/ac/dftproj/Own/TheDoctorIsHere/02_catchmeifyoufall.pdf
    _st:
    _et: 66
  }}}
  Pluck me sideways {{{
  ~/Dropbox/rsc/media/scores/i.guitar/ac/dftproj/Own/TheDoctorIsHere/05_yourekiddingmrholmes.pdf  #Pluck me sideways
    _st:
    _et: 118(ev. lite l√§gre)
  }}}
  Birdman {{{
  }}}
--
  live and let die {{{
  ~/Dropbox/rsc/media/scores/i.guitar/ac/dftproj/.blue/live_and_let_die.pdf
  }}}

}}}
            : - sweet dreams  - mrs robinson  - browneyed g.
              - sweet child of. mine  - nytt arr: holy diver
                - kashmir
        +KOLLA CHECKLIST DFT-VIDPRES. 1--REMAKE(=2020-2021(!!)) (****(!!!!)) @@
        +Recreate 'Juha+Yerba'++ 2014**** (=Satellit, Under Pressure, etc(!!))
            [[ = in at.muTeach.bash ]]
        }}}
    - drs 'Hall√• D√§r!' + karaoke-pres(=videos)
    - listen|document: Genres, 2 songs + its lyrics(!)      pre: 'Lathund'(!|??)
      - dfs s√•ng√∂vn.programmet =in office + 'mobile'(!!)

    'piecemeal':
       - bash (blue, unpow, orange, bcb, TLCL, [2xclassic],  ABSG, Rute, debbib1,  yellow-vids, lsag) {{{
         + 2x_script-bible, linCb, hacks, sam24, sob, wicked
       }}}
    - svganimDrasn
       - pshell (forsysadms, )
       - LinInterface + LinProgr Advanced
       - c hardw. + c modern
    - calc(etc)
    - ffmpeg [tasks  + Mans]
    }}}

-- OFFICE.PROJS ___index=2  #'odin-tree' [+lists on gkeep(?)] {{{
\v\@([^ ]?)+

V I M  +  E M A C S

    Gremlin + Neptune
        'MuL√§roplans-Tr√§den' **(!!)
        ----
        netrw (**)
        JavaScript Functional
        Elixir, Ocaml, F# DomainModeling
    Abe Kotlin
Py/F# Sysadm. + Devops[!!]
      [Dlang-proj + PhobosNext|Per Nordl.]
        vlang, Go, Ring
        Cloj. + Java
  datastructures PROGR-List + Db(SqLite) + PROGR-Langs-list[!]
              (+graphdb, SPARQL/CYPHER/GREMLIN, sqlite,   redis,  mongo)
    ----
LINSYS:  debbib
Blue + Scoll.  +Analog Synth.
        lynx  pyweb,  @Greasmonk
    Nsplitdiff (+Soc.Framg)
Nushell
        Git, Github Projects  @GithubDocs @GitActions
Datasci@ + MLEARN[!!!!] @Webscrape / @GoogleHacks
    Xml (+xaml, faml, etc)
  'Coding with Music'  MidiCpp-Guy[!!]  h5g**  Listking   jQuery(Cb), FREEC Compl,
  refact, legacycode, TDD(etc) @  +C-CppFunct
  @c#funct, C# Docs Avanc. C# Des.patts, C# 50-70 Tips
            flux, xmonad, openb, ice, awes
        sed (+py/dlang etc)
    --
    Aws(+dynamo), Docker, Kubernetes  CyberSec  @
  b√∂rja kolla quincy l-l√§nkar @  +Stanford etc
React (FreeCodeCamp)
        Pluralsight, w3school, w3resources
        kotlin/jetpack progr-videos(!!)
        (gimp etc) Py (!!)
@xsane, font(forge)/Scribus
    HTML, HTTP/TCPIP + 'The Web'
    Mojo
    Devops, CI @
            PHP + funct.
algos
        Scribus
    CSS + Compass
        pyfunct(!) 1+2
        Bash + Termux (+vim-bash) (etc)
Linux (Android etc) + Sys-Structure, Sysprogr
    Cypher,
SparQL
    Pshell + Choco
Inkscape (+Rita och skriva f√∂r Online-Undervisning  @@
- websearch (duckduck, Google, etc)  [+Webscraping] +lynx(etc)  @@
        Audacity
@AnlSynthesis + Midi@ + Keyb.Synths
            [+Nyq (etc)]
    Pyramid
Csound(Qt + Blue), Scollider

='Topics/Areas'   ~/Dropbox/rsc/aubooks/data.WISHLIST
    Bcb Etc (+Find/Xargs, etc), UNIX POW-TOOLS  @
PyAut3** +PyFunct, Gimp Python, +  @
      webscrape, cv/mmedia, au-transcribe,
    5 w3resources C# datetime-√∂vningar
    Datasci, text-natlang  #to at.Python.bash
    WebSearch/GoogleTricks  #+grease/violent/tamper-monkey  @
    . {{{
      ~/Empire/Doks/Comp/gui-wtoolkits/hack.greasemonk.txt
        ~/Empire/Doks/Comp/gui-wtoolkits/greasemonkey.txt  #kin
      ~/Empire/Doks/Comp/lang/webdev/js/ffox/ffox-hacking.txt
      ~/Empire/Doks/Comp/lang/webdev/js/ffox/programming_firefox.pdf
    }}}
Samsung Notes [!(!)]
    Hardw: Phone + Tablet
    ~/Empire/Doks/Comp/lang/webdev/Aux/youtube/
    --- Kotlin: Test Projects 1 (***!!)  @

    - MOODLE  @@ (=Indexes[?|!])   | Wordpress |
- ORG (=emacs) ** @   ___minis_dailies
    --
        ~/Dropbox/rsc/data/lists/learnqna/vanki/lynx.txt
  HCJP-5e  
  C (modern, hardway, etc) + Lin(etc) sysArchit. **  @@
    Dlang [Ali, +Learning, Cb]
    Flutter+Dart    @
    Elixir(**!)     @
    C# + 'ciss' (etc)     F#(??)
    WEBDEV:  Freec'Restart'  (+Js Multimedia, 'drasnanim', ???)
  wappdev.js eloquent.js
  +h5g / three.js (w.gamedev)
    Clj  @ + 'javamethods'  #'cheats' + jDir14/PhrasebJava
    Nyq, Csound, Scoll  muHask*(*), Midi  @  Chuck
    SICP (etc, ...)   @
  JFx(!) + Clj   @
    --

    --
    mc
    'Debian.Cb 1'
    --
                vlang

    ----
                - Dft: bohemian rhaps. etc
                - Freec. Webdev (+svganim, wappdev1, h5g  ,JS-Cbs+h5c3-1)  typescript  = Done by 4 may  (+ap-a/ap-i)
                . {{{
                - Dlang Restart (+doks x3,5 +vibe-new)  #+clean up all vankis 1(!!) {{{
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/dlang/dcookb.txt
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/dlang/dlearn.tagged.txt
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/dlang/dwebdev.txt
                }}}
                ar, dan-dict, +fr/de, spa, ry
                kanjilist 2000: ~/processdir/kanjilist2000/
                @ MuTe-list (!!)
                Android Java-Dev 1(!)
                - Mail till Mikael Frendberg {{{
                Hej Mikael.

                det var sagt/satt att
                Andreas N skulle h√∂ra av sig 
                att h√∂ra av sig till mig om en anst√§llning med tidsm√•tt
                efter en anmodan fr√•n Transport i slutet av 2021
                men trots att jag s√∂kt honom (ibland flera g√•nger i veckan) sedan √•rsskiftet 2022, har han inte √•terkommit till  mig
                med tid f√∂r m√∂te med ett erbjudande.
                .
                Jag ber dig d√§rf√∂r h√∂ra av dig till mig snarast m√∂jligt
                senast n√•gon g√•ng under kommande veckan
                s√• vi kan ordna detta  skyndsamt
                V√§nliga h√§lsningar D. Albertsson
                i annat fall m√•ste jag vid det h√§r laget
                g√• vidare
                till HR centralt p√• Securitas
                }}}
                St√§d(!)
                        [Andreina (et al)(**!)]
                tommy skaresund (m.fl. =spelutveckl.)
                @ - Bluesbooks, Improv, arr + harm
                - B√∂rja Klippa: hall√• d√§r, Speln.videos, doctor is here(!)
                - Minilist Inl√§rn. 1  = till Alex + Freddan (+ Vim Abe)
                - brev till jakob fransson {{{
                Hej Jakob.
                P.g.a. av en miss har jag f√•tt boka om unders√∂kningstiden f√∂r lungr√∂ntgen (jag har varit i kontakt med enheten p√• Ua sjukhus)
                Det funkar som sagt n√•got b√§ttre med sm√§rtjusteringen via Duloxetinet (PS Finns det n√•got man d√§rigenom kan s√§ga ang√•ende vad orsaken till sm√§rtorna skulle kunna vara? (=att just den medicinen har hj√§lpt, √•tminstone n√•got))
                D√§remot f√•r jag oftast 1-3 (el. likn) g√•nger per dag eftermiddagar
                sv√•ra hugg av sm√§rta  som g√∂r att jag f√•r pausa arbete och uppgifter och vila mig,
                har sv√•rt att b√∂ja mig f√∂r att ta p√• byxor, knyta ett par skor
                har sv√•rt att vrida mig mm
                50 % eller mer(!) av dagarna √§r jag ocks√• s√• tr√∂tt och susig, att jag oftast inte kommer ig√•ng med n√•got f√∂rr√§n n√•gra f√• timmar fram√•t sen eftermiddag/kv√§ll, och m√•nga dagar f√∂rsover jag mig med 1-6 timmar, trots att jag s√§tter larm.
                Jag tar ocks√• n√§stan varje kv√§ll en oxynorm, och en eller tv√• alvedon, f√∂r att kunna sova (=p.g.a. sm√§rtan); Vid n√•gra tillf√§llen har jag ocks√• f√•tt dubbel d.v.s maxdos (=2 oxynorm och 2-4 alvedon). Vid n√•gra enstaka tillf√§llen (t.ex. ti 12/14) f√•r jag ocks√• upprepa oxynorm+alvedon mitt p√• dagen.
                .
                Jag har nu f√•tt en tid f√∂r m√∂te
                om utv√§rdering/utredning
                med F-kassan och AF ang√•ende min arbetsf√∂rm√•ga
                och hur vi kan hitta ett arbete
                som passar mina kompetenser  och min sj-problematik.
                M√∂testiden f√∂r en f√∂rsta utredningskontakt √§r satt till
                4 maj.
                Utredaren gjorde mig ocks√• uppm√§rksam p√•
                att min sjukskrivning gick ut den 4 april.
                .
                Jag ringde d√§rf√∂r f√∂r att boka en telefontid med dig
                s√• vi kan l√∂sa √§rendet s√• sjukskrivningen inte l√∂pt ut (=d√• kan 
                Jag fick prata med Susanne (som du ju vet att jag framf√∂rt kritik mot).
                Hon var dock trevlig, och framf√∂rde att n√•gon skulle ringa upp mig dagen efter samtalet.
                Denna person h√∂rde dock inte av sig under tisdagen, eller onsdagen.
                }}}
                - sed + Deb
                }}}
                scheme + Ly-Snippets (+Lilypond @)
                - rsteno: hall√• d√§r (+facket + breven som skickas)
                BlendPy
                inks + webgrafik(!)  +Tuts(!)
            MAPPING, GEO-MAPPING, Gis(*(*)): ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/openlayers3-start_plusgis-geoinfo.txt
                --
                Philto/Verktl. + Gilje|Univ.(!!):
              2022-04-19 ti - 20.15: Vaccin-dos 2 (!!)
                Bollen + Sty.tr√§n.
                Samsung Notes(!(!))
                NextCloud(!! Puh)   (Obsidian??)
                PROGRAMMING 'Concepts of Prl' + Algos + HTDP/SICP + Softw.Design + 'Beaut./Pragm/Clean-x3' + 'Mozart'-book
                GameDev(*) (=agk++ (**)) (Unity, React 4, agk(), Godot, ..)
                - PyAux (=PyProgr + Lib  +  blendpy, stats, datasci, (etc etc))  @@
                Stat/'Data Science'
                - Allm.A-doks [Forums stora, Bildoks(x3)]  #+ocr hemohyra|hyresg.f√∂ren.
                - vidauprocess + grafik 4, Ffmpeg(!), Heros(!)
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/Manuals/GoPro_Hero-Texgear4kaction.txt
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/graf/g/digbildbeh_4.orig.txt
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/graf/g/digbildbeh_4.txt
                - v3+1 {{{
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/_v3_plus-ssh/ssh-defguide.txt
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/_v3_plus-ssh/vbox_uman.txt
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/_v3_plus-ssh/veracrypt-userguide.txt
                ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/_v3_plus-ssh/vnc-uguide.txt
                }}}
                ----
                - Vim: Uman, RefMan, vimlang  @@
                - Evil, EmacsQ 1 (+refc. long--index), Org(*), im-dired|pdf-tools(*)        -->  (Elisp)
                Scribus(!): ~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/graf/scribusmandef.txt
                YouTube(?? +)  =Learn
                fontforge {{{
                https://fontforge.org/en-US/documentation/
                --
                https://archive.flossmanuals.net/_booki/fontforge/fontforge.pdf
                http://designwithfontforge.com/ebook/design-with-fontforge_en-US.pdf
                http://designwithfontforge.com/en-US/index.html
                https://englishonline.info/fontforge-manual-17/
                --
                https://fontforge.org/docs/scripting/python.html
                https://fontforge.org/docs/scripting/scripting.html
                }}}
                --
                Litt (+biografier)
                Anki (=relearn 2022+(!!))
                . diff+patch, dolphin,  ed, id3||Easytag,  Audacity(!) {{{
                - Install LightTable + Clojure (**)
                ----
                - thunar, dolphin, audacious, mutt, markdown
                - diff + patch,  ed   Vim,  vbox,  Easytag++,  id3
                . {{{
                search: bash diff and patch examples
                https://www.man7.org/linux/man-pages/man1/diff.1.html
                https://linux.die.net/man/1/patch
                ----
                https://acloudguru.com/blog/engineering/introduction-using-diff-and-patch
                https://www.pair.com/support/kb/paircloud-diff-and-patch/
                https://www.thegeekstuff.com/2014/12/patch-command-examples/
                https://www.systutorials.com/diff-and-patch-generating-and-applying-patches/
                }}}
                --
                - fontforge + Scribus
                - Festival,  Ub.Studio-Man
                --
                - Audacity(!!)
                - LPY 3(++ !!)
                }}}
                http://potrace.sourceforge.net/  http://potrace.sourceforge.net/faq.html
            Audacity   @@@@
                Blender X  @
                - Keyb.s, "Csounds", an.ljudyntes (**(!)) {{{
                - Keyboard Magazine 1, Korg Dw-6000 man,  casio-privia-piano-man
                - yourock-guitar(**)
                - An.Ljudsyntes(**):  - SynthCookbook(**(*)), - Log.Effects
                - NordKeyboards(??)
                - Csound, SuperCollider etc
                - Analyze|Visualize w. SuperCollider (**!)
                - Clam Framework + clam chordata (**)
                - 
                ----
                - Blue Improv. (jazz-rock)
                - Coker(!!)
                - 
                - Jazz-Improv (brown+blackwhite) **
                ----
                - GuitarEffects  (+as Pedals / Software)
                - Gitarr =Lagning + Underh√•ll (!!!!(**))
                }}}
                - (Mu: ARRAN, HARM,      ) {{{
                - Ingelf (x2)
                - rock-arr
                -  tradi-arr
                -
                ----
                - Directing-books
                - Arr w Midi-Book(****)
                - ARRBOOKS: COMPOSING + FULL ORCH. SCORES (Wagner, Williams etc etc) (*******(!!!!))
                }}}
                ----
                - SVG  @@
                - erlang   Elixir
                - C# ('ciss.txt')
                - BASH (orange[de], blue(**), purple('Bcb')) {{{
                (Rute=7, lcert-orange=1, yell-vids=8, Blue-Bash=2, BashCb=4, PTools(x2)=3, lsag, DebCb, DEBBIB(x2)=6,  LCmds.org=5, CLine-Fu"Db"(!!(**)), BigGreyList,  Elbot-Lin)
                }}}
                PostScript()
                - PShell 5         ar(!), it(!), Fra, (Stranna Dushy(++)), 
                rlang  julia
                netrw
                - anim-foto-video-graf(**)  {{{
                - fstd, digbildbeh. 4, 'Rip-Books', 
                - 'Anim-Books', 12 Principles of Animation, filmbooks + 'Filma med Foto-kamera'
                - DRAWING/RITA(**), CARTOON-DRAWING   # + Olle Johansson(+inspir-grafik)
                - 'tidnings-design, undervisn.grafik'
                - 'Typografi', Fonts(!!)
                - "Imag" (**)
                - Graf.Kokb.(*)
                }}}
                . AuVid-compression
                . . SvSynDb, svskrivregl, Eng-WORDS (etc) {{{
                Zen of Filesystems
                Idioms (eng|sv)
                Beving | CITAT  #+Citat-tags/kateg.(*!)
                SvSynDb(!!!!(!!))
                Sv.Skrivregl.(x2), Eng-WORDS(*), Eng-App_Words 1, Eng Learned Words (memrize 2),
                (instant-intellectual), 
                Hist-Speeches
                .
                Hist
                JUR
                PR, Markn.F
                Ekon (etc) (**!)
                Proj.Manag
                taskjuggler(!)
                Allm.B[Encycl.s(**), TP:s(*!)] + Sci(eg. Fogtdals, WIK(!)) / McGraw(**!)
                }}}
                - MAPPING
                ----
                readline =emacs|vim
                ed, mc, etc etc(=Bash(!))   ~/Dropbox/rsc/aubooks/data/bash/ {{{
                +Grey Commands-List as Ref|Master-list (**)
                bind_macros.txt
                dirs.txt
                ed.txt
                mc.txt
                readline.txt
                history-fc.txt
                find-xargs.txt
                grep-ag.txt
                grub.txt
                man-info.txt
                less.txt
                printf.txt
                test.txt
                Sed-Awk.txt
                TODO
                extras/Apt-Aptitude.txt
                extras/ps-top.txt
                extras/wakeonlan.txt
                extras/cron-anacron.txt
                }}}
                - GIT
                .   XCode {{{
                search: install mac and xcode in ubuntu vm
                https://izziswift.com/can-i-install-xcode-in-ubuntu/
                https://hkdb.medium.com/running-macos-in-virtualbox-with-ubuntu-31ec745f21ae
                https://www.raywenderlich.com/8325890-a-complete-guide-to-swift-development-on-linux
                }}}
                . . . Fluxbox, Vivaldi, Logic, Hydrog/Roseg  markdown(+rtf, wiki etc) {{{
                Fluxbox, Openbox, IceWm, Awesome, Xmonad
                blendpy(-*)
                .
                scheme-guile, gambit, racket, minischeme(?)
                .
                impress.js
                Thunar {{{
                https://askubuntu.com/questions/446458/thunar-command-line-options
                http://freesoftwaremagazine.com/articles/tips_tricks_and_scripts_thunar_file_browser/
                }}}
                .   audacious {{{
                https://pkgs.org/download/audacious-skins
                https://www.gnome-look.org/browse/cat/129/order/latest
                https://store.kde.org/browse/cat/129/order/latest
                http://www.xmms.org/
                --
                https://help.ubuntu.com/community/Audacious
                https://wiki.archlinux.org/title/Audacious
                https://audacious-media-player.org/
                }}}
                Vivaldi
                mutt
                gentoo (fman)
                vim-bash | em.bash

                Burge.txt
                Logic X + Eff.
                zoom ps-04 ministudio(!)
                UbuntuStudio-Man(**(!))
                Ardour(*)
                Hydrogen, Rosegarden*
                MIDI
                --
                MacX + safari + ForDummies(*!)
                Win 10 + MS Keyb.Creator  #+seccopy mskb files 1(!)

                markdown
                wiki + wiki-like {{{
                mediawiki syntax
                https://www.mediawiki.org/wiki/Help:Formatting
                wiki markup syntax
                https://en.wikipedia.org/wiki/Help:Wikitext

                wiki-like desktop software
                https://en.wikipedia.org/wiki/Comparison_of_wiki_software
                https://en.wikipedia.org/wiki/List_of_wiki_software
                https://en.wikipedia.org/wiki/Personal_wiki
                https://vimwiki.github.io/
                }}}


                Elixir | Erlang (*)
                lua (*)
                Haskell (-lys, -Music(**))
                qpython()

                Java Fx
                Jdir14(+swing)
                Android-Tut
                JVE-langs
                Groovy
                Clojure + clojurescript
                lighttable
                jakarta ee

                Okular
                Eclipse
                Netbeans
                VS Code (*)
                lynx
                yourock
                mplayer
                vbox
                vnc* | wakeonlan | anacron
                vera
                tor / openvpn(!)
                }}}
                data.WISHLIST (Samsung Notes, julia, Dired, ffmpeg, Synfig, Imag, Chocolatey {{{
                Samsung Notes *(*)      ___dataWISHL
                em:image-viewer
                iimage
                em:pdf-tools
                em:dired
                emms
                Amarok  #+more KDE docs
                em:w3m
                gentoo filebrowser
                kdenlive, openshot
                mt(??) video framework  #python etc
                pitivi
                ffmpeg
                (Imag)
                Vala
                Festival (festvox*)
                Julia **(!)
                Glade
                Krita
                praat
                Clam++, clam chordata
                Synfig, anigen
                vivaldi: quick-commands
                Fluxbox, icewm, openbox,  awesome, xmonad
                solaris
                readline emacs/vi *
                Nix/NixOS
                apt, debian-alternatives
                chocolatey
                markdown, ubuntu forum/github markdown
                SnapCraft
                search: Lin. Package-Managers (flatpak, snaps, appimage, packages)
                eric, PyCharm
                google/duckduckgo search tips/tricks
                EasyTag, id3tags
                cinepaint, rawtherapee, lightzone, fspot
                ((shortcutfu))
                FS-H  #un, win, andr (etc)
                azure
                puppy linux
                }}}
                (Pandoc etc--listblock(!!))
                - FS-Hier. + lsag {{{
                - Lin
                - bsd(/solaris)
                - MacOsX
                - Win 10
                - ios
                - Andr
                }}}
                Writer/Calc + Starb.       #Excel, gnum.
                ----
                (.more)  Nix/NixOS|GUIX, LFS,  gentoo, sabayon ... {{{
                snap(craft)
                nix + nixos *
                lfs / dsl / pocket lin
                gentoo lin.
                portable linux distros(slax etc)
                .
                wxwidgets
                }}}
                ====
                C# (**)
                F#
                Stat.
                Welding
                Electronics (*)  #+soldering
                Julia
                . . {{{
                SocFramg√•ng (**(!!))
                NevSplit
                Sec/V√§kt ((****(!!)))  #+Sec./Bya Online Learning-Platforms(!!)
                STRAT/Vjud (etc)
                Python Bioinformatics
                'Engineering'
                Passage/Security-Systems
                Lock-Picking(*)
                }}}
                . . . . . . .
                |evince|
                ||shotwell||
}}}

---- Win-Overview =x3 ----
Office.Rush [1]  # rush through + take review/notes {{{

@ = Clean/Focus On
# = Suited for Ontheroad

            Pegged, Tsv-Utils, Perlstyle-Regex
    ANDROID SCRIPTING/PROGRAMMING  [+Flutter, KIVY]
TC CORE READTHROUGH + THE WIKI[!!]  __
  CLEAN UP NEW DOTNETCORE-DOKS  __
----
Maui / AVALONIA  __
C# DotNet Core MVC __  + Blazor  Cs Funct 3
    Puppet Lang + Patterns(etc)
    FuncPy  [_Renskriv_]  __  Py/F# SysAdmin
    Nushell, Xonsh  _
    Choco (+Puppet) + PowerShell (+AutoHotKeys)
            Mpv-Docs
'linuxcommands core' [=Gemini-Q]
MLEARN: FIRST DOKS  + formulas w. Obsidian Md/Latex[!!]  _
    JuPyter/Polyglot(?) Notebooks (etc)  __
F# - TOCs + Concepts,  Fabulous (Fable, Suave)  _
Bash/Dash-Mans
XUnit Patts  __
Roslyn + Analysis/CodeGen  __
SSH (Veracrypt)  + Puppet  __
    Nix Master
Devops + Python (+iPy/Xonsh) ; F# Devops  _
  Vim PyPlugins  __ | VIMSCRIPT (x4)  _
Reason + PureScript  ___onroad=maybye
 LEARN REACT  [__]  [+=OldNotes 1]    Sass

Bcb, Bluebash + PShell,  ASM 1 (+binalys)
Docker + Kubernetes + Azure Devops + GithubActions  __
    Gremlin (+Neptune)  _
  ----  Anki Redone
    Arch Linux

Music With JavaScript *  __
Buckey's Godot
        ~/Empire/Doks/learn/speedread.txt
}}}
office.Overview [2]  # write summary|overview {{{
Reveal.js|Impress.js  __
Spectre Console  __
  iPython(*)
  Xonsh
  CsRx 3, Rx.Net;  Csharp Tips (etc)
Android-Scripting + Termux  __
F# [Overview and Concepts]  +Cloj.
  FuncPy **
  Anki
  ----
    Py Webscraping
  Avalonia  __
    [CsFunct 3]

}}}
    -- office.Slog ___index=3 [3] {{{
____ __
.     . {{{
Reduce down rectangular file-block to gvim one-liner
  @r: 
}-$F/c,}-$F.i}
-V{
:s/\.txt
{
A{VipJgv:s/[^ ],b ,e[^ ]//g
}}}
    ~/Dropbox/rsc/data/lists/todo/MasterlistDownload-onedeepmans-online.txt
    ../todo/MasterlistDownload-onedeepmans-online.txt  # Win
RUSH/OVERVIEW DOKS-LIST[!!] {{{
  ...tagged... {{{

## ~/gdrive/rsc/Doks/scratch/pshell/Win10keysdef.tags.txt
~/gdrive/gambitscm-smallefficientnativeapps.tags1.txt

~/Dropbox/rsc/aubooks/comp/shotwell-man.tags.txt
~/Dropbox/rsc/aubooks/comp/thunar-man.tags.txt
~/Dropbox/rsc/aubooks/comp/id3_easytag-vim-id3t-eyeD3.txt
~/Dropbox/rsc/aubooks/comp/id3_easytag-vim-id3t-eyeD3.tags.txt
~/Dropbox/rsc/aubooks/comp/dolphin-man.tags.txt
~/Dropbox/rsc/Doks/PRIO/graphdbs.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/scm/lydoc03-extend.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/py/py3aut.Tags2.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/py/py3aut.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/py/py3aut.Tags1 (Case Conflict).txt
~/Dropbox/rsc/Doks/phone/Comp/lang/py/Python3Aut.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/py/sedawk-shscript-withPython.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/xml/xmlhacks100_2010.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/xml/xml-w3schools.ToClean.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/elx-erl/ElixirSchool.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/svg/svganimdrasn.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/dlang/dlearn.tagged.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/cscb_2022.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/functional-cs.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/fs/fsharp-wikibooks.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/csfunct.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/designpatts.cs.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/db/graphdbs.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/h5wappdevex.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/funct/jsfunctmaster.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/funct/functjs-begin.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/FsharpWikibooks.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/java/cloj/clojcb_2014.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/loffice/starbasic/calc2011.fmt35.tags2.txt
~/Dropbox/rsc/Doks/phone/Comp/loffice/starbasic/calc2011.fmt35.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/datasci/ai-mlearn/py/mlearnapps-ideatoprod_2020.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/bluebash.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/1_unpowtools-3ed2002.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/mutt-man.tagged1.txt
~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/lincmdorg.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/1_unpowtools-3ed2002_1.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/helix.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/neovimLua.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/lvimscrhard.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/evilman1.tags.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/emacsmanual1.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/emacs/OrgmodeMan.tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/mu/ly/lydoc03-extend.Tags1.txt
~/Dropbox/rsc/Doks/phone/Comp/mu/au/scoll/scoll-mapvisu.tagged.txt
~/Dropbox/rsc/Doks/phone/clean/ipydocs-tut.tags1.txt
~/Dropbox/rsc/Doks/phone/clean/nix-master_2024.tags1.txt
~/Dropbox/rsc/Doks/phone/clean/guile-against-r.tags1.txt
~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/dlang/dlearn.tagged.txt
~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/mutt-man.tagged1.txt
~/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/scoll-mapvisu.tagged.txt
~/Dropbox/rsc/Doks/Comp/lang/java/jdir14.tagged.txt
~/Dropbox/rsc/Doks/Comp/vimdoc8/rman.files/tagsrch.txt
~/Dropbox/rsc/data/lists/ref/lang/shorthrskrift-FackV√•rdS√∂karen.tagged.txt
~/Dropbox/rsc/data/lists/keys.shortc/mscore3.shortckeys.tagged.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/pick.legacy/em-mastext1.tagged.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/idiom-eng_list1.Tags.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/MacXkeys.tags.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/decks/comp/lang/cpp/komvux2023-Cpp1.Tags2.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/decks/comp/lang/webdev/freec01_h5c3.tags.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/Win10keysdef.tags.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/tagged/dlang-ali1.tagged.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/tagged/lpy01.tags.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/tagged/Win10keysdef.tags.txt
~/Dropbox/scratch/Math1_Komvux-mars2023.Tags1.txt
~/Dropbox/scratch/Math2_Komvux-mars2023-v2.Tags1.txt
~/Dropbox/scratch/Math2_Komvux-mars2023-v1.Tags.txt
~/Dropbox/scratch/Math1_Komvux-mars2023.Tags2.txt
~/Dropbox/scratch/Math2_Komvux-mars2023-v3.Tags1.txt
~/Dropbox/bin/scripts/va/doc/svsyndb-tagging.txt
}}}

  winterminal
  . {{{
    ~/gdrive/rsc/Doks/taskuj/winterminal-tipstricksprodhacks_2021.Tags1.txt
  }}}
  ----
    Reveal, Impress  __
    . {{{
      ~/gdrive/rsc/Doks/taskuj/mmedia/present/revealjs.Tags1.txt
            ~/Dropbox/rsc/Doks/phone/graf/revealjs.Tags1.txt

      ~/Dropbox/rsc/data/lists/ref/graf/pr/impressjs.txt
      --
      ~/Empire/graf/imprjs.txt
      ~/Empire/graf/pr/imprjs.txt
            ~/Empire/Comp/lang/webdev/imprjs_aux.txt
            ~/Empire/Comp/lang/webdev/js/present/imprjs.txt
    }}}
  Spectre Console
  . {{{
    ~/gdrive/SpectreConsole.tags1.txt
  }}}
  android scripting
  . {{{
    ~/gdrive/rsc/Doks/taskuj/AndroidProgr/android-scriptautomation.Tags1.txt
  }}}
  ASP.NET CORE MVC __ (++Web APIs)
  . {{{
    gvim ~/gdrive/rsc/Doks/taskuj/LIA2/DotNetCore/{AspDotnetCore-InAct-3e_2023,AspDotnetCore7-Pro-10e_2023,AspDotnetCore-WebAPI_2023,manning-morebooks/0_manning-extratitles_including-free,manning-morebooks/api-designpatts_BUY,manning-morebooks/apidelivery-automate,manning-morebooks/dotnetcore-inact-2e_mauiavalonia,manning-morebooks/webapi-test,manning-morebooks/webapis-design-2e}.txt

    gvim ~/gdrive/rsc/Doks/taskuj/LIA2/DotNetCore/AspDotnetCore{-InAct-3e_2023,7-Pro-10e_2023,-WebAPI_2023}.txt
        rsc/Doks/taskuj/LIA2/DotNetCore/AspDotnetCore-InAct-3e_2023.txt
        rsc/Doks/taskuj/LIA2/DotNetCore/AspDotnetCore7-Pro-10e_2023.txt
        rsc/Doks/taskuj/LIA2/DotNetCore/AspDotnetCore-WebAPI_2023.txt
  }}}
  FuncPy
  . {{{
    ~/gdrive/FuncPy.binder.Tags1.txt
  }}}
  py/f# sysadm  #
  . {{{
      PyProgr
    ~/Empire/Doks/Comp/lang/py/sysadm/py-unlin-sysadm.txt
      ~/Empire/Doks/Comp/lang/py/sysadm/propysysadmin.txt
  }}}
  JupNotebooks, polyglot notebooks, Pandas(etc)
  . {{{
      ~/gdrive/JupNoteb.binder.Tags1.txt

        https://learn.microsoft.com/en-us/training/modules/polyglot-notebooks/
        https://code.visualstudio.com/docs/languages/polyglot
  }}}
    datawrangl {{{
        ~/gdrive/rsc/Doks/taskuj/Misc/datasci/pydatawrangl-clean_2022.txt

        ~/gdrive/rsc/Doks/phone/Comp/datasci/py/pydatawrangl-clean_2022.txt
    }}}
  Obsidian __ @  MLEARN**(+)
  . {{{
    gvim -c 'colors molokai_dark' ~/Empire/Doks/Comp/lang/py/mlearn/{mlearnapps-ideatoprod_2020.tags1,mlearn-mobprojs_2018,mlearn-scikitkerastflow-2e_2019,py-aiproj-uprunning_2018}.txt

    ~/Dropbox/rsc/Doks/phone/Comp/pr/Obsidian.txt
    ~/Empire/lang/markup/MD/md-obsidian.txt
  }}}
    vim pyplugins  _
    . {{{
      [Video-transcription + Taylor's Wiki]
    }}}
  Xonshell  __
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/XonShell.Tags1.txt
  }}}
  Termux  __  @@
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/sysadm/Termux.Tags1.txt
  }}}
  Mpv-Docs
  . {{{
    ~/gdrive/rsc/Doks/taskuj/mmedia/Mpv-Docs.txt
  }}}
  AVALONIA
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/Avalonia.txt

    ~/gdrive/rsc/Doks/taskuj/LIA2/manning-morebooks/dotnetcore-inact-2e_mauiavalonia.txt
    ~/Empire/Doks/Comp/lang/clangs/csharp/gui/xaml-avalonia/Avalonia.txt
  }}}
  NuShell  _
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/nushell_docs-book.txt
    ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/nushell_cb-oneline.txt

    ~/Empire/Doks/Comp/lang/webdev/db/relational/mysql-maria/mysql-nushell_2009.txt
  }}}
  Wsl
  . {{{
    ~/gdrive/rsc/Doks/taskuj/WSL/*.txt

    gvim ~/Empire/Doks/Comp/sysadm/lin/wsl/*.txt
  }}}
      Graph, MSAL
  ----
  GraphQL(!)  #
    sqlitebrowser
    . {{{
      ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/db/sqlitebrowser-docs.txt
    }}}
    MongoDB Compass  @@
    . {{{
    }}}
  Rx.Net
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/rx/RxDotnet-2e_2024.txt
  }}}
  REACT (+Mongo)  ##  _Clean_
  . {{{
    gvim ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/freec-0{3_frontendlibs,5_nodemong-apimicros}.txt
    [+Material UI]
  }}}
    Bash|Dash-Mans
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/sh-Bash.txt
    ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/sh-dash.txt
  }}}
  Puppet
  Mojo  TODO:OCR
  Devops
  . {{{
    ~/Empire/Doks/Comp/PROGR/devops/PyDevops-ansibdockeraws_2019.txt
    ~/Empire/Doks/Comp/PROGR/devops/py-fordevops_2020.txt
  }}}
  F#[!!!!] + Webframeworks (Fabulous, Fable, Suave)
  . {{{
    gvim ~/gdrive/rsc/Doks/taskuj/Cs/Fs/{Fable/Fable-framew,Fabulous/Fabulous-framew}.txt
      https://suave.io/

    gvim ~/Empire/Doks/Comp/lang/clangs/csharp/fsharp/{fsdeepdives_2015,fs-domainmodel_2018,fs-ess_2023,FsharpRealworld,fsharp-survguide,fswebmob-netmvtazurewbebsock_2013,functprogr-realworld_2010}.txt

    gvim ~/Empire/Doks/Comp/lang/clangs/csharp/fsharp/{fs-domainmodel_2018,fs-datastructsalgos_2015,FsharpDocs_2022plus,FsharpRealworld,fsharp-survguide,FsGetprogr_2018}.txt
  }}}
  Roslyn (+Analysis|CodeGen)
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/codegen/cs-roslyncb_2017.txt
    ~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/codegen/roslyn-codegen_2017.txt
  }}}
  Reason + PureScript
  . {{{
    ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/compilesto/reasonml-qsguide_2019.txt
    ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/compilesto/reasonml2.txt
    ~/Empire/Doks/Comp/lang/webdev/js/compilesto/reasonml/ReasonRescriptBuckle-Docs.txt
    ~/Empire/Doks/Comp/lang/webdev/js/compilesto/reasonml/bucklescript-cb.txt
    ~/Empire/Doks/Comp/lang/webdev/js/compilesto/reasonml/reasonml-qsguide_2019.txt
    ~/Empire/Doks/Comp/lang/webdev/js/compilesto/reasonml/reasonml2.txt

    ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/pscript/purescript-functweb_2017.txt
    ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/js/pscript/purescript-lenses_2018.txt
    ~/Empire/Doks/Comp/lang/webdev/js/pure/purescript-functweb_2017.txt
    ~/Empire/Doks/Comp/lang/webdev/js/pure/purescript-getstarted.txt
    ~/Empire/Doks/Comp/lang/webdev/js/pure/purescript-lenses_2018.txt
  }}}
  AzDevops
  . {{{
    ~/Empire/Doks/Comp/PROGR/projman/azdevops/azuredevops-agileprojman_2019.txt
    ~/Empire/Doks/Comp/PROGR/projman/azdevops/azuredevops-solutimplem_2020.txt

    ~/Empire/Doks/Comp/PROGR/projman/azdevops/azuredev-guide_2019.txt
    ~/Empire/Doks/Comp/PROGR/projman/azdevops/azuredevops-begguide.mini.txt
    ~/Empire/Doks/Comp/PROGR/projman/azdevops/azure-prodaccel.txt
  }}}
  Java|Cloj Semantic-Web
  . {{{
    ~/Empire/Doks/Comp/lang/webdev/db/semweb/semanticweb-clojjava_2010.txt
  }}}

  ~/Dropbox/rsc/Doks/phone/Comp/sysadm/win/PshellforSysadms_2020.txt
}}}

cd ~/gdrive
----

  # GitExtensions:  https://git-extensions-documentation.readthedocs.io/en/release-5.1/

gvim `find ~/gdrive/rsc/Doks/taskuj/ -type f -name '*.txt' 2>/dev/null`

~/Empire/Doks/Comp/lang/webdev/js/jsjsoncb_2015.txt
gvim ~/Empire/Doks/Comp/mu/au/csound/{CsoundBook,csoundqt,csound-virtualsoundprocess_2000}.txt
+Blue
Set up def. .vimrc Linux (+test _vimrc for Win)
  ----
gvim ~/Empire/Doks/Comp/lang/clangs/csharp/codegen/{cs-roslyncb_2017,roslyn-codegen_2017}.txt


  MSAL / Microsoft Identity
      gvim ~/Empire/Doks/Comp/lang/clangs/csharp/webmob/maui/{NET_MAUI_in_Action_2023,maui-enterprisepatts_2022}.txt
  Graph API
      ~/Empire/Doks/Comp/lang/webdev/js/jsjsoncb_2015.txt
      ~/Empire/Doks/Downl/exjobb-exempel/msoft-graph/MsoftDocs-GraphAPI.txt
      ~/Empire/Doks/Downl/exjobb-exempel/_newtonsoft-json/jsjsoncb_2015.txt
      ~/Empire/Doks/Downl/exjobb-exempel/sharepoint/Msoft365-Progr_2016.txt
      ~/Empire/Doks/Downl/exjobb-exempel/sharepoint/MsoftDocs-Sharepoint.txt
      ~/Empire/Doks/Downl/exjobb-exempel/sharepoint/sharepoint-tut.txt
      ~/Empire/Doks/Downl/exjobb-exempel/swagger-api/swagger.pres.txt
      ~/Empire/Doks/Downl/exjobb-exempel/msal-msidentity/MsDocs-MsalMSIdentity.txt
  Win 10 Remote Desktop
  ANDROID PROGRAMMING




Bash-Man / YT-DL Cleaning
  Ocaml Master

  Restart THE DOC(+DrStr√§ng)-Publishing(!!)
    Prompt Engineering
    CSound, SuperCollider (etc +Recording)
    Dlang + Vlang
      REF.CB-LISTS[!!]
  Emacs-Install + Setup (Per N++)
    --
  TODO - UPDATE LIST: ____ REFACT[!!], DEBUG  = TODO {{{
    gvim ~/Empire/Doks/Comp/PROGR/refact/{refact-2e_2019,efflegcode,refct,legacycode-beyond_2016,refact-divein_2019,refact-designsmells_2015,refact-despatts_2012,refact-topatts_2005,db-refact_2006}.txt
    + LLDB
    gvim ~/Empire/Doks/Comp/debug/{debugeff-66_2017,Cgdb_2022,debugart-gdbddd_2008,debugit_2009,debug-optim-legacycode_2003,gdb-debuggingwith_2022}.txt
    gvim ~/Empire/Doks/Comp/PROGR/revengineer/{AsmUnderstand-revengin_2019,datamine-revengin_1997,x86disassembly_2013,ghidra-revengineer_2020,revengineer-forbeg_2014}.txt
  }}}
          ~/Empire/Doks/Comp/PROGR/refact/db-refact_2006.txt
      ~/Empire/Doks/Comp/wman/fluxbox/fluxbox-book_2016.txt

gvim ~/Empire/Doks/Comp/mu/au/{midi/modernmidi-sequencing_2020,auprogr-book_2011}.txt

  gvim ~/Empire/Doks/Mu/arr/{MidOrch,ProOrch1.shared,arrpoprock,MuComp,OrchInstr,tradarrroine}.txt
    SCOLL, CSOUND, (ETC) {{{
      gvim ~/Empire/Doks/Comp/mu/au/{csound/csound-virtualsoundprocess_2000,scoll/scoll-book,scoll/ScollLogicpro,scoll/ScollBook,scoll/overtone/overtone-uguide,csound/man-tut/csound-flossman_2011,csound/man-tut/tutorial_5.07,csound/man-tut/1_masteringcsound,csound/man-tut/csound_editingbasics,csound/man-tut/super_mikelson_csound_primer,csound/man-tut/vercoe_a_beginner_tutorial,csound/man-tut/singer_an_introduction_to_csound,csound/man-tut/steven_yi_scanned_tutorial,csound/midi/2_real-time_synthesis_in_csound_with_midi_control,csound/midi/3_midi_instrument_designs_for_real-time_performance}.txt
    }}}

  ~/Empire/Doks/Comp/lang/webdev/db/nosql/graphdb/gremlin/GraphData.txt

  ???????

     ~/Empire/Doks/Comp/sysadm/lin/fhs/fhsstandard_2004.txt
     ~/Empire/Doks/Comp/sysadm/lin/fhs/lsag_2005.txt
     ~/Empire/Doks/Comp/sysadm/lin/fhs/UnixFhs_2003.txt
  ~/Empire/Doks/Comp/sysadm/lin/101linhacks-3e.txt
  ~/Empire/Doks/Comp/sysadm/lin/101bashhacks.txt
  ~/Dropbox/rsc/Doks/Comp/debbib.txt
  ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/sh-Bash.txt
  ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/XonShell.Tags1.txt
  ~/Dropbox/rsc/Doks/phone/Comp/sysadm/lin/1_unpowtools-3ed2002.Tags1.txt
    /home/bluelegend/Empire/Doks/Comp/sysadm/lin/unixworkbench_2017.txt
    [Unix PowerTools]

    gvim ~/Empire/Doks/Comp/{lang/webdev/js/ffox/ffox-hacking_2005,lang/webdev/js/ffox/ffox-progr_2007,gui-wtoolkits/jsmonkey/hack.greasemonk_2006,gui-wtoolkits/jsmonkey/greasemonkey_2005}.txt

    gvim ~/Empire/Doks/Comp/lang/webdev/c3/sass/sass*.txt

    ~/Empire/Doks/Comp/lang/webdev/db/relational/sqlite/sqlite-mobdev_2015.txt
    ~/Empire/Doks/Comp/lang/webdev/db/nosql/mongo/

    gvim ~/Empire/Doks/Comp/lang/java/build/gradle/{gradle-androidrecip_2016,gradle-buildautomhandb_2016,gradle-buildtest_2011,gradle-effimplem_2012,gradle-succinctly_2017,gradle-uguide2,gradle-uman56_2018}.txt

Hask {{{
    gvim -c 'colors molokai_dark' ~/Empire/Doks/Comp/lang/haskell/{haskpract-2_2019,algebradriven-design_2020,datanalys/hask-datanalys_2015,datanalys/haskell-dataanalysiscb_2014,webdev/hask-practwebdev_2018,webdev/hask-yesodwebapps-2e_2015}.txt
}}}
    gvim ~/Empire/Doks/Comp/lang/haskell/datanalys/{hask-datanalys_2015,haskell-dataanalysiscb_2014}.txt

    ~/Empire/Doks/Downl/  = CLEAN UP DOKS ____
        /home/bluelegend/Empire/Doks/Comp/mu/au/midi/modernmidi-sequencing_2020.txt
        /home/bluelegend/Empire/Doks/Comp/mu/au/auprogr-book_2011.txt

    .   Fs / F# {{{
        gvim ~/Empire/Doks/Comp/lang/clangs/csharp/fsharp/{fsdeepdives_2015,fs-domainmodel_2018,fs-ess_2023,FsharpRealworld,fsharp-survguide,fswebmob-netmvtazurewbebsock_2013,functprogr-realworld_2010}.txt

    gvim ~/Empire/Doks/Comp/lang/clangs/csharp/fsharp/{fs-domainmodel_2018,fs-datastructsalgos_2015,FsharpDocs_2022plus,FsharpRealworld,fsharp-survguide,FsGetprogr_2018}.txt
    }}}
    Flutter {{{
        gvim ~/Empire/Doks/Comp/lang/dart-flutter/flutter/{flutter-apprentice_2021,flutterapprentice_2020,flutter-beg_2019,flutter-gamedev,flutter-layouts,fluttermob-qsguide_2019,flutterpragm_2022,flutter-progr_2020,flutterprojs_2020,flutter-recip_2019,flutter-uis_2022}.txt
    }}}
    ~/Empire/Doks/Comp/lang/dart-flutter/dartlearn_2013.txt  ___Functional
      [+New Functional]

        :args `cat files.txt`
        gvim -c "args `cat ~/RiderProjects/Acme/files.txt`"
MLEARNAPPS-INTRO ** {{{
    gvim -c 'colors molokai_dark' ~/Empire/Doks/Comp/lang/py/mlearn/{mlearnapps-ideatoprod_2020.tags1,mlearn-mobprojs_2018,mlearn-scikitkerastflow-2e_2019,py-aiproj-uprunning_2018}.txt
}}}

Elix** {{{
  Phoenix LiveProgramming

  gvim ~/Empire/Doks/Comp/lang/erlang-elix/{web/phoenix-inact,web/phoenix-realtime-channels,elix-concurrdataprocess_2021,elix-action_2019,elix-adopt_2018,elixmast_2018,elixgraphqlapis-absinthe_2018,ElixGenetic,functwebdev_2018,elixotp-systdesign_2019,elixfunct-newworldfounds_2018,domaindrivendesign_2006,elixir-succinctly_2019,ElixCb_2015,elix-ectodatabaseapps_2019,elix-functprogr_2018}.txt

  ~/Empire/Doks/Comp/lang/erlang-elix/elix-introd_2e_2017.txt
  ~/Empire/Doks/Comp/lang/erlang-elix/elixir-language_2017.txt
  ~/Empire/Doks/Comp/lang/erlang-elix/ElixirSchool.txt
  ~/Empire/Doks/Comp/lang/erlang-elix/elix-learnfunctprogr_2018.txt
  ~/Empire/Doks/Comp/lang/erlang-elix/elixprogr-16_2018.txt
  ~/Empire/Doks/Comp/lang/erlang-elix/elx-littleotp_2017.txt
}}}
Xml W3Shools {{{
    ~/Empire/Doks/Comp/lang/xml/xml-w3schools.ToClean.tags1.txt
}}}
XunitPatts ** {{{
    gvim ~/Empire/Doks/Comp/PROGR/test/framew/{xunit/XunitPatts,selenium/selen-datadriventest_2018,selenium/selen-tipstrickspract_2021,selenium/selen-webdriver3-practguide_2018}.txt
}}}
DotNet Core (+EF Core) {{{
    gvim ~/Empire/Doks/Comp/lang/clangs/csharp/webmob/dotnet-core/{aspdotnetcore5_2020,cs7-dotnetcore2-crossplatfdev_2017,cs7-dotnetcore-cb_2017,dotnetcore2-byex_2018,dotnetcore-inact_2018}.txt
}}}
____ Cs DesignPatterns {{{
    gvim -c 'colors molokai_dark' ~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/cs/{cs-despatts_2018,designpatts.cs.Tags1,effective-cs-with-scottm_2017,cscb_2022.Tags1,cs-codeconventions,csharptips-2014,cshconceptsavanc,functional-cs.Tags1}.txt
}}}
EF Core {{{
    gvim -c 'colors molokai_dark' ~/Empire/Doks/Comp/lang/clangs/csharp/db/entity/{entityframewcore6-2e_2022,pract-entity-framework_2020,entitydev-codefirst_2015,cs8-dotnetcore3-entity-vscode-4e_2019,entity-framework-core-2-aspnet-core-mvc_2019.ru,entitycore2-asp-coremvc_2018,entitycore-inaction_2018,cs7-dotnetcore_2017.ru}.txt
}}}
.  (nix(guix) + nix-os) {{{
    gvim ~/Empire/Doks/Comp/sysadm/lin/distro/NixGuix/{NixRefman,NixpkgsRefman,NixOSMan,guix-cookbook,GuixMan,guix-refcard}.txt
}}}
    gvim ~/Empire/Doks/Comp/lang/java/cloj/{cloj-bravtrue_2015,clscript/clojworkshop-clojscript,datasci/clojdatanalyscb,clojrecip,clojurecb,clojure-realworld_2012,cloj-workshop,getting-clojure2_2018,microservices-with-clojure_2018,practical_clojure_2010}.txt
__ __ CLOJURE + Clscript {{{
    gvim -c 'colors industry' ~/Empire/Doks/Comp/lang/java/cloj/{clojcb_2014,sicp.clojure,clojprof_2016,cloj-progr-2e_2012,clojrecip,clojurecb,cloj-workshop,jcloj-2e_2014,microservices-with-clojure_2018,practical_clojure_2010,clojquick_2017,clojure-realworld_2012,getting-clojure2_2018,programming-clojure_2018,clojelems_2019,cloj-hiperf,clojliving_2015,cloj-pract_2010}.txt
      webdev
    gvim -c 'colors industry' ~/Empire/Doks/Comp/lang/java/cloj/clscript/{clojscript-studies_2016,clojscrlearn2,clojscrlearn_2016,clojscr-rxwebfunct_2017,clojworkshop-clojscript,lclojurescript}.txt
    patts/algos + Rx + Datasci ----
    gvim -c 'colors industry' ~/Empire/Doks/Comp/lang/java/cloj/{datasci/cloj-datanalys_2014,datasci/clojdatanalyscb,datasci/cloj-datasci_2015,datasci/clojmlearn_2014,patts-algos/clojalgodatastruct,patts-algos/clojscala-functprogrpatts_2013,patts-algos/clojscalfunct-datastructalgos,rx/cloj-hiperform--asynchchannels-logicrx_2017,rx/cloj-rx_2015,rx/cloj-rxhandson_2019}.txt
}}}
        clojure-sicp
    gvim ~/Empire/Doks/Comp/lang/webdev/Aux/Aws/{AwsCb_2022,awslambda-progr_2020,go-serverless-awslambda_2018}.txt
    gvim ~/Empire/Doks/Comp/PROGR/git/{githubactions_2021,githubactions-workflowautom_2021,gittools-building_2016}.txt
____ Docker (+Aws/Azure, kubernetes)  vagrant, ansible  AUX {{{

    gvim ~/Empire/Doks/Comp/network/networksec-nmap_2017.txt

    gvim ~/Empire/Doks/Comp/lang/webdev/deploy/{openshift-dockerdeploy_2018,kubernetes/kubernetes-essentials,kubernetes/kub-completedev_2020,kubernetes/kubern-bestpract_2020,kubernetes/kubernetes-admin_2022,kubernetes/kubernetesguide_2019,kubernetes/kubern-progr_2019}.txt

    ____
    gvim ~/Empire/Doks/Comp/PROGR/devops/{ci/cipipeline-jenkinskubernterraform_2021,aiml-devops_2019,devopsautom-cb_2015,devopscareer-handb_2022,PyDevops-ansibdockeraws_2019,py-fordevops_2020,serverlessops_2017}.txt

    gvim ~/Empire/Doks/Comp/PROGR/projman/azdevops/{azuredev-guide_2019,azuredevops-agileprojman_2019,azuredevops-begguide.mini,azuredevops-solutimplem_2020,azure-prodaccel}.txt

        gvim ~/Empire/Doks/Comp/{PROGR/devops/vagrant/sharepointdevops-packerterraformansibvagrant_2018,PROGR/devops/vagrant/vagrant-devops_2018,PROGR/devops/vagrant/vagrantcb_2015,PROGR/devops/vagrant/vagrant_2013,cybersec/ansible/secautom-ansib2cb_2018,cybersec/ansible/secautom-ansib2_2017}.txt

}}}
Functional Algos/Design-Patterns {{{
    gvim -c 'colors molokai_dark' ~/Empire/Doks/Comp/funct-reactive/{functreact-domainmodel_2017,purefunct-datastructs_1998,reactive-despatts_2017}.txt
}}}
SEMANTIC WEB + Elastic Search {{{
    gvim ~/Dropbox/rsc/Doks/phone/Comp/lang/webdev/db/{azure-cosmosdb-mongo_2018,elastsearch-action_2022,dynamo-book_2020,dynamodb_2016.tutspoint,dynamo-mast_2014,semweb/intellsemwebsyst-epistemof_2016,semweb/knowlgraphs-linkeddata-largeorgs_2017,semweb/semanticweb-clojjava_2010,semweb/semweb-datamanage-qprocess_2011,semweb/semwebRDFSPARQL,semweb/semweb-structdata_2015,semweb/semweb-webscience_2013,semweb/sparql-learn,semweb/sparql-learn_2011,semweb/webdataapi-forknowlgraphs_2021}.txt
}}}
        ~/Empire/Doks/Comp/lang/scm/kawa/kawa-docs.txt
Coq, Isabelle, Agda {{{
    ~/Empire/Doks/Comp/lang/{
      misc-lang/coq-isabelle/Coq-8-19-2-Refman_2024
      misc-lang/coq-isabelle/coq-certifprogrwdeptypes_2019
      misc-lang/agda/agda-verifiedfunctional_2016
      + Owl, Ontology(Isabelle,Vampire)
      webdev/db/semweb/ontology/isabelle-part1.txt
      webdev/db/semweb/ontology/vampire-prover_2012.txt
      webdev/db/semweb/ontology/ontology101.txt
    }.txt
}}}

    Misc Datasci: (AI/MLEARN ETC) {{{
        gvim ~/Empire/Doks/Comp/{mlearn-ai/mlops/pymlearn-mlopsengineer_2021,mlearn-ai/cloud/aipragm-cloudmlearn.ru,mlearn-ai/Js/jsmlearn-pract_2021,mlearn-ai/Js/jsmlearn-handson_2018,lang/go-v/go-serverless_,datasci/cmdline-datasci_2015,lang/py/datasci/py-complexnetwanalys_2018}.txt
    }}}

    - Study TPope Vimrc[!!] (+Dotfiles)
    - START MODULARIZING VIMRC|EMACSINIT.EMPIRE(!)  @@


        UNIX POW.TOOLS (*!)       @@
    - mutt, Graphdbs(?)
        - Blender Py Getstarted 1  @
    - Termux: new tagged list  @@
        grep/sed/awk w. Python **(!)

                - Bluebash 1 ****  @@
    --
    to Txt-Manuals(!!): PyPyramid, 'AudacityMans'*
gvim -c 'colors molokai_dark' ~/Empire/Doks/Comp/lang/py/webmob/{pyramid/PyramidFrawew-Docs_2023,flask/pywebdev-flask-2013,py3webdev_2011,pyreact}.txt
      ~/Dropbox/rsc/data/lists/ref/comp/lang/kotlin/Kotlin-Refdocs.txt
      RevealJs-Doks,
      - ~/Dropbox/rsc/Doks/phone/Comp/lang/py/hylang.txt
          (+install vim syntax plugin)

    - Start Cut: Hall√• D√§r + Dft-Vids(+ Magnus B F√∂delsedagsfest(!))  @
      - L√ÑR/√ñVA IN DFT + THE DOC-MUSIC @
    - 4K Gear / Hero Manuals[!] @@ *** [+filma (+publ.) DFT-PIECES]
    --
    VimRefman Review 2022(!!)  #+make flat list of topics|bests|pickouts
    --
    - Anki-Man
      kde connect (!!) (+PHONES, TABLET S3)
    --
    - Clean out NatureImages 1 (+set new Shotwell-architecture)
      - Clean DrStr-Images 1 [!]
    - L√ÑROPLANSTR√ÑDET MU-UNDERVISN. (**/!!)  @(!!)
    - B√∂. planka trum:'timeagent'(****)  #+Allt(!!) i gamla Elevfiler (=w. the|a new more flexible scheme(**/!!))   ((********))
    --
    - RESET THIS INDEX TO FOLDMETHOD=INDENT(???)
    --
      - ps typefacelib 1 'pickout-lists'(!!)
      - Blender: Prepare - Real Blenderwork (+Ss-Books/Tuts(!!))  [[=3 Books]]
        - Digest Bildoks
        --renskriv f√∂ret:paulaw-petraa-andreasanacka_Notes/Sammanst.(*!!)
        LAT
        ~/Dropbox/rsc/lists/ref/Lang/Lat/vivlinglat.txt
        ~/Dropbox/rsc/Doks/phone.fmt35/todo/suitecrm.txt
    }}}
--------------------------

-- ontheroad.store ---- ___index=4 [4] {{{
Termux
    PowerShell[!]  WSL ____
  AndroidProgr (+Kotlin??)
  ----
AnkiMan (+Renskriv ___office)
SASS+Compass

    MAUI (=Office)  [Kotlin + Funct.] {{{
      https://dotnet.microsoft.com/en-us/apps/maui
          https://github.com/dotnet/maui

      https://app.pluralsight.com/search/?q=maui&type=conference%2Cvideo-course%2Cinteractive-course%2Clab%2Cpath%2Cproject%2Cskilliq&m_sort=relevance&query_id=4b3da816-f267-4168-ad9d-93702ef2f151&source=user_typed
      https://app.pluralsight.com/library/courses/dot-net-maui-big-picture/table-of-contents
      https://app.pluralsight.com/library/courses/dot-net-maui-fundamentals/table-of-contents
      https://app.pluralsight.com/library/courses/building-dot-net-maui-applications-mvvm/table-of-contents
      https://app.pluralsight.com/skilliq/dot-net-maui/intro

      https://app.pluralsight.com/library/courses/blazor-hybrid-apps-building/table-of-contents

      https://app.pluralsight.com/search/?q=javascript%20functional&type=conference%2Cvideo-course%2Cinteractive-course%2Clab%2Cpath%2Cproject%2Cskilliq&m_sort=relevance&query_id=600873c0-ec10-413b-8707-92fdca418845&source=user_typed

      https://app.pluralsight.com/library/courses/asp-dot-net-core-mvc-deep-dive/table-of-contents
      https://app.pluralsight.com/library/courses/aspdotnet-core-mvc-enterprise-application/table-of-contents
      https://app.pluralsight.com/library/courses/asp-dot-net-core-6-fundamentals/table-of-contents
      https://app.pluralsight.com/library/courses/aspdotnet-core-6-entity-framework-6-tailwindcss-vue-3-building-web-app/table-of-contents
      https://app.pluralsight.com/library/courses/asp-dot-net-core-6-crash-course/table-of-contents
      https://app.pluralsight.com/library/courses/architecting-aspnet-core-mvc-unit-testability/table-of-contents

      https://app.pluralsight.com/search/?q=dotnet%20core%20mvc&type=conference%2Cvideo-course%2Cinteractive-course%2Clab%2Cpath%2Cproject%2Cskilliq&m_sort=relevance&query_id=939e25e0-c3de-4c12-bc26-79e62831d81b&source=user_typed
      https://app.pluralsight.com/library/courses/dotnet-ecosystem-big-picture/table-of-contents
    }}}
    festival
            Samsung Notes (+Phone/Tablet)
            Nyxt (+qutebrowser/'hackers browser')
        Learn/Memory(+pomodoro)
    F#/Elix/Cloj/OCaml(etc) Datastructs[!!]
    jsCb 1, 
    Datomic *!  (+Datalog | Prolog)
    PureScript (x2.5)
        Bluebash **  @@
        Jseloq|JsFunct[!] + (h5g 2) @ - Wappdevex 1  SASS + Compass, TScript  UrWeb
          FreeC [!!]
    AnkiDef =2024++
    NuShell
    NetRW: =new minilist   vim-bashmode, vim-outliner
    VimscrHardw
        ClojWebdev,  clojurescript [!!]
    Pyfunct (1+2?)
        FreecRedone2 (+js-wappdev2)
    Emacs, Org + Elisp
      webscraping[!]
    - Termux: new tagged list  @@
    - Vnc (+remote desktop)  @
      - Ssh  @
    Dlang**,   Vlang
      Sass/Compass, Elm
      Docker/Kubern, AWS
      SemWeb =Knowl.Graphs, Ontologies: SUMO/Kif
      cypher (+gremlin), GraphQL
      julia[!]
    wine
    Funct C# / Cpp  + C# Avanc[!!(!)]  +UNITTESTING[!!!!]
      F#, Elixir[**] +Domain-Modeling
        Clojure[!!]  + LightTable
        reveal.js, impress.js
      Datasci + Stat + MLearn/AI [!!!**]
      blockchain + solidity(!)
    Asm[!!]
     C[!!]
     Haskell, Flutter[!]
    Tasker + Scripting Android(!!)  @
        Java with EE[!!]
        F* [=Need Cleaning +Setting Code]
        vera    @
    - Debian-bib  @(!)
    [+start Lang|Words|Litt]
    --
    rskrift | Gregg-snippets
    ---- Shop 1 {{{
        Lisp/Scheme/Elisp
      FunctReactive [+Datastructs]
     pygimp
    C + Datastructs
        gradle( +maven)
     DataSci + Stats[!], MLearn + NLTK/OpenCv
     microserv.
     blockch. + Go[V]
    Aux[comp]
    Archit.Comp/.Sys [*]
     netw.
     Testing + Cybersec.
    Ssh, vnc, Docker, Puppet,  Ansible
     Haskell + Liquid
    Idris
    debug
    webcomponents
    Rust
    gradle
    }}}

    
        BASH/UNIX
    - Ardour
    - socframg.[++]
    - Bevingat    @
        Saol.run1
      encyclstart (+hist)  Mini
        - 'greps' / Regex[!]
        cpp1+
    ('py boring')
        - Vidau-compress[!]  @
        @  teal, (fennel)   nvim-lua (+lua4)
            DUMMIES-start (**)
    --
      Writer|VimLatex
        ProGit(=relisten) + VankilistGit 1 =Rewrite (****(!!)) - + derekbanas + Tim Pope / SysCrafters(!)
     --
     - forts. planka 'rel.ond'(=rsteno)  +nystart Gregg +A.Doyle(**)
                 svsyndb(start  (=??))
     - JUR, Grundlagar, etc
       .
       .
    ----

    ---- k√∂rn./ute sommar 2021 (**(!)) ----
    - 'Strat'/ V√ÑKT** (+Sec Online**)
        # +pre(??): Ny L√§genhet, Allm.A(St√§d, recept/n√§ring, Hemsk√∂tsel, Bil(**))
    ----------
     - three.js (+=Games with __)
    - SvSynTotal(??)
    - Csounds (etc  ??)   #=keyb, Scoll, 
       - Algo (etc), PROGR****(??),  'Data Science' + Math(!!(**))
            + Grafik/Video mm (??/**)
         - Allm-A | JUR(+), Hist(!)
     - LITT(??/*)  - Bevingat
     - BASH(!!!!)
    - grep / Regex (etc)
    ----
    - haskell-mu(**!)  - haskell-lyself(**!)
                               (+klar m. vankiutils framework(!!)  +  more tagging/making vankinote(etc)-scripts (**!!))
                                            (HM!!!!! (=TAKING NOTES AS STENONOTES?????//////) )
     - 'Strat'/ V√ÑKT** (+Sec Online**)
                    # +pre(??): Ny L√§genhet, Allm.A(St√§d, recept/n√§ring, Hemsk√∂tsel, Bil(**))
    ----------
    - SvSynTotal(??)
    - Csounds (etc  ??)
     - 'More Python?? // Dlang(***(!!))   (=PyStdLib **(!!))
        - Algo (etc), PROGR****(??),  'Data Science' + Math(!!(**))
            + Grafik/Video mm (??/**)
     - LITT(??/*)  - Bevingat
                - Sk√§mt|Hist // Citat(!(/??))
    - grep / Regex (etc)
    ----
    - haskell-mu(**!)  - haskell-lyself(**!)
}}}


script oneliners(='nuggets'), 'reusing scripts.legacy[!]'  [+bashr|vimrc to ~/Dropbox/config-dirs  + xkbmap-aliases (+document all in lazarus.txt)] {{{
__area=1
    ~/dropbox-legacy/scripts/./wallpapers.bash

    (vim)utilscript-ideas 2021+  - charsperminute.el  - fontlarger.vim  **

    vim:fdm=marker:
    vim:syntax=cs:shiftwidth=2:
    set syntax=cs shiftwidth=2 | colors molokai_dark | set guifont=*


new(!)
    Rider Vim 0.1 ----

    evince -p 4 -l uncheck /home/bluelegend/Dropbox/rsc/Doks/phone.fmt35/0_todo/curr/mscore3.man.pdf &
        #start dok w. evince, go to page, search for 'word' [*****]
        # (=redo Greggref-system + Rskriftref-system2(!) w. this mechanism[!!])

    ls | grep DirnamePart | zip ZipName -r -@

    find -type f -iname '*.txt' 2>/dev/null | gvim -; ding
    find -type f -mtime -3 -name '*.txt' 2>/dev/null
        # search below =for all txtfiles modf.d last three days[!!]

    "copy + mkdir -p"
        install -D ~/path/to/source.txt ~/path/to/destin/dir/destin.txt

    bashrc-aliases: keyq(w) keyd(v)   k-qw k-dv
        setxkbmap -layout se                    #qwerty   keys.qwer
        setxkbmap -layout se -variant dvorak    #svdvor.  keys.sdvor

    bash list-of-commands.txt


-- 'nuggets' (format-strings, mini-hacks, commands) ------
    00H:02m:31s                 # vlc time
    %Y%m%d_%NNNNNN              # shutter
    %s:\v(/\*|\*/)::g           # remove '/* */'
    set syntax=svg              # list lang-names:
                                #   ls /usr/share/vim/vim81/syntax | c:\tools\vim\vimNUM\syntax
                                #   (python, java, bash, clojure, tex, etc)
    screenshot: csa-s  #gimp: take screenshot
    manual duplex               # [print last odd+ ]
                                #   even, odd+reversed
    man manpage | col -b | gvim -   # export unix manpage to .txt

rename links automatically prepended by 'link to ' by thunar:
    for f in link\ to\ *; do mv "$f" "${f#link to }"; done
    for f in zlib*; do mv $f ${f#zlib.pub_}; done

    xclock -update 10 &
    gnome-clocks                # world time
    curl wttr.in/uddevalla      # cmd-line weather
    ----
    ncal -w -A 2                # show weeks, curr. month, + two months ahead
    ncal -w -A 2 -b
    ncal -bw
    ncal -bw -m 6; ncal -bw -m 7; ncal -bw -m 8
                                # show three months - vertically

    find(+list) largest dirs|files
    compare dirs (+recurs)      # diff, mc
    ----
    apt, dpkg  etc
    sudo apt -y update && sudo apt -y upgrade
      sudo dpkg -i install-file.deb     # install deb-file fr. commandline

    ---- [reusing legacy scripts]
    legacy.runscript.bash `legacy.atgrep.bash ocr`


guix pull
guix package -u
hash guix


Remove stale or missing PPA (Ubuntu)
  # e.g. https://ppa.launchpadcontent.net/me-davidsansome/clementine/ubuntu
sudo apt-add-repository --remove ppa:me-davidsansome/clementine

}}}
legacy scripts {{{
__area=2
    ~/dropbox-legacy/scripts/./export_steno2pdf.bash DoneStenodok.svg
        .
    ~/dropbox-legacy/scripts/./GALAXYJPG2TXT_FLEX-norotation_notextcleaner.bash  #use legacyscript for ocr:ing (**)
~/dropbox-legacy/scripts/ALLTODOIST/./zz_OCRPROC-OCRPROJ.bash {{{

Signs|Chars to replace:
        ‚Äú ‚Äù ‚Äò ‚Äô
               ((+add more char.s, like <4656>-style spec|ctrl-char.s(!!)))
        ‚Äì  (+w. ' ' around)
        ‚Ä¢  (espec. at start of line)
Adjust lines ending in '-' | Words w. embedded '- '
Insert line after:
        lines ending in  \.)\=  :  ?  !
        lines end w. \l, next starts w. \u
Generate incremental bulletlists (1. 2. ..., a. b. ...)
  temp: o
Immo0`ov0"my  #pre: set reg. 'm' to '1. '  +  macro sets marker 'o'

@i(nterweave)  #pull and merge lines fr. next textblock  to end of lines of curr. textblock
@block-split   #separate line-ending textparts in curr. textblock  down to separ. textblock below(!!)
@n: }dd

}}}
      ~/dropbox-legacy/scripts/./mid2mp3
      ~/dropbox-legacy/scripts/./wav2mp3
    ==== Note: ** Pic/Media-scripts migrated to at.transcribe.bash ** ====
    ~/dropbox-legacy/scripts/./frecord.bash  #crap(!! =inte ljud; bara brus)
      ~/dropbox-legacy/scripts/frecord.bash
      ~/dropbox-legacy/bla/frecord.bash
    ~/dropbox-legacy/scripts/ALLTODOIST/./ALLM-ST√ÑD_dataadmin_RENSAFILERLAGRINGH√ÖRDDISKAR.bash
        ~/dropbox-legacy/scripts/ALLTODOIST/ALLM-ST√ÑD_dataadmin_RENSAFILERLAGRINGH√ÖRDDISKAR.bash
}}}


GEMINI NEWEST  [Termux PKG, ] {{{

Drs LangDb Empire {{{

I have a small personal language-database I would like to implement, and I have looked a bit into MongoDB, Semantic Web using technologies like Jena/AllegroGraph/Sesame, exploring AWS Neptune and Gremlin, and using Cosmos DB or Dynamo DB, and lastly Datalog. Could you comment on these different choices of technologies?

What I'm looking for is a technology that is not insanely difficult to implement, not having to specify all manner of schemas and pre-specified relations that come with relational-database solutions, and (which could make an otherwise difficult technology a viable option) exploring some interesting options/technologies.

Absolutely. Let's break down those technology choices for your personal language database, keeping in mind your desire for ease of implementation, schema flexibility, and exploration of interesting options.

1. MongoDB (Document Database)

    Pros:
        Extremely flexible schema (or lack thereof). You can store language data in JSON-like documents, which is very natural for representing linguistic information.   

Relatively easy to learn and implement.
Large community and abundant resources.
Good for handling semi-structured data, which is common in language data.  

    Cons:
        Less ideal for complex, deeply interconnected relationships. While you can model relationships, it might require more manual work compared to graph databases.
        Querying for complex relationships can become cumbersome.
        Does not provide native semantic reasoning.

2. Semantic Web Technologies (Jena/AllegroGraph/Sesame)

    Pros:
        Excellent for representing and querying complex relationships using RDF (Resource Description Framework).
        Supports semantic reasoning, allowing you to infer new knowledge from existing data.   __

Can handle ontologies and controlled vocabularies __hm, which are valuable for linguistic analysis.
These technologies support SPARQL, a query language designed for working with RDF data.  

Cons:

    Steeper learning curve, especially if you're new to RDF and SPARQL.
    __ Requires careful design of your ontology (schema), although it's more flexible than relational schemas.
    Can be more complex to set up and manage compared to simpler databases.
    AllegroGraph is a commercial product, while Jena and Sesame are open source.   [__]

3. AWS Neptune and Gremlin (Graph Database)  __

    Pros:
        Designed specifically for handling highly connected data, making it ideal for representing relationships between words, concepts, and languages.
        Gremlin is a powerful graph traversal language.   

        Scalable and managed service on AWS.
    Cons:
        Requires understanding graph data models and Gremlin.
        While flexible, designing your graph-schema is still important.
        You will be locked into the AWS ecosystem.

4. Cosmos DB or DynamoDB (NoSQL Key-Value or Document Databases)

    Pros:
        Highly scalable and performant.
        Flexible schema (similar to MongoDB).
        Managed services, reducing operational overhead.
    Cons:
        Similar to MongoDB, less ideal for complex relationship queries compared to graph databases.
        DynamoDB is key-value based, so document based cosmosDB would be a better fit.   

        You will be locked into the Azure or AWS ecosystems respectively.

5. Datalog (Logic Programming)  [__]

    Pros:
        Excellent for expressing complex rules and relationships declaratively.  __
        Powerful for reasoning and inference.
        Very flexible and expressive.
        It's a very interesting technology.
    Cons:
        Can be challenging to learn if you're not familiar with logic programming.
        May require more effort to implement a full-fledged database system.
        Less mainstream than other options, so community support might be limited.
        Performance can be a concern for very large datasets.

Recommendations:

    For Ease of Implementation and Flexibility:
        MongoDB: If you prioritize getting started quickly and having maximum schema flexibility, MongoDB is a strong choice. Its document-based model is well-suited for language data.
        CosmosDB: If you are already within the Azure ecosystem, CosmosDB would be a good option.
    For Exploring Relationships and Semantic Reasoning:
        Semantic Web Technologies (Jena/Sesame): If you're interested in exploring the semantic aspects of language and don't mind a steeper learning curve, these technologies are excellent.
        AWS Neptune: If you want a managed graph database and are comfortable with AWS, Neptune is a good option.
        Datalog: If you are willing to spend the time to learn this technology, it is a very powerful option, and very interesting.
    Considerations:
        Size of your database: For small to medium-sized personal projects, most of these options will work well.
        Complexity of relationships: If you anticipate many complex relationships, a graph database or semantic web technology will be more suitable.  __
        Your programming background: If you're comfortable with logic programming, Datalog could be a fascinating choice.  [__]

In summary, for a personal language database, I would suggest starting with MongoDB for ease of use, or exploring Semantic Web technologies or AWS Neptune if you want to delve into complex relationships and semantic reasoning. If you want a very powerful and interesting option, that will require more work, Datalog is worth considering.

What is MongoDB? An Expert Guide | Oracle Sverige
Source icon
www.oracle.com
Semantic Web - Wikipedia
Source icon
en.wikipedia.org
Apache Jena SPARQL APIs
Source icon
jena.apache.org
Purchase - AllegroGraph
Source icon
allegrograph.com
Gremlin (query language) - Wikipedia
Source icon
en.wikipedia.org

- Oh I forgot to mention two a bit
  obscure, but potentially very
  interesting and rewarding
  options: Prolog and/or in tandem
  with Mercury, and building a
  small ontology using SUMO.

Ah, Prolog and Mercury, and SUMO! Those are indeed interesting and potentially very rewarding choices, especially for a language database with a focus on semantic representation and reasoning. Let's add them to the discussion:

6. Prolog (Logic Programming)  __

    Pros:
        Excellent for expressing logical rules and relationships declaratively.
        Built-in backtracking and unification, which are powerful for searching and reasoning.
        Can be used to build knowledge representation systems and ontologies.
        Very powerful for parsing, which could be very useful for language related data.
    Cons:
        Can be challenging to learn if you're not familiar with logic programming.
        Performance can be a concern for very large datasets if you do not use indexing and other techniques.
        Less mainstream than other options, so community support might be limited.
        It is not a database in the classical sense, so you would be creating a program that contains and queries your data.  _!

7. Mercury (Logic/Functional Programming)

    Pros:
        A logic/functional programming language that aims to improve on Prolog's performance and maintainability.
        Strong type system and compile-time error checking.
        Can be compiled to efficient native code.  [__]
        Can be very useful for large, complex programs.
    Cons:
        Even less mainstream than Prolog, so community support is even more limited.
        Steeper learning curve than Prolog.
        It is also not a database in the classical sense.
    Prolog and Mercury together: They can be used in tandem. Prolog can be used for rapid prototyping, and Mercury for creating more robust and performant applications.

8. SUMO (Suggested Upper Merged Ontology)

    Pros:
        A large, comprehensive ontology that provides a foundation for building domain-specific ontologies.
        Can be used to represent a wide range of concepts and relationships.
        Provides a shared vocabulary for semantic interoperability.
        SUMO is designed to be mapped to WordNet, which is very useful for language processing.  __ __
    Cons:
        Can be overwhelming due to its size and complexity.
        Requires careful consideration of how to map your language data to SUMO concepts.
        Requires using a technology that can handle ontologies, such as Jena or AllegroGraph, or using a language like Prolog.  __ [__]
        SUMO provides an upper level ontology, that you will still need to add your own ontology on top of.

Integration and Considerations:

    Prolog/Mercury + SUMO: This combination is very interesting. You could use Prolog or Mercury to build a knowledge base that incorporates SUMO concepts. This would allow you to perform sophisticated reasoning and inference on your language data.  [[__]]
    Semantic Web Technologies + SUMO: You could import parts of SUMO into a semantic web database (like Jena or AllegroGraph) and then add your language data as RDF triples. This would allow you to leverage SPARQL for querying and reasoning.

    Complexity: Using Prolog/Mercury and SUMO will significantly increase the complexity of your project. However, it will also provide you with a very powerful and flexible system.
    Learning Curve: Be prepared for a steep learning curve, especially if you're new to logic programming and ontologies.
    Reward: The reward for mastering these technologies is the ability to create a very sophisticated and intelligent language database. [__]

In summary:

    If you're looking for a challenging but rewarding project, exploring Prolog or Mercury in tandem with SUMO is an excellent option.
    This approach will allow you to build a very powerful and flexible system for representing and reasoning about language data.
    However, be prepared for a steep learning curve and significant development effort.
    If your main goal is to explore those technologies, then this is a great project to do it with.
    If your main goal is to create a working language database quickly, then MongoDB, or CosmosDB would still be the better option.

- Also (and I have at least a
  friend who has been looking into
  this option) using any of the
  above solutions or databases with
  Dlang or (for that matter) other
  programming languages like Python
  etc. Plus (just as a note) I have
  no particular preference
  personally when it comes to
  selection of programming
  languages - ones that could do
  the job well are of interest.

Excellent point! Considering the programming languages you'll use to interact with your chosen database is crucial. Let's explore how D and Python, and other languages, fit into the picture with the database options we discussed.

Programming Languages and Database Interactions:

    Python:
        Python is incredibly versatile and has excellent libraries for interacting with nearly all the database options we've discussed.
        MongoDB: pymongo is the official Python driver.
        CosmosDB: Azure provides python SDKs for cosmosDB.
        AWS Neptune: gremlinpython is the official Python driver for Gremlin.
        Semantic Web (Jena/Sesame): rdflib is a powerful Python library for working with RDF and SPARQL.
        Datalog: There are Python libraries that can interact with Datalog engines.
        Python is very useful for processing text, and language related data.
        Python has excellent NLP libraries.
    D (Dlang):
        D is a systems programming language known for its performance and expressiveness.
        While D might not have as extensive a library ecosystem as Python, it can still interact with most databases.
        MongoDB: There are D drivers for MongoDB.
        PostgreSQL/Other SQL Databases: D has libraries for interacting with SQL databases, which could be relevant if you decide to use a relational database.
        C Bindings: D can easily interface with C libraries, so you can leverage C drivers for various databases.
        D is very fast, so if speed is a concern, D is a good option.
    Prolog/Mercury:
        Prolog and Mercury are themselves programming languages, so you'll be writing your database logic directly in them.
        You can still interact with external systems using their foreign language interfaces. (__)
    General Considerations:
        Drivers and Libraries: Check for available drivers and libraries for your chosen database and programming language.
        Performance: If performance is critical, D or languages like C++ might be preferred. Python can be performant, but D and C++ are generally faster for raw processing.
        Ease of Development: Python excels in ease of development and rapid prototyping. D offers a good balance of performance and expressiveness.
        Community and Ecosystem: Python has a massive community and a vast ecosystem of libraries, which can be a significant advantage. D's community is smaller, but growing.
        __ Interoperability: Languages that can easily interoperate with C libraries provide access to a wide range of database drivers.

Language Specific Notes:

    Python for NLP: Python's rich ecosystem of NLP libraries (NLTK, spaCy, Transformers) makes it a natural choice for processing and analyzing language data.  __ __
    D for Performance-Critical Tasks: If you need to perform computationally intensive tasks on your language data, D's performance can be a significant advantage.
    Prolog/Mercury for Reasoning: If your focus is on logical reasoning and knowledge representation, Prolog or Mercury are excellent choices.  [__]

Recommendations:

    If you prioritize ease of development and access to NLP libraries, Python is a strong choice.
    If you need high performance and are comfortable with a less mature ecosystem, D is a good option.
    If you're primarily interested in logical reasoning and knowledge representation, Prolog or Mercury are excellent choices.
    __ You can also use a combination of languages. For example, you could use Python for data processing and analysis, and D for performance-critical tasks.
    When using prolog or mercury, you will be coding the database logic within that language.

In essence, your choice of programming language should align with your project's goals, performance requirements, and your own comfort level.


__ __ ____
The task for me would be to create a bit of a web of 'entries' which are words or phrases in different languages. Each entry should also have a general category-tag, i.e. things like 'Greetings', 'Understanding', 'Adjectives' etc - very similar to Lonely Planet, Berlitz and other phrase-books. Swedish and/or English would provide the primary translation for words and phrases in the different languages, and I would then be able to drill myself in and develop along a path through a language from simple phrases going on to more difficult or abstract phrases and reasoning. Also, I'm hoping to leverage one or several languages to provide a 'base-plate' of knowledge in the sense that if I then would like to explore and collect some words and phrases in a new language, I can look back at one or more languages where I have collected and acquired phrases and provide a path for that new language (i.e. 'These 50, 100 or some number of words in my strongest languages provides a good firm 'base-knowledge' for a new language. Let me gradually collect and acquire these entries in my new language')

Okay, that clarifies your project very well! You're essentially building a personalized, interconnected phrasebook with a focus on categorized learning and cross-lingual knowledge transfer. Let's revisit the technology options with this specific use case in mind:

Key Considerations for Your Phrasebook Project:

    Categorization and Tagging: You need a system that efficiently handles categories like "Greetings," "Understanding," and "Adjectives."
    Multilingual Support: The database must accommodate words and phrases in various languages.
    Relationships and Interconnections: You want to establish relationships between entries, such as translations, related concepts, and learning paths.
    Querying and Filtering: You need to be able to query and filter entries based on language, category, and other criteria.
    Scalability: While you're starting with a personal project, consider whether you might want to scale it in the future.
    __ ____ Learning Path: You will need to be able to create some kind of ordering of entries, so that you can create a learning path.

Technology Recommendations Based on Your Use Case:

    Graph Database (AWS Neptune or similar):
        Pros: __??
            Excellent for representing relationships between entries, such as translations and related concepts.
            Gremlin allows for powerful querying and filtering based on language, category, and relationships.
            You can easily model learning paths by creating edges that represent the order in which entries should be learned.
            Graph databases are designed to handle highly interconnected data.
        Cons:
            Requires learning Gremlin.
            AWS Neptune is a cloud service, so you'll be tied to the AWS ecosystem.
    Semantic Web Technologies (Jena/Sesame):
        Pros: __
            RDF is well-suited for representing multilingual data and relationships.
            SPARQL allows for complex queries and reasoning.
            You can use ontologies to define categories and relationships in a structured way.
            You could incorporate SUMO or other ontologies to provide a base for your knowledge.
        Cons:
            Steeper learning curve.
            Requires careful ontology design. [__]
    MongoDB (Document Database):
        Pros:
            Flexible schema allows you to easily add new languages and categories.
            JSON-like documents are easy to work with.
            Easy to get started.
            MongoDB can store arrays, so you could store arrays of translations.
        Cons:
            Less ideal for complex relationship queries compared to graph databases or semantic web technologies.
            Modeling learning paths might require more manual work.
    Prolog/Mercury:
        Pros:
            Excellent for representing rules and relationships.
            Built-in reasoning capabilities.
            You can create a very flexible and powerful system.
            Can be used to implement learning paths using logical rules.
        Cons:
            Steep learning curve.
            Less mainstream.
            Not a traditional database.

Specific Implementation Suggestions:

    Graph Database: __
        Create nodes for each entry (word or phrase).
        Add properties to nodes for language, category, and translations.
        Create edges to represent relationships, such as "translationOf," "relatedTo," and "partOfLearningPath."
        Use Gremlin to query and filter entries and traverse the graph.
    Semantic Web:
        Create RDF triples to represent entries, categories, and relationships.
        Use SPARQL to query and filter the data.
        Consider using an ontology to define your categories and relationships.
    MongoDB: ____ __ ____
        Create documents for each entry, with fields for language, category, translations, and related entries.
        Use arrays to store translations and related entries.
        Use queries to filter and retrieve entries.
    Prolog/Mercury:
        Represent entries as facts and rules.
        Use logical queries to retrieve and filter entries.
        Implement learning paths using logical rules.

____
For your specific use case, I would
lean towards a graph database (AWS
Neptune) or semantic web
technologies (Jena/Sesame) if you
want to emphasize relationships and
learning paths. If you want to get
started quickly and don't need
complex relationship queries,
MongoDB is a good option.
Prolog/Mercury are very powerful,
but will require a large amount of
time to implement.

- Great. What languages programming
  languages would be most
  advantageous to use in tandem
  with the top picks you mentioned
  (i.e. with MongoDB for instance).
  + Let's say I would later on like
  to make my little database
  project available 'on the road',
  i.e. developing some kind of
  Android-based client whereby I
  could drill myself while walking,
  running, commuting etc. What
  extra languages or technologies
  might we want to add to the list
  (i.e. languages like Kotlin,
  Flutter + Dart etc), and would
  that tilt the rank-order of
  technologies that we just
  discussed?

Excellent questions! Let's break
down the programming language
choices for your database
interactions and mobile development
plans.


Programming Languages for Database Interactions:

    MongoDB:
        Python:
            pymongo is the official Python driver and is very well-supported.
            Python's ease of use and extensive ecosystem make it ideal for backend development.
            It is very easy to create APIs in python using frameworks like Flask or FastAPI.
        Node.js (JavaScript/TypeScript):
            MongoDB is a NoSQL database, and JavaScript/TypeScript are also used for JSON-like data, making them a natural fit.
            Node.js is excellent for building scalable backend-APIs.
            TypeScript can be used to add type-safety to JavaScript-code.
    Graph Databases (AWS Neptune):
        Python:
            gremlinpython is the official Python driver for Gremlin.
            Python's versatility makes it a good choice for interacting with graph databases.
        Java:
            Java is also supported for Gremlin interactions.
    Semantic Web (Jena/Sesame):
        Python:
            rdflib is a powerful Python library for working with RDF and SPARQL.
        Java:
            Jena and Sesame are Java-based frameworks, so Java is a natural choice.

C#/F# DotNet Core (+Avalonia/MAUI)

Mobile Development (Android Client):

    Kotlin:
        Kotlin is the official language for Android development.
        It is modern, concise, and interoperable with Java.
        It is the best choice for native Android development.
    Flutter (Dart):
        Flutter is a cross-platform framework that allows you to build native-like apps for Android and iOS from a single codebase.
        Dart is the programming language used with Flutter.
        Flutter is excellent for rapid development and creating visually appealing apps.
        Flutter can also be used for desktop and web development.
    Backend Considerations for Mobile:
        Regardless of whether you choose Kotlin or Flutter, you'll likely need a backend API to serve data to your mobile app.
        Python (Flask, FastAPI) or Node.js (Express.js) are excellent choices for building RESTful APIs.

Impact on Technology Rank-Order:

    Flutter's Cross-Platform Capabilities:
        If you prioritize cross-platform development (Android and iOS), Flutter becomes a very strong contender. __
        This might tilt the balance towards technologies that are easier to integrate with a backend API, such as MongoDB or graph databases with well-supported RESTful APIs. ____
    Kotlin's Native Android Performance:
        If you prioritize native Android performance and a seamless user experience, Kotlin is the best choice.
        This choice makes the backend API very important.
    API-First Approach:
        The need for a mobile client emphasizes the importance of an API-first approach.
        This means choosing a database and programming language that make it easy to build and maintain a robust API.
        This favors Python and Node.js.
    Graph Database and Mobile:
        While Graph databases are powerful, making them work smoothly with mobile applications adds a layer of complexity.
        You will need to create a robust API that can translate the graph data to a format that the mobile application can understand.
    Semantic Web and Mobile:
        Semantic Web technologies are less common in mobile development.
        You would need to build an API that can handle SPARQL queries and return data in a mobile-friendly format.

Revised Recommendations:

    MongoDB + Python (FastAPI/Flask) + Kotlin/Flutter:
        This combination provides a good balance of ease of use, scalability, and mobile development flexibility.
        Python's FastAPI or Flask can be used to create a robust API, and Kotlin or Flutter can be used to build the mobile client.
        MongoDB is very easy to use, and is well supported.
    Graph Database (AWS Neptune) + Python (FastAPI/Flask) + Kotlin/Flutter:
        This option is excellent if you prioritize relationships and learning paths.
        However, it requires more effort to set up and manage.
        The API layer is very important in this design.
    Semantic Web (Jena) + Java (Spring Boot) + Kotlin/Flutter:
        This is a strong option if you want to use semantic web technologies.
        Java is a very robust language, and Spring Boot is a very popular framework.
        This option will require the most work.

In summary, for your project, I would recommend MongoDB and Python, as it provides a good balance of ease of use, and mobile development flexibility.

Just as a quick comment on the Semantic Web and Java (the entry marked as number 3 just above). I have had some interest in Clojure which seems like a very interesting choice for both leveraging Java-based technologies and favoring rapid test/prototype-based development. Could that be an interesting/feasible technology to add to the mix here?

Absolutely! Clojure is an excellent and very interesting option to add to the mix, especially when considering leveraging Java-based technologies like Jena for Semantic Web applications. Let's explore why:

Clojure and Semantic Web (Jena):

    Java Interoperability:
        Clojure runs on the Java Virtual Machine (JVM), making it seamless to interact with Java libraries like Jena.
        You can directly call Java functions and classes from Clojure code, allowing you to leverage the full power of Jena.
    Functional Programming:
        Clojure's functional programming paradigm is well-suited for working with data and transformations, which are core to Semantic Web applications.
        Its emphasis on immutability and pure functions can lead to more robust and maintainable code.
    Rapid Prototyping and REPL-Driven Development:
        Clojure's REPL (Read-Eval-Print Loop) allows for interactive development, making it easy to experiment and iterate on your code.
        This is particularly valuable for prototyping and testing Semantic Web queries and transformations.
    Data Manipulation:
        Clojure's data structures (lists, maps, vectors) are well-suited for representing RDF data.
        Its powerful data manipulation functions make it easy to process and transform RDF triples.
    Concurrency:
        Clojure has excellent concurrency features, which could be useful for handling large Semantic Web datasets.

Feasibility and Advantages:

    Feasibility: Using Clojure with Jena is highly feasible. There are examples and resources available online that demonstrate how to integrate them.
    Advantages:
        Clojure's conciseness and expressiveness can lead to more elegant and maintainable code compared to Java.
        Its REPL-driven development can significantly speed up development time.
        Clojure's functional programming paradigm can help you write more robust and predictable code.
        Clojure is very good at data manipulation, which is extremely important when working with RDF data.

Considerations:

    Learning-Curve: Clojure has a learning curve, especially if you're not familiar with functional programming.
    Community: While the Clojure community is active, it's smaller than the Java or Python communities.
    Libraries: While Clojure can leverage Java libraries, there might be fewer Clojure-specific libraries for Semantic Web development compared to Java.

In summary:

    Clojure is an excellent choice for leveraging Java-based Semantic Web technologies like Jena.
    Its functional programming paradigm, REPL-driven development, and data manipulation capabilities make it well-suited for building Semantic Web applications.
    If you're interested in exploring a more expressive and interactive development experience, Clojure is definitely worth considering.
    If you are already interested in Clojure, this is a very good project to explore it with.

- If I/we add Clojure to the mix
  here (i.e. maybe with regard to
  trying out interesting and
  potentially very rewarding
  technologies), is it possible
  (without too much hassle) to
  enter that into the mix when it
  comes to the Android client,
  maybe being used as or in tandem
  with the background technologies?

That's a very interesting question! Integrating Clojure into the Android client, especially for background tasks or data processing, is indeed possible, but it comes with some considerations. Let's break it down:

Clojure on Android:

    ClojureScript:
        ClojureScript is a Clojure compiler that targets JavaScript.   

        You could potentially use ClojureScript for parts of your Android app's logic, especially if you're using a hybrid approach (e.g., with React Native or Capacitor).
        However, this would introduce a JavaScript layer, which might add complexity.
    Clojure on the JVM (Android):
        Android runs on a modified JVM (Dalvik/ART).
        You can, in theory, run Clojure code on Android by packaging the Clojure runtime with your app.
        However, this comes with significant challenges:
            Runtime Size: The Clojure runtime adds a considerable amount of overhead to your app's size.
            Performance: While Clojure on the JVM can be performant, it might not be as optimized for Android's limited resources as native Kotlin code.
            AOT Compilation: Ahead-of-time (AOT) compilation can help with performance, but it adds complexity to the build process.
            Android Ecosystem: Android development is heavily centered around Kotlin and Java. Integrating Clojure can make it harder to use Android-specific libraries and APIs.
    Background Tasks:
        Clojure could be more feasible for background tasks that don't require tight integration with the Android UI.
        However, the overhead of the Clojure runtime still applies.
        It would be possible to create a Clojure-based library, that is then accessed by the Kotlin android application.

Feasibility and Considerations:

    Complexity: Adding Clojure to an Android client significantly increases the complexity of your project.
    Performance: Be prepared to address potential performance issues, especially on older Android devices.
    Build Process: Setting up a build process that handles Clojure on Android can be challenging.
    Maintenance: Maintaining a Clojure-based Android app might require specialized knowledge.
    Interoperability: Clojure's Java interoperability can be useful for accessing Android APIs, but it adds another layer of complexity.
    Alternative: a better solution would likely be to create a Clojure based backend, and then have the android application communicate with that backend.

Recommendations:

    For most Android development scenarios, especially for UI-intensive apps, Kotlin is the recommended choice.
    If you're primarily interested in exploring Clojure, consider using it for the backend-API instead of the Android client. This approach allows you to leverage Clojure's strengths without the complexities of running it directly on Android.
    If you have a very specific use case that requires Clojure's capabilities on Android, and you're willing to invest the time and effort, it is possible.
    If you wanted to explore a hybrid approach, using ClojureScript, and React Native would be a more viable option.

In summary:

    While technically possible, running Clojure directly on Android is generally not recommended due to its overhead and complexity.
    Using Clojure for the backend API is a more practical and efficient approach.
    If you are set on using Clojure, then using Clojure for the backend, and Kotlin for the android application is the best option.

- Got it. Very helpful. One small question: I was intrigued by some entries in the Kawa Scheme documentation that - since it is Java-based - one could potentially build or at least prototype Android apps with not too much of a hassle? I would suspect it would not hold up as a more definitive solution in this case, but perhaps I'm wrong on that point, and regardless it might be interesting to fiddle with at least as a side-project.

You've hit on another intriguing possibility! Let's explore Kawa Scheme and its potential for Android development.

Kawa Scheme and Android:

    Java Interoperability:
        Kawa Scheme, being a Scheme implementation that runs on the JVM, inherently possesses strong Java interoperability.
        This means it can, in theory, access Android's Java-based APIs.
    Android Development Potential:
        The Kawa documentation's hints about Android development stem from this Java interoperability.
        You could potentially use Kawa to create Android applications by:
            Calling Android's Java APIs from Kawa code.
            Packaging the Kawa runtime with your Android application.
    Limitations and Considerations:
        Runtime Overhead: Like Clojure, Kawa's runtime adds overhead to your app's size. While potentially smaller than Clojure, it's still a factor.
        Android Ecosystem: Android development is heavily geared towards Kotlin and Java. Integrating Kawa can lead to compatibility and integration challenges.
        Tooling and Support: The tooling and community support for Kawa-based Android development are significantly less extensive than those for Kotlin or Java.
        Performance: Performance might be a concern, especially for UI-intensive applications.
        AOT Compilation: Just like Clojure, AOT compilation could help with performance, but adds complexity.
    Prototyping and Experimentation:
        Your assessment is accurate: Kawa could be interesting for prototyping and experimentation.
        If you want to explore alternative approaches to Android development, Kawa provides a way to do so.
        It would be a very interesting side project.

Feasibility and Recommendations:

    Not a Definitive Solution: For production-ready Android applications, Kotlin remains the most practical and well-supported choice.
    Exploration and Learning: If your goal is to explore Scheme on Android and push the boundaries of Android development, Kawa is a viable option.
    Side Project Potential: Kawa-based Android development lends itself well to side projects and experiments.
    Learning Scheme: If you want to learn scheme, this is a very interesting way to do so.

In summary:

    Kawa Scheme offers the potential for Android development due to its Java interoperability.
    However, it comes with limitations related to runtime overhead, ecosystem integration, and performance.
    It's best suited for prototyping, experimentation, and educational purposes.
    It is a very interesting technology, and worth exploring.

Could you help give me an idea of a bit of Kawa code that could potentially create a rudimentary little app that could be runnable on Android? I.e. not exactly a hello world style app, but something like a very small calculator app, something that translates degrees Celsius to Fahrenheit and has two or three clickable buttons... or something like that

Alright, let's sketch out a conceptual idea for a rudimentary Android app using Kawa Scheme. Please keep in mind that this will be a simplified example to illustrate the general approach, and it might require adjustments and further research to get it working perfectly on Android.

Conceptual Approach:

    Android SDK and AWT/Swing:
        We'll leverage Android's Java SDK and potentially AWT/Swing (though Android's native UI toolkit is preferred) to create the UI.
        Kawa's Java interoperability will be crucial for calling Android's Java APIs.
    Kawa Code:
        We'll write Kawa code to define the UI elements, event handlers, and logic for the Celsius-to-Fahrenheit conversion.
    Compilation and Packaging:
        We'll need to compile the Kawa code to Java bytecode.
        Then, we'll package the compiled code and the Kawa runtime into an Android application package (APK).

Conceptual Kawa Code (Illustrative):
Scheme

(define (celsius-to-fahrenheit c)
  (+ (* c 1.8) 32))

(define (create-ui)
  (let* (
        (frame (java.awt.Frame "Celsius to Fahrenheit"))
        (celsius-label (java.awt.Label "Celsius:"))
        (celsius-input (java.awt.TextField 10))
        (fahrenheit-label (java.awt.Label "Fahrenheit:"))
        (fahrenheit-output (java.awt.Label ""))
        (convert-button (java.awt.Button "Convert"))
        (layout (java.awt.FlowLayout)))

    (.setLayout frame layout)
    (.add frame celsius-label)
    (.add frame celsius-input)
    (.add frame fahrenheit-label)
    (.add frame fahrenheit-output)
    (.add frame convert-button)

    (.addActionListener convert-button
                      (lambda (event)
                        (let* (
                               (celsius-str (.getText celsius-input))
                               (celsius (string->number celsius-str)))
                          (if celsius
                              (let ((fahrenheit (celsius-to-fahrenheit celsius)))
                                (.setText fahrenheit-output (number->string fahrenheit)))
                              (.setText fahrenheit-output "Invalid input")))))

    (.setSize frame 300 150)
    (.setVisible frame #t)))

(create-ui)

Explanation:

    celsius-to-fahrenheit: This function performs the conversion.
    create-ui: This function creates the UI elements (frame, labels, text fields, button) using Java's AWT/Swing classes.
    addActionListener: This attaches an event handler to the "Convert" button.
    The event handler retrieves the Celsius value, performs the conversion, and displays the Fahrenheit value.

Important Notes:

    Android Compatibility: This code uses AWT/Swing, which might not be the best fit for Android's UI. You'd ideally use Android's native UI toolkit (Android Views).
    Android SDK Integration: You'll need to integrate the Android SDK and Kawa runtime into your build process.
    Compilation and Packaging: You'll need to compile the Kawa code and package it into an APK.
    Error Handling: This is a very basic example and lacks robust error handling.
    Android Studio: You will likely need to use Android studio to do the build process.
    Real Android UI: To create a real android UI, you will need to use the android SDK, and call android specific functions from within your Kawa code.

Challenges:

    Integrating the Kawa runtime into an Android app.
    Using Android's native UI toolkit from Kawa.
    Handling Android's lifecycle events.

Next Steps:

    Research how to use Android's native UI toolkit (Android Views) from Kawa.
    Explore Kawa's documentation for Android-specific examples.
    Experiment with compiling and packaging Kawa code for Android.

This example gives you a starting point. Building a fully functional Android app with Kawa will require further research and experimentation.

}}}
-- -- " " -- --  2 {{{
`

Question: I would like to (for context) refer you to a previous question I asked:

- "The task for me would be to create a bit of a web of 'entries' which are words or phrases in different languages. Each entry should also have a general category-tag, i.e. things like 'Greetings', 'Understanding', 'Adjectives' etc - very similar to Lonely Planet, Berlitz and other phrase-books. Swedish and/or English would provide the primary translation for words and phrases in the different languages, and I would then be able to drill myself in and develop along a path through a language from simple phrases going on to more difficult or abstract phrases and reasoning. Also, I'm hoping to leverage one or several languages to provide a 'base-plate' of knowledge in the sense that if I then would like to explore and collect some words and phrases in a new language, I can look back at one or more languages where I have collected and acquired phrases and provide a path for that new language (i.e. 'These 50, 100 or some number of words in my strongest languages provides a good firm 'base-knowledge' for a new language. Let me gradually collect and acquire these entries in my new language')"

Could you help me sketch out and start out with producing a MongoDB-based solution for starting off this project?

____
Absolutely! Let's design a MongoDB schema and outline a basic structure to get your multilingual phrasebook project started.

1. MongoDB Schema Design

We'll use a single collection
called entries to store all your
language entries. Here's a
suggested schema:

+ add 'block|cluster-index'
  learningpath-index

{
  "_id": ObjectId(), // MongoDB's unique document ID
  "term": {
    "en": "Hello", // English translation (or your primary base language)
    "sv": "Hej",  // Swedish translation (or your secondary base language)
    "fr": "Bonjour", // Example: French translation
    // ... more language translations as needed
  },
  "category": "Greetings", // Category tag
  "base_knowledge_reference": ["en:Hello", "sv:Hej"], // Optional: References to base knowledge entries
  "notes": "Formal greeting used in the morning.", // Optional: Additional notes
  "created_at": ISODate(),
  "updated_at": ISODate()
}

Explanation:

- _id: MongoDB's default unique
  identifier for each document.
- term: An object containing
  translations for the entry in
  different languages. The keys are
  language codes (e.g., "en" for
  English, "sv" for Swedish, "fr"
  for French).
- category: A string representing
  the category of the phrase (e.g.,
  "Greetings", "Understanding",
  "Adjectives").
- base_knowledge_reference: An
  optional array of strings that
  reference other entries that form
  the "base knowledge" for this
  entry. Each string is a
  concatenation of the language
  code and the term (e.g.,
  "en:Hello"). This is very usefull
  for your intended use case.

notes: An optional string for
additional notes or context.

- created_at: Timestamp of when the
  entry was created.
- updated_at: Timestamp of when the
  entry was last updated.

2. Basic MongoDB Operations (Conceptual)

Here are some conceptual MongoDB
operations you'll likely use:

Inserting Entries:

db.entries.insertOne({
  term: {
    en: "Goodbye",
    sv: "Adj√∂",
    fr: "Au revoir"
  },
  category: "Greetings",
  created_at: new Date(),
  updated_at: new Date()
});

Querying Entries by Category:

db.entries.find({ category: "Greetings" });

Querying Entries by Language Term:

db.entries.find({ "term.en": "Hello" });

Querying Entries by multiple
languages:

db.entries.find({"term.en": "Hello", "term.fr": "Bonjour"})

Querying Entries by Base Knowledge
Reference:

db.entries.find({ "base_knowledge_reference": "en:Hello" });

Updating Entries:

db.entries.updateOne(
  { "term.en": "Hello" },
  { $set: { "term.es": "Hola", updated_at: new Date() } }
);

- 3. Considerations and Next Steps

- Language Codes: Standardize your
  language codes (ISO 639-1 or ISO
  639-3).
- Indexing: Add indexes to
  frequently queried fields (e.g.,
  category, language term fields)
  for better performance.
- Data Validation: Consider using
  MongoDB's schema validation to
  enforce data integrity.
- Application Logic: You'll need to
  build an application (e.g., using
  Node.js, Python, or another
  language) to interact with the
  MongoDB database. This
  application would handle things
  like:
  - User interface for adding,
    editing, and querying entries.
  - Logic for displaying entries in
    different languages.
  - Logic for displaying base
    knowledge references.
- Base Knowledge Relationships: The
  base_knowledge_reference field is
  powerful. You can use it to
  create a graph-like structure,
  allowing you to traverse related
  entries and build your language
  learning path.
- User Management: If you plan on
  having multiple users, you'll
  need to add user authentication
  and authorization.
- Data Import/Export: Plan for
  importing and exporting data
  (e.g., CSV, JSON) to facilitate
  data migration and sharing.

Example of base knowledge usage

Let's say you have the phrase "How
are you?" in english, and you want
to use the word "you" as a base to
help you understand the next
language.

{
  "_id": ObjectId(),
  "term": {
    "en": "How are you?",
    "fr": "Comment allez-vous?"
  },
  "category": "Greetings",
  "base_knowledge_reference": ["en:you"]
}

Then you have the entry for the
word "you"

{
  "_id": ObjectId(),
  "term": {
    "en": "you",
    "fr": "vous"
  },
  "category": "Pronouns"
}

This will allow you to query all
the phrases that build on the base
knowledge word "you".

Let me know if you'd like to dive
deeper into any of these areas!

- Great great! I think I would like
  to intersperse one quick comment
  here, which is that I think this
  is a very good starting-point for
  me, and what I would like to
  explore going forward (and
  explore in a gradual progressive
  manner) is how to progress from a
  modest starting-point here
  towards a small to medium-sized
  solution for this personal
  language database-project, and
  the goal would be to establish a
  database with the addition of a
  simple desktop- and
  Android-client (including which
  programming-languages to use
  along the way) making it possible
  for me to both add new and
  interesting words and phrases to
  the database, and be able to
  drill myself continuously on new
  words and phrases whether being
  in the office in front of a
  computer, or on the road doing
  exercise or commuting. What I
  mean by this comment is, that
  along the way (as we explore and
  progress along this path of
  developing the app), I will
  continuously want to intersperse
  these comments so we do not end
  up along the 'wrong path' when it
  comes to selecting technologies,
  developing the
  database-structure, etc.

Excellent! That's a very clear and
well-defined goal. I completely
understand your desire for a
gradual, progressive approach,
ensuring that we stay on the right
track for your personal language
learning database.

Here's a breakdown of how we can
proceed, keeping your desired
desktop and Android clients in
mind:

- 1. Technology Choices (Initial Considerations)

- Backend (Database and API):
  - MongoDB (already established):
    We'll stick with MongoDB for
    its flexibility and ease of
    use, especially for handling
    multilingual data.
  - Node.js with Express.js:
    Node.js is excellent for
    building RESTful APIs.
    Express.js simplifies the
    process. This combination is
    cross-platform, which is a
    major benefit.
- Desktop Client:
  - Electron: Allows you to build
    cross-platform desktop
    applications using web
    technologies (HTML, CSS,
    JavaScript). This aligns well
    with Node.js and would allow
    you to reuse code, should you
    choose to use it in other
    areas.
  - Python with PyQt/Tkinter:
    Python is a versatile language,
    and PyQt or Tkinter are good
    for creating desktop GUIs.
- Android Client:
  - React Native: Cross-platform
    mobile development using
    JavaScript and React. This
    would allow for code sharing
    with the desktop client (if you
    choose electron), and the web
    API.
  - Kotlin (Native): Provides
    excellent performance and
    native Android features.
  - Flutter: Cross platform
    framework that provides good
    performance, and one codebase
    for IOS and Android.

2. Development Strategy (Progressive Steps)

[Or use GraphQL]
- Phase 1: Robust API Development
  (Node.js/Express.js)
  - Focus on building a
    well-structured and
    well-documented RESTful API
    that allows for:
    - Creating, reading, updating,
      and deleting entries in the
      MongoDB database.
    - Querying entries by category,
      language, and base knowledge
      references.
    - Implementing basic error
      handling and data validation.
  - This API will serve as the
    foundation for both the desktop
    and Android clients.
- Phase 2: Desktop Client (Electron
  or Python)
  - Start with a basic desktop
    client that allows you to:
    - Display entries in a
      user-friendly way.
    - Add and edit entries.
    - Filter entries by category or
      language.
    - Implement basic search
      functionality.
  - Electron would be advantageous
    for sharing code with the web
    API, and React Native.
- Phase 3: Android Client (React
  Native, Kotlin or Flutter)
  - Develop an Android client that
    mirrors the functionality of
    the desktop client.
  - Consider offline capabilities
    for on-the-go learning.
- Phase 4: Advanced Features
  - Implement spaced repetition
    algorithms for effective
    learning.
  - Add audio pronunciation
    support.
  - Include user accounts and
    progress tracking.
  - Integrate with external
    dictionaries or translation
    services.

- 3. Key Considerations

- Code Reusability: Aim for code
  reusability across the API,
  desktop, and Android clients.
  This will save development time
  and ensure consistency.
- API Design: A well-designed API
  is crucial for maintainability
  and scalability.
- User Experience (UX): Focus on
  creating a simple and intuitive
  user interface for both the
  desktop and Android clients.
- Offline Functionality: Consider
  offline capabilities for the
  Android client, as users may not
  always have internet access.
- Testing: Implement thorough
  testing at each stage to ensure
  the application's reliability.


Next Steps

Let's start with Phase 1: Robust API Development (Node.js/Express.js).

Would you like to start with:

- Setting up a Node.js/Express.js
  project?
- Defining the API endpoints?
- Or would you like to discuss the
  pros and cons of the different
  client side technologies?

I think I would like to just
quickly comment on the technologies
(at least briefly). I think I have
two thoughts I would like to
explore:

- My sense (and correct me if this
  is not accurate or 'needs some
  tweaking') is that if I choose to
  go along the path of using Python
  for a large part of the project,
  that might make the project more
  amenable to integrating
  machine-learning solutions (at
  least some simple models) further
  down the line.

  On the other hand, my day-to-day
  work at the workplace where I am
  currently an apprentice involves
  using C# and DotNet Core. Another
  track for me to explore
  would/might therefore be to
  leverage C# and/or F# to develop
  an API and possibly also a
  desktop-client, and then to use
  technologies like MAUI and/or
  Avalonia to be able to reach both
  web (making my app usable through
  a web-interface on my personal
  Linux-workstation) and to reach
  my Android-device as well.

You've hit on two very relevant
points that deserve careful
consideration. Let's break down the
implications of each approach:

- 1. Python for Machine Learning Potential:

- Accuracy: You are absolutely
  correct. Python is the dominant
  language in the machine learning
  and data science world. Libraries
  like scikit-learn, TensorFlow,
  PyTorch, and spaCy provide a rich
  ecosystem for developing ML
  models.
- Relevance to Language Learning:
  There are many ways ML could
  enhance your project:
  - Spaced Repetition Optimization:
    ML could be used to personalize
    spaced repetition algorithms
    based on your learning
    patterns.
  - Language Analysis: You could
    use NLP techniques to analyze
    the structure and grammar of
    phrases, providing deeper
    insights.
  - Translation Enhancement:
    Integrating with or even
    building simple translation
    models could be possible.
  - Pronunciation Assessment: ML
    could be used to evaluate your
    pronunciation.
- Considerations:
  - While Python is excellent for
    ML, it might add complexity to
    the API development if you're
    not already proficient in
    Python web frameworks (like
    Flask or FastAPI).
  - If you choose python for the
    api, you would most likely want
    to use python for the Desktop
    application as well, to avoid
    having to use several
    languages.

2. C#/.NET for Workplace Synergy and Cross-Platform Potential:

- Accuracy: Yes, C# and .NET Core
  (now just .NET) are very capable
  for building both APIs and
  desktop applications.
- Workplace Relevance: Leveraging
  your existing C# knowledge could
  significantly speed up
  development.
- Cross-Platform with
  MAUI/Avalonia:
  - MAUI (Multi-platform App UI):
    Designed for building native
    mobile and desktop apps from a
    single codebase. It's a strong
    contender for reaching both
    Android and desktop.
  - Avalonia: Another
    cross-platform UI framework
    that supports various
    platforms, including Linux,
    macOS, Windows, and Android.
- Considerations:
  - While .NET has ML.NET, its ML
    ecosystem is not as extensive
    as Python's.
  - If your primary goal is to
    deeply integrate ML, you might
    find yourself needing to bridge
    between .NET and Python.
  - MAUI is relatively new, and
    while promising, it's still
    evolving.

Decision-Making Framework:

- ML Priority:
  - If ML is a core component of
    your vision, Python might be
    the better long-term choice.
  - You could still use .NET for
    the API and desktop client and
    integrate with Python ML
    services when needed.
- Development Speed and Workplace
  Synergy:
  - If you want to leverage your C#
    skills and prioritize rapid
    development, .NET with
    MAUI/Avalonia is a strong
    option.
- Long-Term Maintainability:
  - Consider which language and
    framework you'll be most
    comfortable maintaining in the
    long run.
- Community and Ecosystem:
  - Both Python and .Net have very
    large communities, and
    extensive packages.

My Recommendation:

Given your workplace experience
with C# and .NET, I would recommend
starting with .NET for the API and
desktop/Android clients. This will
allow you to quickly build a
functional application and then
assess the need for deeper ML
integration. If you decide to add
significant ML features, you can
then explore integrating Python
services.

Let's begin by defining the API
endpoints for your .NET API. Would
you like to proceed with that?

- Let's explore this with a couple
  of questions on my part. My sense
  is that it will still be
  beneficial to use MongoDB as the
  database-solution for holding the
  database or 'knowledge-base' of
  words and phrases that will then
  be queried by other technologies.
  Would you agree with that
  statement?

Yes, I absolutely agree. Using
MongoDB as your database solution
is still highly beneficial, even if
you choose .NET for your API and
clients. Here's why:

- Flexibility with Multilingual
  Data:
  - MongoDB's document-oriented
    structure is perfect for
    storing the varying language
    translations within each entry.
    You won't have to deal with
    rigid schema constraints that
    relational databases might
    impose.
- Ease of Development:
  - MongoDB's JSON-like documents
    map well to the objects you'll
    be working with in your API and
    clients, simplifying data
    serialization and
    deserialization.
- Scalability:
  - MongoDB is designed to scale
    horizontally, which is
    important if your database
    grows significantly.
- .NET Integration:
  - There are excellent MongoDB
    drivers for .NET, making it
    easy to connect your .NET API
    to the database.
- Ability to handle complex data:
  - The base_knowledge_reference
    field, that we talked about
    earlier, is very easy to
    implement in MongoDB.
- No Schema Changes:
  - As you add languages, or other
    data to the entries, you will
    not have to alter the Schema of
    your database.

Therefore, I strongly recommend
keeping MongoDB as your database
backend. It will work seamlessly
with your .NET API and provide the
flexibility you need for your
multilingual data.

- Great. Are there good
  language-connections or drivers
  (mind you, I'm not entirely clear
  on the exact terminology, but I
  think you know what I'm angling
  for here) for adding and querying
  the data in the MongoDB database
  using C# and F#?

You're absolutely right, the
terminology you're looking for is
"drivers" or "language connectors."
And yes, there are excellent
drivers for connecting C# and F# to
MongoDB.

- C# Driver:
  - The official MongoDB C# driver
    is called MongoDB.Driver. It's
    a robust and well-maintained
    library that provides all the
    necessary functionality to
    interact with MongoDB from your
    C# code.
  - It's available as a NuGet
    package, making it easy to
    install and integrate into your
    .NET projects.
  - It offers a wide range of
    features, including:
    - Connecting to MongoDB
      servers.
    - Performing CRUD (Create,
      Read, Update, Delete)
      operations.
    - Querying data using LINQ-like
      syntax.
    - Handling data serialization
      and deserialization.
    - Supporting asynchronous
      operations.
- F# Driver:
  - Since F# runs on the .NET
    runtime, you can directly use
    the MongoDB.Driver C# driver
    from your F# code.
  - F# integrates seamlessly with
    .NET libraries, so you'll have
    full access to the driver's
    capabilities.
  - There are also some F# type
    providers that can enhance the
    interaction with MongoDB, but
    the standard C# driver is the
    most common and robust way to
    connect.

Key Points:

- The MongoDB.Driver is the
  standard and recommended way to
  connect .NET applications
  (including those written in C#
  and F#) to MongoDB.
- It's well-documented and actively
  maintained by MongoDB.
- It provides a comprehensive set
  of features for working with
  MongoDB.

Therefore, you can confidently use
MongoDB as your database backend
with your .NET API, knowing that
there's a reliable and efficient
driver available.

- Great. Another small(ish)
  question just on the
  technology-side before we move
  forward: The three primary
  code-editors (in the loose sense
  of that word, going from
  text-editors with
  programming-language support and
  tools all the way up to
  full-blown IDEs) are Vim/NeoVim,
  Emacs, and JetBrains (primarily
  Rider).

- Since MongoDB uses JSON as the
  primary format, could you help me
  explore just for a moment which
  tools and additions are available
  for these three 'editors', if you
  know what I mean?

You're right to consider your
development environment. A good
editor or IDE can significantly
improve your workflow when working
with JSON and MongoDB. Let's
explore the support for Vim/NeoVim,
Emacs, and JetBrains Rider.

1. Vim/NeoVim:

- JSON Support:
  - Vim has built-in JSON syntax
    highlighting.
  - Plugins like vim-json enhance
    JSON support with features
    like:
    - Indentation and formatting.
    - Syntax validation.
    - JSON schema validation.
  - jq Integration:
    - jq is a powerful command-line
      JSON processor. You can
      integrate jq with Vim to:
      - Format JSON.
      - Query and filter JSON data.
      - Transform JSON.
  - MongoDB Integration:
    - There are plugins that
      facilitate working with
      MongoDB from within Vim, but
      they are not as common as the
      JSON plugins.
    - You can always use the
      command line tools for
      MongoDB within a Vim terminal
      buffer.
- Pros:
  - Highly configurable and
    customizable.
  - Lightweight and fast.
  - Excellent for text
    manipulation.
- Cons:
  - Steeper learning curve.
  - Requires manual configuration
    for advanced features.

2. Emacs:

    JSON Support:
        Emacs has excellent built-in JSON support.
        json-mode provides syntax highlighting, indentation, and validation.
        jq Integration:
            Just like in Vim, you can easily integrate jq with Emacs.
        MongoDB Integration:
            Emacs has packages that can interact with MongoDB, but they are not as widely used as the general JSON tools.
            Emacs's mongo-shell can be used within Emacs.
    Pros:
        Extremely powerful and extensible.
        Excellent for working with various file formats.
        Strong community support.
    Cons:
        Steeper learning curve than most IDE's.
        Can be resource-intensive.

- 3. JetBrains Rider:  ____

    JSON Support:
        Rider has excellent built-in JSON support, including:
            Syntax highlighting.
            Code completion.
            Schema validation.
            Formatting.
        MongoDB Integration:
            Rider (through the DataGrip plugin that is included) provides excellent MongoDB integration.
            You can connect to MongoDB databases, browse collections, and execute queries directly within Rider.
            This is a large advantage over vim and emacs.
    Pros:
        Powerful IDE with a wide range of features.
        Excellent MongoDB integration.
        Good support for .NET development.
    Cons:
        Resource-intensive.
        Commercial (though there are free versions for students and open-source developers).

Recommendation:

- For working directly with
  MongoDB, JetBrains Rider (and the
  included DataGrip) offers the
  most seamless and integrated
  experience. Its MongoDB support
  is excellent.
- Vim/NeoVim and Emacs are
  excellent for general JSON
  manipulation and text editing,
  but they require more manual
  configuration for MongoDB
  integration.
- If you are going to be working
  with C# and .NET, Rider is a very
  strong choice.

For your project, if you are going
to be working a lot with the
MongoDB database, I would strongly
recommend Rider.

- If I wanted to install jq on an
  Ubuntu or an Arch system, what
  would be the command to run, and
  (maybe more importantly) what
  would be the package-name - i.e.
  I suspect that the name is not
  simply 'jq', but that it might be
  something more like 'json-tools'
  or something like that.

You're right to be cautious about
package names! Thankfully, jq is
typically packaged under its
straightforward name, jq.

Here's how to install it on Ubuntu and Arch Linux:

Ubuntu (Debian-based systems):

    Command: sudo apt install jq
    Package Name: jq

Arch Linux (and Arch-based systems like Manjaro):

    Command: sudo pacman -S jq
    Package Name: jq

Explanation:

    apt (Advanced Package Tool) is the package manager used in Debian-based distributions like Ubuntu.
    pacman is the package manager used in Arch Linux and its derivatives.
    In both cases, the package name is simply jq.

Therefore, you will not have to worry about looking for another package name.


- Going back to our main
  exploration of setting a basic
  'scheme' for and implementing the
  MongoDB - i.e. I would like to
  get started testing out, adding
  some entries, and then play
  around with the data to build up
  a mock-implementation to be able
  to work forward. Let's say we go
  for the scheme you and I
  discussed 2 or three posts prior
  to my last question, could you
  help me explore how I would go
  about exploring this at the Linux
  command-line?

- Plus, maybe I should be at least a
tad bit more specific:

- What would I need to install from
  the Linux command-line to be able
  to start exploring MongoDB? (I
  suspect it would look something
  like 'sudo apt install mongodb')

- Could you help me explore
  interacting with the database
  using a couple of different
  programming-languages, both the
  standard (i.e. using JavaScript),
  but also Python, and C#/F#, so I
  can determine for myself which
  one of those options seems the
  most simple and viable to me?

- I would also like to explore some
  commands I could run from the
  command-line to start up a
  MongoDB database, where I guess
  there are similar solutions to
  using 'the PostGres shell' (or
  whatever it is called) for
  creating and manipulating
  PostGres databases from the
  command-line


Excellent! Let's get you set up with MongoDB on your Linux system and explore some basic interactions.

1. Installing MongoDB on Linux:

sudo apt update
sudo apt install mongodb

Arch Linux (and Arch-based):

sudo pacman -S mongodb

    Starting the MongoDB Service:
        After installation, you'll need to start the MongoDB service:
            Systemd (most modern distros): sudo systemctl start mongod
            To make it start on boot: sudo systemctl enable mongod
    Checking MongoDB Status:
        To check if MongoDB is running: sudo systemctl status mongod

2. Interacting with MongoDB from the Command Line (MongoDB Shell):

    Starting the MongoDB Shell:
        Type mongo in your terminal. This will open the MongoDB shell, which is a JavaScript environment for interacting with MongoDB.
    Basic Commands:
        Show Databases: show dbs
        Use a Database: use your_database_name (creates the database if it doesn't exist)
        Show Collections: show collections
        Insert a Document:
        JavaScript

db.entries.insertOne({
  term: { en: "Hello", sv: "Hej" },
  category: "Greetings"
});

Find Documents: db.entries.find()
Find Documents with a Condition: db.entries.find({ category: "Greetings" })
Update a Document:

        db.entries.updateOne(
          { "term.en": "Hello" },
          { $set: { "term.fr": "Bonjour" } }
        );

        Delete a Document: db.entries.deleteOne({ "term.en": "Hello" })

3. Interacting with MongoDB from Different Programming Languages:

    JavaScript (Node.js):
        Install the MongoDB Node.js Driver: npm install mongodb
        Example Code:
        JavaScript

    const { MongoClient } = require('mongodb');

    async function main() {
      const uri = 'mongodb://127.0.0.1:27017'; // MongoDB URI
      const client = new MongoClient(uri);

      try {
        await client.connect();
        const database = client.db('your_database_name');
        const entries = database.collection('entries');

        const result = await entries.insertOne({
          term: { en: 'Hello', sv: 'Hej' },
          category: 'Greetings',
        });
        console.log('Inserted document with _id:', result.insertedId);

        const foundEntries = await entries.find({ category: 'Greetings' }).toArray();
        console.log('Found entries:', foundEntries);
      } finally {
        await client.close();
      }
    }

    main().catch(console.dir);

Python:

    Install the PyMongo Driver: pip install pymongo
    Example Code:

    from pymongo import MongoClient

    client = MongoClient('mongodb://127.0.0.1:27017/')
    db = client['your_database_name']
    entries = db['entries']

    result = entries.insert_one({
        'term': {'en': 'Hello', 'sv': 'Hej'},
        'category': 'Greetings'
    })
    print(f'Inserted document with _id: {result.inserted_id}')

    found_entries = list(entries.find({'category': 'Greetings'}))
    print(f'Found entries: {found_entries}')

    client.close()

.NET (C#):

    Install the MongoDB C# Driver (NuGet): Install-Package MongoDB.Driver
    Example Code:

        using MongoDB.Driver;
        using System;
        using System.Threading.Tasks;

        public class Program
        {
            public static async Task Main(string[] args)
            {
                var client = new MongoClient("mongodb://127.0.0.1:27017");
                var database = client.GetDatabase("your_database_name");
                var entries = database.GetCollection<MongoDB.Bson.BsonDocument>("entries");

                var document = new MongoDB.Bson.BsonDocument
                {
                    { "term", new MongoDB.Bson.BsonDocument { { "en", "Hello" }, { "sv", "Hej" } } },
                    { "category", "Greetings" }
                };

                await entries.InsertOneAsync(document);
                Console.WriteLine("Inserted document.");

                var foundEntries = await entries.Find(Builders<MongoDB.Bson.BsonDocument>.Filter.Eq("category", "Greetings")).ToListAsync();
                Console.WriteLine("Found entries:");
                foreach (var entry in foundEntries)
                {
                    Console.WriteLine(entry.ToJson());
                }
            }
        }

        F# code can be very similar to the C# code, since F# uses the same .Net driver.

Key Points:

- The MongoDB shell is excellent
  for quick interactions and
  testing.
- The language drivers provide
  powerful and flexible ways to
  interact with MongoDB from your
  application code.
- You can choose the language that
  best suits your needs and
  preferences.

Let me know if you have any further
questions or if you'd like to
explore any of these examples in
more detail!

- Just one thing to clear up so I
  get a clearer picture: Right
  after starting up the
  Mongo-utility on the
  command-line, checking which
  databases I have (etc) there is a
  small JavaScript-snippet for
  inserting new entries into my
  database. Does that mean that the
  way to insert new entries into my
  MongoDB-database is to run those
  JavaScript-snippets inside my
  MongoDB shell? Have I understood
  that correctly?

Yes, you've understood that perfectly!

When you type mongo into your
terminal and launch the MongoDB
shell, you're entering a JavaScript
environment specifically designed
to interact with your MongoDB
server.

Therefore:

- JavaScript as the Shell Language:
  The commands you run within the
  MongoDB shell are indeed
  JavaScript commands.
- Direct Database Interaction:
  Those JavaScript snippets
  directly manipulate the MongoDB
  database. You can:
  - Insert new documents (entries).
  - Query existing documents.
  - Update documents.
  - Delete documents.
  - And perform various other
    database operations.

So, to reiterate, you're absolutely
correct: the way to insert, query,
and manipulate data within the
MongoDB database from the command
line is by running JavaScript
snippets within the MongoDB shell.

- Perfect. I guess that is a common
  point of confusion for many
  people starting off using
  MongoDB.

- Also (for making the deployment-
  and backup-questions really
  clear), once I have inserted some
  json 'document-entries' into my
  mongo database, is there a simple
  way of saving the database to
  backup, put it under
  version-control or such?

Yes, that's a very common point of confusion, and it's great that we've cleared it up!

And you're absolutely right to
consider backup and version control
early on. Data safety is crucial.
Here's a breakdown of how you can
back up and manage your MongoDB
data:

1. Database Backup:

    mongodump:
        This is the primary tool for creating backups of your MongoDB databases.
        It exports the data in BSON format, which is a binary representation of JSON.
        Command: mongodump --db your_database_name --out /path/to/backup/directory
            This command will create a directory at /path/to/backup/directory containing a BSON file for your database.
        To backup all databases, you can simply run mongodump without the --db option.
    File System Backup:
        If you're running MongoDB on a file system that supports snapshots or backups (e.g., LVM snapshots), you can take a snapshot of the data directory.
        This is a lower-level approach but can be very efficient.
        This is not the preferred method, as it can cause database corruption if the mongod process is running while the backup is being performed.
    MongoDB Atlas (Cloud):
        If you're using MongoDB Atlas, the cloud-hosted version, backups are automatically managed.
        Atlas provides point-in-time recovery and other backup features.

2. Database Restore:

    mongorestore:
        This is the tool for restoring MongoDB backups created with mongodump.
        Command: mongorestore --db your_database_name /path/to/backup/directory/your_database_name
            This command will restore the data from the specified backup directory to the database.

3. Version Control:

    Storing Backup Files:
        You can store your mongodump backup files in a version control system like Git.
        This allows you to track changes to your database over time.
        However, keep in mind that BSON files can be large, so you might want to compress them before committing them to Git.
    Storing Seed Data (JSON Files):
        If you have initial seed data for your database, you can store those JSON files in version control.
        This makes it easy to recreate your database from scratch.
        You could also create scripts that create the database, and insert the seed data, and then store those scripts in your version control.

4. Important Considerations:

    Backup Frequency:
        Determine how often you need to back up your database based on your data's importance and the rate of change.
    Backup Retention:
        Decide how long you need to keep your backups.
    Backup Security:
        Encrypt your backups to protect sensitive data.
    Backup Testing:
        Regularly test your backups to ensure they can be restored successfully.

In summary:

    mongodump and mongorestore are your primary tools for backing up and restoring MongoDB databases.
    You can use version control to manage your backup files and seed data.
    Always prioritize backup frequency, retention, and security.

- What is the price-tag for using
  MongoDB Atlas, i.e. it seems like
  an interesting option, but I
  guess there would be some
  price-plan for most users?

- Also, the option of storing
  json-file seed-data also seems
  (at least to my mind right now) a
  viable option, i.e. storing a
  json-representation of my data
  (somewhat similar to storing an
  SQL-file that can recreate a
  database, rather than trying to
  store the entire database), and
  as the database grows in size
  beyond simple test-running, I can
  explore other options at that
  stage

You're absolutely right to consider
the pricing of MongoDB Atlas and to
explore the JSON seed data
approach. Let's break down both:

1. MongoDB Atlas Pricing:

    MongoDB Atlas offers a tiered pricing structure, and it depends on your needs. Here's a general overview:
        Free Tier (M0):
            Atlas provides a free tier that's excellent for development, testing, and small projects.
            It comes with limited storage and resources.
            This is a great place to start.
        Shared Clusters (M2, M5):
            These are shared clusters with limited resources, suitable for small to medium-sized applications.
            Pricing varies based on the region and instance size.
        Dedicated Clusters (M10 and above):
            These are dedicated clusters with more resources and advanced features.
            Pricing scales based on instance size, storage, and other factors.
        Serverless:
            MongoDB Atlas also offers a serverless option, where you pay for what you use. This can be cost-effective for applications with variable workloads.
        Factors Affecting Cost:
            Region: Pricing varies between AWS, Google Cloud, and Azure regions.
            Instance size: Larger instances cost more.
            Storage: Storage costs are separate.
            Backup and data transfer: Additional costs for backups and data transfer.
            Advanced features: Features like encryption and auditing may incur additional charges.
    Recommendation:
        Start with the free tier (M0) to experiment and develop your application.
        As your application grows, you can upgrade to a shared or dedicated cluster based on your needs.
        Always use the Atlas pricing calculator on the MongoDB website to get the most accurate and up to date pricing.

2. JSON Seed Data Approach:

    Advantages:
        Simplicity: JSON files are easy to create and manage.
        Version Control: You can easily store JSON seed data in Git or other version control systems.
        Portability: JSON files are portable and can be used to recreate your database on any MongoDB instance.
        Human-Readable: JSON is human-readable, making it easy to inspect and modify your data.
        Scriptability: you can create scripts that parse the json files, and insert the data into your database.
    Implementation:
        Create JSON files that represent your initial database entries.
        Write scripts (e.g., in JavaScript, Python, or C#) to read the JSON files and insert the data into your MongoDB database.
        Store these scripts in your version control system.
    Considerations:
        This approach is best suited for initial data and smaller datasets.
        As your database grows, you may need to consider more robust backup and restore strategies.
        If the dataset grows very large, parsing and inserting the data can take a long time.
    Recommendation:
        For your initial development and testing, the JSON seed data approach is an excellent choice.
        It's simple, portable, and easy to manage.
        You can always transition to mongodump or MongoDB Atlas backups as your database scales.

In essence, MongoDB Atlas offers a scalable and managed solution, but the JSON seed data approach is a practical and efficient way to get started.


- Great. Could we also go back to
  the previous post (discussing how
  to interact with the MongoDB with
  C#, Python etc) and amend that
  with how to interact with Mongo
  using F#?

Yes, absolutely! Let's add an F#
example to the previous post,
demonstrating how to interact with
MongoDB using F#.

Since F# runs on the .NET runtime,
it uses the same MongoDB.Driver as
C#. The code will be very similar
to the C# example, but with F#'s
functional syntax.

Here's the F# example:

open MongoDB.Driver
open System
open System.Threading.Tasks

[<EntryPoint>]
let main argv =
    task {
        let client = MongoClient("mongodb://127.0.0.1:27017")
        let database = client.GetDatabase("your_database_name")
        let entries = database.GetCollection<MongoDB.Bson.BsonDocument>("entries")

        let document = MongoDB.Bson.BsonDocument(
            [|
                "term", MongoDB.Bson.BsonDocument([| "en", "Hello"; "sv", "Hej" |])
                "category", "Greetings"
            |]
        )

        do! entries.InsertOneAsync(document) |> Async.AwaitTask
        printfn "Inserted document."

        let! foundEntries = entries.Find(Builders<MongoDB.Bson.BsonDocument>.Filter.Eq("category", "Greetings")).ToListAsync() |> Async.AwaitTask

        printfn "Found entries:"
        for entry in foundEntries do
            printfn "%A" (entry.ToJson())
    } |> Async.RunSynchronously

    0

Explanation:

    Open Namespaces:
        open MongoDB.Driver and open System bring in the necessary namespaces.
    [<EntryPoint>]:
        This attribute marks the main function as the entry point of the F# application.
    task { ... }:
        This is an asynchronous computation expression, used to handle asynchronous operations.
    MongoClient and GetDatabase:
        These are used to connect to the MongoDB server and get a reference to the database.
    GetCollection<MongoDB.Bson.BsonDocument>:
        This gets a reference to the "entries" collection, specifying that we're working with BSON documents.
    MongoDB.Bson.BsonDocument:
        This is used to create BSON documents, which are the F# representation of json documents for MongoDB.
    entries.InsertOneAsync(document) |> Async.AwaitTask:
        This inserts the document into the collection asynchronously.
    entries.Find(Builders<MongoDB.Bson.BsonDocument>.Filter.Eq("category", "Greetings")).ToListAsync() |> Async.AwaitTask:
        This finds documents with the specified category and converts the result to a list asynchronously.
    printfn "%A" (entry.ToJson()):
        This prints the JSON representation of each found document.
    Async.RunSynchronously:
        This executes the asynchronous task synchronously.
    NuGet Package:
        As with C#, you'll need to install the MongoDB.Driver NuGet package in your F# project.

Key Points:

- The F# code is very similar to
  the C# code, demonstrating the
  interoperability of F# with .NET
  libraries.
- F#'s functional syntax provides a
  concise and expressive way to
  interact with MongoDB.
- The task { ... } computation
  expression simplifies
  asynchronous operations.

This F# example should give you a
good starting point for interacting
with MongoDB from your F#
applications.

}}}

Android + Windows: =SVDVORAK UTILITY {{{

- Question: I have been working for
  some time both myself and in
  tandem with a relative (who is
  very knowledgeable in the area of
  software-development) on learning
  more about Android
  app-development primarily using
  Kotlin. I have a small but
  nagging problem of being able to
  use a custom SvDvorak setup when
  using a keyboard connected via
  bluetooth to my Android-device.
  Since it seems unlikely to be
  able to get that functionality on
  my phone without rooting it and
  changing the system-files
  directly, I was thinking another
  solution could be to write a
  small headless Android-utility
  that sits as a middle-layer in
  between my external
  keyboard-signal and the system
  and 'translates' keystrokes from
  my keyboard to the right key. One
  example would be that if I press
  the letter g, that should
  translate to the letter i and so
  forth.

That's a very interesting and
practical problem! You're right,
getting a custom keyboard layout
like SvDvorak to work system-wide
on Android without rooting is
challenging. Creating a headless
utility (a background service) to
remap keystrokes is a clever
approach. Here's a breakdown of how
you could tackle this, along with
some considerations:

Conceptual Overview

    Background Service:
        Create an Android service that runs in the background. This service will be responsible for intercepting and modifying keyboard events.
    Input Event Interception:
        Use the InputManager and InputDevice APIs to listen for keyboard events from your Bluetooth keyboard.
        You'll need to filter for events specifically from your external keyboard.
    Key Remapping Logic:
        Implement a mapping table or function that translates the incoming keycodes from your SvDvorak layout to the standard QWERTY (or whatever the device expects) layout.
        For example, if the 'g' key in SvDvorak corresponds to 'i' in QWERTY, your code should perform this translation.
    Injecting Modified Events:
        Use the InputManager to inject the modified key events back into the system. This effectively simulates pressing the correct keys.

Technical Implementation (Kotlin)

Here's a simplified outline of how
you might implement this in Kotlin:

import android.app.Service
import android.content.Intent
import android.os.IBinder
import android.view.InputDevice
import android.view.KeyEvent
import android.view.InputManager
import android.util.Log

class KeyboardRemappingService : Service() {

    private lateinit var inputManager: InputManager
    private val svDvorakToQwertyMap = mapOf(
        KeyEvent.KEYCODE_G to KeyEvent.KEYCODE_I,
        // Add more key mappings here...
    )

    override fun onCreate() {
        super.onCreate()
        inputManager = getSystemService(INPUT_SERVICE) as InputManager
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Start listening for keyboard events
        startListeningForKeyboardEvents()
        return START_STICKY
    }

    private fun startListeningForKeyboardEvents() {
        Thread {
            while (true) {
                val devices = InputDevice.getDeviceIds()
                for (deviceId in devices) {
                    val device = InputDevice.getDevice(deviceId)
                    if (device?.sources?.and(InputDevice.SOURCE_KEYBOARD) == InputDevice.SOURCE_KEYBOARD) {
                        //check if the device is a bluetooth device.
                        if(device.getName().contains("Bluetooth", true)){

                            val events = inputManager.getInputDevice(deviceId).getMotionRanges()

                            inputManager.registerInputDeviceListener(object : InputManager.InputDeviceListener {
                                override fun onInputDeviceAdded(deviceId: Int) {}
                                override fun onInputDeviceRemoved(deviceId: Int) {}
                                override fun onInputDeviceChanged(deviceId: Int) {
                                    val device = InputDevice.getDevice(deviceId)
                                    if(device?.sources?.and(InputDevice.SOURCE_KEYBOARD) == InputDevice.SOURCE_KEYBOARD){
                                        val events = inputManager.getInputDevice(deviceId).getMotionRanges()
                                    }
                                }
                            }, null)

                            inputManager.registerInputDeviceListener(object : InputManager.InputDeviceListener {
                                override fun onInputDeviceAdded(deviceId: Int) {}
                                override fun onInputDeviceRemoved(deviceId: Int) {}
                                override fun onInputDeviceChanged(deviceId: Int) {
                                    val device = InputDevice.getDevice(deviceId)
                                    if(device?.sources?.and(InputDevice.SOURCE_KEYBOARD) == InputDevice.SOURCE_KEYBOARD){
                                        val events = inputManager.getInputDevice(deviceId).getMotionRanges()
                                    }
                                }
                            }, null)

                            val keyEvents = inputManager.getInputDevice(deviceId).getKeyCharacterMap()
                            //This is very simplified, and does not actually intercept the keyboard events.
                            //This is where the keyboard events would be intercepted and modified.

                            //Example of how to remap a key.
                            //if (keyEvent.action == KeyEvent.ACTION_DOWN) {
                            //    val originalKeyCode = keyEvent.keyCode
                            //    val mappedKeyCode = svDvorakToQwertyMap[originalKeyCode] ?: originalKeyCode
                            //    if (mappedKeyCode != originalKeyCode) {
                            //        // Inject the modified key event
                            //        val newKeyEvent = KeyEvent(
                            //            keyEvent.downTime, keyEvent.eventTime, keyEvent.action,
                            //            mappedKeyCode, keyEvent.repeatCount, keyEvent.metaState,
                            //            keyEvent.deviceId, keyEvent.scanCode, keyEvent.flags,
                            //            keyEvent.source
                            //        )
                            //        inputManager.injectInputEvent(newKeyEvent, InputManager.INJECT_INPUT_EVENT_MODE_ASYNC)
                            //    }
                            //}
                        }
                    }
                }
                Thread.sleep(100)
            }
        }.start()
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null
    }
}

Important Considerations

    Permissions:
        This type of app might require special permissions, potentially including INPUT_METHOD or accessibility service permissions. The exact permissions will depend on how you implement the input interception and injection.
    Complexity:
        Accurately intercepting and modifying all keyboard events can be complex. You'll need to handle various key combinations, modifiers (Shift, Ctrl, Alt), and special keys.
    Android Security:
        Android's security model is designed to prevent apps from arbitrarily intercepting and modifying input events. You might encounter limitations or restrictions.
    Accessibility Service:
        An accessibility service might be a more viable option. It allows you to monitor user input, and modify it. However, the user must explicitly enable your accessibility service.
    Key Character Map:
        Getting the correct keycodes from the Bluetooth keyboard, and then correctly translating them will be the hardest part of the project.
    Testing:
        Thorough testing is crucial to ensure that your remapping logic works correctly and doesn't introduce unexpected behavior.
    Battery Usage:
        A constantly running background service can impact battery life. Optimize your code to minimize resource usage.

Next Steps

    Research InputManager and KeyEvent:
        Dive deeper into the Android documentation for these classes to understand how to work with keyboard events.
    Start with a Simple Mapping:
        Begin by implementing a simple key remapping (e.g., just a few letters) to test your basic setup.
    Expand the Mapping:
        Gradually expand your mapping table to cover all the keys in your SvDvorak layout.
    Test Thoroughly:
        Test your app with different apps and scenarios to identify and fix any issues.

This is a complex project, but it's definitely achievable. Good luck!

- The accessibility approach seems
  interesting and something we
  might want to explore deeper, so
  maybe you could comment a bit on
  that. Also, I would like to point
  out (which I failed to think
  about until just now) that me to
  some extent but certainly my
  brother is very knowledgeable in
  a range of different technologies
  and languages - including C and
  other very close to the hardware
  options. What I'm thinking now is
  that the app does not necessarily
  have to be written primarily in
  Kotlin (although that might be
  necessary to act as a bridge
  somewhere). What I mean is, both
  he and I have looked in the past
  at a range of different languages
  and solutions, including (just to
  take one small example) one
  article that I have read and
  saved from a guy that wrote a
  tutorial/blog-post about having
  some success in writing small and
  very efficient apps using Gambit
  Scheme which compiles down to
  native and (I think) pretty
  efficient C-based utilities.

You're right, the accessibility
service approach and leveraging
your brother's C expertise open up
some interesting possibilities.
Let's delve into those:

Accessibility Service Approach

    How it Works:
        An accessibility service is designed to help users with disabilities interact with their devices. It can monitor user input, including keyboard events, and provide alternative ways to interact with the device.
        In your case, you can create an accessibility service that listens for keyboard events from your Bluetooth keyboard. When a key is pressed, your service can intercept the event, remap the keycode, and then inject the modified event.
    Advantages:
        Less Invasive: It doesn't require rooting the device or directly manipulating system files.
        Established Framework: Android provides a well-defined framework for accessibility services, making it easier to implement.
        User Control: Users must explicitly enable your accessibility service, which enhances security and privacy.
    Disadvantages:
        Permissions: It requires the BIND_ACCESSIBILITY_SERVICE permission, and users will see a warning when enabling the service.
        Potential Performance Overhead: Intercepting and processing every keyboard event can introduce some performance overhead, especially on less powerful devices.
        Complexity: Handling all possible keyboard events and modifiers can still be complex.
        Android restrictions: Android is designed to limit the amount of control that accessibility services have, to protect the user.
    Implementation Notes:
        You'll need to create a class that extends AccessibilityService.
        Override the onAccessibilityEvent() method to handle keyboard events.
        Use the sendKeyEvent() method to inject modified key events.
        You will need to create an accessibility service configuration xml file.

Leveraging C and Gambit Scheme

    C for Low-Level Input Handling:
        C is an excellent choice for low-level input handling due to its direct access to hardware and operating system APIs.
        You could potentially use the Android Native Development Kit (NDK) to write a C library that interacts with the Linux input subsystem to intercept and modify keyboard events.
        This approach could offer better performance and more fine-grained control over input handling.
    Gambit Scheme for Application Logic:
        Gambit Scheme, with its ability to compile to efficient C code, could be a great way to implement the application logic for your keyboard remapping utility.
        You could write the core remapping logic in Gambit Scheme, compile it to C, and then integrate it with your Android app using the NDK.
        This would allow you to write very efficient code.
    Hybrid Approach:
        A hybrid approach could be the most effective:
            Use C (via the NDK) to handle low-level keyboard input and event manipulation.
            Use Gambit Scheme to implement the key remapping logic.
            Use Kotlin to create the Android service and UI (if needed) that interacts with the C/Gambit Scheme components.
    Advantages of the C/Gambit Scheme Approach:
        Performance: C and compiled Scheme code can offer excellent performance.
        Low-Level Control: C provides fine-grained control over input handling.
        Efficiency: Gambit Scheme can generate very efficient C code.
    Disadvantages of the C/Gambit Scheme Approach:
        Complexity: Integrating C and Scheme code with an Android app can be complex.
        Development Time: Writing and debugging C and Scheme code can take more time than using Kotlin alone.
        Portability: NDK code is platform-specific, so you'll need to compile it for different Android architectures.

Recommendations

    Start with the Accessibility Service:
        Begin by implementing a basic keyboard remapping utility using an accessibility service in Kotlin. This will allow you to quickly test your core remapping logic and identify any potential issues.
    Explore the NDK and C:
        If the accessibility service approach doesn't provide the desired performance or control, then explore using the NDK and C for low-level input handling.
    Consider Gambit Scheme:
        If you're comfortable with Scheme, then consider using Gambit Scheme to implement the application logic. Its ability to compile to efficient C code can offer significant performance benefits.
    Incremental Development:
        Break down the project into smaller, manageable tasks. Start with a simple key remapping and gradually expand the functionality.
    Thorough Testing:
        Test your app thoroughly on different Android devices and with various apps to ensure that it works correctly.

By combining the strengths of Kotlin, C, and Gambit Scheme, you can create a powerful and efficient keyboard remapping utility.

- So the Gambit Scheme approach was
  just to mention one option here.
  The device would not be for sale
  and would be strictly custom made
  for myself and my workflow (at
  least there are no other plans at
  the moment). I also use strictly
  Android devices because of their
  easier accessibility and
  malleability compared to e.g.
  iPhone-devices. Also, I'm very
  keen to use functional approaches
  as much as possible, as I think
  (and correct me if I'm wrong
  here) they may be the best game
  in town when it comes to this
  kind of 'pipe this input and
  translate to something else' kind
  of utility.

You've hit on some excellent
points, and your focus on a custom,
highly personalized workflow is a
significant advantage. Let's refine
the approach based on your
preferences:

Prioritizing Functional Approaches and Customization

    Functional Languages:
        You're absolutely right; functional programming paradigms are exceptionally well-suited for tasks involving data transformation and pipeline processing.
        Languages like Scheme (Gambit or others), Haskell (if you're feeling adventurous), or even Kotlin with a strong emphasis on its functional features (lambdas, higher-order functions, immutable data) can be ideal.
        The core logic of your keyboard remapping utility can be expressed as a series of pure functions, making it easier to reason about, test, and maintain.
    Custom Workflow:
        Since this is a custom tool for your own use, you have the freedom to tailor it precisely to your needs.
        This means you can:
            Implement highly specific key mappings.
            Add advanced features like macros or custom shortcuts.
            Optimize the performance for your particular device and usage patterns.
    Android's Malleability:
        Android's openness is a crucial asset, allowing you to explore various implementation options and fine-tune the system to your liking.
        Even if you start with an accessibility service, you can gradually move towards a more low-level approach using the NDK if needed.

Refined Implementation Strategy

    Functional Core Logic:
        Choose a functional language or utilize Kotlin's functional capabilities to implement the core key remapping logic.
        Define your SvDvorak to QWERTY mapping as a pure function or a data structure that can be easily transformed.
        Consider using a declarative approach to define your key mappings, making them easy to read and modify.
    Accessibility Service as a Starting Point:
        Begin with an accessibility service in Kotlin to quickly prototype and test your remapping logic.
        This allows you to focus on the functional aspects of your code without getting bogged down in low-level details.
    NDK and C (Optional):
        If performance or control becomes a bottleneck, explore using the NDK and C for low-level input handling.
        You can create a C library that intercepts keyboard events and passes them to your functional core logic for remapping.
    Incremental Development and Testing:
        Adopt an iterative development approach, adding features and refinements incrementally.
        Write comprehensive unit tests to ensure that your remapping logic works correctly.
        Test your app thoroughly on your target device and with your typical workflow.
    Configuration and Customization:
        Design your app to be highly configurable, allowing you to easily modify key mappings and add custom features.
        Consider using a configuration file or a simple UI to manage your settings.
    Focus on Efficiency:
        Because this is a personal project, you can focus on making it as efficient as possible.
        This includes reducing latency and minimizing resource usage.

Key Functional Concepts

    Pure Functions: Functions that always produce the same output for the same input and have no side effects.
    Immutability: Data structures that cannot be modified after they are created.
    Higher-Order Functions: Functions that take other functions as arguments or return functions as results.
    Data Transformations: Using functions to transform data from one form to another.
    Pipelines: Composing functions to create a sequence of data transformations.

By embracing functional programming
and focusing on a highly customized
workflow, you can create a powerful
and efficient keyboard remapping
utility that perfectly suits your
needs.

- Great. So could you rank order
  the three avenues mentioned in
  your last answer, maybe as a
  first benchmark according to
  resource-efficiency, i.e. some
  Scheme dialect (I have
  documentation for a whole range
  of them, from TinyScheme to MIT
  Scheme, Kawa, Chez, Chicken etc),
  Haskell, and Kotlin - the latter
  particularly using a functional
  approach?

Alright, let's rank those options in terms of resource efficiency, keeping in mind that "resource efficiency" can have multiple facets (CPU, memory, battery, etc.), and the specific implementation will play a significant role.

Here's my ranking, with explanations:

    Scheme (Optimized Implementation):
        Why it's potentially most efficient:
            Scheme dialects, especially those designed for embedded systems or compilation to native code (like Chicken or Gambit), can produce very efficient machine code.   

The functional nature of Scheme allows for concise and optimized code, and its focus on tail-call optimization can minimize stack usage.  

        When you have a very specific use case, and you are willing to spend the time to optimize, scheme gives very good control.
    Caveats:
        Efficiency heavily depends on the specific Scheme implementation and how you write your code. Some interpreters might be less efficient than compiled code.
        The NDK integration will add some overhead.

Kotlin (Functional Approach, Compiled):

    Why it's highly efficient:
        Kotlin compiles to native bytecode (or native code with Kotlin/Native), which is generally very efficient.
        Kotlin's functional features are well-integrated and optimized.   

        The Android runtime (ART) is highly optimized for Kotlin.
        Kotlin has great interop with C through the NDK.
    Caveats:
        The Java/Kotlin runtime environment introduces some overhead compared to pure native code.
        The accessibility service will add overhead.

Haskell (Compiled):

    Why it's potentially efficient:
        Haskell compilers (like GHC) can produce highly optimized native code.
        Haskell's strong type system and purity can lead to efficient and reliable code.   

        Caveats:
            Haskell's runtime system (RTS) can introduce some overhead, especially for I/O-intensive tasks.
            Integrating Haskell with the Android NDK can be more complex than with C or Kotlin.
            Haskell has a steeper learning curve than Kotlin or Scheme.
            The Haskell run time libraries are larger than some of the Scheme libraries.

Rationale:

    Scheme's Potential: If you're willing to invest time in optimizing your Scheme code and using a compiler that generates efficient native code, it can be the most resource-efficient option.
    Kotlin's Practicality: Kotlin offers a great balance of efficiency, ease of use, and Android integration. Its functional features allow you to write efficient and maintainable code.   

    Haskell's Complexity: While Haskell can produce very efficient code, its runtime system and integration with Android can introduce overhead. It also has a greater learning curve.

Important Notes:

    Micro-optimizations: The actual performance differences between these options might be negligible for your specific use case.
    Development Time: Consider the development time and your familiarity with each language. Kotlin might be the most practical choice if you want to get a working prototype quickly.
    Testing: Thoroughly test your app on your target device to measure its actual performance.

In your specific situation, I would lean toward a highly optimized Scheme implementation, or a very well written Kotlin implementation. If you have the time and skill, the Scheme option has the potential to be the most efficient. If you want to get something working quickly, and still have great efficiency, Kotlin is a very good option.
CHICKEN Scheme
Source icon
call-cc.org
Tail call - Wikipedia
Source icon
en.wikipedia.org
Kotlin Advantages Over Java - Guaran√°
Source icon
guarana-technologies.com
Functional correctness -- Haskell-ing your way to reliable code - media.ccc.de
Source icon
media.ccc.de
Is Kotlin Worth It in 2024? Evaluating the Benefits and Limitations for Developers - Leanware
Source icon
www.leanware.co

Also, when I use my Android-device outdoors, I have come to rely on always carrying an extra battery-pack or even two (i.e. power-banks), so as long as the resource-usage is not too outrageous (i.e. introducing a lot of wear and tear on the device) I think I have that base fairly covered.

That's a very practical approach! Knowing you have a good power backup definitely shifts the focus a bit. If you're less concerned about absolute minimum battery usage, it allows for more flexibility in your implementation choices. Here's how that impacts the decision:

Impact of Power Backup

    Reduced Pressure for Extreme Optimization:
        You don't need to obsess over squeezing every last drop of performance. You can prioritize development speed, maintainability, and features over micro-optimizations.
    Flexibility in Language and Approach:
        You have more freedom to choose languages and frameworks that you are comfortable with, even if they have a slightly higher overhead.
        This means that if you are more comfortable with Kotlin, that is a perfectly viable option.
    Focus on User Experience:
        You can prioritize a smooth and responsive user experience, even if it means using slightly more resources.
        This includes things like:
            Fast key remapping.
            Reliable handling of all key combinations.
            Easy configuration and customization.
    Increased Exploration:
        You can freely explore different approaches and technologies.

Revised Recommendations

    Kotlin (Functional Approach):
        Given your power backup, Kotlin becomes an even stronger contender.
        Its ease of use, excellent Android integration, and good performance make it a very practical choice.
        It also allows for fast prototyping.
    Scheme (if you want to explore):
        If you are very interested in learning and using Scheme, then this is still a viable option.
        If you want to spend the time to optimize it, it could be very efficient.
    Prioritize Maintainability:
        Focus on writing clean, well-structured code that is easy to understand and maintain.
        This will make it easier to add new features and fix bugs in the future.
    Thorough Testing:
        Regardless of the language you choose, thorough testing is essential.
        Test your app with different apps and scenarios to ensure that it works reliably.

In summary:

    With a power backup, Kotlin becomes a very strong option.
    If you have a strong interest in Scheme, it is still viable.
    Focus on maintainability and thorough testing.

Essentially, the power backup removes the stress of absolute resource minimization, allowing you to focus on creating a tool that is both functional and enjoyable to use.

- Could you sketch out some code
  for a Kotlin-solution to the
  problem and maybe as you said
  focusing on using the
  service-based approach? As we
  have discussed, I think relying
  on a mainly functional approach
  could be very beneficial, and (if
  applicable and certainly if
  feasible) if using or introducing
  a reactive approach could be
  useful?

Absolutely. Let's sketch out a
Kotlin solution using a
service-based approach, focusing on
functional programming and
incorporating reactive elements
where appropriate.

Conceptual Structure

    Service:
        A background service (KeyboardRemappingService) to listen for and remap keyboard events.
    Key Mapping Logic:
        A functional component (KeyMapper) to handle the SvDvorak to QWERTY mapping.
    Event Handling:
        Reactive streams (using Flow or RxJava) to process keyboard events asynchronously.
    Accessibility Service:
        An AccessibilityService to capture and inject key events.

Kotlin Code (Conceptual)
Kotlin

import android.accessibilityservice.AccessibilityService
import android.accessibilityservice.AccessibilityServiceInfo
import android.view.KeyEvent
import android.view.accessibility.AccessibilityEvent
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob

class KeyboardRemappingService : AccessibilityService() {

    private val job = SupervisorJob()
    private val scope = CoroutineScope(Dispatchers.Default + job)
    private val keyEventFlow = MutableSharedFlow<KeyEvent>()
    private val keyMapper = KeyMapper()

    override fun onServiceConnected() {
        super.onServiceConnected()
        val info = AccessibilityServiceInfo().apply {
            eventTypes = AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED
            flags = AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS
            feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC
        }
        serviceInfo = info

        keyEventFlow
            .filter { it.action == KeyEvent.ACTION_DOWN }
            .map { keyMapper.remap(it.keyCode) }
            .filter { it != null }
            .onEach { keyCode ->
                val event = KeyEvent(
                    KeyEvent.ACTION_DOWN,
                    keyCode!!
                )
                sendKeyEvent(event)
            }
            .launchIn(scope)
    }

    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
        if (event?.eventType == AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED) {
            val keyEvent = event.parcelableData as? KeyEvent
            if (keyEvent != null) {
                keyEventFlow.tryEmit(keyEvent)
            }
        }
    }

    override fun onInterrupt() {
        job.cancel()
    }

    override fun onDestroy() {
        super.onDestroy()
        job.cancel()
    }

    override fun onKeyEvent(event: KeyEvent?): Boolean {
        if (event != null) {
            keyEventFlow.tryEmit(event)
        }
        return true;
    }
}

class KeyMapper {

    private val svDvorakToQwertyMap = mapOf(
        KeyEvent.KEYCODE_G to KeyEvent.KEYCODE_I,
        // Add more key mappings here...
    )

    fun remap(keyCode: Int): Int? {
        return svDvorakToQwertyMap[keyCode]
    }
}

Explanation

    KeyboardRemappingService:
        Extends AccessibilityService.
        Uses CoroutineScope and SupervisorJob for coroutine management.
        keyEventFlow: A MutableSharedFlow to emit keyboard events.
        KeyMapper: An instance of the KeyMapper class.
        onServiceConnected(): Configures the accessibility service.
        onAccessibilityEvent(): Captures keyboard events and emits them to keyEventFlow.
        onKeyEvent(): Captures key events and emits them to keyEventFlow.
        Uses Flow operators (filter, map, onEach) for reactive event processing.
    KeyMapper:
        Contains the svDvorakToQwertyMap.
        remap(): A pure function that translates keycodes.

Important Notes

    Permissions:
        You'll need to add the BIND_ACCESSIBILITY_SERVICE permission to your AndroidManifest.xml.
        Users will need to enable your accessibility service in their device settings.
    Key Event Handling:
        The code currently filters for KeyEvent.ACTION_DOWN events. You might need to handle other event types (e.g., ACTION_UP) as well.
    Error Handling:
        Add error handling to your code to gracefully handle unexpected events or errors.
    Testing:
        Thoroughly test your app with different apps and scenarios.
    Manifest:
        You must add the accessibility service to your AndroidManifest.xml file.

XML

<service
    android:name=".KeyboardRemappingService"
    android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"
    android:exported="true">
    <intent-filter>
        <action android:name="android.accessibilityservice.AccessibilityService" />
    </intent-filter>
    <meta-data
        android:name="android.accessibilityservice"
        android:resource="@xml/accessibility_service_config" />
</service>

    accessibility_service_config.xml
        Create a xml file named accessibility_service_config.xml in the res/xml folder.
        Add the following to the file:

XML

<accessibility-service xmlns:android="http://schemas.android.com/apk/res/android"
    android:description="@string/accessibility_description"
    android:accessibilityEventTypes="typeViewTextChanged"
    android:packageNames=""
    android:accessibilityFlags="flagReportViewIds"
    android:accessibilityFeedbackType="feedbackGeneric"
    android:notificationTimeout="100"
    android:canPerformGestures="false"
    android:settingsActivity=".MainActivity"/>

    String Resource
        add a String resource to your strings.xml file.

XML

<string name="accessibility_description">Remaps Keyboard keys.</string>

This is a starting point. You'll need to expand it to handle all your SvDvorak mappings and edge cases.

____
- Great. One thing I maybe failed
  to mention is that (without
  having looked at the code above
  in detail) since the app is
  primarily for my own personal
  use, the GUI-part of the app can
  be as minimal as possible, i.e.
  one single icon that represents
  the utility would be perfectly
  sufficient - perhaps an icon that
  could sit on the 'phone desktop'
  and indicate with color or
  looking like a pressed button if
  the utility is active, and
  another color or a button
  'un-pressed' to signal that the
  utility is not active.

Perfect, a minimal GUI is
absolutely feasible and aligns well
with the custom, personal nature of
your project. Here's how we can
adapt the solution to achieve that:

Minimal GUI Approach

    Launcher Icon and Activity:
        Create a simple launcher icon for your app.
        Create a minimal MainActivity that serves as the entry point for your app.
    Toggle Service State:
        The MainActivity will have a single button (or a visual toggle) to start and stop the KeyboardRemappingService.
        You can use a ToggleButton or a custom view to visually represent the service's state.
    Visual Feedback:
        Change the button's color or appearance to indicate whether the service is active or inactive.
        Optionally, you can display a small status notification in the notification bar.

Kotlin Code (Minimal GUI)

1. MainActivity.kt:
Kotlin

import android.content.Intent
import android.os.Bundle
import android.widget.ToggleButton
import androidx.appcompat.app.AppCompatActivity

class MainActivity : AppCompatActivity() {

    private lateinit var toggleButton: ToggleButton

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        toggleButton = findViewById(R.id.toggleButton)

        toggleButton.setOnCheckedChangeListener { _, isChecked ->
            if (isChecked) {
                startService(Intent(this, KeyboardRemappingService::class.java))
            } else {
                stopService(Intent(this, KeyboardRemappingService::class.java))
            }
        }
    }
}

2. activity_main.xml (Layout):
XML

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res/app"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <ToggleButton
        android:id="@+id/toggleButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textOff="Remapping Off"
        android:textOn="Remapping On"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>

3. Modify KeyboardRemappingService.kt:
Kotlin

// ... (existing code)

class KeyboardRemappingService : AccessibilityService() {

    // ... (existing code)

    override fun onDestroy() {
        super.onDestroy()
        job.cancel()
        //Add code here to remove the notification, if you implemented one.
    }
}

4. AndroidManifest.xml (Add MainActivity):
XML

<application
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:roundIcon="@mipmap/ic_launcher_round"
    android:supportsRtl="true"
    android:theme="@style/Theme.YourAppTheme">
    <service
        android:name=".KeyboardRemappingService"
        android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"
        android:exported="true">
        <intent-filter>
            <action android:name="android.accessibilityservice.AccessibilityService" />
        </intent-filter>
        <meta-data
            android:name="android.accessibilityservice"
            android:resource="@xml/accessibility_service_config" />
    </service>
    <activity android:name=".MainActivity" android:exported="true">
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
    </activity>
</application>

Explanation

    MainActivity:
        Sets up the ToggleButton.
        Starts and stops the KeyboardRemappingService based on the button's state.
    activity_main.xml:
        Defines the layout with a single ToggleButton.
    Visual Feedback:
        The ToggleButton's text and state provide visual feedback.
    AndroidManifest:
        The MainActivity is added as the launcher activity.

Enhancements

    Custom Toggle Button:
        You can create a custom view or use a library to create a more visually appealing toggle button.
    Notification:
        Display a small notification in the notification bar to indicate that the service is running.
    Settings:
        If you need to add configuration settings (e.g., custom key mappings), you can add a settings activity or use a configuration file.

This minimal GUI approach keeps the app simple and focused on its core functionality, which aligns perfectly with your requirements.

- Excellent. And(!!), just as a
  quick thought - something that
  crossed my mind just this instant
  actually: What just occurred to
  me is that (at least looking just
  a bit past the present moment),
  what I might be interested in is
  to widen the scope just slightly
  and go for a solution that would
  work on both Android, and(!!) on
  Windows. A bane for me on Windows
  has been being able to install or
  use some utility to accomplish
  the same functionality. I have
  been sketching out a solution
  using AutoHotKey, but if I could
  use some language (I'm thinking
  Flutter or something similar),
  that would REALLY be interesting
  to me.

That's a fantastic idea! Expanding the scope to include Windows support would significantly increase the utility of your project. Using a cross-platform framework like Flutter is a very promising approach. Let's explore that:

Cross-Platform Approach (Flutter)

____
    Flutter's Advantages:
        Cross-Platform Development: Flutter allows you to write code once and deploy it to multiple platforms (Android, iOS, Windows, macOS, Linux, web).
        Native Performance: Flutter apps are compiled to native code, providing excellent performance.
        Rich UI Framework: Flutter provides a rich set of UI widgets and tools for creating visually appealing and responsive apps.
        Dart Language: Dart is a modern, object-oriented language that is easy to learn and use.
        Community and Ecosystem: Flutter has a large and active community, and a growing ecosystem of packages and plugins.
    Challenges:
        Low-Level Input Handling: Intercepting and modifying keyboard events at a low level can be challenging in a cross-platform environment. You'll likely need to use platform-specific plugins or native code.
        Accessibility Services (Android) and Input Hooks (Windows): You'll need to handle platform-specific APIs for input event interception.
        Plugin Development: You might need to develop custom plugins for platform-specific functionality.
    Conceptual Architecture:
        Flutter App:
            The core application logic and UI will be written in Dart.
            The app will handle key mapping logic and user configuration.
        Platform-Specific Plugins:
            Android: Use a Flutter plugin that integrates with the Android Accessibility Service to intercept keyboard events.
            Windows: Use a Flutter plugin that integrates with Windows input hooks or low-level keyboard APIs.
        Key Mapping Logic (Dart):
            Implement the SvDvorak to QWERTY mapping logic in Dart, making it platform-independent.
        Service/Background Process:
            Implement the key remapping functionality as a background process or service on both platforms.

Implementation Steps

    Flutter Setup:
        Install Flutter and set up your development environment.
    Create a Flutter Project:
        Create a new Flutter project.
    UI Development:
        Create the UI for your app, including a toggle button and any necessary configuration settings.
    Platform-Specific Plugins:
        Android:
            Create a Flutter plugin that integrates with the Android Accessibility Service.
            Use the plugin to capture and inject key events.
        Windows:
            Explore existing Flutter plugins for Windows input handling.
            If necessary, create a custom plugin that uses Windows input hooks or low-level keyboard APIs.
    Key Mapping Logic (Dart):
        Implement the key mapping logic in Dart.
    Background Processing:
        Implement the key remapping functionality as a background process or service on both platforms.
    Testing:
        Thoroughly test your app on both Android and Windows.

Considerations

    Plugin Availability: The availability and quality of Flutter plugins for Windows input handling will be a crucial factor.
    Native Code Integration: You might need to write some native code (Kotlin/Java for Android, C++ for Windows) to handle platform-specific input APIs.
    Performance: Cross-platform performance is generally good with Flutter, but you'll need to optimize your code for both platforms.

Benefits

    Code Reusability: Write code once and deploy it to multiple platforms.
    Consistent UI: Maintain a consistent UI across platforms.
    Faster Development: Speed up development by using a single codebase.

By using Flutter, you can create a cross-platform keyboard remapping utility that works seamlessly on both Android and Windows, providing a consistent and efficient experience.

- My concern when it comes to
  Flutter (although it might not be
  a complete showstopper) is being
  able to include and leverage the
  functional and reactive
  approaches we talked about. Could
  you comment a bit about that, and
  also if languages like D or Rust
  may be interesting just to glance
  at, although they definitely have
  their 'kinks' (difficulty, reach
  etc, although their respective
  performances are excellent)

You've raised valid concerns about Flutter's compatibility with functional and reactive approaches, and you're right to consider alternatives like D and Rust. Let's break down those points:

Flutter and Functional/Reactive Programming

    Dart's Capabilities:
        Dart, the language used in Flutter, has functional programming features, including:
            First-class functions: Functions can be assigned to variables and passed as arguments.
            Lambdas: Anonymous functions.
            Collection methods: map, filter, reduce, etc.
        However, Dart's functional features are not as extensive as those in dedicated functional languages like Haskell or Scheme.
    Reactive Programming in Flutter:
        Flutter has excellent support for reactive programming through:
            Streams: Dart's built-in Stream class allows you to work with asynchronous data streams.
            rxdart package: A popular package that provides a rich set of reactive operators based on the ReactiveX (Rx) standard.
            Flutter's widget tree is rebuilt reactively, so that when data changes, the UI updates.
        Therefore, while Dart is not a pure functional language, it is highly possible to use reactive programming, and a functional style of programming.
    Limitations:
        Dart's type system is not as powerful as Haskell's, which limits some advanced functional programming techniques.
        The emphasis in Flutter is on UI development, which can sometimes lead to less pure functional code.

D and Rust as Alternatives

    D:
        D is a systems programming language that offers a blend of C++, Java, and Python features.
        It has good support for functional programming and metaprogramming.
        D can be compiled to native code, providing excellent performance.
        Pros:
            Excellent performance.
            Good functional programming support.
            Metaprogramming capabilities.
        Cons:
            Smaller community and ecosystem compared to Flutter.
            Cross-platform UI development can be more challenging.
            Less mobile support than Flutter.
    Rust:
        Rust is a systems programming language that focuses on safety, performance, and concurrency.
        It has excellent support for functional programming and is known for its memory safety.
        Rust can be compiled to native code, providing excellent performance.
        Pros:
            Excellent performance and memory safety.
            Strong functional programming support.
            Growing community and ecosystem.
        Cons:
            Steeper learning curve.
            Cross-platform UI development can be more challenging.
            Less mobile support than Flutter.
    Suitability for Your Project:
        D and Rust are excellent choices if performance and low-level control are your top priorities.
        However, they require more effort for cross-platform UI development.
        Rust is gaining more and more mobile support, and there are UI frameworks being developed for rust, so it is a language that is worth keeping an eye on.
    Recommendation:
        - If cross-platform UI development is crucial, Flutter with rxdart and a functional approach is a good choice.
        If performance and low-level control are paramount, and you're willing to invest more time in platform-specific UI development, Rust is a strong contender.
        If you are very comfortable with C/C++ like languages, then D is also a good option.
        It is worth noting that it is possible to use Rust or D for the backend logic and use Flutter for the UI. This hybrid approach could give you the best of both worlds.

In summary, Flutter can handle functional and reactive programming, but D and Rust offer more robust support for those paradigms at the cost of increased complexity in UI development.

- Right. AND(!!) since the
  UI-requirements for my particular
  app - especially at the initial
  stages - are really very minimal,
  then both D (which is a community
  where I have excellent
  connections with several core
  developers) and Rust become very
  interesting alternatives I think.

That's excellent! Given your strong connections within the D community and your minimal UI requirements, D becomes a very compelling option. Rust is also an excellent choice, but your existing connections with D developers provide a significant advantage. Let's explore how you can leverage D for your cross-platform keyboard remapping utility:

D Approach

    D's Strengths:
        Performance: D is a systems programming language that compiles to native code, providing excellent performance.
        Functional Programming: D supports functional programming paradigms, including first-class functions, lambdas, and immutable data.
        Metaprogramming: D's metaprogramming capabilities allow you to write highly flexible and efficient code.
        Cross-Platform: D can be compiled for various platforms, including Windows and Android.
        Community: Your connections within the D community will be invaluable for support and guidance.
    Implementation Strategy:
        Core Logic (D):
            Implement the key remapping logic in D, leveraging its functional and metaprogramming capabilities.
            Create a D library that handles the SvDvorak to QWERTY mapping.
        Platform-Specific Input Handling:
            Windows:
                Use D's Windows API bindings to intercept keyboard events using input hooks.
                Inject modified key events using the SendInput function.
            Android:
                Use the Android NDK to create a D library that interacts with the Linux input subsystem.
                Alternatively, explore using the accessibility service approach, but implemented from D with the help of the NDK.
            Use the D programming language, and the NDK to create a shared library, that can be called from a very small Kotlin wrapper application, that starts the service.
        Minimal UI (Platform-Specific):
            Windows:
                Use a simple console application or a minimal GUI framework (e.g., Win32 API, or a light weight cross platform GUI library, that can be called from D) to provide a toggle button and status indicator.
            Android:
                Create a very basic Kotlin wrapper application with a single toggle button to start and stop the D service.
        Build System:
            Use a cross-platform build system (e.g., CMake, Meson) to manage the build process.
    Advantages:
        Excellent performance.
        Fine-grained control over input handling.
        Leverage your D community connections.
    Considerations:
        Platform-specific UI development will require more effort.
        Android NDK integration can be complex.
        Testing on multiple platforms is critical.
    D specific advantages:
        D has good support for low level interaction, and the standard library, Phobos, is very extensive.
        D's compile time features, can be used to create very optimized mapping tables.

Next Steps

    D Development Environment:
        Set up your D development environment.
    Key Mapping Library:  ___hm_eng
        Start by implementing the key remapping logic in D.
    Windows Input Handling:
        Explore D's Windows API bindings and implement keyboard event interception and injection.
    Android NDK Integration:
        Experiment with the Android NDK to create a D library for Android input handling.
    Minimal UI:
        Create simple UI components for Windows and Android.
    Testing:
        Thoroughly test your app on both platforms.

By leveraging D's strengths and your community connections, you can create a highly efficient and customized keyboard remapping utility.


}}}


Good. Another question regarding Android: One thing that would really level up my use of Android as an integrated part of my workflow is if I could cast my Android-device's screen to my computer (both Windows and Linux) and preferably also vice-versa, i.e. if I could cast my computer's screen to my Android device.

Of course (if possible) it would be great if I could access and manipulate the screen I cast to my desktop-screen, and also the other way around, i.e. being able to control my computer when I cast my desktop/laptop screen to my Android device.

You're looking for solutions that provide robust screen mirroring and remote control capabilities between your Android device and both Windows and Linux computers. Here's a breakdown of the best options, focusing on functionality and cross-platform compatibility:

1. Scrcpy (Screen Copy):

    Functionality:
        Scrcpy is a free and open-source command-line tool that allows you to display and control your Android device's screen on your computer (Windows, Linux, macOS).
        It offers excellent performance, low latency, and high-quality screen mirroring.
        You can control your Android device with your computer's keyboard and mouse.
        It also allows you to record the screen and take screenshots.
    Pros:
        Very low latency.
        High performance.
        Free and open-source.
        Cross-platform compatibility.
    Cons:
        Requires ADB (Android Debug Bridge) setup.
        Command-line interface (though there are some GUI wrappers available).
        Does not cast the computer's screen to the android device.
    Setup:
        Install ADB on your computer.
        Enable USB debugging on your Android device.
        Connect your Android device to your computer via USB.
        Run the scrcpy command in your terminal.
    Best for: Developers and users who want high performance and low latency.

2. KDE Connect:

    Functionality:
        KDE Connect is a cross-platform application that integrates your Android device with your desktop.
        It offers screen mirroring, remote control, file transfer, notifications syncing, and more.
        It works wirelessly over your local network.
    Pros:
        Wireless connectivity.
        Multiple features beyond screen mirroring.
        Cross-platform compatibility (Linux, Windows, Android).
    Cons:
        Screen mirroring performance may vary depending on your network.
        The Windows version, while functional, can be less streamlined than the Linux version.
    Setup:
        Install KDE Connect on your computer and Android device.
        Pair your devices over your local network.
    Best for: Users who want a comprehensive integration solution.

3. TeamViewer/AnyDesk:

    Functionality:
        These are popular remote desktop applications that offer screen mirroring and remote control.
        They work over the internet, so you can control your devices from anywhere.
        They offer apps for Windows, Linux, and Android.
    Pros:
        Remote access over the internet.
        Easy to use.
        Cross-platform compatibility.
        Works in both directions.
    Cons:
        May have latency issues, especially over slow internet connections.
        Free versions may have limitations.
        Security concerns if not used carefully.
    Best for: Remote access and control over the internet.

4. Vysor:

    Functionality:
        Vysor allows you to view and control your Android device on your computer.
        It works via USB or Wi-Fi.
        It offers screen mirroring, keyboard and mouse control, and file transfer.
    Pros:
        Easy to use.
        Works via USB or Wi-Fi.
        Cross platform.
    Cons:
        Free version has limitations.
        Latency can be an issue over Wi-Fi.
    Best for: Users who want a simple and convenient screen mirroring solution.

Key Considerations:

    Latency: Scrcpy generally offers the lowest latency, making it ideal for real-time control.
    Wireless vs. Wired: KDE Connect and TeamViewer/AnyDesk offer wireless connectivity, while Scrcpy and Vysor can work via USB.
    Features: KDE Connect and TeamViewer/AnyDesk offer a wider range of features beyond screen mirroring.
    Security: Be cautious when using remote access tools over the internet, and ensure you're using strong passwords and secure connections.

For most users, Scrcpy will be the best option for casting the android screen to the computer, and TeamViewer or AnyDesk will be the best option for casting the computer screen to the android device.

Many thanks, and I'll definitely jot that down and try it out. Another question that (when established) will be an absolute game-changer for me.

A couple of weeks ago I posed a couple of questions about being able to connect to and read and write to and from cloud-services (like Dropbox or Google Drive) directly from an Android device.

I have granted access for Termux to my Android-device, and I have installed the rclone-utility, so I'm almost there.

The last piece of configuration I would need to setup would be the following:



How to Unmount:

    Use the fusermount -u command, followed by the mount point. For example:
    Bash

fusermount -u ~/dropbox

or
Bash

    fusermount -u ~/gdrive

    This command will gracefully unmount the specified directory.

What Happens If You Don't Unmount:

    Termux Closure: When you close Termux, Android will typically terminate the rclone process, which will effectively unmount the directory. However, there's a small risk that pending write operations might not be fully completed.
    Android Shutdown/Reboot: Similar to closing Termux, a shutdown or reboot will terminate the rclone process.
    Potential for data corruption: If rclone is in the middle of writing a file when it is forced to close, it is possible that the file will become corrupted.

Best Practices:

    Develop a Habit: Make it a habit to unmount your rclone mounts before closing Termux or shutting down your device. It only takes a few seconds and can save you from potential headaches.
    Scripting: If you frequently use rclone mounts, consider creating a simple script that unmounts all your mounts before exiting Termux.

In summary, while Android and Termux will usually handle unmounting automatically, manually unmounting is the safest and most reliable approach.

When I try writing 'fuse' in Termux and then pressing tab (for completion), the only name that pops up is 'fuser'. Does that mean that I have to install 'fusermount' in Termux using pkg?

Yes, you're absolutely right! The fact that "fusermount" isn't auto-completing when you type "fuse" and press Tab in Termux indicates that it's not currently installed.

Here's a breakdown and the solution:

Why "fusermount" Is Needed:

    FUSE (Filesystem in Userspace): FUSE is a kernel module that allows non-privileged users to create their own filesystems.   

fusermount: This utility is part of the FUSE package and is used to mount and unmount FUSE filesystems. rclone relies on fusermount to mount cloud storage as local directories.  

How to Install "fusermount" in Termux:

    Update Packages: It's always a good practice to update your package list before installing new packages.
    Bash

pkg update

Install the "fuse-utils" Package: The fusermount utility is included in the fuse-utils package.
Bash

    pkg install fuse-utils

    Verify Installation: After the installation is complete, try typing "fusermount" and pressing Tab. It should now auto-complete.

Important Considerations:

    Termux Permissions: Ensure that Termux has the necessary permissions to access your device's file system.
    Root Access: FUSE itself does not require root access, which is one of its key advantages.

By installing the fuse-utils package, you'll have the fusermount utility available in Termux, allowing you to properly mount and unmount rclone filesystems.
Filesystem in Userspace - Wikipedia
Source icon
en.wikipedia.org
FUSE ‚Äî The Linux Kernel documentation
Source icon
www.kernel.org
Rclone - rsync for cloud storage - MSU HPCC User Documentation
Source icon
docs.icer.msu.edu

The message I got back was 'Unable to locate package fuse-utils'

You're encountering a common issue with Termux package management. The "Unable to locate package fuse-utils" message means the package name or the repository information is slightly off. Here's how to fix it:

The Correct Package Name:

    The correct package name in Termux is simply fuse, not fuse-utils.

Steps to Install:

    Update Repositories (Again):
        It's crucial to ensure your package lists are up-to-date.
    Bash

pkg update

Install the fuse Package:

    Use the correct package name:

Bash

    pkg install fuse

    Verify Installation:
        After installation, try typing fusermount and pressing Tab. It should now autocomplete.
        You can also verify the installation by typing which fusermount in the terminal. If it is installed, it will print the path to the fusermount executable.

Explanation:

    Termux uses a slightly different package naming convention than some other Linux distributions.
    By installing the package named fuse, you will also install the fusermount utility.

By following these corrected steps, you'll successfully install fusermount and be able to proceed with your rclone mount configuration.

I got the same error-message. Is there a flag or separate command I could run with pkg whereby I can query for fusermount - in a way similar to choco search packagename on Windows or apropos on Linux - to retrieve the right name?

Yes, you're right to look for a search functionality within pkg. Termux, being based on Debian, uses apt (Advanced Package Tool) under the hood, even though it presents a simplified pkg interface. You can leverage apt's search capabilities directly within Termux.

Here's how you can search for packages containing "fusermount":

Using apt search:

    Update Package Lists (If Not Already Done):
    Bash

pkg update

Use apt search with a Regular Expression:
Bash

apt search fusermount

or to do a more thorough search, including descriptions:
Bash

    apt search fuse | grep fusermount

    This command will search the package lists for any packages that contain "fusermount" in their names or descriptions.

    Interpret the Results:
        The output will show a list of matching packages, along with brief descriptions.
        Look for the package that seems most relevant. In this case, you're likely to find the fuse package.

Explanation:

    apt search is a powerful tool for finding packages in Debian-based systems.
    The | grep command pipes the output of apt search to grep, which filters the results to show only lines containing "fusermount." This is useful for more specific searches.

Why pkg search Might Not Be Ideal:

    While Termux's pkg command is designed for simplicity, it may not expose all of apt's search capabilities.
    Using apt search directly gives you more control and flexibility.

Troubleshooting if apt search Fails:

    Repository Issues: If apt search doesn't return any results, there might be a problem with your Termux repositories.
        Try running pkg update again to refresh the repository lists.
        If you have any issues with your internet connection, this can also cause issues.
    Termux Architecture: Ensure that your Termux installation matches your device's architecture (e.g., arm64).

By using apt search, you'll be able to effectively search for packages and find the correct name for fusermount or any other package you need.

The information I've gathered after doing a bit of searching on the internet is that it seems some people have had to obtain the sources for fusermount and compile them.

You're right to be thorough in your research. It's true that in some very specific scenarios, especially with highly customized Android setups or older Termux installations, compiling fusermount from source might be necessary. However, this is generally a last resort and often indicates a deeper underlying issue.

Here's a breakdown of why compiling from source might be suggested and when it's appropriate:

Reasons for Compiling from Source:

    Missing Package: If the fuse package is genuinely unavailable in your Termux repositories (which is unusual), compiling from source is a workaround.
    Custom Builds: Some users might have highly customized Android ROMs or Termux setups that require specific versions of fusermount or FUSE.
    Architecture Incompatibilities: In rare cases, there might be architecture incompatibilities between the pre-built packages and your device.
    Learning/Experimentation: Compiling from source can be a valuable learning experience for understanding how FUSE and fusermount work.

Why It's Generally Not Necessary:

    Termux Repositories: Termux typically provides up-to-date packages, including fuse, in its repositories.
    Complexity: Compiling from source can be complex, especially for users who are not familiar with Linux build tools and dependencies.
    Maintenance: Maintaining a self-compiled fusermount installation can be challenging, as you'll need to manually update it when new versions are released.

Steps to Compile from Source (If Absolutely Necessary):

    Install Build Tools:
        You'll need to install essential build tools like gcc, make, and pkg-config.
    Bash

pkg install clang make pkg-config

Download FUSE Source Code:

    Download the FUSE source code from the official FUSE website or a trusted repository.   

    Extract and Configure:
        Extract the source code archive and navigate to the extracted directory.
        Run the ./configure script to prepare the build environment.

    Compile:
        Run the make command to compile the source code.

    Install:
        Run the make install command to install the compiled binaries.

Important Considerations:

    Dependencies: Compiling from source might require installing additional dependencies.
    Android NDK: For more complex builds, you might need to use the Android NDK (Native Development Kit).
    Termux Environment: Ensure that your Termux environment is properly configured for building native code.

Recommendation:

    Before resorting to compiling from source, double-check your Termux repositories and ensure that you're using the correct package name (fuse).
    If you're still having trouble, consider seeking help from the Termux community or forums.

In most cases, installing the fuse package from the Termux repositories will be the simplest and most reliable solution.





I have toyed with the thought of obtaining another Android-device that may pack a better punch than the phone I'm currently using and maybe you could give me some suggestions. What I'm looking for is a phone - which would be preferable to me compared to e.g. a tablet. My ideal device would have a bigger screen and more processing power than my current phone - an Android A20, and also a bigger screen, but not being as large as the largest phones or a tablet, as both of those types of devices would be a bit too (or much too) bulky to take along for physio-exercises like running etc.

You're looking for a sweet spot: a phone with a larger screen and more power than your A20, but not so large that it becomes cumbersome for activities like running. This means we're aiming for something in the "phablet" or larger-than-average phone category, but still manageable. Here are some suggestions, keeping in mind that availability and pricing can vary:

Key Considerations:

    Screen Size: Aim for something in the 6.5-6.8 inch range. This offers a noticeable upgrade from the A20's 6.4 inches without being overly bulky.
    Processor: Look for a mid-range to high-mid-range processor. Snapdragon 700 or 800 series, or equivalent MediaTek or Exynos chips, would be a significant improvement.
    RAM: 6GB or 8GB of RAM is ideal for smooth performance.
    Battery Life: A larger battery is essential for extended use, especially if you're using the device for demanding tasks or outdoor activities.
    Durability: If you plan on using the phone for physical activities, consider a device with some degree of water and dust resistance.

Phone Recommendations:

    Google Pixel 7a/8a:
        These phones offer excellent performance, a great camera, and a clean Android experience.
        They are a good size, not being excessively large.
        The Pixel series is known for its timely software updates.
        The "a" series is a good value for the price.
    Samsung Galaxy A54/A55:
        Samsung's A series provides a good balance of features and price.
        The A54/A55 have a vibrant display, a decent camera, and good battery life.
        Samsung has also improved their software update policy.
    OnePlus Nord 3:
        OnePlus Nord phones are known for their fast performance and smooth software.
        They offer a good balance of features and price.
        OnePlus devices usually have fast charging.
    Motorola Edge (series):
        Motorola has been producing some good mid-range to high mid-range devices.
        They typically have near stock android, and good battery life.
        The Motorola Edge series of phones have a good screen size.

Tips for Choosing:

    Read Reviews: Check reputable tech websites and YouTube channels for reviews of the phones you're considering.
    Compare Specs: Use websites like GSMArena to compare the specifications of different phones.
    Consider Your Budget: Prices can vary significantly, so set a budget and stick to it.
    Check for Deals: Look for deals and discounts from retailers and carriers.
    Physical size: Go to a store and physically hold the phones that you are considering. This is the best way to determine if the device will be too large for your needs.

When considering the physical exercise aspect, a good protective case is always recommended.

I also had a quick look in a store and got the recommendation that maybe a Samsung Galaxy S25 might fit my needs. Could you comment on that device?

The Samsung Galaxy S25 series, particularly the S25 Ultra, represents Samsung's top-tier flagship smartphones. Here's a breakdown of what that means and how it might fit your needs:

Key Strengths of the Samsung Galaxy S25 Series:

    Top-Tier Performance:
        The S25 series will feature the latest and most powerful processors, ensuring incredibly smooth performance for any task, from demanding apps to gaming.
        This is a significant upgrade in processing power compared to your current A20.
    Exceptional Camera System:
        Samsung's Galaxy S Ultra phones are renowned for their advanced camera technology. Expect a versatile and high-quality camera setup that excels in various lighting conditions.
    Premium Display:
        The Dynamic AMOLED displays on the S25 series are known for their vibrant colors, deep blacks, and high refresh rates, providing an immersive viewing experience.
    Advanced Features:
        These phones will come packed with the latest features, including enhanced AI capabilities, improved connectivity, and advanced security features.
    Build Quality:
        The S25 series is built with premium materials, making for a very durable device.

Considerations for Your Needs:

    Size and Portability:
        The "Ultra" models, while offering the most features, are also the largest. Consider the standard S25 or S25+ models if you prioritize a more compact form factor.
        It is very important to try and hold the phone in your hand to see if the size is acceptable for your needs.
    Price:
        Flagship phones like the Galaxy S25 series come with a premium price tag.
    Overkill?
        If your primary needs are general use, browsing, and some light apps, the S25 series might be more powerful than you require. However, if you want the best performance and camera capabilities, it's an excellent choice.
    Fitness use:
        Samsung does a very good job of making there phones water and dust resistant. This is very good for using the phone during physical exercise.

In summary:

    The Samsung Galaxy S25 series is a fantastic choice if you want a top-of-the-line Android phone with excellent performance, a great camera, and a premium display.
    However, consider the size and price before making a decision.
    If you want the best of the best, the S25 Ultra is a very strong contender. If you want a great phone that is a little more compact, then look at the S25, or S25+.

I hope this helps!

If I wanted to go for even a bit bigger screen size, that might actually be feasible as well. I think the only upper constraint size-wise would be to be able to get hold of one of those soft cases used to wrap the phone when going for a run - i.e. I don't know what they're called in English, but they're fairly common and are used to 'strap the phone' to the side of ones arm, if you know what I mean.

Yes, I know exactly what you're referring to! Those are called armband phone holders or simply phone armbands.

If you're willing to consider a slightly larger screen size, knowing that you can still use a phone armband, that opens up your options. Here's a breakdown of considerations and some potential devices:

Screen Size Considerations:

    Up to 7 Inches:
        Many "phablet" style phones and some of the larger "Ultra" models fall into this range.
        Armbands are readily available for phones in this size category.
    Armband Compatibility:
        When choosing a larger phone, pay close attention to the dimensions (height, width, and thickness).
        Check the specifications of the armband to ensure it can accommodate your chosen phone.
        Many armbands are designed to be adjustable, but there are limits.

Device Recommendations (Larger Screen Options):

    Samsung Galaxy S25 Ultra (or future Ultra models):
        These phones typically have the largest screens in Samsung's lineup.
        They offer top-tier performance and features.
        Make sure to find an armband that is compatible with the "Ultra" models, as these are often the largest phones on the market.
    Samsung Galaxy Z Fold Series:
        These foldable phones offer a tablet-like experience when unfolded.
        When folded, they are still a large phone.
        They are great for media consumption and productivity.
        Finding an armband for these may be more difficult, but there are some available.
    OnePlus Open:
        This is another foldable phone, that is in direct competition with the Samsung Fold series of phones.
        This phone also offers a large screen, when unfolded.
    Google Pixel Fold:
        Google's foldable phone.
        This phone also offers a large screen, when unfolded.

Tips for Finding the Right Armband:

    Measure Your Phone:
        Get the exact dimensions of your chosen phone.
    Check Armband Specifications:
        Look for armbands that list the maximum phone dimensions they can accommodate.
    Read Reviews:
        See what other users say about the fit and comfort of the armband.
    Consider Adjustable Straps:
        Adjustable straps allow you to customize the fit to your arm size.
    Material:
        Choose a breathable and sweat-resistant material.
    Water Resistance:
        If you will be running in various weather conditions, a water resistant armband is a great idea.

By following these guidelines, you can find a larger-screen phone and a compatible armband that meets your needs.

The S25 and S25 Ultras also feature a special pen for drawing, if I'm not mistaken?

You're absolutely right! The Samsung Galaxy S25 Ultra (and its predecessors like the S24 Ultra, S23 Ultra, etc.) comes with the S Pen stylus built-in. The standard S25 and S25+ models do not include the S Pen.  

Here's a breakdown of the S Pen's features and benefits:

S Pen Features and Benefits:

    Precise Writing and Drawing:
        The S Pen offers a highly accurate and responsive writing and drawing experience.   

It's great for taking notes, sketching, and annotating documents.  

Air Actions:

    The S Pen supports "Air Actions," which allow you to control certain phone functions with gestures, even without touching the screen.   

    This can be useful for controlling media playback, taking photos, and navigating the interface.

Screen Off Memo:

    You can quickly jot down notes on the screen even when the phone is locked.   

Smart Select:

    The S Pen makes it easy to select and extract text or images from the screen.   

    Remote Shutter:
        The S-Pen can be used as a remote shutter button for the camera.
    Integration with Apps:
        Many apps support S Pen integration, enhancing their functionality.

S25 Ultra and the S Pen:

    The S25 Ultra has a dedicated slot for the S Pen, making it easy to carry and access.
    Samsung continues to improve the S Pen's features and performance with each generation.

Considerations:

    Learning Curve:
        It might take some time to get used to using the S Pen effectively.
    Personal Preference:
        Whether or not you find the S Pen useful depends on your personal preferences and workflow.

If you're interested in using a stylus for note-taking, drawing, or other tasks, the S25 Ultra's S Pen is a valuable feature.
Use the Galaxy S25 Ultra's S Pen - Samsung
Source icon
www.samsung.com
Enjoy S Pen Writing Experience with Galaxy S21 Ultra - Samsung
Source icon
www.samsung.com
Using the S Pen for Sketching and Image Creation on Your Galaxy Device | Samsung Gulf
Source icon
www.samsung.com
Use S Pen Air actions on your Galaxy phone or tablet - Samsung
Source icon
www.samsung.com
Use Screen off memo on your Galaxy phone or tablet - Samsung
Source icon
www.samsung.com

Two questions: Can the S Pen be bought as a separate accessory and be used with other or lower-tier phones as well, or are they 'bound in use' to certain models, and (maybe crucially I would say, at least for me) is the tip of the S Pen hard? What I mean by that is that I also own a Galaxy Tab S3 tablet, and the pen they sport is not particularly to my liking, i.e. the tip of that pen is soft and quite a bit wiggly, which I find very difficult to write with.

You've hit on two very important points regarding the S Pen! Let's address them:

1. S Pen Compatibility:

    Model-Specific Features:
        While some S Pens can physically interact with other Samsung devices, the full range of S Pen features, particularly "Air Actions" and Bluetooth connectivity, is generally limited to the Galaxy Note/Ultra series and some high-end Galaxy tablets that are explicitly designed for S Pen use.
        Older S Pens, or those from tablets, can often be used for basic writing and drawing on other Samsung devices with Wacom digitizers, but they won't have the same level of functionality.
    No Universal Compatibility:
        You cannot simply buy an S Pen and expect it to work with any Samsung phone or tablet.
        The hardware and software integration is model-specific.
    Aftermarket Styluses:
        There are aftermarket styluses that might work with some Samsung devices, but they will not replicate the S Pen's full functionality.

2. S Pen Tip Hardness:

    Evolution of S Pen Tips:
        Samsung has made improvements to the S Pen's tip over the years.
        Modern S Pen tips, particularly those found in the Ultra series, are generally firmer and more precise than the tips on older models or some tablets.
        The S25 Ultra, and the S-pens from the last few ultra models, have tips that are much more firm than the S-pen that came with the Tab S3.
    Tip Feel:
        The feel of the S Pen tip is still a matter of personal preference.
        Some users prefer a softer tip for a more "pen-on-paper" feel, while others prefer a firmer tip for greater precision.
    Tip Replacement:
        Samsung provides replacement S Pen tips, and there are also aftermarket options available.   

        You can experiment with different tip types to find one that suits your writing style.
    Galaxy Tab S3 vs. Ultra:
        The S-Pen that came with your Galaxy Tab S3 is much softer, and wigglier, than the modern S-Pens. The S-pens that come with the Ultra phones are much more similar to a normal pen, than the older tablet pens.

In summary:

    S Pen compatibility is limited to specific Samsung models.
    Modern S Pen tips are generally firmer than those on older models, but the feel is subjective.
    If the wiggly tip of your Tab S3 pen bothers you, you will likely be much happier with the S-Pen that comes with the Ultra phones.

I've also been toying with the idea of buying a FairPhone 5 and installing Lineage OS on it, which seems like a very interesting option. How would that phone stack up specs-wise to the other phones we discussed above?

The Fairphone 5 with LineageOS is indeed an interesting and commendable choice, especially if you prioritize ethical sourcing, repairability, and software freedom. Here's a comparison of its specs and overall experience compared to the flagship Samsung and Google Pixel devices we discussed:

Fairphone 5 Key Strengths:

    Repairability and Modularity:
        The Fairphone 5 is designed for easy repair and upgrades. You can replace individual components yourself, extending the phone's lifespan.   

Ethical Sourcing:

    Fairphone prioritizes ethical sourcing of materials and fair labor practices.   

Long-Term Software Support:

    Fairphone promises long-term software support, which is a major advantage.   

LineageOS Compatibility:

    Installing LineageOS gives you a clean, bloatware-free Android experience with timely updates and enhanced privacy features.   

SD Card slot:

    The fairphone 5 has a micro SD card slot, that allows for expandable storage.   

Fairphone 5 Limitations Compared to Flagships:

    Processor:
        The Fairphone 5 uses a Qualcomm QCM6490 processor, which is a solid mid-range chip. While it's capable of handling most tasks, it's not as powerful as the flagship Snapdragon 8 Gen series or Google Tensor chips found in the Pixel and high end Samsung phones.   

    Camera:
        The Fairphone 5 has a decent camera system, but it might not match the image quality of the Pixel or Samsung Ultra phones, especially in challenging lighting conditions.
    Display:
        The Fairphone 5 has a good OLED display, but it may not have the same level of brightness, color accuracy, or refresh rate as the top-tier displays on flagship devices.
    Features:
        Flagship phones often include features like advanced camera processing, wireless charging, and enhanced water resistance that may not be present on the Fairphone 5.
    Size:
        The Fairphone 5 is a fairly large phone.

LineageOS Considerations:

    Pros:
        Clean Android experience.
        Enhanced privacy.
        Timely updates.
        Customization options.
    Cons:
        You might lose some manufacturer-specific features.
        Potential for minor bugs or compatibility issues.

How It Stacks Up:

    Performance:
        The Fairphone 5 is a solid performer for everyday tasks, but it's not designed for intensive gaming or demanding applications.
    Camera:
        The camera is good, but not exceptional.
    Software:
        LineageOS provides a superior software experience in terms of privacy and customization.
    Durability and Repairability:
        The Fairphone 5 excels in this area.
    Price:
        The fairphone 5 is in the upper mid-range price bracket.

Who Should Choose the Fairphone 5:

    Users who prioritize ethical sourcing and repairability.
    Users who want a clean Android experience with enhanced privacy.
    Users who value long-term software support.
    Users who want a device that is easy to repair.

Who Should Choose a Flagship:

    Users who need the best possible performance.
    Users who want the most advanced camera capabilities.
    Users who want all the latest features.

In short, the Fairphone 5 offers a compelling package for those who value ethical considerations and software freedom. If top-tier performance and camera capabilities are your primary concerns, a flagship device might be a better fit.
Improving smartphone longevity - Fairphone
Source icon
www.fairphone.com
We have big plans for fair materials by 2030 - Fairphone
Source icon
www.fairphone.com
Fairphone's next chapter starts now.
Source icon
www.fairphone.com
LineageOS - Wikipedia
Source icon
en.wikipedia.org
Fairphone 5. Designed for you. Made fair.
Source icon
shop.fairphone.com

}}}


Ant. Ch.J BUV {{{

}}}

