set foldmethod=indent foldlevel=2
vim: fdm=indent:fdl=2:

~/Empire/Doks/Comp/mu/au/scoll/ScollBook.txt
~/Dropbox/rsc/Doks/phone/Comp/mu/au/scoll/scoll-mapvisu.tagged.txt

Overtone

scide (1)            - SuperCollider IDE
scsynth (1)          - SuperCollider audio synthesis server
supernova (1)        - SuperCollider audio synthesis server

Normalization of Audio (LUFS)
            Thanks. I know we talked about
            normalization of audio using
            Nyquist earlier (specifically using
            LUF and shooting for a level of
            about -19). I had some trouble
            getting Nyquist to behave the way I
            wanted (even for very simple
            tasks), so could I instead use
            Supercollider to do something
            similar, and what would the code in
            that case look like?

            Yes, you can use SuperCollider to
            normalize audio based on the LUF
            (Loudness Units relative to Full
            Scale) and target a specific level
            such as -19 LUFs. Here's an example
            of how to do this:

            // Load the audio file
            s = SynthDef(\normalize, {
              var in = In.ar(0, 2),
                  lufs = Loudness.ar(in),
                  gain = 1 / (Lufs.toGain(-19) / Loudness.toGain(lufs));

              Out.ar(0, gain * in);
            });

            // Load the audio file into a buffer
            buf = Buffer.read(s, "file:///path/to/audio.wav");

            // Normalize the audio
            play(Synth(\normalize, buf));

            In this example, the SynthDef named
            \normalize is defined to take an
            audio input in and normalize it
            based on the LUFs of the input
            signal. The Lufs object is used to
            measure the LUFs of the input
            signal, and the Gain object is used
            to calculate the gain required to
            achieve the target LUF level of
            -19. The Out object is used to send
            the normalized audio signal to the
            output.

            To use this code, you will need to
            replace "path/to/audio.wav" with
            the actual path to the audio file
            you want to normalize. You can then
            load the audio file into a buffer
            using the Buffer.read function and
            then play the SynthDef. The
            normalized audio will be played
            through the output.

            Here is an example of how to load
            the audio file and play the
            normalized audio:

            // Load the audio file
            buf = Buffer.read(s, "/path/to/audio.wav");

            // Normalize the audio
            play(Synth(\normalize, buf));

            This code will load the audio file
            "/path/to/audio.wav" into a buffer
            and then play the normalized audio
            through the output.

            I hope this helps!

            - The play command, is that something
            I have to have installed on Linux,
            or does that come with
            Supercollider?

            The play command is part of the
            SuperCollider environment and does
            not need to be installed separately
            on Linux. It is used to play audio
            generated by SuperCollider
            synthesizers. To use the play
            command, you need to first load the
            audio file into a buffer using the
            Buffer.read function. Then, you can
            play the buffer using the play
            command.

            Here is an example of how to load
            an audio file into a buffer and
            then play it:

            // Load the audio file
            buf = Buffer.read(s, "file:///path/to/audio.wav");

            // Play the audio
            play(buf);

            This code will load the audio file
            "/path/to/audio.wav" into a buffer
            and then play it through the
            output.

Supercollider Tutorial (30 YT-videos)  [written in C++]
https://www.youtube.com/watch?v=ntL8QDOhhL8&list=PLPYzvS8A_rTaNDweXe6PX4CXSGq4iEWYC&index=7
            tut 1 ----
            scide prefs  c-,  (+check keyb.shortcuts)
            clear post-window  cs-p
            classes
            reciever.message  #i.e. an object recieves a message|method
            3.cubed  + evaluate  s-Enter  __
            x = 3.cubed  #set a variable
            x + 10

            global vs local variables
            var number;
            # local vars must be declared before used
            # + must begin with lcase letter
            number = 3.cubed
            (freestanding) statements should be ended with ';'

            evaluate multiple statements:
            1. mark + s-Enter
            2. '(' and ')' on lines before and after,
               cursor between, + press c-Enter
            local vars (i.e. between parens) are lost after evaluation
            var number;  #declaring a local variable

            global vars:  (are actually environment variables)
            1. a through z
            2. '~' before (i.e. '~number = 3.cubed;')
                 (i.e. turning a local var into a global one)
            [variable overriding, plus
             no operator precedenc (i.e. strict left to right)
                .
            // comment
            /* multiline comment */
            Help for word under cursor:  c-d  __
            search help for word  cs-d

            tut 2 ----
            boot soundserver  Server.local.boot;
            quit soundserver  Server.local.quit;
            convenience variable for the local server  s
            s.boot;  // or ca-b
            create a function  {}
            {SinOsc.ar}.play;
                 ^-- unit generator (one or more)
            stop all sound  c-.
            synths  individual entities that exist on the audioserver
              x = {SinOsc.ar}.play;
            free single synths  x.free;
            about freeing:
              ## x = {SinOsc.ar};  x.play;  x.free;  ##
              x = {SinOsc.ar};  y = x.play;  y.free;
            Unit Generators  'UGens'
            ugens are ___  calculations with signals  // the basic building blocks of synth definitions on the server and are used to generate and process both audio and control signals
            ugens accept three signals  ar, kr, ir  // audio rate, control rate, initialization rate
            Evaluating examples in the help/documentation  __ __!!
            freq, phase, mul, add
              x = {SinOsc.ar(700, 0, 0.125, 0).play;
            x = {SinOsc.ar(700, mul:0.125).play;
            // named arguments, i.e. custom order
            x = {SinOsc.ar(700) * 0.125).play;  ??
                .
            declare own arguments (to manipulate sound as it's playing)
            (
            z = {
                arg freq=440, amp=1;  // __ + args declared first
                var sig;              // then vars
                sig = SinOsc.ar(freq) * amp;  // then rest of the code
            }.play;

            symbols  \freq  // =preceded by a backslash
            modify arguments of an active synth
            z.set(\freq, 330)  // change a variable
            ___zzzz halftime video 2

            range(

            LFNoise0, LFNoise1, 
            SynthDef.new
            Out.ar(0, sig);  // output ugen
            .add  load send store
            [  ]  array
            Pulse
            FreeVerb

            tut 4 ----  Envelopes (custom signal shape that controls one or more paramaters of the sound)
            Line  (+ doneAction:2)
            s.plotTree;
              s.freeAll;
            XLine
            (exponential is important), or use Db
            dbamp (or ampdb)
            EnvGen
              Env.new.plot
             curve
             gate
            LFPulse
            t_   trigger-arguments  \t_gate
            Env.adsr
                .
            tut 5 ---- multi-channel expansion
            s.meter  // c-m  (inputs and outputs)
            Mix ugen
            dup(
            60!4  // shortcut for dup
            Splay.
            PinkNoise
            not invoke multi-channel expansion on Out ugens
            rrand(
              exprand(
            {rrand(50, 1200)}!4
            ExpRand

            tut 6 ---- iteration
            [Search on Collections]
            do
            postln
            collect
            _.squared
            10.do
            VarSaw
             Rand
            nil  // special val non-initialized value
            midicps  __
             Blip
             exprange(
            reciprocal
             (+concerning Control)
            (change number of partials with do)

            tut 7 ----  audio server architecture
            [having many synths running simult.]
            Nodes, Busses, Order of Execution
              ^        |
              modules  |
                      passing signals betw. synths
            Dust
            In.ar
            s.options.numAudioBusChannels
            s.options.numOutputBusChannels = 4;  // +reboot server
            s.options.numInputBusChannels   // 1 - 127
                                               8-127 = private busses
            ~reverbBus = Bus.audio(s, 1);
            ~reverbBus.index;
            Pan2
            -- OoE  (order of signal and effect matters)
            nodes  synths and groups(collection of groups in specif. order)
            group node in the tree-repres.  grey rectangle
            server as a target
            head
            \addToTail \addAfter
            after before head tail replace (=convenience methods)
            ~sourceGrp = Group.new
            Group.after
            sending .set method to a Group
            ~sourceGrp.freeAll;
            (read documentation for Synth, Group, Node)

            tut 8 ----
              holding recording + playing back sample audio
            Buffer (=server-side objects, i.e. server has to be booted first)
            .read (to local server s, +path)  aiff wav
            "strings"
            .zero  clear buffer
            .free  (remove buffer,  like synths and groups)
            Buffer.freeAll  // remove all buffers
            drag + drop file into window
            // Frames  = length of buffer
            .numFrames;  // similar to samples in mono
            .numChannels
            numSamples   // frames * channels
            .readChannel
            .duration    // length in channels
            'bufnum'  .bufnum
            .sampleRate
            .query  __ __
            read part of soundfile into buffer
                startFrame numFrames
            read many soundfiles at once
            Array.new  ~folder = PathName.new("path/to")
                ~folder.entries.do({
            s.options.NumBuffers (= 2000;)
            -- manipulate buffers with ugens
            PlayBuf, BufRd
            rate  0.5 2 -1
            BufRateScale [!]  BufRateScale.ir(
             loop
            12.midiratio -12.midiratio
            7.midiratio  // = a perfect fifth  __ __
            [Setting a group __]
            Line
             BufDur
            Phasor  (loop through buffer with BufRd)
            Sweep, LfSaw
             3pi/2
            RecordBuf, BufWr

            tut 9 ----  SC MidiClasses __ __
            guide: Using MIDI  (or just 'MIDI' for overview)
            MIDIClient.init;
            MIDIIn.connectAll;
            MIDIClient.sources;
            MIDIIn.connect(2);
            (MIDIFunc)
            MIDIdef
            --
            MIDIdef.noteOn(\noteOnTest, {"key down".postln});
            MIDIdef.noteOn(\noteOnTest).enable;
            MIDIdef.noteOn(\noteOnTest).disable;
            MIDIdef.noteOn(\noteOnTest).free;
            permanent_(false)  __ __

            (
            MIDIdef.noteOn(\noteOnTest, {
                arg vel, nn, chan, src;
                [vel, nn, chan, src].postln;
                {
                    var sig, env;
                    sig = sinOsc.ar(nn.midicps)!2;
                    env = EnvGen.kr(Env.perc, doneAction:2);
                    sig = sig * env * vel.linexp(1,127,0.01,0.3);
                }.play;
            });
            )

            s.boot;
            0-15
                .
            LFTri
            .add
            Midi Polyphony (=using an array)  <__>
            ~notes = Array.newClear(128)
            MIDIdef.noteOff ...
            MIDIdef.bend ...
            .midiratio


            Patterns I
             Pbind, Pseq, Pshuf
             ++ (=concatenation)

            GUI Programming
            check Syntax Shortcuts  __ __
            check Decorator  (eg. FlowLayout)
            subviews + nested layouts
              CompositeView, 
                .
            Composing + Performing ----
            building SynthDefs
            BFP, EnvGen
            Scale.major minor chromatic  // etc
            Scale.directory
             Scale.minor.degrees+60
            (1..6).choose.do(
            .detune .bipolar
            Saw
             Balance2
            s.reeboot;
            PanAz
            BLowShelf
            Pbind, Pseq, Pxrand, Pwhite, Pkey, Prand, Pexprand  // patterns
            ~chords.stop;
            Synth.new(
            XFade2
             Scale.lydian.degrees
            d = Dictionary.new;
            d.add(\foo -> 10);
            d[\foo];
            d[\crotales][2];
            PathName(
             subfolder.folderName.asSymbol ->
             Array.fill(
            .fullPath
             DelayN
             AllpassN, Rand
            Bus.audio(s,2);
            .inf
                .
            - 1. server config
            - 2. initializing global vars
            - 3. define piece-specific functions
            - 4. register functions with ServerBoot/Quit/Tree
            - 5. boot server
            - 6. anything else requiring a booted server
                .
            s = Server.local;
            s.options.outDevice_(
            .......
            .......
            s.options.sampleRate_(44100);
            thisProcess.nowExecutingPath).parentPath...
            Routine({
            AppClock
             ServerTree
            s.sync;
            MIDIdef.cc(
            case
            {} {}
             |
             test-function that eval.s to true or false
            {num==73 && val==127} {.....}
            {num==37 && val==102} {.....}
            {true} {nil}

            FM Synthesis -- (using sinewaves)
            s.scope;  __ __
            FreqScope.new;
            MouseX.kr(
            MouseY.kr(
            'modulator' + 'carrier'

            Wavetable Synthesis --  #power-of-two table, read as values
            SinOsc, Osc, COsc, VOsc, Shaper
            (+additive synthesis)
            .sort .sort.reverse
            .loadCollection(
            VERY NICE EXAMPLE WITH CODE  __ __ __

            Granular Synthesis --
            (chopping up sound + reconstituting into weird sounds)
            b.plot  __ __
            b.0;

            Contributing with Git and Github --
            fork + clone
            clone github/path --recursive
            git remote -v
            git remote add upstream path/to/remote/fork
            <git fetch upstream>
            <git checkout develop>
            <git pull upstream develop>
            <<git config pull.ff only>>
            [develop vs topic-branches]
            git checkout -b topic/glossary-typo
            [get path to file to edit]
            git status
            git add HelpSource // .  #add is recursive by default
            git commit -m "docs: fix glossary typo"
            git push --set-upstream origin topic/glossary-typo
                                                 ^--branch name
            [push will show up in your github]
            Click 'Compare and pull request'
              #green button in your github
            [complete the form  + click off everything]

            Write Classes and Methods ----
            https://www.youtube.com/watch?v=9gs0WPnxyak&list=PLPYzvS8A_rTaNDweXe6PX4CXSGq4iEWYC&index=29

            Patterns II
             1. tempo/quantization
             2. \sustain and \legato
             3. Pfunc and other function-based patterns
             4. constraint patterns
             5. modular pattern composition
             6. sharing data across several Pbinds
https://ccrma.stanford.edu/~ruviaro/texts/A_Gentle_Introduction_To_SuperCollider.pdf  #download

