set foldmethod=indent foldlevel=2
vim: fdm=indent:fdl=2:

~/Empire/Doks/Comp/lang/dart-flutter/cheatsh-qref/dart.cheatsh.pdf
            Dart Cheat Sheet
            Variables
            int n1 = 5; // explicitly typed
            var n2 = 4; // type inferred
            // n2 = "abc"; // error
            dynamic n3 = 4; // dynamic means n3
            // can take on any
            // type
            n3 = "abc";
            double n4; // n4 is null
            String s1 = 'Hello, world!';
            var s2 = "Hello, world!";

            Constants
            const PI = 3.14; // const is used
            // for compile-time constant
            final area = PI * 5*5;
            // final variables can only be set
            // once

            Optional Named
            Parameters
            int addNums4(num1, {num2=0, num3=0})
            {
            return num1+num2+num3;
            }
            print(addNums4(1));
            print(addNums4(1,num3:2));
            print(addNums4(1,num2:5,num3:2));

            Parsing
            var s1 = "123";
            var s2 = "12.56";
            var s3 = "12.a56";
            var s4 = "12.0";
            print(num.parse(s1)); // 123
            print(num.parse(s2)); // 12.56
            print(num.parse(s3));
            // FormatException: 12.a56

            Conditional Expressions

            print(num.tryParse(s3)); // null

            var grade = 3;
            var reply = grade > 3 ? "Cool":"Not
            cool";

            String Interpolation

            var input; // input is null
            var age = input ?? 0;
            print(age); // 0

            Functions
            void doSomething() {
            print("doSomething()");
            }
            int addNums1(num1, num2, num3) {
            return num1+num2+num3;
            }
            doSomething();
            print(addNums1(1,2,3));

            Arrow Syntax
            void doSomethingElse() {
            doSomething();
            }
            // the above can be rewritten using
            // arrow syntax
            void doSomethingElse() =>
            doSomething();

            Optional Positional
            Parameters
            int addNums2(num1, [num2=0, num3=0])
            {
            return num1+num2+num3;
            }
            print(addNums2(1));
            print(addNums2(1,2));
            print(addNums2(1,2,3));

            Named Parameters
            // named parameters
            int addNums3({num1, num2, num3}) {
            return num1+num2+num3;
            }
            print(addNums3(
            num1:1,num2:2,num3:3));

            var s1 = "Hello";
            var s2 = "world";
            var s3 = s1 + ", " + s2;
            var s = "${s3}!";
            print(s);
            // Hello, world!
            print("Sum of 5 and 6 is ${5+6}");
            // Sum of 5 and 6 is 11

            List (Arrays)
            // dynamic list
            var arr = [1,2,3,4,5];
            print(arr.length); // 5
            print(arr[1]);
            // 2
            arr[4] *= 2;
            print(arr[4]);
            // 10
            arr.add(6);
            print(arr); // [1, 2, 3, 4, 10, 6]
            List arr2;
            arr2 = arr;
            arr2[1] = 9;
            print(arr); // [1, 9, 3, 4, 10, 6]
            print(arr2); // [1, 9, 3, 4, 10, 6]
            // fixed size list
            var arr3 = new List(3);
            print(arr3); // [null, null, null]
            arr3.add(5);
            // Uncaught exception:
            // Unsupported operation: add

            Map
            var details = {"name":"Sam",
            "age":"40"};
            print(details);
            var devices = new Map();
            var apple = ["iPhone","iPad"];
            var samsung = ["S10","Note 10"];
            devices["Apple"] = apple;
            devices["Samsung"] = samsung;
            for (String company in
            devices.keys) {
            print(company);
            for (String device in
            devices[company]) {
            print(device);
            }
            }

            Lambda Functions
            var nums = new
            List<int>.generate(10, (i) => i);
            print(nums);
            // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
            var odds = nums.where(
            (n) => n % 2 == 1).toList();
            print(odds); // [1, 3, 5, 7, 9]
            var sum = nums.reduce(
            (s,n) => s + n);
            print(sum); // 45
            var prices = nums.map(
            (n) => "\$$n").toList();
            print(prices);
            // [$0, $1, $2, $3, $4, $5, $6, $7,
            // $8, $9]

            Higher Order Functions
            var names = ["Jimmy","TIM","Kim"];
            // sort alphabetically with case
            // insensitivity
            names.sort(
            (a, b) =>
            a.toUpperCase().compareTo(
            b.toUpperCase())
            );
            print(names);
            // [Jimmy, Kim, TIM]
            // sort by length of name
            names.sort((a,b) {
            if (a.length > b.length)
            return 1;
            else
            return -1;
            });
            print(names);
            // [Kim, TIM, Jimmy]

            List bubbleSort(List items, bool
            Function (int,int) compareFunction)
            {
            for (var j=0; j<items.length-1;
            j++) {
            var swapped = false;
            for (var i=0;
            i<items.length-1-j; i++) {
            if (!compareFunction(items[i],
            items[i+1])) {
            var t = items[i+1];
            items[i+1] = items[i];
            items[i] = t;
            swapped = true;
            }
            }
            if (!swapped) break;
            }
            return items;
            }
            var nums = [5,2,8,7,9,4,3,1];
            // sort in ascending order
            var sortedNums = bubbleSort(nums,
            (n1,n2) => n1<n2);
            print(sortedNums);
            // sort in descending order
            sortedNums = bubbleSort(nums,
            (n1,n2) => n1>n2);
            print(sortedNums);

            1

            Rev 1.1.1 © Wei-Meng Lee , Developer Learning Solutions, http://calendar.learn2develop.net All rights reserved.

            }

            Iterations
            for (int i=0;i<5; i++) {
            print(i);
            } // prints 0 to 4
            var list = [1,2,3,4,5];
            for (final i in list) {
            print(i);
            } // prints 1 to 5

            var loc1 = new MyLocation();
            var loc2 = new
            MyLocation.withPosition(
            57.123,37.22);

            Getters and Setters
            class MyLocation {
            double _lat;
            double _lng;
            double get lat => _lat;
            set lat (double value) {
            if (value > 90 || value < -90) {
            throw("Invalid latitude");
            }
            _lat = value;
            }

            int i=0;
            while (i < 5) {
            print(i);
            i++;
            } // prints 0 to 4
            i = 0;
            do {
            print(i);
            i++;
            } while (i<5);
            // prints 0 to 4

            double get lng => _lng;
            set lng (double value) {
            if (value > 180 ||
            value < -180) {
            throw("Invalid longitude");
            }
            _lng = value;
            }

            Class
            class MyLocation {
            }
            // type inference
            var loc1 = new MyLocation();

            // read-only property
            final arrived = false;

            // declare and initialize
            MyLocation loc2 = new MyLocation();

            // unnamed constructor
            MyLocation() {
            this.lat = 0;
            this.lng = 0;
            }

            Properties
            class MyLocation {
            // read/write properties
            var lat;
            var lng;

            // named constructor
            MyLocation.withPosition(
            var lat, var lng) {
            this.lat = lat;
            this.lng = lng;
            }

            // read-only property
            final arrived = false;
            }
            loc1.lat = 57.123;
            loc1.lng = 37.22;
            // loc1.arrived = true; // error
            var arr = loc1.arrived;

            Methods
            class MyLocation {
            // read/write properties
            var lat;
            var lng;
            // read-only property
            final arrived = false;
            void someMethod() {
            }
            }

            Constructors
            class MyLocation {
            // read/write properties
            var lat;
            var lng;
            // read-only property
            final arrived = false;
            // unnamed constructor
            MyLocation() {
            this.lat = 0;
            this.lng = 0;
            }
            // named constructor
            MyLocation.withPosition(
            var lat, var lng) {
            this.lat = lat;
            this.lng = lng;
            }
            void someMethod() {

            }
            class Rectangle extends Shape {
            Rectangle() {}
            Rectangle.withDimension(
            double length, double width):
            super.withDimension(
            length, width);
            }

            Final Class
            // Square cannot be extended (it
            // does not have a zero-argument
            // constructor)
            class Square extends Rectangle {
            Square(double length):
            super.withDimension(
            length, length);
            }
            Square s = new Square(5);
            print(s.area());
            // 25
            print(s.perimeter()); // 20

            Overriding
            class Circle extends Shape {
            Circle(double radius):
            super.withDimension(
            radius, radius);
            double area() {
            return 3.14 * this.length *
            this.length;
            }
            double perimeter() {
            return (2 * 3.14 * this.length);
            }
            // overloading of methods not
            // supported in Dart
            }

            void someMethod() {
            }

            Circle c = new Circle(6);
            print(c.area());
            // 113.03999999999999

            var loc1 = new MyLocation();
            var loc2 = new
            MyLocation.withPosition(
            57.123,37.22);

            print(c.perimeter()); // 37.68

            }

            loc1.lat = 57.123;
            loc1.lng = 37.22;
            loc2.lat = 999;
            // Uncaught exception:Invalid
            // latitude

            Inheritance

            loc1.someMethod();

            }
            double area() {
            return this.length * this.width;
            }

            }

            // abstract class cannot be
            // instantiated directly
            abstract class Shape {
            double length;
            double width;
            // without this zero-argument
            // constructor, class cannot be
            // extended
            Shape() {
            this.length = 0;
            this.width = 0;
            }
            // constructor with another name
            Shape.withDimension(double length,
            double width){
            this.length = length;
            this.width = width;
            }
            double perimeter() {
            return 2 * (this.length +
            this.width);

            Static Members/Methods
            class Car {
            static var MilesToKM = 1.60934;
            static double kilometersToMiles(
            double km) {
            return km / 1.60934;
            }
            void accelerate() {}
            void decelerate() {}
            void stop() {}
            void printSpeed() {}
            }

            Interfaces
            class CarInterface {
            void accelerate() {
            // default implementation
            ...
            }
            void decelerate() {}
            void accelerateBy(int amount) {}
            }
            class MyCar implements
            CarInterface {
            void accelerate() {
            }
            void decelerate() {
            }
            void accelerateBy(int amount) {
            }
            }

            2

            Rev 1.1.1 © Wei-Meng Lee , Developer Learning Solutions, http://calendar.learn2develop.net All rights reserved.

            
~/Empire/Doks/Comp/lang/dart-flutter/cheatsh-qref/dart2.cheatsh.pdf
            Dart 2 Cheat Sheet and Quick Reference
            main function

            Operators

            void main() {
            print("Hello, Dart!");
            }

            // Arithmetic
            40 + 2; // 42
            44 - 2; // 42
            21 * 2; // 42
            84 / 2; // 42
            84.5 ~/ 2.0; // int value 42
            392 % 50; // 42
            // Types can be implicitly converted
            var answer = 84.0 / 2; // int 2 to double
            // Equality and Inequality
            42 == 43; // false
            42 != 43; // true
            // Increment and decrement
            print(answer++); // 42, since it prints first for
            postfix
            print(--answer); // 42, since it decrements first
            for prefix
            // Comparison
            42 < 43; // true
            42 > 43; // false
            42 <= 43; // true
            42 >= 43; // false
            // Compound assignment
            answer += 1; // 43
            answer -= 1; // 42
            answer *= 2; // 84
            answer /= 2; // 42
            // Logical
            (41 < answer) && (answer < 43); // true
            (41 < answer) || (answer > 43); // true
            !(41 < answer)); // false

            Variables, Data Types, & Comments
            // Use var with type inference or instead use type
            name directly
            var myAge = 35; // inferred int created with var
            var pi = 3.14; // inferred double created with var
            int yourAge = 27; // type name instead of var
            double e = 2.718; // type name instead of var
            // This is a comment
            print(myAge); // This is also a comment.
            /*
            And so is this.
            */
            // dynamic can have value of any type
            dynamic numberOfKittens;
            // dynamic String
            numberOfKittens = 'There are no kittens!';
            numberOfKittens = 0; // dynamic int
            numberOfKittens = 1.0; // dynamic double
            bool areThereKittens = true; // bool
            // Compile-time constants
            const speedOfLight = 299792458;
            // Immutables with final
            final planet = 'Jupiter';
            // planet = 'Mars'; // error: planet is immutable
            // Enumerations
            enum Month { january, february, march, april, may,
            june, july, august, september, october, november,
            december
            }
            final month = Month.august;

            Null
            int age; // initialized to null
            double height;
            String err;
            // Check for null
            var error = err ?? "No error"; // No error
            // Null-check compound assignment
            err ??= error;
            // Null-check on property access
            print(age?.isEven);

            Strings
            // Can use single or double quotes for String type
            var firstName = 'Albert';
            String lastName = "Einstein";
            // Embed variables in Strings with $
            var physicist = "$firstName $lastName”;
            // Albert Einstein
            // Escape sequences such as \' and \n
            // and concatenating adjacent strings
            var quote = 'If you can\'t' ' explain it simply\n'
            "you don't understand it well enough.";
            // Concatenation with +
            var energy = "Mass" + " times " + "c squared";
            // Preserving formatting with """
            var model = """

            Source: raywenderlich.com. Visit for more Flutter/Dart resources and tutorials!
            Page 1
            ! of 4

            I'm not creating the universe.
            I'm creating a model of the universe,
            which may or may not be true.""";
            // Raw string with r prefix
            var rawString =r”I'll\nbe\nback!";
            // prints I’ll\nbe\nback!

            Control Flow: Conditionals
            var animal = 'fox';
            if (animal == 'cat' || animal == 'dog') {
            print('Animal is a house pet.');
            } else if (animal == 'rhino') {
            print('That\'s a big animal.');
            } else {
            print('Animal is NOT a house pet.');
            }
            // switch statement
            enum Semester { fall, spring, summer }
            Semester semester;
            switch (month) {
            case Month.august:
            case Month.september:
            case Month.october:
            case Month.november:
            case Month.december:
            semester = Semester.fall;
            break;
            case Month.january:
            case Month.february:
            case Month.march:
            case Month.april:
            case Month.may:
            semester = Semester.spring;
            break;
            case Month.june:
            case Month.july:
            semester = Semester.summer;
            break;
            }

            Version 1.0.1. Copyright 2019 Razeware LLC. All rights reserved.

            Dart 2 Cheat Sheet and Quick Reference
            Control Flow: While loops

            Functions

            var i = 1;
            // while, print 1 to 9
            while (i < 10) {
            print(i);
            i++;
            }
            // do while, print 1 to 9
            i = 1;
            do {
            print(i);
            ++i;
            } while (i < 10);
            // break at 5
            do {
            print(i);
            if (i == 5) {
            break;
            }
            ++i;
            } while (i < 10);

            // Named function
            bool isBanana(String fruit) {
            return fruit == 'banana';
            }
            var fruit = 'apple';
            isBanana(fruit); // false
            // Optional parameters with square brackets
            String fullName(String first, String last, [String
            title]) {
            return "${title == null ? "" : "$title "}$first
            $last";
            }
            fullName("Ray", "Wenderlich"); // Ray Wenderlich
            fullName("Albert", "Einstein", "Professor"); //
            Professor Albert Einstein
            // Optional named arguments with braces
            bool withinTolerance(
            int value, {int min, int max}) {
            return (min ?? 0) <= value && value <= (max ??
            10);
            }
            withinTolerance(11, max: 10, min: 1); // false
            // Default values
            bool withinTolerance(
            int value, {int min = 0, int max = 10}) {
            return min <= value && value <= max;
            }
            withinTolerance(5); // true
            // Function as parameter
            int applyTo(int value, int Function(int) op) {
            return op(value);
            }
            int square(int n) {
            return n * n;
            }
            applyTo(3, square); // 9
            // Arrow syntax for one line functions
            int multiply(int a, int b) => a * b;
            multiply(14, 3); // 42

            Control Flow: For loops
            var sum = 0;
            // Init; condition; action for loop
            for (var i = 1; i <= 10; i++) {
            sum += i;
            }
            // for-in loop for list
            var numbers = [1, 2, 3, 4];
            for (var number in numbers) {
            print(number);
            }
            // Skip over 3 with continue
            for (var number in numbers) {
            if (number == 3) {
            continue;
            }
            print(number);
            }
            // forEach with function argument
            numbers.forEach(print); // 1, 2, 3, 4 on separate
            lines
            // forEach with anonymous function argument
            numbers = [13, 14, 15, 16];
            numbers.forEach(
            (number) => print(number.toRadixString(16));
            // d, e, f, 10

            Source: raywenderlich.com. Visit for more Flutter/Dart resources and tutorials!
            Page 2
            ! of 4

            Anonymous Functions and
            Closures
            // Anonymous functions (without a name)
            // Assign anonymous function to a variable
            var multiply = (int a, int b) {
            return a * b;
            }
            // Call a function variable
            multiply(14, 3); // 42
            // Closures
            Function applyMultiplier(num multiplier){
            // Return value has access to multiplier
            return (num value) => value * multiplier;
            }
            var triple = applyMultiplier(3);
            triple(14.0); // 42.0

            Collections: Lists
            // Fixed-size list
            var pastries = List<String>(3);
            // Element access by index
            pastries[0] = 'cookies';
            pastries[1] = 'cupcakes';
            pastries[2] = 'donuts';
            // Growable list
            List<String> desserts = [];
            desserts.add('cookies');
            // Initialize by growable list
            var desserts = ['cookies', 'cupcakes', 'pie'];
            // List properties and methods
            desserts.length; // 3
            desserts.first; // 'cookies'
            desserts.last; // 'pie'
            desserts.isEmpty; // false
            desserts.isNotEmpty; // true
            desserts.firstWhere((str) => str.length < 4));
            // pie
            // Collection if
            var peanutAllergy = true;
            var candy = [
            'junior mints',
            'twizzlers',
            if (!peanutAllergy) 'reeses'
            ];
            // Collection for
            var numbers = [1, 2, 3];
            var doubledNumbers =
            [for (var number in numbers) 2 * number];
            // [2, 4, 6]

            Version 1.0.1. Copyright 2019 Razeware LLC. All rights reserved.

            Dart 2 Cheat Sheet and Quick Reference
            Collections: List Operations
            // Spread Operator and null-spread operator
            var pastries = ['cookies', 'cupcakes'];
            var desserts = ['donuts', ...pastries, ...?candy];
            // Map to transform list
            var numbers = [1, 2, 3, 4];
            var squares = numbers.map(
            (number) => number * number).toList();
            // [1, 4, 9, 16]
            // Filter list using where
            var evens = squares.where(
            (square) => square.isEven); // (4, 16)
            // Reduce list to combined value
            var amounts = [199, 299, 299, 199, 499];
            var total = amounts.reduce(
            (value, element) => value + element); // 1495

            Collections: Sets
            // Create set of int
            var someSet = <int>{};
            // Set type inference
            var anotherSet = {1, 2, 3, 1};
            // Check for element
            anotherSet.contains(1); // true
            anotherSet.contains(99); // false
            // Adding and removing elements
            someSet.add(42);
            someSet.add(2112);
            someSet.remove(2112);
            // Add to set from list
            someSet.addAll([1, 2, 3, 4]);
            // Intersection
            var intersection = someSet.intersection(anotherSet);
            // Union
            var union = someSet.union(anotherSet);

            Collections: Maps
            // Map from String to int
            var emptyMap = Map<String, int>();
            // Map from String to String
            var avengers = {
            "Iron Man": "Suit", "Captain America": "Shield",
            "Thor": "Hammer"};

            // Element access by key
            var ironManPower = avengers["Iron Man"]; // Suit
            avengers.containsKey("Captain America"); // true
            avengers.containsValue("Arrows"); // false
            // Access all keys and values
            avengers.keys.forEach(print); // Iron Man, Captain
            America, Thor
            avengers.values.forEach(print); // Suit, Shield,
            Hammer
            // Loop over key-value pairs
            avengers.forEach((key, value) => print('$key ->
            $value'));

            Classes and Objects
            class Actor {
            // Properties
            String name;
            var filmography = <String>[];
            // Short-form constructor
            Actor(this.name, this.filmography);

            Page 3
            ! of 4

            // Override from Object
            String toString() =>
            "${[name, ...filmography].join("\n- ")}\n";
            }
            var gotgStar = Actor('Zoe Saldana', []);
            gotgStar.name = 'Zoe Saldana';
            gotgStar.filmography.add('Guardians of the Galaxy');
            gotgStar.debut = 'Center Stage';
            print(Actor.rey().debut); // The Force Awakens
            var kit = Actor.gameOfThrones('Kit Harington');
            var star = Actor.inTraining('Super Star');
            // Cascade syntax ..
            gotgStar // Get an object
            ..name = 'Zoe' // Use property
            ..signOnForSequel('Star Trek'); // Call method

            Static Class Members

            // Named constructor
            Actor.rey({this.name = "Daisy Ridley"}) {
            filmography = ['The Force Awakens', 'Murder on
            the Orient Express'];
            }
            // Calling other constructors
            Actor.inTraining(String name) : this(name, []);
            // Constructor with initializer list
            Actor.gameOfThrones(String name)
            : this.name = name, this.filmography = ['Game
            of Thrones'] {
            print('My name is ${this.name}');
            }
            // Getters and Setters
            String get debut => '$name debuted in $
            {filmography.first}';
            set debut(String value) => filmography.insert(0,
            value);
            // Methods
            void signOnForSequel(String franchiseName) {

            Source: raywenderlich.com. Visit for more Flutter/Dart resources and tutorials!

            filmography.add('Upcoming $franchiseName
            sequel');
            }

            enum PhysicistType { theoretical, experimental, both
            }
            class Physicist {
            String name;
            PhysicistType type;
            // Internal constructor
            Physicist._internal(this.name, this.type);
            // Static property
            static var physicistCount = 0;
            // Static method
            static Physicist newPhysicist(
            String name,
            PhysicistType type) {
            physicistCount++;
            return Physicist._internal(name, type);
            }
            }

            final emmy = Physicist.newPhysicist(
            "Emmy Noether", PhysicistType.theoretical);
            final lise = Physicist.newPhysicist(
            "Lise Meitner", PhysicistType.experimental);
            print(Physicist.physicistCount); // 2

            Version 1.0.1. Copyright 2019 Razeware LLC. All rights reserved.

            Dart 2 Cheat Sheet and Quick Reference
            Class Inheritance

            Abstract Classes, Interfaces, Mixins

            // Base aka parent class
            class Person {
            // Parent properties inherited by child
            String firstName;
            String lastName;
            // Parent class constructor
            Person(this.firstName, this.lastName);
            // Parent class method
            String get fullName => '$firstName $lastName';
            // Optional @override annotation
            // All class hierarchies and types have Object as
            root class
            @override
            String toString() => fullName;
            }
            // Subclass aka child class
            class Student extends Person {
            // Properties specific to child
            var grades = <String>[];
            // Call super on parent constructor
            Student(String firstName, String lastName)
            : super(firstName, lastName);
            // Optional override annotation on parent method
            override
            @override
            String get fullName => '$lastName, $firstName';
            }
            final jon = Person('Jon', 'Snow');
            final jane = Student('Jane', 'Snow'); // Calls
            parent constructor
            print(jon); // Jon Snow
            // Use toString in parent, in turn using subclass
            override of fullName
            print(jane); // Snow, Jane

            enum BloodType { warm, cold }
            abstract class Animal {
            BloodType bloodType; // Base class property
            void goSwimming(); // Abstract method without
            implementation
            }
            mixin Milk {
            bool hasMilk;
            bool doIHaveMilk() => hasMilk;
            }
            // Concrete class inheriting from abstract class
            class Cat extends Animal with Milk {
            BloodType bloodType = BloodType.warm; // Set value
            for property
            Cat() { hasMilk = true; } // Set mixin property
            // Concrete subclass must implement abstract
            methods
            @override
            void goSwimming() { print("No thanks!"); }
            }
            // Concrete class that also implements Comparable
            interface
            class Dolphin extends Animal implements
            Comparable<Dolphin> {
            BloodType bloodType = BloodType.warm;
            double length; // Concrete sublcass property
            Dolphin(this.length); // Concrete subclass
            constructor
            // Concrete subclass must implement abstract
            methods
            @override
            void goSwimming() { print("Click! Click!"); }
            // Also must implement interface methods
            @override
            int compareTo(other) =>
            length.compareTo(other.length);
            @override
            String toString() => '$length meters';
            }
            class Reptile extends Animal with Milk {
            BloodType bloodType = BloodType.cold;
            Reptile() { hasMilk = false; }
            @override
            void goSwimming() { print("Sure!"); }
            }

            Source: raywenderlich.com. Visit for more Flutter/Dart resources and tutorials!
            Page 4
            ! of 4

            // var snake = Animal(); // error: can't instantiate
            abstract class
            // Can instantiate concrete classes
            var garfield = Cat();
            var flipper = Dolphin(4.0);
            var snake = Reptile();
            // Call concrete methods
            flipper.goSwimming(); // Click! Click!
            garfield.goSwimming(); // No thanks!
            // Use interface implementation
            var orca = Dolphin(8.0); var alpha = Dolphin(5.0);
            var dolphins = [alpha, orca, flipper];
            dolphins.sort();
            print(dolphins); // [4 meters, 5 meters, 8 meters]
            print(snake.doIHaveMilk()); // false
            print(garfield.doIHaveMilk()); // true

            Version 1.0.1. Copyright 2019 Razeware LLC. All rights reserved.

            
~/Empire/Doks/Comp/lang/dart-flutter/cheatsh-qref/dart3.cheatsh.pdf
            Dart cheat sheet
            Build-in types

            Control flow statements

            Numbers: num, int, double

            // if else

            Strings: String, StringBuffer

            if (isRaining()) {

            Booleans: bool, true, false

            you.bringRainCoat();

            Lists (arrays): [0,1,2,3]

            } else if (isSnowing()) {

            Sets (unique): {'A', 'B', 'C'}

            you.wearJacket();

            Maps: {'key': 'value'}

            } else {
            car.putTopDown();

            Variables

            }
            // for loops

            var name = 'CodeSabai';

            for (var i = 0; i < 5; i++) {

            dynamic name = 'CodeSabai';

            print(i);

            String name = 'Code' + 'Sabai';

            }

            List<String> myList = ['C','O'];

            // while

            var mySet = <String> {};

            while (!isDone()) {

            var myMap = {54: 'xenon'};
            final name = 'Bob'; // set only once
            const bar = 1000000; // compile-time

            doSomething();
            }
            do {
            printLine();

            Functions
            int addNumber (int num1, int num2) {
            return num1 + num2;

            } while (!atEndOfPage());
            // switch case
            var command = 'OPEN';

            }

            switch (command) {

            // omit the types

            case 'CLOSED':

            addNumber (num1, num2) {

            executeClosed();

            return num1 + num2;

            break;

            }

            case 'OPEN':

            // named parameters

            executeOpen();

            void enableFlags ({bool bold, bool

            break;

            hidden}) {...}

            default:

            enableFlags (bold: true, hidden:

            executeUnknown();

            false);

            }

            // required
            Scrollbar ({Key key, @required Widget
            child})

            // assert (development only)
            assert (number < 100);

            // default parameter values

            Exceptions

            enableFlags ({bool bold = false, bool
            hidden = false}) {...}

            try {

            // anonymous functions

            breedMoreLlamas();

            var list = ['apples','bananas'];

            } catch (e) {

            list.forEach ( (item) =>
            print('${list.indexOf(item)}: $item'));
            });

            Copyright © All rights reserved by CodeSabai,

            print('Error: $e');
            } finally {
            cleanLlamaStalls(); }

            https://github.com/codesabai

            https://www.facebook.com/codesabai

            Dart cheat sheet
            Classes

            Abstract Classes

            class Point {
            num x, y;
            // static variable
            static const fixedNumber = 16;
            // constructor
            Point(this.x, this.y);
            // named constructor
            Point.origin() {
            x = 0;
            y = 0;
            }
            // initializer constructor
            Point.fromJson(Map<String, num> json)
            : x = json['x'],
            y = json['y'] {
            print('In Point.fromJson(): ($x, $y)');
            }
            }
            // invoking non-default constructor
            class Employee extends Person {
            Employee.fromJson(Map data) :
            super.fromJson(data) {
            // do something
            }
            }
            // factory constructors
            class Logger {
            final String name;
            bool mute = false;
            static final Map<String, Logger> _cache =
            <String, Logger>{};

            }

            factory Logger(String name) {
            if (_cache.containsKey(name)) {
            return _cache[name];
            } else {
            final logger =
            Logger._internal(name);
            _cache[name] = logger;
            return logger;
            }
            }
            Logger._internal(this.name);
            void log(String msg) {
            if (!mute) print(name + ' ' + msg);
            }

            Copyright © All rights reserved by CodeSabai,

            abstract class Doer {
            void doSomething();
            }
            class EffectiveDoer extends Doer {
            void doSomething() {
            print('something');
            }
            }
            class Greeter implements
            EffectiveDoer {
            doSomething () {
            print('Hello');
            }
            }

            Mixins
            // multiple class hierarchies
            class Musician extends Performer with
            Musical, Conductor, Composer {
            }
            mixin Musical {
            bool canPlayPiano = true;
            void entertainMe() {
            print('Playing piano');
            }
            }

            Asynchrony
            Future checkVersion() async {
            try {
            version = await lookUpVersion();
            } catch (e) {
            Print(e.toString);
            }
            // Do something with version
            }

            https://github.com/codesabai

            https://www.facebook.com/codesabai

            

~/Empire/Doks/Comp/lang/dart-flutter/dart-about.pdf
~/Empire/Doks/Comp/lang/dart-flutter/dart-about.spa.pdf
~/Empire/Doks/Comp/lang/dart-flutter/dart-action.pdf
~/Empire/Doks/Comp/lang/dart-flutter/dartapprentice.pdf
~/Empire/Doks/Comp/lang/dart-flutter/dartlangtut.pdf
~/Empire/Doks/Comp/lang/dart-flutter/dartlearn.pdf
    +h https://www.scribd.com/book/272071436/Dart-Essentials
~/Empire/Doks/Comp/lang/dart-flutter/dartwebapps.copy.pdf
~/Empire/Doks/Comp/lang/dart-flutter/dartwebapps.pdf


    ~/Empire/Doks/Comp/lang/dart-flutter/cheatsh-qref/flutter-mini.dart
(+Flutter Cookbook)
https://cheatography.com/kahmic16/cheat-sheets/flutter/
            Hello World in Flutter

            import 'package:flutter/material.dart';

            void main() => runApp(HelloWorldApp());

            class HelloWorldApp extends StatelessWidget {
              @override
              Widget build(BuildContext context) {
                return MaterialApp(
                  title: 'Hello World App',
                  home: Scaffold(
                    appBar: AppBar(
                      title: Text('App Bar Title here'),
                    ),
                    body: Center(
                      child: Text('Hello World'),
                    ),
                  ),
                );
              }
            }

                    
            Create Widget

            class RandomWords extends StatefulWidget {
              @override
              RandomWordsState createState() => RandomWordsState();
            }

            Add Something to a Widget

            @override
            Widget build(BuildContext context) {
              return Scaffold(
                appBar: AppBar(
                  title: Text('Startup Name Generator'),
                ),
                body: _buildSuggestions(),
              );
            }

            Change appearance of a Widget

            class RandomWordsState extends State<RandomWords> {
              final _suggestions = <WordPair>[];
              final _biggerFont = const TextStyle(fontSize: 18.0);
            }
https://dev.to/codemagicio/flutter-widgets-cheat-sheet-33an
            Flutter is an open-source tool designed to build fast and beautiful applications across multiple platforms. The Flutter SDK has been widely adopted for developing mobile applications, and many developers are learning Flutter every day. It is important to create content that can help them do this, and that's the aim of this blog post! So, we've prepared a simple cheat sheet of different Flutter widgets (and in Flutter, everything is a widget!), which you can use to build your Flutter apps.

            We've grouped the widgets into several categories:

            - Interaction widgets. These help make your Flutter app interactive.
            - Input widgets. These widgets are used to handle user input.
            - Alignment and layout widgets. You use these widgets everywhere to position other widgets on the screen relative to one another and organize them into structures.
            - Scrollable widgets. These widgets come in handy when you need to create scrollable lists and galleries.
            - Structure widgets. These are the foundational widgets for your app.
            - Paint widgets. These widgets allow you to customize the design of your app.
            - Button widgets. These are, as you might have guessed, for creating buttons.
            - Basic navigation. To navigate between screens, you'll need navigation. We'll provide a basic example of navigation in this article.

            If you don't understand the concept of widgets, you can refer to our Flutter From Scratch video on this topic.

            How do you use this Flutter widgets cheat sheet? Just copy-paste the code for the widgets you want to use in your app, and modify it to incorporate the logic you need. Let's get started!
            1. Interaction widgets

            Interaction widgets make your application dynamic and provide a good user experience, so it's essential to understand how to use them.
            GestureDetector

            GestureDetector is a widget that responds to events or gestures that correspond to its non-callbacks.

            - onTap
            - onTapUp
            - onTapDown
            - onLongPress
            - onDoubleTap
            - onHorizontalDragStart
            - onVerticalDragDown
            - onPanDown
            - onScaleStart

            You can use this gesture detector to create custom buttons or clickable text or pictures.

            To add a gesture detector, use the code below:

            - GestureDetector(

                  onTap: () {
                    const snackBar = SnackBar(content: Text('Tap'));

                    ScaffoldMessenger.of(context).showSnackBar(snackBar);
                  },
                  // The custom button
                  child: Container(
                    padding: const EdgeInsets.all(12.0),
                    decoration: BoxDecoration(
                      color: Colors.lightBlue,
                      borderRadius: BorderRadius.circular(8.0),
                    ),
                    child: const Text('My Button'),
                  ),
                )

            AlertDialog

            The AlertDialog widget creates a window to display crucial information with options that allow the user to make decisions.

            To add an alert dialog to your app, you can use the following code:

                 Future<void> _showMyDialog() async {
                  return showDialog<void>(
                    context: context,
                    barrierDismissible: false, // user must tap button!
                    builder: (BuildContext context) {
                      return AlertDialog(
                        title: const Text('Cheat Sheet'),
                        content: SingleChildScrollView(
                          child: ListBody(
                            children: const <Widget>[
                              Text('This is a demo alert dialog.'),
                              Text('Would you like to approve of this message?'),
                            ],
                          ),
                        ),
                        actions: <Widget>[
                          TextButton(
                            child: const Text('Approve'),
                            onPressed: () {
                              Navigator.of(context).pop();
                            },
                          ),
                        ],
                      );
                    },
                  );
                }

            SnackBar

            The SnackBar widget is used to briefly tell a user that an action has taken place. For example, you can delete an item that triggers a snackbar, which tells the user that an item has just been deleted.

            To add a snackbar to your application, use the code below:

            - Center(
                        child: ElevatedButton(
                          onPressed: () {
                          final snackBar =  SnackBar(
                            content: const Text('Yay! A SnackBar!'),
                            action: SnackBarAction(
                              label: 'Undo',
                              onPressed: () {
                               Text('data');
                              },
                            ),
                          );
                              ScaffoldMessenger.of(context).showSnackBar(snackBar);
                          },
                          child: const Text('Show snackbar'),
                        ),
                      ),

            Dismissable

            You can use a Dismissable widget to remove or dismiss items from a list. You can swipe left or right to remove any item.

            Use the code below to implement this feature:

            - List<String> items = <String>[
                    'banana',
                    'strawberry',
                    'apple'
                    'orange'
                    'cat'
                    'bobcat'
                  ];
            - ListView.builder(
                          itemCount: items.length,
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          itemBuilder: (BuildContext context, index) {
                            return Dismissible(
                              background: Container(
                                color: Colors.green,
                              ),
                              key: Key(items[index]),
                              onDismissed: (DismissDirection direction) {
                                setState(() {
                                  items.removeAt(index);
                                });
                              },
                              child: ListTile(
                                title: Text(
                                  'Item ${items[index]}',
                                ),
                              ),
                            );
                          },
                        ),

            InteractiveViewer

            If you have a big picture that doesn't fit on the screen, you can use the InteractiveViewer widget to enable it to fit on the screen by allowing the user to zoom in and out of the picture.

            - InteractiveViewer(
                        boundaryMargin: const EdgeInsets.all(20.0),
                        child: Container(
                          decoration: const BoxDecoration(
                            gradient: LinearGradient(
                              begin: Alignment.topCenter,
                              end: Alignment.bottomCenter,
                              colors: <Color>[Colors.blue, Colors.yellow],
                              stops: <double>[0.0, 1.0],
                            ),
                          ),
                        ),
                      ),

            2. Input widgets

            Input widgets are a very important part of modern-day Flutter applications. For example, they are used to create an account, log in, or even perform a simple search.
            Flutter forms

            You can create a login and signup form using these widgets.

            Try creating a form using the Forms widget and TextFormFields widget:

                  class MyApp extends StatelessWidget {
                  const MyApp({Key? key}) : super(key: key);
                  @override
                  Widget build(BuildContext context) {
                    const appTitle = 'Flutter Form Demo';
                    return MaterialApp(
                      title: appTitle,
                      home: Scaffold(
                        appBar: AppBar(
                          title: const Text(appTitle),
                        ),
                        body: const MyCustomForm(),
                      ),
                    );
                  }
                }
                // Create a Form widget
            - class MyCustomForm extends StatefulWidget {
                  const MyCustomForm({Key? key}) : super(key: key);
                  @override
                  MyCustomFormState createState() {
                    return MyCustomFormState();
                  }
                }
            - class MyCustomFormState extends State<MyCustomForm> {
                  final formKey = GlobalKey<FormState>();
                  @override
                  Widget build(BuildContext context) {
                    // Build a Form widget using the formKey created above
                    return Form(
                      key: formKey,
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: <Widget>[
                          TextFormField(
                            decoration: const InputDecoration(
                              icon:  Icon(Icons.person),
                              hintText: 'Enter your name',
                              labelText: 'Name',
                            ),
                          ),
                          TextFormField(
                            decoration: const InputDecoration(
                              icon: Icon(Icons.calendar_today),
                              hintText: 'Enter your date of birth',
                              labelText: 'Dob',
                            ),
                          ),
                          const ElevatedButton(
                            child:  Text('Submit'),
                            onPressed: null,
                          ),
                        ],
                      ),
                    );
                  }
                }

            Autocomplete

            This widget can come in handy in search boxes.

            To add autocomplete to your Flutter application, you can use the following code snippet. The options to be displayed are determined by the optionsBuilder and rendered by the optionsViewBuilder.

                // have a list of words or names from a remote source or package
            - const List<String> _kOptions = <String>[
                    'aardvark',
                    'bobcat',
                    'chameleon',
                  ];
                // use the Autocomplete widget to make selections
            - Autocomplete<String>(
                      optionsBuilder: (TextEditingValue textEditingValue) {
                        if (textEditingValue.text == '') {
                          return const Iterable<String>.empty();
                        }
                        return _kOptions.where((String option) {
                          return option.contains(textEditingValue.text.toLowerCase());
                        });
                      },
                      onSelected: (String selection) {
                        debugPrint('You just selected $selection');
                      },
                    );

            TextField

            TextField is one of the most fundamental and commonly used widgets for keyboard input.

            - TextField(
                  obscureText: true,
                  decoration: InputDecoration(
                    border: OutlineInputBorder(),
                    labelText: 'Password',
                  ),
                )

            3. Alignment and layout widgets cheat sheet

            These widgets are very important for building UIs in Flutter.
            Center

            This widget centers a child within itself.

            - Center( child: Text('Center me'))

            Expanded

            The Expanded widget expands the child of a Row or Column to fill any available space.

            For example, you can use it to build a UI that fills the screen with just three containers or pictures. Theoretically, we can just specify their heights, but remember that there are different screen sizes for different devices, including tablets such as iPad devices. The expanded widget can help you create a more responsive design that can easily fit all screen sizes.

            - Row(
                          children: <Widget>[
                            Expanded(
                              flex: 2,
                              child: Container(
                                color: Colors.amber,
                                height: 100,
                              ),
                            ),
                            Container(
                              color: Colors.blue,
                              height: 100,
                              width: 50,
                            ),
                            Expanded(
                              child: Container(
                                color: Colors.amber,
                                height: 100,
                              ),
                            ),
                          ],
                        ),

            Align

            The Align widget aligns its child within itself. This widget is very flexible and can take the size of its child.

            The child can be placed at different points within its parent widget using the alignment property, as shown below:

            - Container(
                    height: 120.0,
                    width: 120.0,
                    color: Colors.blue[50],
                    child: const Align(
                      alignment: Alignment.topRight,
                      child: FlutterLogo(
                        size: 60,
                      ),
                    ),
                  ),

            Row

            The Row widget takes a list of widgets and arranges them horizontally. You will likely use this widget a lot when making layouts in your code.

            - Row(
                        children: [
                          ElevatedButton(
                            child: const Text('Widget 1'),
                            onPressed: () => Navigator.pushNamed(context, '/second'),
                          ),
                           ElevatedButton(
                            child: const Text('Widget 2'),
                            onPressed: () => Navigator.pushNamed(context, '/third'),
                          ),
                           ElevatedButton(
                            child: const Text('Widget 3'),
                            onPressed: () => Navigator.pushNamed(context, '/fourth'),
                          ),
                        ],
                      ),

            Column

            The Column widget allows you to arrange a list of widgets vertically, similar to how the Row widget aligns them horizontally.

            - Column(
                  children: const <Widget>[
                    Text('Deliver features faster'),
                    Text('Craft beautiful UIs'),
                    Expanded(
                      child: FittedBox(
                        fit: BoxFit.contain,
                        child: FlutterLogo(),
                      ),
                    ),
                  ],
                )

            SizedBox

            Use SizedBox to give a specific size to its child widget or provide some white space between widgets.

            - const SizedBox(
                  width: 200.0,
                  height: 300.0,
                  child: Card(child: Text('Size me!')),
                )

            BaseLine

            Use the BaseLine widget to position the child widget according to the starting point of the parent widget.

            - Center(
                      child: Container(
                              width: 100,
                              height: 100,
                              color: Colors.green,
                              child: Baseline(
                                baseline: 50,
                                baselineType: TextBaseline.ideographic,
                                child: Container(
                                  width: 50,
                                  height: 50,
                                  color: Colors.purple,
                                ),
                              ),
                            ),
                    );

            LimitedBox

            Use this widget to assign a default size to a list of widgets that are unconstrained.

            - LimitedBox(
                         maxHeight: 150,
                         maxWidth: 150,
                         child: Container(
                         color: Colors.red,
                        )
                       )

            Padding

            Use the Padding widget to provide space around its child. The padding widget adds space around its child using the abstract EdgeInsetsGeometry class.

            The padding property of the padding widget accepts the EdgeInsets object, which allows you to add different types of padding, including padding only in certain places using EdgeInsets.only or from different angles using EdgeInsets.fromLTRB.

            - const Card(
                  child: Padding(
                    padding: EdgeInsets.all(16.0),
                    child: Text('Hello World!'),
                  ),
                )

            4. Scrollable widgets
            ListView Builder

            ListView Builder is the most used scrollable widget. It displays its children in the scroll direction one after the other. For example, if you have a long list that is dynamically created, you can use Listview.builder to display it.

            Use the following code to get started:

            - final List<String> entries = <String>['A', 'B', 'C'];
            - ListView.builder(
                  padding: const EdgeInsets.all(8),
                  itemCount: entries.length,
                  itemBuilder: (BuildContext context, int index) {
                    return Container(
                      height: 50,
                      color: Colors.amber[colorCodes[index]],
                      child: Center(child: Text('Entry ${entries[index]}')),
                    );
                  }

            SingleChildScrollView

            The SingleChildScrollView widget will come in handy if you have a list of items that you initially didn't intend for the user to scroll through, but the requirements change upon implementation. In this case, you can quickly wrap the parent widget with a SingleChildScrollView to make it scrollable.

            - SingleChildScrollView(
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        mainAxisAlignment: MainAxisAlignment.spaceAround,
                        children: <Widget>[
                          Container(
                            color:  Colors.red,
                            height: 300.0,
                            alignment: Alignment.center,
                            child: const Text('Fixed Height Content'),
                          ),
                          Container(
                            color: Colors.blue,
                            height: 250.0,
                            alignment: Alignment.center,
                            child: const Text('Fixed Height Content'),
                          ),
                          Container(
                            color: Colors.green,
                            height: 250.0,
                            alignment: Alignment.center,
                            child: const Text('Fixed Height Content'),
                          ),
                          Container(
                            color: Colors.purple,
                            height: 250.0,
                            alignment: Alignment.center,
                            child: const Text('Fixed Height Content'),
                          ),
                        ],
                      ),
                    );

            5. Structure widgets

            These are the widgets that compose your app. In this Flutter widget cheat sheet, we will only be highlighting two of them: Scaffold and Loader.
            Scaffold

            Use Scaffold widgets for all your application layers.

            - Scaffold(
                      appBar: AppBar(),
                      body: Row(
                        children: [
                          ElevatedButton(
                            child: const Text('Widget 1'),
                            onPressed: () => Navigator.pushNamed(context, '/second'),
                          ),
                      ),

            Adding Loader

            Create Loaders for your app when making an API request.

            - class SomeWidget extends StatefulWidget {
                  @override
                  _SomeWidgetState createState() => _SomeWidgetState();
                }
            - class _SomeWidgetState extends State<SomeWidget> {
                  late Future future;
                  @override
                  void initState() {
                    future = Future.delayed(const Duration(seconds: 8));
                    super.initState();
                  }
                  @override
                  Widget build(BuildContext context) {
                    return FutureBuilder(
                      future: future,
                      builder: (context, snapshot) {
                        return snapshot.connectionState == ConnectionState.done
                            ? const Text('Loaded')
                            : const CircularProgressIndicator();
                      },
                    );
                  }
                }

            6. Paint widgets

            Painting effects can give a finished look to your app's design.
            InkWell

            With the InkWell widget, you can create ink splash effects on images or custom buttons when you click on them.

            - class _SomeWidgetState extends State<SomeWidget> {
                  @override
                  Widget build(BuildContext context) {
                    Image img = Image.network(
                        'https://images.unsplash.com/photo-1592194996308-7b43878e84a6?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=687&q=80');
                    return Material(
                      child: Ink.image(
                        fit: BoxFit.fill,
                        width: 300,
                        height: 300,
                        image: img.image,
                        child: InkWell(
                          onTap: () {
                            print('image');
                          },
                          child: const Align(
                            child: Padding(
                              padding: EdgeInsets.all(10.0),
                              child: Text(
                                'PUFFIN',
                                style: TextStyle(
                                  fontWeight: FontWeight.w900,
                                  color: Colors.white,
                                ),
                              ),
                            ),
                          ),
                        ),
                      ),
                    );
                  }
                }

            DecoratedBox

            DecoratedBox, together with BoxDecoration, helps you add more styling to your container widget.

            - Container(
                      decoration: const BoxDecoration(
                        borderRadius: BorderRadius.all(
                          Radius.circular(12),
                        ),
                        gradient:RadialGradient(
                      center: Alignment(-0.5, -0.6),
                      radius: 0.15,
                      colors: <Color>[
                        Color(0xFFEEEEEE),
                        Color(0xFF111133),
                      ],
                      stops: <double>[0.9, 1.0],
                    )));

            ClipRect

            Use ClipRect to clip the child within different shapes.

            - class DecorateContainer extends StatelessWidget {
                   const DecorateContainer(Key? key, this.image) : super(key: key);
                 final Image image;
                  @override
                  Widget build(BuildContext context) {
                    return ClipRect(
                  child: Container(
                    child: Align(
                      alignment: Alignment.center,
                        widthFactor: 0.4,
                        heightFactor: 1.0,
                        child: image
                    ),
                  ),
                );
                  }
                }

            ClipPath

            With the ClipPath widget, you can give any shape to the child widget. This means you can use it to draw any shape of your choice or according to your UI requirements with less code.

                 // body of your app
            - ClipPath(
                        child: Container(
                          width: MediaQuery.of(context).size.width,
                          height: 250,
                          color: Colors.red,
                        ),
                        clipper: CustomClipPath(),
                      ),

                // custom class
                 class CustomClipPath extends CustomClipper<Path> {
                  var radius=5.0;
                  @override
                  Path getClip(Size size) {
                    Path path = Path();
                    path.lineTo(size.width / 2, size.height);
                    path.lineTo(size.width, 0.0);
                    return path;
                  }
                  @override
                  bool shouldReclip(CustomClipper<Path> oldClipper) => false;
                }

            7. Buttons

            There are many types of buttons in Flutter, so we'll only suggest the most useful ones in this cheat sheet.
            TextButton

            This is a Material button with text that has no borders.

                 TextButton(
                                  style: TextButton.styleFrom(
                                    padding: const EdgeInsets.all(16.0),
                                    primary: Colors.white,
                                    textStyle: const TextStyle(fontSize: 20),
                                  ),
                                  onPressed: () {},
                                  child: const Text('Gradient'),
                                ),

            ElevatedButton

            ElevatedButton is a Material button that elevates when pressed. Avoid using elevated buttons on widgets that are already elevated, like dialogs.

            - ElevatedButton(
                            style: ElevatedButton.styleFrom(),
                            onPressed: () {},
                            child: const Text('Enabled'),
                          ),

            FloatingActionButton

            Use FloatingActionButton to create a primary action on the screen.

            - Scaffold(
                      appBar: AppBar(
                        title: const Text('Floating Action Button'),
                      ),
                      body: const Center(child: Text('Press the button below!')),
                      floatingActionButton: FloatingActionButton(
                        onPressed: () {
                          // on pressed
                        },
                        backgroundColor: Colors.green,
                        child: const Icon(Icons.navigation),
                      ),
                    );

            8. Basic navigation

            Named routing can be used for small to medium-sized projects. Alternatively, you can use the Navigator API, which provides various routing functions.

            Flutter provides named routing to enable users to navigate your application:

            - void main() {
                  runApp(MaterialApp(
                    initialRoute: '/',
                    routes: {
                      '/' : ((context) => const FirstScreen()),
                      '/second':(context) => const SecondScreen()
                    },
                    home: const MyApp()));
                }
            - class MyApp extends StatelessWidget {
                  const MyApp({Key? key}) : super(key: key);
                  @override
                  Widget build(BuildContext context) {
                    return Scaffold(
                        appBar: AppBar(
                          title: const Text('Navigation'),
                        ),
                        body:const FirstScreen()

                    );
                  }
                }

            - class FirstScreen extends StatelessWidget {
                  const FirstScreen({Key? key}) : super(key: key);
                  @override
                  Widget build(BuildContext context) {
                    return Center(
                      child: ElevatedButton(
                        child: const Text('Go to SecondScreen'),
                        onPressed: () => Navigator.pushNamed(context, '/second'),
                      ),
                    );
                  }
                }
                // can add this in a new file
            - class SecondScreen extends StatelessWidget {
                  const SecondScreen({Key? key}) : super(key: key);

                  @override
                  Widget build(BuildContext context) {
                    return ElevatedButton(
                      child:const Text('Go back!'),
                      onPressed: () => Navigator.pop(context),
                    );
                  }
                }

            - To learn more about Flutter Navigator 2.0, read this article.

            Conclusion

            We have created this list of Flutter widgets as a quick reference for you while you build your Flutter app. We hope you have learned something new about these widgets that can help you improve the functionality of your Flutter application.

            We have an ebook that covers a list of libraries commonly used by Flutter developers, including networking, state management, and more. You can also watch our Flutter From Scratch tutorial, which goes into detail about how to use these libraries and widgets.

            Codemagic is a CI/CD tool for Flutter and other mobile developers.
~/Empire/Doks/Comp/lang/dart-flutter/flutter/flutterlayout.cheatsh.pdf
            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            Tomek Polański Follow
            Passionate mobile developer. One thing I like more than learning new things: sharing them
            May 2 · 9 min read

            Flutter Layout Cheat Sheet

            Do you need simple layout samples for Flutter?
            I present you my set of Flutter layout code snippets. I will keep it short,
            sweet and simple with loads of visual examples.
            Still, it is work in progress - the catalog of samples will grow. I will
            focus more on the usage of Flutter widgets rather than showcasing the
            components (Flutter Gallery is great for that!).
            If you have an issue with “layouting” your Flutter or you wanna share
            your snippets with others, please drop a line!

            . . .

            Table of Contents
            - Row and Column

            - IntrinsicWidth and IntrinsicHeight NEW

            - Stack

            - Expanded

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            1/38

                evince -p 2 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            - ConstrainedBox

            - Container

            - SizedBox

            - SafeArea

            . . .

            Row and Column
            MainAxisAlignment

            new Row /*or Column*/(
            mainAxisAlignment: MainAxisAlignment.start,

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            2/38


                evince -p 3 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            children: <Widget>[
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            ],
            ),

            . . .

            new Row /*or Column*/(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            ],
            ),

            . . .
            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            3/38


                evince -p 4 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            new Row /*or Column*/(
            mainAxisAlignment: MainAxisAlignment.end,
            children: <Widget>[
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            ],
            ),

            . . .

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            4/38


                evince -p 5 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            new Row /*or Column*/(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: <Widget>[
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            ],
            ),

            . . .

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            5/38


                evince -p 6 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            new Row /*or Column*/(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: <Widget>[
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            ],
            ),

            . . .

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            6/38


                evince -p 7 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            new Row /*or Column*/(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: <Widget>[
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            ],
            ),

            . . .

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            7/38


                evince -p 8 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            You should use

            CrossAxisAlignment.baseline

            if you require for the

            baseline of di erent text be aligned.

            new Row(
            crossAxisAlignment: CrossAxisAlignment.baseline,
            textBaseline: TextBaseline.alphabetic,
            children: <Widget>[
            new Text(
            'Baseline',
            style: Theme.of(context).textTheme.display3,
            ),
            new Text(
            'Baseline',
            style: Theme.of(context).textTheme.body1,
            ),
            ],
            ),

            . . .
            CrossAxisAlignment

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            8/38


                evince -p 9 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            new Row /*or Column*/(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: <Widget>[
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 200.0),
            new Icon(Icons.star, size: 50.0),
            ],
            ),

            . . .

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            9/38


                evince -p 10 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            new Row /*or Column*/(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: <Widget>[
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 200.0),
            new Icon(Icons.star, size: 50.0),
            ],
            ),

            . . .

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            10/38


                evince -p 11 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            new Row /*or Column*/(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: <Widget>[
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 200.0),
            new Icon(Icons.star, size: 50.0),
            ],
            ),

            . . .

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            11/38


                evince -p 12 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            new Row /*or Column*/(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: <Widget>[
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 200.0),
            new Icon(Icons.star, size: 50.0),
            ],
            ),

            . . .
            MainAxisSize

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            12/38


                evince -p 13 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            new Row /*or Column*/(
            mainAxisSize: MainAxisSize.max,
            children: <Widget>[
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            ],
            ),

            . . .

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            13/38


                evince -p 14 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            new Row /*or Column*/(
            mainAxisSize: MainAxisSize.min,
            children: <Widget>[
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            new Icon(Icons.star, size: 50.0),
            ],
            ),

            . . .

            IntrinsicWidth and IntrinsicHeight
            Want all the widgets inside Row or Column to be as tall/wide as the
            tallest/widest widget? Search no more!
            In case you have this kind of layout:

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            14/38


                evince -p 15 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            Widget build(BuildContext context) {
            return Scaffold(
            appBar: AppBar(title: Text('IntrinsicWidth')),
            body: Center(
            child: Column(
            children: <Widget>[
            RaisedButton(
            onPressed: () {},
            child: Text('Short'),
            ),
            RaisedButton(
            onPressed: () {},
            child: Text('A bit Longer'),
            ),
            RaisedButton(
            onPressed: () {},
            child: Text('The Longest text button'),
            ),
            ],
            ),
            ),
            );
            }

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            15/38


                evince -p 16 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            But you would like to have all buttons as wide as the widest, just use
            IntrinsicWidth

            :

            Widget build(BuildContext context) {
            return Scaffold(
            appBar: AppBar(title: Text('IntrinsicWidth')),
            body: Center(
            child: IntrinsicHeight(
            child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: <Widget>[
            RaisedButton(
            onPressed: () {},
            child: Text('Short'),
            ),
            RaisedButton(
            onPressed: () {},
            child: Text('A bit Longer'),
            ),
            RaisedButton(
            onPressed: () {},
            child: Text('The Longest text button'),
            ),
            ],
            ),
            ),

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            16/38


                evince -p 17 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            ),
            );
            }

            In case you have a similar problem but you would like to have all the
            widgets as tall as the tallest just use combination of
            and

            Row

            IntrinsicHeight

            widgets.

            . . .

            Stack
            Perfect for overlaying Widgets on top of each other

            @override
            Widget build(BuildContext context) {
            Widget main = Scaffold(
            appBar: AppBar(title: Text('Stack')),
            );

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            17/38


                evince -p 18 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            return Stack(
            fit: StackFit.expand,
            children: <Widget>[
            main,
            Banner(
            message: "Top Start",
            location: BannerLocation.topStart,
            ),
            Banner(
            message: "Top End",
            location: BannerLocation.topEnd,
            ),
            Banner(
            message: "Bottom Start",
            location: BannerLocation.bottomStart,
            ),
            Banner(
            message: "Bottom End",
            location: BannerLocation.bottomEnd,
            ),
            ],
            );
            }

            . . .
            With your own Widgets, you need to place them in

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            Positioned

            Widget

            18/38


                evince -p 19 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            Widget build(BuildContext context) {
            return new Scaffold(
            appBar: AppBar(title: Text('Stack')),
            body: Stack(
            fit: StackFit.expand,
            children: <Widget>[
            Material(color: Colors.yellowAccent),
            Positioned(
            top: 0.0,
            left: 0.0,
            child: Icon(Icons.star, size: 50.0),
            ),
            Positioned(
            top: 340.0,
            left: 250.0,
            child: Icon(Icons.call, size: 50.0),
            ),
            ],
            ),
            );
            }

            . . .

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            19/38


                evince -p 20 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            If you don't want to guess the top/bottom values you can use
            LayoutBuilder

            to retrieve them

            Widget build(BuildContext context) {
            const iconSize = 50.0;
            return Scaffold(
            appBar: AppBar(title: Text('Stack with LayoutBuilder')),
            body: LayoutBuilder(
            builder: (context, constraints) =>
            Stack(
            fit: StackFit.expand,
            children: <Widget>[
            Material(color: Colors.yellowAccent),
            Positioned(
            top: 0.0,
            child: Icon(Icons.star, size: iconSize),
            ),
            Positioned(
            top: constraints.maxHeight - iconSize,
            left: constraints.maxWidth - iconSize,
            child: Icon(Icons.call, size: iconSize),
            ),
            ],
            ),
            ),

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            20/38


                evince -p 21 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            );
            }

            . . .

            Expanded
            Expanded

            works with Flex\Flexbox layout and is great for distributing

            space between multiple items.

            new Row(
            children: <Widget>[
            new Expanded(
            child: new Container(
            decoration: const BoxDecoration(color: Colors.red),
            ),
            flex: 3,
            ),
            new Expanded(
            child: new Container(
            decoration: const BoxDecoration(color:

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            21/38


                evince -p 22 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            Colors.green),
            ),
            flex: 2,
            ),
            new Expanded(
            child: new Container(
            decoration: const BoxDecoration(color: Colors.blue),
            ),
            flex: 1,
            ),
            ],
            ),

            . . .

            ConstrainedBox
            By default, most of the widgets will use as little space as possible:

            new Card(child: const Text('Hello World!'), color:
            Colors.yellow)

            . . .

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            22/38


                evince -p 23 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            ConstrainedBox

            allows a widget to use the remaining space as desired.

            new ConstrainedBox(
            constraints: new BoxConstraints.expand(),
            child: const Card(
            child: const Text('Hello World!'),
            color: Colors.yellow,
            ),
            ),

            . . .
            Using

            BoxConstraints

            — you specify

            min

            /

            you specify how much space a widget can have

            max

            BoxConstraints.expand

            of

            height

            /

            width

            .

            uses in nite (all the available) amount of

            space unless speci ed:

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            23/38


                evince -p 24 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            new ConstrainedBox(
            constraints: new BoxConstraints.expand(height: 300.0),
            child: const Card(
            child: const Text('Hello World!'),
            color: Colors.yellow,
            ),
            ),

            And it's the same as:

            new ConstrainedBox(
            constraints: new BoxConstraints(
            minWidth: double.infinity,
            maxWidth: double.infinity,
            minHeight: 300.0,
            maxHeight: 300.0,
            ),
            child: const Card(
            child: const Text('Hello World!'),
            color: Colors.yellow,
            ),
            ),

            . . .

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            24/38


                evince -p 25 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            Container
            One of the most used Widgets - and for good reasons:

            Container as a layout tool
            When you don't specify the
            it will match its

            child

            height

            and the

            width

            of the

            Container

            ,

            's size

            Widget build(BuildContext context) {
            return Scaffold(
            appBar: AppBar(title: Text('Container as a layout')),
            body: Container(
            color: Colors.yellowAccent,
            child: Text("Hi"),
            ),
            );
            }

            If you want to stretch the
            double.infinity

            for the

            Container
            height

            to match its parent, use

            and

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            width

            properties

            25/38


                evince -p 26 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            Widget build(BuildContext context) {
            return Scaffold(
            appBar: AppBar(title: Text('Container as a layout')),
            body: Container(
            height: double.infinity,
            width: double.infinity,
            color: Colors.yellowAccent,
            child: Text("Hi"),
            ),
            );
            }

            Container as decoration
            You can use color property to a ect
            decoration

            and

            Container

            foregroundDecoration

            you can completely change how

            's background but

            . (With those two properties,

            Containe

            r looks like but I will be

            talking about di erent decorations later as it quite big topic)
            decoration

            is always placed behind the child, whereas

            foregroundDecoration

            is on top of the

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            child

            26/38


                evince -p 27 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            decoration

            Widget build(BuildContext context) {
            return Scaffold(
            appBar: AppBar(title: Text('Container.decoration')),
            body: Container(
            height: double.infinity,
            width: double.infinity,
            decoration: BoxDecoration(color: Colors.yellowAccent),
            child: Text("Hi"),
            ),
            );
            }

            . . .

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            27/38


                evince -p 28 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            decoration and foregroundDecoration

            Widget build(BuildContext context) {
            return Scaffold(
            appBar: AppBar(title:
            Text('Container.foregroundDecoration')),
            body: Container(
            height: double.infinity,
            width: double.infinity,
            decoration: BoxDecoration(color: Colors.yellowAccent),
            foregroundDecoration: BoxDecoration(color:
            Colors.red.withOpacity(0.5)),
            child: Text("Hi"),
            ),
            );
            }

            Container as Transform
            If you don't want to use
            can use

            transform

            Transform

            widget to change your layout, you

            property straight from the

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            Container

            28/38


                evince -p 29 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            Widget build(BuildContext context) {
            return Scaffold(
            appBar: AppBar(title: Text('Container.transform')),
            body: Container(
            height: 300.0,
            width: 300.0,
            transform: Matrix4.rotationZ(pi / 4),
            decoration: BoxDecoration(color: Colors.yellowAccent),
            child: Text(
            "Hi",
            textAlign: TextAlign.center,
            ),
            ),
            );
            }

            . . .

            SizedBox
            It's one of the simplest but most useful Widgets

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            29/38


                evince -p 30 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            SizedBox as ConstrainedBox
            SizedBox

            can work in a similar fashion as

            ConstrainedBox

            SizedBox.expand(
            child: Card(
            child: Text('Hello World!'),
            color: Colors.yellowAccent,
            ),
            ),

            . . .
            SizedBox as padding
            When in need of adding padding or margin, you might choose
            Padding

            or

            Container

            redeable than adding a

            widgets. But they can be more verbose and less
            Sizedbox

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            30/38


                evince -p 31 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            Column(
            children: <Widget>[
            Icon(Icons.star, size:
            const SizedBox(height:
            Icon(Icons.star, size:
            Icon(Icons.star, size:
            ],
            ),

            50.0),
            100.0,),
            50.0),
            50.0)

            SizedBox as an Invisible Object
            Many time you would like to hide/show a widget depending on a

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            bool

            31/38


                evince -p 32 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            Widget build(BuildContext context) {
            bool isVisible = ...
            return Scaffold(
            appBar: AppBar(
            title: Text('isVisible = $isVisible'),
            ),
            body: isVisible
            ? Icon(Icons.star, size: 150.0)
            : const SizedBox(),
            );
            }

            Because

            SizedBox

            has a

            const

            constructor, using

            const SizedBox()

            is really cheap**.
            ** One cheaper solution would be to use
            the

            opacity

            value to

            0.0

            Opacity

            widget and change

            . The drawback of this solution is that the

            given widget would be only invisible, still would occupy the space.

            . . .
            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            32/38


                evince -p 33 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            SafeArea
            On di erent Platforms, there are special areas like Status Bar on
            Android or the Notch on iPhone X that we might avoid drawing under.
            The solution to this problem is
            without/with

            SafeArea

            SafeArea

            widget (example

            )

            Widget build(BuildContext context) {
            return Material(
            color: Colors.blue,
            child: SafeArea(
            child: SizedBox.expand(
            child: Card(color: Colors.yellowAccent),
            ),
            ),
            );
            }

            . . .
            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            33/38


                evince -p 34 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            More coming soon

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            34/38


                evince -p 35 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            35/38


                evince -p 36 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            36/38


                evince -p 37 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            37/38


                evince -p 38 ~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheatsh.pdf &

            10/8/2018

            Flutter Layout Cheat Sheet - ProAndroidDev

            https://proandroiddev.com/ﬂutter-layout-cheat-sheet-5363348d037e

            38/38
~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf
~/Empire/Doks/Comp/lang/dart-flutter/flutter/flutter-layouts.txt
                evince -p 1 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            Building Layouts in Flutter
            What youll learn:
            How Flutter's layout mechanism works.
            How to lay out widgets vertically and horizontally.
            How to build a Flutter layout.

            This is a guide to building layouts in Flutter. You'll build the layout for the following screenshot:

            This guide then takes a step back to explain Flutter's approach to layout, and shows how to place a single widget on the screen. After a discussion of
            how to lay widgets out horizontally and vertically, some of the most common layout widgets are covered.
            Building a layout
            Step 0: Set up
            Step 1: Diagram the layout
            Step 2: Implement the title row
            Step 3: Implement the button row
            Step 4: Implement the text section
            Step 5: Implement the image section
            Step 6: Put it together
            Flutter's approach to layout
            Lay out a widget
            Lay out multiple widgets vertically and horizontally
            Aligning widgets
            Sizing widgets
            https://flutter.io/tutorials/layout/

            1/26


                evince -p 2 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            Packing widgets
            Nesting rows and columns
            Common layout widgets
            Standard widgets
            Material Components
            Resources

            Building a layout
            If you want a “big picture” understanding of the layout mechanism, start with Flutter's approach to layout.

            Step 0: Set up
            First, get the code:
            Make sure you've set up your environment.
            Create a basic Flutter app.
            Next, add the image to the example:
            Create an images directory at the top of the project.
            Add lake.jpg . (Note that wget doesn't work for saving this binary le.)
            Update the pubspec.yaml le to include an assets tag. This makes the image available to your code.

            Step 1: Diagram the layout
            The rst step is to break the layout down to its basic elements:
            Identify the rows and columns.
            Does the layout include a grid?
            Are there overlapping elements?
            Does the UI need tabs?
            Notice areas that require alignment, padding, or borders.
            First, identify the larger elements. In this example, four elements are arranged into a column: an image, two rows, and a block of text.

            https://flutter.io/tutorials/layout/

            2/26


                evince -p 3 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            Next, diagram each row. The rst row, called the Title section, has 3 children: a column of text, a star icon, and a number. Its rst child, the column,
            contains 2 lines of text. That rst column takes a lot of space, so it must be wrapped in an Expanded widget.

            The second row, called the Button section, also has 3 children: each child is a column that contains an icon and text.

            https://flutter.io/tutorials/layout/

            3/26


                evince -p 4 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            Once the layout has been diagrammed, it's easiest to take a bottom-up approach to implementing it. To minimize the visual confusion of deeply
            nested layout code, place some of the implementation in variables and functions.

            Step 2: Implement the title row
            First, you'll build the left column in the title section. Putting Column inside an Expanded widget stretches the column to use all remaining free space in
            the row. Setting the crossAxisAlignment property to CrossAxisAlignment.start positions the column to the beginning of the row.
            Putting the rst row of text inside a Container enables adding padding. The second child in the Column, also text, displays as grey.
            The last two items in the title row are a star icon, painted red, and the text “41”. Place the entire row in a Container and pad along each edge with 32
            pixels.
            Here's the code that implements the title row.
            Note: If you have problems, you can check your code against lib/main.dart on GitHub.

            class MyApp extends StatelessWidget {
            @override
            Widget build(BuildContext context) {
            Widget titleSection = Container(
            padding: const EdgeInsets.all(32.0),
            child: Row(
            children: [
            Expanded(
            child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
            Container(
            padding: const EdgeInsets.only(bottom: 8.0),
            child: Text(
            'Oeschinen Lake Campground',
            style: TextStyle(
            fontWeight: FontWeight.bold,
            ),
            ),
            ),
            Text(
            'Kandersteg, Switzerland',
            style: TextStyle(
            color: Colors.grey[500],
            ),
            ),
            ],
            ),
            ),
            Icon(
            Icons.star,
            color: Colors.red[500],
            ),
            Text('41'),
            ],
            ),
            );
            //...
            }

             Tip: When pasting code into your app, indentation can become skewed. You can x this in your Flutter editor using the automatic reformatting
            support.

             Tip: For a faster development experience try Flutter's hot reload feature Hot reload allows you to modify your code and see the changes

            https://flutter.io/tutorials/layout/

            4/26


                evince -p 5 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

             Tip: For a faster development experience, try Flutter s hot reload feature. Hot reload allows you to modify your code and see the changes
            without fully restarting the app. The Flutter enabled IDEs support ‘hot reload on save', or you can trigger from the command line. For more
            information about reloads, see Hot Reloads vs. Full Application Restarts.

            Step 3: Implement the button row
            The button section contains 3 columns that use the same layout—an icon over a row of text. The columns in this row are evenly spaced, and the text
            and icons are painted with the primary color, which is set to blue in the app's build() method:

            class MyApp extends StatelessWidget {
            @override
            Widget build(BuildContext context) {
            //...
            return MaterialApp(
            title: 'Flutter Demo',
            theme: ThemeData(
            primarySwatch: Colors.blue,
            ),
            //...
            }

            Since the code for building each row would be almost identical, it's most e cient to create a nested function, such as buildButtonColumn() , which
            takes an Icon and Text, and returns a column with its widgets painted in the primary color.

            class MyApp extends StatelessWidget {
            @override
            Widget build(BuildContext context) {
            //...
            Column buildButtonColumn(IconData icon, String label) {
            Color color = Theme.of(context).primaryColor;
            return Column(
            mainAxisSize: MainAxisSize.min,
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
            Icon(icon, color: color),
            Container(
            margin: const EdgeInsets.only(top: 8.0),
            child: Text(
            label,
            style: TextStyle(
            fontSize: 12.0,
            fontWeight: FontWeight.w400,
            color: color,
            ),
            ),
            ),
            ],
            );
            }
            //...
            }

            The build function adds the icon directly to the column. Put text into a Container to add padding above the text, separating it from the icon.
            Build the row containing these columns by calling the function and passing the icon and text speci c to that column. Align the columns along the
            main axis using MainAxisAlignment.spaceEvenly to arrange the free space evenly before, between, and after each column.

            class MyApp extends StatelessWidget {
            @override
            Widget build(BuildContext context) {
            //...
            Widget buttonSection = Container(
            child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
            buildButtonColumn(Icons.call, 'CALL'),
            buildButtonColumn(Icons.near_me, 'ROUTE'),
            b ildB tt C l
            (I
            h
            'SHARE')

            https://flutter.io/tutorials/layout/

            5/26


                evince -p 6 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            buildButtonColumn(Icons.share, 'SHARE'),
            ],
            ),
            );
            //...
            }

            Step 4: Implement the text section
            De ne the text section, which is fairly long, as a variable. Put the text in a Container to enable adding 32 pixels of padding along each edge. The
            softwrap property indicates whether the text should break on soft line breaks, such as periods or commas.

            class MyApp extends StatelessWidget {
            @override
            Widget build(BuildContext context) {
            //...
            Widget textSection = Container(
            padding: const EdgeInsets.all(32.0),
            child: Text(
            '''
            Lake Oeschinen lies at the foot of the Blüemlisalp in the Bernese Alps. Situated 1,578 meters above sea level, it is one o
            f the larger Alpine Lakes. A gondola ride from Kandersteg, followed by a half-hour walk through pastures and pine forest,
            leads you to the lake, which warms to 20 degrees Celsius in the summer. Activities enjoyed here include rowing, and ridin
            g the summer toboggan run.
            ''',
            softWrap: true,
            ),
            );
            //...
            }

            Step 5: Implement the image section
            Three of the four column elements are now complete, leaving only the image. This image is available online under the Creative Commons license, but
            it's large and slow to fetch. In Step 0 you included the image in the project and updated the pubspec le, so you can now reference it from your code:

            return MaterialApp(
            //...
            body: ListView(
            children: [
            Image.asset(
            'images/lake.jpg',
            height: 240.0,
            fit: BoxFit.cover,
            ),
            // ...
            ],
            ),
            //...
            );

            BoxFit.cover tells the framework that the image should be as small as possible but cover its entire render box.

            Step 6: Put it together
            In the nal step, you assemble the pieces together. The widgets are arranged in a ListView, rather than a Column, because the ListView automatically
            scrolls when running the app on a small device.

            //...
            return MaterialApp(
            title: 'Flutter Demo',
            theme: ThemeData(
            primarySwatch: Colors.blue,
            ),
            home: Scaffold(
            appBar: AppBar(
            title: Text('Top Lakes'),
            ),
            body: ListView(
            children: [
            Image.asset(
            'images/lake.jpg',
            idth 600 0

            https://flutter.io/tutorials/layout/

            6/26


                evince -p 7 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            width: 600.0,
            height: 240.0,
            fit: BoxFit.cover,
            ),
            titleSection,
            buttonSection,
            textSection,
            ],
            ),
            ),
            );
            //...

            Dart code: main.dart
            Image: images
            Pubspec: pubspec.yaml
            That's it! When you hot reload the app, you should see the same layout shown in the screenshots. You can add interactivity to this layout by following
            Adding Interactivity to Your Flutter App.

            Flutter's approach to layout
            What's the point?
            Widgets are classes used to build UIs.
            Widgets are used for both layout and UI elements.
            Compose simple widgets to build complex widgets.

            The core of Flutter's layout mechanism is widgets. In Flutter, almost everything is a widget—even layout models are widgets. The images, icons, and
            text that you see in a Flutter app are all widgets. But things you don't see are also widgets, such as the rows, columns, and grids that arrange,
            constrain, and align the visible widgets.
            You create a layout by composing widgets to build more complex widgets. For example, the screenshot on the left shows 3 icons with a label under
            each one:

            The second screenshot displays the visual layout, showing a row of 3 columns where each column contains an icon and a label.
            Note: Most of the screenshots in this tutorial are displayed with debugPaintSizeEnabled set to true so you can see the visual layout. For more
            information, see Visual debugging, a section in Debugging Flutter Apps.
            Here's a diagram of the widget tree for this UI:

            https://flutter.io/tutorials/layout/

            7/26


                evince -p 8 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            Most of this should look as you might expect, but you might be wondering about the Containers (shown in pink). Container is a widget that allows you
            to customize its child widget. Use a Container when you want to add padding, margins, borders, or background color, to name some of its capabilities.
            In this example, each Text widget is placed in a Container to add margins. The entire Row is also placed in a Container to add padding around the row.
            The rest of the UI in this example is controlled by properties. Set an Icon's color using its color property. Use Text's style property to set the font,
            its color, weight, and so on. Columns and Rows have properties that allow you to specify how their children are aligned vertically or horizontally, and
            how much space the children should occupy.

            Lay out a widget
            What's the point?
            Even the app itself is a widget.
            It's easy to create a widget and add it to a layout widget.
            To display the widget on the device, add the layout widget to the app widget.
            It's easiest to use Scaffold, a widget from the Material Components library, which provides a default banner, background color, and has API
            for adding drawers, snack bars, and bottom sheets.
            If you prefer, you can build an app that only uses standard widgets from the widgets library.

            How do you layout a single widget in Flutter? This section shows how to create a simple widget and display it on screen. It also shows the entire code
            for a simple Hello World app.
            In Flutter, it takes only a few steps to put text, an icon, or an image on the screen.
            1. Select a layout widget to hold the object.
            Choose from a variety of layout widgets based on how you want to align or constrain the visible widget, as these characteristics are typically
            passed on to the contained widget. This example uses Center which centers its content horizontally and vertically.
            2. Create a widget to hold the visible object.
            Note: Flutter apps are written in the Dart language. If you know Java or similar object-oriented coding languages, Dart will feel very familiar. If
            not, you might try DartPad, an interactive Dart playground you can use from any browser. The Language Tour provides an overview of the
            features of the Dart Language.
            For example, create a Text widget:

            Text('Hello World', style: TextStyle(fontSize: 32.0))

            Create an Image widget:
            Image asset('images/myPic jpg'

            https://flutter.io/tutorials/layout/

            fit: BoxFit cover)

            8/26


                evince -p 9 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Image.asset( images/myPic.jpg , fit: BoxFit.cover)

            Building Layouts in Flutter - Flutter

            Create an Icon widget:

            Icon(Icons.star, color: Colors.red[500])

            3. Add the visible widget to the layout widget.
            All layout widgets have a child property if they take a single child (for example, Center or Container), or a children property if they take a list
            of widgets (for example, Row, Column, ListView, or Stack).
            Add the Text widget to the Center widget:

            Center(
            child: Text('Hello World', style: TextStyle(fontSize: 32.0))

            4. Add the layout widget to the page.
            A Flutter app is, itself, a widget and most widgets have a build() method. Declaring the widget in the app's build method displays the widget on the
            device.
            For a Material app, you can add the Center widget directly to the body property for the home page.

            class _MyHomePageState extends State<MyHomePage> {
            @override
            Widget build(BuildContext context) {
            return Scaffold(
            appBar: AppBar(
            title: Text(widget.title),
            ),
            body: Center(
            child: Text('Hello World', style: TextStyle(fontSize: 32.0)),
            ),
            );
            }
            }

            Note: The Material Components library implements widgets that follow Material Design principles. When designing your UI, you can
            exclusively use widgets from the standard widgets library, or you can use widgets from Material Components. You can mix widgets from
            both libraries, you can customize existing widgets, or you can build your own set of custom widgets.
            For a non-Material app, you can add the Center widget to the app's build() method:

            // This app doesn't use any Material Components, such as Scaffold.
            // Normally, an app that doesn't use Scaffold has a black background
            // and the default text color is black. This app changes its background
            // to white and its text color to dark grey to mimic a Material app.
            import 'package:flutter/material.dart';
            void main() {
            runApp(MyApp());
            }
            class MyApp extends StatelessWidget {
            @override
            Widget build(BuildContext context) {
            return Container(
            decoration: BoxDecoration(color: Colors.white),
            child: Center(
            child: Text('Hello World',
            textDirection: TextDirection.ltr,
            style: TextStyle(fontSize: 40.0, color: Colors.black87)),
            ),
            );
            }
            }

            Note that, by default, the non-Material app doesn't include an AppBar, title, or background color. If you want these features in a non-Material app,
            https://flutter.io/tutorials/layout/

            9/26


                evince -p 10 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            you have to build them yourself. This app changes the background color to white and the text to dark grey to mimic a Material app.
            That's it! When you run the app, you should see:

            Dart code (Material app): main.dart
            Dart code (widgets-only app): main.dart

            Lay out multiple widgets vertically and horizontally
            One of the most common layout patterns is to arrange widgets vertically or horizontally. You can use a Row widget to arrange widgets horizontally,
            and a Column widget to arrange widgets vertically.

            What's the point?
            Row and Column are two of the most commonly used layout patterns.
            Row and Column each take a list of child widgets.
            A child widget can itself be a Row, Column, or other complex widget.
            You can specify how a Row or Column aligns its children, both vertically and horizontally.
            You can stretch or constrain speci c child widgets.
            You can specify how child widgets use the Row's or Column's available space.

            Contents
            Aligning widgets
            Sizing widgets
            Packing widgets
            Nesting rows and columns
            To create a row or column in Flutter, you add a list of children widgets to a Row or Column widget. In turn, each child can itself be a row or column, and
            so on. The following example shows how it is possible to nest rows or columns inside of rows or columns.
            This layout is organized as a Row. The row contains two children: a column on the left, and an image on the right:

            https://flutter.io/tutorials/layout/

            10/26


                evince -p 11 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            The left column's widget tree nests rows and columns.

            You'll implement some of Pavlova's layout code in Nesting rows and columns.
            Note: Row and Column are basic primitive widgets for horizontal and vertical layouts—these low-level widgets allow for maximum customization.
            Flutter also offers specialized, higher level widgets that might be su cient for your needs. For example, instead of Row you might prefer ListTile,
            an easy-to-use widget with properties for leading and trailing icons, and up to 3 lines of text. Instead of Column, you might prefer ListView, a
            column-like layout that automatically scrolls if its content is too long to t the available space. For more information, see Common layout widgets.

            Aligning widgets
            You control how a row or column aligns its children using the mainAxisAlignment and crossAxisAlignment properties. For a row, the main axis
            runs horizontally and the cross axis runs vertically. For a column, the main axis runs vertically and the cross axis runs horizontally.

            https://flutter.io/tutorials/layout/

            11/26


                evince -p 12 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            The MainAxisAlignment and CrossAxisAlignment classes offer a variety of constants for controlling alignment.
            Note: When you add images to your project, you need to update the pubspec le to access them—this example uses Image.asset to display the
            images. For more information, see this example's pubspec.yaml le, or Adding Assets and Images in Flutter. You don't need to do this if you're
            referencing online images using Image.network.
            In the following example, each of the 3 images is 100 pixels wide. The render box (in this case, the entire screen) is more than 300 pixels wide, so
            setting the main axis alignment to spaceEvenly divides the free horizontal space evenly between, before, and after each image.

            appBar: AppBar(
            title: Text(widget.title),
            ),
            body: Center(
            child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
            Image.asset('images/pic1.jpg'),

            Dart code: main.dart
            Images: images
            Pubspec: pubspec.yaml
            Columns work the same way as rows. The following example shows a column of 3 images, each is 100 pixels high. The height of the render box (in
            this case, the entire screen) is more than 300 pixels, so setting the main axis alignment to spaceEvenly divides the free vertical space evenly
            between, above, and below each image.

            appBar: AppBar(
            title: Text(widget.title),
            ),
            body: Center(
            child: Column(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
            Image.asset('images/pic1.jpg'),

            Dart code: main.dart
            Images: images
            Pubspec: pubspec.yaml

            https://flutter.io/tutorials/layout/

            12/26


                evince -p 13 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            Note: When a layout is too large to t the device, a red strip appears along the affected edge. For example, the row in the following screenshot is
            too wide for the device's screen:

            Widgets can be sized to t within a row or column by using an Expanded widget, which is described in the Sizing widgets section below.

            Sizing widgets
            Perhaps you want a widget to occupy twice as much space as its siblings. You can place the child of a row or column in an Expanded widget to
            control widget sizing along the main axis. The Expanded widget has a flex property, an integer that determines the ex factor for a widget. The
            default ex factor for an Expanded widget is 1.
            For example, to create a row of three widgets where the middle widget is twice as wide as the other two widgets, set the ex factor on the middle
            widget to 2:

            appBar: AppBar(
            title: Text(widget.title),
            ),
            body: Center(
            child: Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
            Expanded(
            hild I

            https://flutter.io/tutorials/layout/

            t('i

            / i 1 j

            ')

            13/26


                evince -p 14 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            child: Image.asset('images/pic1.jpg'),
            ),
            Expanded(
            flex: 2,
            child: Image.asset('images/pic2.jpg'),
            ),
            Expanded(

            Dart code: main.dart
            Images: images
            Pubspec: pubspec.yaml
            To x the example in the previous section where the row of 3 images was too wide for its render box, and resulted in the red strip, wrap each widget
            with an Expanded widget. By default, each widget has a ex factor of 1, assigning one-third of the row to each widget.

            appBar: AppBar(
            title: Text(widget.title),
            ),
            body: Center(
            child: Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
            Expanded(
            child: Image.asset('images/pic1.jpg'),
            ),
            Expanded(
            child: Image.asset('images/pic2.jpg'),
            ),
            Expanded(

            Dart code: main.dart
            Images: images
            Pubspec: pubspec.yaml

            Packing widgets
            By default, a row or column occupies as much space along its main axis as possible, but if you want to pack the children closely together, set its
            mainAxisSize to MainAxisSize.min . The following example uses this property to pack the star icons together.

            class _MyHomePageState extends State<MyHomePage> {
            @override
            Widget build(BuildContext context) {
            var packedRow = Row(
            mainAxisSize: MainAxisSize.min,
            children: [
            Icon(Icons.star, color: Colors.green[500]),
            Icon(Icons.star, color: Colors.green[500]),
            Icon(Icons.star, color: Colors.green[500]),
            Icon(Icons.star, color: Colors.black),
            Icon(Icons.star, color: Colors.black),
            ],
            );
            // ...
            }

            https://flutter.io/tutorials/layout/

            14/26


                evince -p 15 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            Dart code: main.dart
            Icons: Icons class
            Pubspec: pubspec.yaml

            Nesting rows and columns
            The layout framework allows you to nest rows and columns inside of rows and columns as deeply as you need. Let's look the code for the outlined
            section of the following layout:

            The outlined section is implemented as two rows. The ratings row contains ve stars and the number of reviews. The icons row contains three
            columns of icons and text.
            The widget tree for the ratings row:

            The ratings variable creates a row containing a smaller row of 5 star icons, and text:

            class _MyHomePageState extends State<MyHomePage> {
            @override
            Widget build(BuildContext context) {
            //...
            var ratings = Container(
            padding: EdgeInsets.all(20.0),
            child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
            Row(
            mainAxisSize: MainAxisSize.min,
            children: [
            Icon(Icons.star, color: Colors.black),
            Icon(Icons.star, color: Colors.black),
            Icon(Icons.star, color: Colors.black),
            Icon(Icons.star, color: Colors.black),
            Icon(Icons.star, color: Colors.black),
            ],
            ),
            Text(
            '170 R

            https://flutter.io/tutorials/layout/

            i

            '

            15/26


                evince -p 16 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            '170 Reviews',
            style: TextStyle(
            color: Colors.black,
            fontWeight: FontWeight.w800,
            fontFamily: 'Roboto',
            letterSpacing: 0.5,
            fontSize: 20.0,
            ),
            ),
            ],
            ),
            );
            //...
            }
            }

             Tip: To minimize the visual confusion that can result from heavily nested layout code, implement pieces of the UI in variables and functions.
            The icons row, below the ratings row, contains 3 columns; each column contains an icon and two lines of text, as you can see in its widget tree:

            The iconList variable de nes the icons row:

            class _MyHomePageState extends State<MyHomePage> {
            @override
            Widget build(BuildContext context) {
            // ...
            var descTextStyle = TextStyle(
            color: Colors.black,
            fontWeight: FontWeight.w800,
            fontFamily: 'Roboto',
            letterSpacing: 0.5,
            fontSize: 18.0,
            height: 2.0,
            );
            // DefaultTextStyle.merge allows you to create a default text
            // style that is inherited by its child and all subsequent children.
            var iconList = DefaultTextStyle.merge(
            style: descTextStyle,
            child: Container(
            padding: EdgeInsets.all(20.0),
            child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
            Column(
            children: [
            Icon(Icons.kitchen, color: Colors.green[500]),
            Text('PREP:'),
            Text('25 min'),
            ],
            ),
            Column(
            children: [
            Icon(Icons.timer, color: Colors.green[500]),

            https://flutter.io/tutorials/layout/

            Text('COOK:'),
            T t('1 h ')

            16/26


                evince -p 17 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            Text('1 hr'),
            ],
            ),
            Column(
            children: [
            Icon(Icons.restaurant, color: Colors.green[500]),
            Text('FEEDS:'),
            Text('4-6'),
            ],
            ),
            ],
            ),
            ),
            );
            // ...
            }
            }

            The leftColumn variable contains the ratings and icons rows, as well as the title and text that describes the Pavlova:

            class _MyHomePageState extends State<MyHomePage> {
            @override
            Widget build(BuildContext context) {
            //...
            var leftColumn = Container(
            padding: EdgeInsets.fromLTRB(20.0, 30.0, 20.0, 20.0),
            child: Column(
            children: [
            titleText,
            subTitle,
            ratings,
            iconList,
            ],
            ),
            );
            //...
            }
            }

            The left column is placed in a Container to constrain its width. Finally, the UI is constructed with the entire row (containing the left column and the
            image) inside a Card.
            The Pavlova image is from Pixabay and is available under the Creative Commons license. You can embed an image from the net using
            Image.network but, for this example, the image is saved to an images directory in the project, added to the pubspec le, and accessed using
            Images.asset . For more information, see Adding Assets and Images in Flutter.

            body: Center(
            child: Container(
            margin: EdgeInsets.fromLTRB(0.0, 40.0, 0.0, 30.0),
            height: 600.0,
            child: Card(
            child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
            Container(
            width: 440.0,
            child: leftColumn,
            ),
            mainImage,
            ],
            ),
            ),
            ),
            ),

            Dart code: main.dart
            Images: images
            Pubspec: pubspec.yaml

             Tip: The Pavlova example runs best horizontally on a wide device, such as a tablet. If you are running this example in the iOS simulator, you can
            https://flutter.io/tutorials/layout/

            17/26


                evince -p 18 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            select a different device using the Hardware > Device menu. For this example, we recommend the iPad Pro. You can change its orientation to
            landscape mode using Hardware > Rotate. You can also change the size of the simulator window (without changing the number of logical pixels)
            using Window > Scale.

            Common layout widgets
            Flutter has a rich library of layout widgets, but here a few of those most commonly used. The intent is to get you up and running as quickly as possible,
            rather than overwhelm you with a complete list. For information on other available widgets, refer to the Widget Overview, or use the Search box in the
            API reference docs. Also, the widget pages in the API docs often make suggestions about similar widgets that might better suit your needs.
            The following widgets fall into two categories: standard widgets from the widgets library, and specialized widgets from the Material Components
            library. Any app can use the widgets library but only Material apps can use the Material Components library.

            Standard widgets
            Container
            Adds padding, margins, borders, background color, or other decorations to a widget.
            GridView
            Lays widgets out as a scrollable grid.
            ListView
            Lays widgets out as a scrollable list.
            Stack
            Overlaps a widget on top of another.

            Material Components
            Card
            Organizes related info into a box with rounded corners and a drop shadow.
            ListTile
            Organizes up to 3 lines of text, and optional leading and trailing icons, into a row.

            Container
            Many layouts make liberal use of Containers to separate widgets with padding, or to add borders or margins. You can change the device's background
            by placing the entire layout into a Container and changing its background color or image.

            Container summary:
            Add padding, margins, borders
            Change background color or image
            Contains a single child widget, but that child can be a Row, Column, or even the root of a widget tree

            Container examples:
            In addition to the example below, many examples in this tutorial use Container. You can also nd more Container examples in the Flutter Gallery.
            This layout consists of a column of two rows, each containing 2 images. Each image uses a Container to add a rounded grey border and margins. The
            Column, which contains the rows of images, uses a Container to change the background color to a lighter grey.
            Dart code: main.dart, snippet below
            Images: images
            Pubspec: pubspec.yaml

            https://flutter.io/tutorials/layout/

            18/26


                evince -p 19 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            class _MyHomePageState extends State<MyHomePage> {
            @override
            Widget build(BuildContext context) {
            var container = Container(
            decoration: BoxDecoration(
            color: Colors.black26,
            ),
            child: Column(
            children: [
            Row(
            children: [
            Expanded(
            child: Container(
            decoration: BoxDecoration(
            border: Border.all(width: 10.0, color: Colors.black38),
            borderRadius:
            const BorderRadius.all(const Radius.circular(8.0)),
            ),
            margin: const EdgeInsets.all(4.0),
            child: Image.asset('images/pic1.jpg'),
            ),
            ),
            Expanded(
            child: Container(
            decoration: BoxDecoration(
            border: Border.all(width: 10.0, color: Colors.black38),
            borderRadius:
            const BorderRadius.all(const Radius.circular(8.0)),
            ),
            margin: const EdgeInsets.all(4.0),
            child: Image.asset('images/pic2.jpg'),
            ),
            ),
            ],
            ),
            // ...
            // See the definition for the second row on GitHub:
            // https://raw.githubusercontent.com/flutter/website/master/src/_includes/code/layout/container/main.dart
            ],
            ),
            );
            //...
            }
            }

            GridView
            Use GridView to lay widgets out as a two-dimensional list. GridView provides two pre-fabricated lists, or you can build your own custom grid. When a
            GridView detects that its contents are too long to t the render box, it automatically scrolls.

            GridView summary:
            Lays widgets out in a grid
            Detects when the column content exceeds the render box and automatically provides scrolling
            Build your own custom grid, or use one of the provided grids:
            GridView.count allows you to specify the number of columns
            GridView.extent allows you to specify the maximum pixel width of a tile
            Note: When displaying a two dimensional list where it's important which row and column a cell occupies (for example it's the entry in the “calorie”

            https://flutter.io/tutorials/layout/

            19/26


                evince -p 20 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            Note: When displaying a two-dimensional list where it s important which row and column a cell occupies (for example, it s the entry in the calorie
            column for the “avocado” row), use Table or DataTable.

            GridView examples:

            Uses GridView.extent to create a grid with tiles a maximum 150 pixels wide.
            Dart code: main.dart, snippet below
            Images: images
            Pubspec: pubspec.yaml

            Uses GridView.count to create a grid that's 2 tiles wide in portrait mode, and 3 tiles wide in landscape mode. The titles are created by setting the
            footer property for each GridTile.
            Dart code: grid_list_demo.dart from the Flutter Gallery

            // The images are saved with names pic1.jpg, pic2.jpg...pic30.jpg.
            // The List.generate constructor allows an easy way to create
            // a list when objects have a predictable naming pattern.
            List<Container> _buildGridTileList(int count) {
            return List<Container>.generate(
            count,
            (int index) =>
            Container(child: Image.asset('images/pic${index+1}.jpg')));
            }
            https://flutter.io/tutorials/layout/

            20/26


                evince -p 21 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            Widget buildGrid() {
            return GridView.extent(
            maxCrossAxisExtent: 150.0,
            padding: const EdgeInsets.all(4.0),
            mainAxisSpacing: 4.0,
            crossAxisSpacing: 4.0,
            children: _buildGridTileList(30));
            }
            class _MyHomePageState extends State<MyHomePage> {
            @override
            Widget build(BuildContext context) {
            return Scaffold(
            appBar: AppBar(
            title: Text(widget.title),
            ),
            body: Center(
            child: buildGrid(),
            ),
            );
            }
            }

            ListView
            ListView, a column-like widget, automatically provides scrolling when its content is too long for its render box.

            ListView summary:
            A specialized Column for organizing a list of boxes
            Can be laid out horizontally or vertically
            Detects when its content won't t and provides scrolling
            Less con gurable than Column, but easier to use and supports scrolling

            ListView examples:

            Uses ListView to display a list of businesses using ListTiles. A Divider separates the theaters from the restaurants.
            Dart code: main.dart, snippet below
            Icons: Icons class
            Pubspec: pubspec.yaml

            https://flutter.io/tutorials/layout/

            21/26


                evince -p 22 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            Uses ListView to display the Colors from the Material Design palette for a particular color family.
            Dart code: colors_demo.dart from the Flutter Gallery

            List<Widget> list = <Widget>[
            ListTile(
            title: Text('CineArts at the Empire',
            style: TextStyle(fontWeight: FontWeight.w500, fontSize: 20.0)),
            subtitle: Text('85 W Portal Ave'),
            leading: Icon(
            Icons.theaters,
            color: Colors.blue[500],
            ),
            ),
            ListTile(
            title: Text('The Castro Theater',
            style: TextStyle(fontWeight: FontWeight.w500, fontSize: 20.0)),
            subtitle: Text('429 Castro St'),
            leading: Icon(
            Icons.theaters,
            color: Colors.blue[500],
            ),
            ),
            // ...
            // See the rest of the column defined on GitHub:
            // https://raw.githubusercontent.com/flutter/website/master/src/_includes/code/layout/listview/main.dart
            ];
            class _MyHomePageState extends State<MyHomePage> {
            @override
            Widget build(BuildContext context) {
            return Scaffold(
            // ...
            body: Center(
            child: ListView(
            children: list,
            ),
            ),
            );
            }
            }

            Stack
            Use Stack to arrange widgets on top of a base widget—often an image. The widgets can completely or partially overlap the base widget.

            Stack summary:
            Use for widgets that overlap another widget
            The rst widget in the list of children is the base widget; subsequent children are overlaid on top of that base widget
            A Stack's content can't scroll
            https://flutter.io/tutorials/layout/

            22/26


                evince -p 23 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            You can choose to clip children that exceed the render box

            Stack examples:

            Uses Stack to overlay a Container (that displays its Text on a translucent black background) on top of a Circle Avatar. The Stack offsets the text using
            the alignment property and Alignments.
            Dart code: main.dart, snippet below
            Image: images
            Pubspec: pubspec.yaml

            Uses Stack to overlay a gradient to the top of the image. The gradient ensures that the toolbar's icons are distinct against the image.
            Dart code: contacts_demo.dart from the Flutter Gallery

            class _MyHomePageState extends State<MyHomePage> {
            @override
            Widget build(BuildContext context) {
            var stack = Stack(
            alignment: const Alignment(0.6, 0.6),
            children: [
            CircleAvatar(
            backgroundImage: AssetImage('images/pic.jpg'),
            radius: 100.0,
            ),
            Container(
            decoration: BoxDecoration(
            color: Colors.black45,
            ),
            child: Text(
            'Mia B',
            style: TextStyle(
            fontSize: 20.0,
            fontWeight: FontWeight.bold,
            color: Colors.white,
            ),
            ),
            ),
            ],
            );
            // ...
            }
            }

            Card
            A Card, from the Material Components library, contains related nuggets of information and can be composed from almost any widget, but is often
            used with ListTile. Card has a single child, but its child can be a column, row, list, grid, or other widget that supports multiple children. By default, a
            Card shrinks its size to 0 by 0 pixels. You can use SizedBox to constrain the size of a card.
            In Flutter, a Card features slightly rounded corners and a drop shadow, giving it a 3D effect. Changing a Card's elevation property allows you to
            https://flutter.io/tutorials/layout/

            23/26


                evince -p 24 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            control the drop shadow effect. Setting the elevation to 24.0, for example, visually lifts the Card further from the surface and causes the shadow to
            become more dispersed. For a list of supported elevation values, see Elevation and Shadows in the Material guidelines. Specifying an unsupported
            value disables the drop shadow entirely.

            Card summary:
            Implements a Material Design card
            Used for presenting related nuggets of information
            Accepts a single child, but that child can be a Row, Column, or other widget that holds a list of children
            Displayed with rounded corners and a drop shadow
            A Card's content can't scroll
            From the Material Components library

            Card examples:

            A Card containing 3 ListTiles and sized by wrapping it with a SizedBox. A Divider separates the rst and second ListTiles.
            Dart code: main.dart, snippet below
            Icons: Icons class
            Pubspec: pubspec.yaml

            A Card containing an image and text.
            Dart code: cards_demo.dart from the Flutter Gallery

            class _MyHomePageState extends State<MyHomePage> {
            @override
            Widget build(BuildContext context) {
            var card = SizedBox(
            height: 210.0,
            child: Card(
            child: Column(
            children: [
            ListTile(
            title: Text('1625 Main Street',
            style: TextStyle(fontWeight: FontWeight.w500)),
            subtitle: Text('My City, CA 99984'),
            leading: Icon(
            Icons.restaurant_menu,
            color: Colors.blue[500],
            ),
            ),
            Divider(),
            ListTile(
            title: Text('(408) 555-1212',
            style: TextStyle(fontWeight: FontWeight.w500)),
            leading: Icon(
            Icons.contact_phone,
            color: Colors.blue[500],
            ),
            ),
            ListTile(
            title: Text('costa@example.com'),
            leading: Icon(
            I
            t t

            https://flutter.io/tutorials/layout/

            il

            24/26


                evince -p 25 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            Icons.contact_mail,
            color: Colors.blue[500],
            ),
            ),
            ],
            ),
            ),
            );
            //...
            }

            ListTile
            Use ListTile, a specialized row widget from the Material Components library, for an easy way to create a row containing up to 3 lines of text and
            optional leading and trailing icons. ListTile is most commonly used in Card or ListView, but can be used elsewhere.

            ListTile summary:
            A specialized row that contains up to 3 lines of text and optional icons
            Less con gurable than Row, but easier to use
            From the Material Components library

            ListTile examples:

            A Card containing 3 ListTiles.
            Dart code: See Card examples.

            Uses ListTile to list 3 drop down button types.
            Dart code: buttons_demo.dart from the Flutter Gallery

            Resources
            The following resources may help when writing layout code.
            Widget Overview
            Describes many of the widgets available in Flutter.
            HTML/CSS Analogs in Flutter
            For those familiar with web programming, this page maps HTML/CSS functionality to Flutter features.
            Flutter Gallery
            Demo app showcasing many Material Design widgets and other Flutter features.
            Flutter API documentation
            Reference documentation for all of the Flutter libraries.
            Dealing with Box Constraints in Flutter
            Discusses how widgets are constrained by their render boxes.
            Adding Assets and Images in Flutter
            Explains how to add images and other assets to your app's package.
            Zero to One with Flutter
            https://flutter.io/tutorials/layout/

            25/26


                evince -p 26 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-layouts.pdf &

            9/13/2018

            Building Layouts in Flutter - Flutter

            One person's experience writing his rst Flutter app.

            https://flutter.io/tutorials/layout/

            26/26
~/Empire/Doks/Comp/lang/dart-flutter/flutter/flutter-succinct.pdf
            ___start1
            ___start2

            www.dbooks.org

            Flutter Succinctly
            By
            Ed Freitas

            Foreword by Daniel Jebaraj

            Copyright © 2019 by Syncfusion, Inc.
            2501 Aerial Center Parkway
            Suite 200
            Morrisville, NC 27560
            USA
            All rights reserved.

            Important licensing information. Please read.
            This book is available for free download from www.syncfusion.com on completion of a
            registration form.
            If you obtained this book from any other source, please register and download a free copy from
            www.syncfusion.com.
            This book is licensed for reading only if obtained from www.syncfusion.com.
            This book is licensed strictly for personal or educational use.
            Redistribution in any form is prohibited.
            The authors and copyright holders provide absolutely no warranty for any information provided.
            The authors and copyright holders shall not be liable for any claim, damages, or any other
            liability arising from, out of, or in connection with the information in this book.
            Please do not use this book if the listed terms are unacceptable.
            Use shall constitute acceptance of the terms listed.
            SYNCFUSION, SUCCINCTLY, DELIVER INNOVATION WITH EASE, ESSENTIAL, and .NET
            ESSENTIALS are the registered trademarks of Syncfusion, Inc.

            Technical Reviewer: James McCaffrey
            Copy Editor: Courtney Wright
            Acquisitions Coordinator: Tres Watkins, content development manager, Syncfusion, Inc.
            Proofreader: Jacqueline Bieringer, content producer, Syncfusion, Inc.

            3
            www.dbooks.org

            Table of Contents
            The Story Behind the Succinctly Series of Books ................................................................ 7
            About the Author ..................................................................................................................... 9
            Acknowledgements ................................................................................................................10
            Introduction .............................................................................................................................11
            Chapter 1 Setup .....................................................................................................................12
            Project overview ...................................................................................................................12
            Installation ............................................................................................................................12
            Setting up an editor ..............................................................................................................15
            Creating the app ...................................................................................................................15
            Creating a virtual device .......................................................................................................18
            Testing our setup..................................................................................................................22
            Hot reloading ........................................................................................................................27
            Summary ..............................................................................................................................29
            Chapter 2 App Fundamentals................................................................................................30
            Quick intro ............................................................................................................................30
            Rewriting—main.dart ............................................................................................................31
            Project structure ...................................................................................................................34
            Bottom-to-top coding approach ............................................................................................35
            Writing utils.dart....................................................................................................................36
            Writing model.dart ................................................................................................................43
            Creating the database—dbhelper.dart ..................................................................................48
            Inserting a new document—dbhelper.dart ............................................................................53
            Getting the list of documents—dbhelper.dart ........................................................................53
            Getting a specific document—dbhelper.dart .........................................................................54

            4

            Counting documents—dbhelper.dart ....................................................................................55
            Updating and deleting documents—dbhelper.dart ................................................................57
            Summary ..............................................................................................................................58
            Chapter 3 App UI—Document Details...................................................................................59
            Quick intro ............................................................................................................................59
            Document Details .................................................................................................................59
            Menu options ........................................................................................................................61
            Stateful widget ......................................................................................................................62
            Initializing text controllers and variables ...............................................................................65
            Choosing a date ...................................................................................................................67
            Deleting a document ............................................................................................................70
            Saving a document...............................................................................................................72
            Submitting the form ..............................................................................................................75
            Building the UI ......................................................................................................................76
            Scaffold ................................................................................................................................81
            AppBar .................................................................................................................................81
            Body .....................................................................................................................................82
            Document Name and Expiry Date ........................................................................................83
            Document Name field ...........................................................................................................84
            Expiry Date field ...................................................................................................................84
            Alert fields ............................................................................................................................85
            Save button ..........................................................................................................................87
            Summary ..............................................................................................................................88
            Chapter 4 App UI—Main Screen............................................................................................89
            Quick intro ............................................................................................................................89
            Getting started: main menu option ........................................................................................90

            5
            www.dbooks.org

            Main stateful widget ..............................................................................................................90
            Getting a list of documents ...................................................................................................92
            Checking dates.....................................................................................................................95
            Navigating to the document details .......................................................................................96
            Resetting the local data ........................................................................................................97
            Selecting the menu option ..................................................................................................100
            Building the list of documents .............................................................................................100
            Finalizing the main screen ..................................................................................................103
            Summary ............................................................................................................................109
            Appendix—Full Code ............................................................................................................111
            Full main.dart code .............................................................................................................111
            Full utils.dart code ..............................................................................................................111
            Full dbhelper.dart code .......................................................................................................114
            Full model.dart code ...........................................................................................................117
            Full docdetail.dart code ......................................................................................................118
            Full doclist.dart code ..........................................................................................................124
            Full Pubspec.yaml code .....................................................................................................128
            Full Android Studio project .................................................................................................129

            6

            The Story Behind the Succinctly Series
            of Books
            Daniel Jebaraj, Vice President
            Syncfusion, Inc.

            S

            taying on the cutting edge
            As many of you may know, Syncfusion is a provider of software components for the
            Microsoft platform. This puts us in the exciting but challenging position of always
            being on the cutting edge.

            Whenever platforms or tools are shipping out of Microsoft, which seems to be about every other
            week these days, we have to educate ourselves, quickly.

            Information is plentiful but harder to digest
            In reality, this translates into a lot of book orders, blog searches, and Twitter scans.
            While more information is becoming available on the Internet and more and more books are
            being published, even on topics that are relatively new, one aspect that continues to inhibit us is
            the inability to find concise technology overview books.
            We are usually faced with two options: read several 500+ page books or scour the web for
            relevant blog posts and other articles. Just as everyone else who has a job to do and customers
            to serve, we find this quite frustrating.

            The Succinctly series
            This frustration translated into a deep desire to produce a series of concise technical books that
            would be targeted at developers working on the Microsoft platform.
            We firmly believe, given the background knowledge such developers have, that most topics can
            be translated into books that are between 50 and 100 pages.
            This is exactly what we resolved to accomplish with the Succinctly series. Isn’t everything
            wonderful born out of a deep desire to change things for the better?

            The best authors, the best content
            Each author was carefully chosen from a pool of talented experts who shared our vision. The
            book you now hold in your hands, and the others available in this series, are a result of the

            7
            www.dbooks.org

            authors’ tireless work. You will find original content that is guaranteed to get you up and running
            in about the time it takes to drink a few cups of coffee.

            Free forever
            Syncfusion will be working to produce books on several topics. The books will always be free.
            Any updates we publish will also be free.

            Free? What is the catch?
            There is no catch here. Syncfusion has a vested interest in this effort.
            As a component vendor, our unique claim has always been that we offer deeper and broader
            frameworks than anyone else on the market. Developer education greatly helps us market and
            sell against competing vendors who promise to “enable AJAX support with one click,” or “turn
            the moon to cheese!”

            Let us know what you think
            If you have any topics of interest, thoughts, or feedback, please feel free to send them to us at
            succinctly-series@syncfusion.com.
            We sincerely hope you enjoy reading this book and that it helps you better understand the topic
            of study. Thank you for reading.

            Please follow us on Twitter and “Like” us on Facebook to help us spread the
            word about the Succinctly series!

            8

            About the Author
            Ed Freitas is a consultant on software development applied to customer success, mostly related
            to financial process automation, accounts payable processing, and data extraction.
            He really likes technology and enjoys playing soccer, running, traveling, life hacking, learning,
            and spending time with his family.
            You can reach him at: https://edfreitas.me

            9
            www.dbooks.org

            Acknowledgements
            Many thanks to all the people from the amazing Syncfusion team who contributed to this book
            and helped it become a reality—especially Jacqueline Bieringer, Tres Watkins, Darren West,
            and Graham High.
            The manuscript manager, Jacqueline Bieringer from Syncfusion, and the technical editor,
            James McCaffrey from Microsoft Research, thoroughly reviewed the book's organization, code
            quality, and overall accuracy. Thank you both.
            This book is dedicated to Mi Chelin, Lala, and Tita, who inspire me every day and light up my
            path ahead—God bless you all, always.

            10


            ___start1
                evince -p 11 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Introduction
            With the rapid rise of cross-platform mobile frameworks such as Ionic, React Native, and
            Xamarin, the folks at Google decided to step into the game and develop their own framework
            with support for both Android and iOS using the same codebase—this is how Flutter came to
            be.
            Flutter is an open-source mobile application development SDK primarily developed and
            sponsored by Google, used for developing applications for Android and iOS—as well as being
            the primary method of creating applications for the Google Fuchsia operating system.
            Flutter is written in C, C++, and Dart, and uses the Skia Graphics Engine. It offers a rich set of
            fully customizable widgets for building native interfaces, including the beautiful Material Design
            library and Cupertino (iOS-flavored) widgets, rich motion APIs, smooth natural scrolling,
            platform awareness, and hot reload—which helps to quickly build UIs without losing state on
            emulators, simulators, and any hardware for iOS and Android.
            All these great features have helped Flutter take off very quickly, and developers are flocking to
            the framework. It’s also one of the trending projects in GitHub, which has helped it gain even
            more popularity.
            With Flutter gaining momentum, it seems unlikely that it will fade away anytime soon, so I
            decided to give it a whirl and write an application with it. My personal experience: I was blown
            away. I felt immediately productive, even though I had never programmed in Dart before.
            Throughout this book, I want to go on that same journey with you. We’ll do this by creating a
            fully functional app, which will allow you to get a good grasp of the framework—whether you are
            coming from another mobile development framework, or have no previous mobile development
            experience.
            I’m quite excited to embark on this journey with you. I hope that by the end of it, you’ll have a
            great impression of the framework and be able to assess whether Flutter is the right choice for
            your mobile development needs. So, without further ado, let’s get going.

            11
            www.dbooks.org


                evince -p 12 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Chapter 1 Setup
            Project overview
            The application that we’ll be building throughout this book is one that we can use to keep track
            of important personal documents that have an expiration date, such as passports, driver’s
            licenses, or credit cards.
            This type of application is handy to have so we know when we need to renew these important
            documents before they expire. If you have read my other book, Electron Succinctly, this is the
            same application concept we explored back then.
            Using the Dart programming language with Flutter, we will take our application one step
            further—we’ll also explore how to use a local SQLite database.
            Awesome—let’s get our engines ready so we can start setting up our development environment
            straight away.

            Installation
            The Flutter setup is incredibly easy, with all the installation steps well documented within the
            official Flutter documentation site.
            I’ll be using Windows 10, so I’ll be describing setup steps and information related to this
            operating system; however, there are also easy-to-follow setup guidelines for both macOS and
            Linux.
            On Windows, there are some essential system requirements that need to be in place, which
            include having PowerShell 5.0 (or later) and Git for Windows 2.X (or later) installed.
            Even though you can write Flutter apps in any editor of your choice—personally, I’m a big fan of
            Visual Studio Code—Flutter relies on a full installation of Android Studio to supply its Android
            platform dependencies. You’ll also need to set up an Android device emulator. These steps are
            described in the official documentation.
            With the prerequisites in place for Windows, all we need to do is download the installation
            bundle of the Flutter SDK—at the time of writing, it is Flutter’s 1.0.0 stable version for Windows.
            Once you’ve downloaded the zip file, extract it to a desired folder within your drive, such as
            C:\Flutter. Don’t extract the Flutter files to C:\Program Files or C:\Program Files (x86), which
            require elevated or admin permissions.
            Once the files are in the desired folder, locate the file Flutter_console.bat file—this is how it
            looks on my machine.

            12


                evince -p 13 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 1-a: The Flutter SDK files

            In principle, you are now ready to run the Flutter console by executing the Flutter_console.bat
            file. It’s recommended—although not strictly necessary—to add the Flutter\Bin folder to the
            System Path Environment variable in Windows.
            If you are unsure how to add a folder to the Windows Path variable, please refer to this nice
            article that explains how to do it, step by step, with screenshots.
            In my machine, this looks as follows.

            Figure 1-b: Flutter added to the Path variable in Windows

            With the SDK file in place, we can now run the Flutter_console.bat file—this is what you
            should see.

            13
            www.dbooks.org


                evince -p 14 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 1-c: The Flutter console running

            On the prompt, type the following command to check if Flutter is fully operational.
            Code Listing 1-a: The “flutter doctor” command

            flutter doctor
            After you execute this command, you will get a result with any issues found—in my case,
            because I had previously installed Android Studio and Visual Studio Code, I get the following
            information.
            When you run the Android Studio installer, please make sure you follow the official
            documentation so that you end up with a successful Android Studio and SDK setup.

            Figure 1-d: Results from running the flutter doctor command

            In my case, Flutter is telling me that I need to run the flutter doctor --android-licenses
            command to resolve an issue with some Android licenses not being accepted.
            It also highlighted that I don’t have a physical device connected, which is fine for now.

            14


                evince -p 15 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Make sure that you resolve all the conflicts highlighted by the flutter doctor command
            before proceeding.

            Setting up an editor
            Once you have completed all the installation steps, it is necessary to set up Flutter to work with
            your editor of choice. Although I usually use Visual Studio Code for my projects, this time I
            decided to use Android Studio to code our Flutter application—to me, it felt more natural, and a
            better fit for mobile development.
            The official Flutter documentation describes how to configure Android Studio (IntelliJ) and Visual
            Studio Code to work with Flutter—please follow these steps.
            If you will also be using Android Studio, once you have followed the steps described, you should
            see the Dart and Flutter plugins installed. On my machine, this looks as follows.

            Figure 1-e: The Dart and Flutter plugins installed on Android Studio

            Creating the app
            Once your editor of choice has been correctly set up following the official documentation
            guidelines and my previous suggestions, it’s time to perform a quick test. We’ll create a demo
            application from one of the predefined templates, and then experience the “hot reload”
            mechanism after making a change to the app.

            15
            www.dbooks.org


                evince -p 16 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            The official documentation, which covers the steps that are described and explained in this
            section, is worth checking.
            Open Android Studio and navigate to File > New > New Flutter Project. The following screen
            will be displayed.

            Figure 1-f: Create new Flutter project option (step 1)

            Choose the Flutter Application option, and then click Next. We’ll then be presented with a
            screen where we can enter the Project name, Flutter SDK path, Project location, and a
            Description for the application—we can see this as follows.

            16


                evince -p 17 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 1-g: Create new Flutter project option (step 2)

            Make sure the Flutter SDK path text field specifies the correct folder location of the SDK, as
            previously explained. With those options entered, click Next.
            In the final step of the app creation process, we are asked to enter the Company domain and
            include (if applicable) Kotlin support for Android code and Swift support for iOS code—in
            our case, there’s no need to include these options.
            The following figure shows the final step of the application creation screen.

            17
            www.dbooks.org


                evince -p 18 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 1-h: Create new Flutter project option (step 3)

            To finalize the creation of the demo application, click Finish. With the demo application created,
            make sure you have a virtual device created and ready so we can quickly test the app.

            Creating a virtual device
            Let’s quickly go over the steps required to create a virtual device. With Android Studio opened,
            go to the Tools menu and click on the AVD Manager option, which will display the following
            screen.

            18


                evince -p 19 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 1-i: Creating a virtual device (step 1)

            Then, click Create Virtual Device, which will display the following window with all the available
            virtual devices that can be created for different categories, such as: phones, TV, tablets, and
            wearable devices.
            I’m going to select the Nexus 6 model from the Phone category, but feel free to choose any
            other.

            Figure 1-j: Creating a virtual device (step 2)

            19
            www.dbooks.org


                evince -p 20 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Once you have your model selected, click Next. You will be prompted to select one of the
            available device images.

            Figure 1-k: Creating a virtual device (step 3)

            I’m going with the first recommended option from the available list; however, you can choose
            any other. It’s important to choose an image that plays well with your computer’s host operating
            system. In essence, for emulator performance reasons, it’s not recommended to choose an
            ARM-based image if your computer’s host operating system is based on a x86 architecture.
            If you’ve chosen a different image than the one highlighted in Figure 1-k you might have to
            download the image, using the Download link next to the image Release Name field.
            Once the image has been selected (and downloaded, if applicable), click Next to continue to the
            last step.

            20


                evince -p 21 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 1-l: Creating a virtual device (step 4)

            The last step contains the configuration details for the virtual device image, which you can
            normally leave to the default options, and then simply click Finish.
            Awesome—you now have created a virtual device. You can create more than one if you wish,
            as it might help you test your application with multiple devices. In my case, I’ve also created
            another virtual device for a Pixel 2 XL phone API 28, which looks as follows.

            21
            www.dbooks.org


                evince -p 22 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 1-m: Virtual device—Android emulator

            Testing our setup
            With our virtual device in place, it’s now time to run the application we have created and see
            what it does.
            To do that, select the Open Android Emulator option from the Android SDK built for x86
            drop-down list, which is next to the run button. Once the Android emulator is opened, you’ll be
            able to execute the application when you click run.

            Figure 1-n: The emulator drop-down and run button

            Try to run the application to see what happens—in my case, I get the following Android Studio
            console output.

            22


                evince -p 23 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Code Listing 1-b: Console output when running the application

            Launching lib\main.dart on Android SDK built for x86 in debug mode...
            Initializing gradle...
            Resolving dependencies...
            * Error running Gradle:
            ProcessException: Process
            "C:\Projects\test\flutter_app\android\gradlew.bat" exited abnormally:
            > Configure project :app
            Checking the license for package Android SDK Build-Tools 28.0.3 in
            C:\Users\EdFreitas\AppData\Local\Android\sdk\licenses
            Warning: License for package Android SDK Build-Tools 28.0.3 not accepted.

            FAILURE: Build failed with an exception.
            * Where:
            Build file 'C:\Projects\test\flutter_app\android\build.gradle' line: 24
            * What went wrong:
            A problem occurred evaluating root project 'android'.
            > A problem occurred configuring project ':app'.
            > Failed to install the following Android SDK packages as some
            licences have not been accepted.
            build-tools;28.0.3 Android SDK Build-Tools 28.0.3
            To build this project, accept the SDK license agreements and install
            the missing components using the Android Studio SDK Manager.
            Alternatively, to transfer the license agreements from one
            workstation to another, see http://d.android.com/r/studio-ui/exportlicenses.html
            Using Android SDK: C:\Users\EdFreitas\AppData\Local\Android\sdk
            * Try:

            23
            www.dbooks.org


                evince -p 24 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Run with --stacktrace option to get the stack trace. Run with --info or -debug option to get more log output. Run with --scan to get full
            insights.
            * Get more help at https://help.gradle.org
            BUILD FAILED in 1s
            Command: C:\Projects\test\flutter_app\android\gradlew.bat
            app:properties
            Finished with error: Please review your Gradle project setup in the
            android/ folder.
            If you didn’t get this console output message after running your application, awesome—you may
            skip the rest of this section and go directly to the “Hot reloading” section.
            If you did, then by carefully reviewing this output information, we find a reference to this
            http://d.android.com/r/studio-ui/export-licenses.html URL that redirects to here.
            This article explains how Gradle can automatically download packages that might be missing,
            and that are required when running an application.
            We can also see that the last line of the message indicates to review the Gradle project setup in
            the Android project folder—which refers to the Build.gradle file found within the Android folder of
            our application. We can see this in the following screenshot.

            24


                evince -p 25 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 1-o: The project structure

            Let’s open the Build.gradle file and inspect its content. Notice in my case how it depends on
            com.android.tools.build:gradle:3.2.1—we can see this in the screenshot that follows.

            Figure 1-p: The Build.gradle file contents

            25
            www.dbooks.org


                evince -p 26 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            The previous console output gives us a hint of what the problem might be: License for
            package Android SDK Build-Tools 28.0.3 not accepted.
            What this is telling us is that it wasn’t able to run the application with this
            com.android.tools.build:gradle:3.2.1 dependency, because I have no license for it.
            In other words, that specific com.android.tools.build:gradle version probably didn’t get
            installed when I went through the Android Studio setup process.
            In that case, the solution is to use a version of the com.android.tools.build:gradle
            dependency that was installed during the Android Studio setup process—which can be one
            version lower than the one mentioned on the Build.gradle file.
            To resolve the problem, all I need to do is change that line on the Build.gradle file from
            com.android.tools.build:gradle:3.2.1 to com.android.tools.build:gradle:3.2.0.

            Figure 1-q: The Build.gradle file contents edited

            After saving the change to the Build.gradle file, if I now click Run, I’ll get the following build
            console output within Android Studio.
            Code Listing 1-c: Console output when running the application (after updating Build.gradle)

            Launching lib\main.dart on Android SDK built for x86 in debug mode...
            Initializing gradle...
            Resolving dependencies...
            Gradle task 'assembleDebug'...
            Built build\app\outputs\apk\debug\app-debug.apk.
            Awesome—that’s so much better! The application has been built, and it is running. We can see
            this on the Android emulator as follows.

            26


                evince -p 27 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 1-r: The demo app running

            With the building issues sorted, let’s now explore how Flutter’s “hot reload” mechanism works,
            and what it does.

            Hot reloading
            Hot reloading is one of the coolest features of Flutter, and basically means that if a change to
            the code is made while the application is running, that change is almost immediately reflected
            within the running application.
            Let’s give hot reloading a try. With the application running, let’s go to the main.dart file under the
            lib folder of our demo application, and locate the following code.
            Code Listing 1-d: Snippet of code of main.dart

            Text(
            'You have pushed the button this many times:',
            )

            27
            www.dbooks.org


                evince -p 28 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Let’s replace the word pushed with the word clicked. The code should now look as follows.
            Code Listing 1-e: Snippet of code of main.dart

            Text(
            'You have clicked the button this many times:',
            )
            Figure 1-s shows the source code and the application running before the change.

            Figure 1-s: App running (before the change)

            Figure 1-t shows the source code and the application running after the change.

            28


                evince -p 29 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 1-t: App running (after the change)

            As you can clearly see, hot reloading worked. Something to notice about hot reloading is that
            the changes take a few seconds to propagate and become effective, as the application is
            basically redeployed to the emulator or device when changes take place.
            Web developers will notice that hot reloading in Flutter is slower than when developing web
            applications. This is because during web development, hot reloading only applies to the HTML,
            CSS, or JavaScript being modified, whereas with Flutter, the actual application runtime needs to
            be synced to the device.
            Nevertheless, Flutter’s hot-reloading mechanism is impressive and very useful, as it helps us
            avoid having to stop the app and restart it.

            Summary
            The goal of this chapter was to set up Flutter and get started—that’s exactly what we managed
            to achieve.
            Next, we’ll dive straight into the code and start writing the fundamental pillars of our app. It’s
            going to be a lot of fun, as we’ll look at how to design our app’s UI and implement its essential
            logic.

            29
            www.dbooks.org



            ___start2
                evince -p 30 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Chapter 2 App Fundamentals
            Quick intro
            To get a sense of what we will be building throughout this book, let’s have a look at how the
            main screen of our finished application will look—we can see this as follows.

            Figure 2-a: The finished app

            We can see that the app contains a list of documents, each with the remaining days before they
            expire and their expiration date.
            The app’s UI is based on Google’s Material Design library, which comes out of the box with
            Flutter.
            Note: You can find all the finished Dart source code files and the Pubspec.yaml
            file for this app in the appendix at the end of the book.

            30


                evince -p 31 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Rewriting—main.dart
            With the setup phase behind us, it’s now time to start building the foundations of our application.
            To do that, go to the main.dart file found under the lib folder, and remove all the existing code it
            contains. With all the out-of-the-box code removed from the main.dart file, let’s add the following
            code.
            Code Listing 2-a: The new, finished main.dart code

            import 'package:flutter/material.dart';
            import './ui/doclist.dart';
            void main() => runApp(DocExpiryApp());
            class DocExpiryApp extends StatelessWidget
            {
            @override
            Widget build(BuildContext context) {
            return MaterialApp(
            debugShowCheckedModeBanner: false,
            title: 'DocExpire',
            theme: new ThemeData(
            primarySwatch: Colors.indigo,
            ),
            home: DocList(),
            );
            }
            }
            What have we done here? Let’s dissect this code into smaller pieces to understand it better.
            Code Listing 2-b: The new, finished main.dart code (part 1)

            import 'package:flutter/material.dart';
            import './ui/doclist.dart';
            The first line imports the Material Design library, which we will use to create our app’s widgets
            (UI components).
            The second line references a file that we have not created yet within our application, which will
            contain the logic for creating and displaying the list of documents, showing whether they have
            expired or not.
            Next, we invoke the main method, which is the app’s main entry point. This method invokes
            runApp, to which a new instance of the DocExpiryApp class is passed.

            31
            www.dbooks.org


                evince -p 32 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Code Listing 2-c: The new, finished main.dart code (part 2)

            void main() => runApp(DocExpiryApp());
            Following that, we declare the DocExpiryApp class, which inherits from the StatelessWidget
            class. This is one of two types of widget classes that Flutter supports.
            Code Listing 2-d: The finished DocExpiryApp code

            class DocExpiryApp extends StatelessWidget
            {
            @override
            Widget build(BuildContext context) {
            return MaterialApp(
            debugShowCheckedModeBanner: false,
            title: 'DocExpire',
            theme: new ThemeData(
            primarySwatch: Colors.indigo,
            ),
            home: DocList(),
            );
            }
            }
            A StatelessWidget describes a widget that does not require mutable state—in other words, it
            is a widget without a state. You can find more details in the official documentation.
            Basically, every UI component in Flutter is a widget, either with state, StatefulWidget, or
            without state, StatelessWidget.
            Within the DocExpiryApp class, we are overriding the Build method inherited from the
            StatelessWidget class, which is responsible for returning a Widget object to its caller, and
            thus building the UI element.
            So, in essence, the Build method creates a MaterialApp widget, the app’s main component.
            The home property is assigned to the result that will be returned from the DocList method. The
            DocList method is imported from doclist.dart (yet to be created), which will return the list of
            documents to be displayed.
            To better understand the relationship between what you see in the code and what is displayed
            on the device’s screen when the app runs, let’s have a look at the following diagram.

            32


                evince -p 33 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 2-b: Relationship between the main.dart code and the app’s main UI

            The MaterialApp widget has properties that determine some of its functionality. The title
            property needs no explanation, but the debugShowCheckedModeBanner and theme properties
            do.
            As its name indicates, the debugShowCheckedModeBanner property is used for displaying a
            smaller banner that indicates that the app is running in debug mode when the property is set to
            true.
            This is how the app’s main screen would look with the debugShowCheckedModeBanner property
            set to true. Notice the small Debug banner on the top, right-hand side of the screen.

            Figure 2-c: The app’s main UI with debugShowCheckedModeBanner set to true

            The theme property basically represents the main color used for the app’s UI, which in this case
            is indigo. More information about theming in Flutter can be found in the official documentation.
            If you’re tempted to run the app after having made these changes to main.dart, you’ll get some
            compilation errors. This is because we haven’t yet created Doclist.dart—but we are referencing
            it in the code.

            33
            www.dbooks.org


                evince -p 34 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Also, we have assigned to the home property the value returned by the DocList method—also
            part of Doclist.dart.
            So, if you would like to run the app at this stage and check how it looks, you’ll have to wait until
            we have written some more code, specifically within the doclist.dart file.

            Project structure
            With the main.dart code rewritten, let’s explore how the current project structure looks, what
            other files and folders we would need to create, and what the finished application project
            structure will look like.

            Figure 2-d: The app’s project folder structure comparison

            As we can see in the preceding diagram, the main differences between the current project folder
            structure and the finished one are the subfolders and files found under the project’s lib folder,
            which we will create throughout this book.
            The lib folder is where all our app’s source code is going to be organized. To make the code
            organization easy, we’ll have three subfolders:
            •

            The model folder, which will be used to keep the object model that will be used for
            storing information on the SQLite database.

            34


                evince -p 35 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            •
            •

            The ui folder, which is where we will have all the logic related to the app’s UI and
            navigation.
            The util folder, which will contain utility, general purpose code, and database helper
            classes and methods.

            By using this structure, we can keep our source code organized. Notice that this is not the only
            possible project folder structure; you might want to name your folders differently or organize
            them in another way. Flutter doesn’t impose a specific way of organizing source files—the way
            you organize your code is entirely up to you.
            However, I suggest you keep this structure, as it will make it easier to follow along with the
            various stages of the development of the application.

            Bottom-to-top coding approach
            For our application to be fully functional, we need to be able to display the list of documents. To
            be able to do that, we need a database model, database helper functions, a detail page that will
            be used for each document, and some generic utility functions.
            All this code needs to be written before we can attempt to display the list of documents. This
            means that doclist.dart will be the last module we will write for our application.
            The first module we will write is going to be called utils.dart, which will contain generic and form
            validation functions that we will need throughout the application.
            We’ll be coding using a bottom-to-top approach, where we write the basic building blocks and
            then build up based on that. This approach will look as follows.

            Figure 2-e: Bottom-to-top coding approach

            Let’s move on, starting with the utils.dart file.

            35
            www.dbooks.org


                evince -p 36 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Writing utils.dart
            To be able to properly validate new documents that we will enter using our application, we need
            to have some general validation routines. This is the main purpose of utils.dart.
            To get a visual understanding of what this means, have a look at the following screenshot that
            represents the finished UI for adding a new document.

            Figure 2-f: App screen to enter a new document

            We can immediately see that there are two validations: one for checking that the Document
            Name field is not empty, and another that checks that the Expiry Date field is a valid future date.
            This is the logic we’ll add to the utils.dart file—let’s go ahead and do that.
            To organize our code properly, create a subfolder under the lib folder called util—this is where
            we will create the utils.dart file.
            You can do this by right-clicking on the lib folder within Android Studio, and then choosing New
            > Directory.

            36


                evince -p 37 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Next, select the lib folder, right-click, and choose New > File.

            Figure 2-g: New file option

            When prompted, enter the name of the file: utils.dart.

            Figure 2-h: New file window

            With the utils.dart file created under the lib\util folder path, let’s add the following code to it.
            Code Listing 2-e: Full utils.dart code

            import 'package:intl/intl.dart';
            class Val {
            // Validations
            static String ValidateTitle(String val) {
            return (val != null && val != "") ? null : "Title cannot be empty";
            }
            static String GetExpiryStr(String expires) {
            var e = DateUtils.convertToDate(expires);
            var td = new DateTime.now();
            Duration dif = e.difference(td);
            int dd = dif.inDays + 1;
            return (dd > 0) ? dd.toString() : "0";
            }

            37
            www.dbooks.org


                evince -p 38 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            static bool StrToBool(String str) {
            return (int.parse(str) > 0) ? true : false;
            }
            static bool IntToBool(int val) {
            return (val > 0) ? true : false;
            }
            static String BoolToStr(bool val) {
            return (val == true) ? "1" : "0";
            }
            static int BoolToInt(bool val) {
            return (val == true) ? 1 : 0;
            }
            }
            class DateUtils {
            static DateTime convertToDate(String input) {
            try
            {
            var d = new DateFormat("yyyy-MM-dd").parseStrict(input);
            return d;
            } catch (e) {
            return null;
            }
            }
            static String convertToDateFull(String input) {
            try
            {
            var d = new DateFormat("yyyy-MM-dd").parseStrict(input);
            var formatter = new DateFormat('dd MMM yyyy');
            return formatter.format(d);
            } catch (e) {
            return null;
            }
            }
            static String convertToDateFullDt(DateTime input) {
            try
            {
            var formatter = new DateFormat('dd MMM yyyy');
            return formatter.format(input);
            } catch (e) {
            return null;
            }
            }

            38


                evince -p 39 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            static bool isDate(String dt) {
            try
            {
            var d = new DateFormat("yyyy-MM-dd").parseStrict(dt);
            return true;
            } catch (e) {
            return false;
            }
            }
            static bool isValidDate(String dt) {
            if (dt.isEmpty || !dt.contains("-") || dt.length < 10) return false;
            List<String> dtItems = dt.split("-");
            var d = DateTime(int.parse(dtItems[0]),
            int.parse(dtItems[1]), int.parse(dtItems[2]));
            return d != null && isDate(dt) &&
            d.isAfter(new DateTime.now());
            }
            // String functions
            static String daysAheadAsStr(int daysAhead) {
            var now = new DateTime.now();
            DateTime ft = now.add(new Duration(days: daysAhead));
            return ftDateAsStr(ft);
            }
            static String ftDateAsStr(DateTime ft) {
            return ft.year.toString() + "-" +
            ft.month.toString().padLeft(2, "0") + "-" +
            ft.day.toString().padLeft(2, "0");
            }
            static String TrimDate(String dt) {
            if (dt.contains(" ")) {
            List<String> p = dt.split(" ");
            return p[0];
            }
            else
            return dt;
            }
            }
            What is going on here? As you might have noticed, the code contains two classes: Val and
            DateUtils. There’s quite a bit of code within the utils.dart file; it’s not incredibly important right

            39
            www.dbooks.org


                evince -p 40 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            now to understand each line of code within it, but rather, to understand how the main parts
            relate with each other.
            Let’s explore the relationship between both classes and the document entry application screen
            we looked at before.

            Figure 2-i: Interconnection between the document entry screen and utils.dart code

            As you can see in Figure 2-i, the relationship among the parts and the application is very clear
            and easy to understand. Most of the methods within the Val and DateUtils classes are
            methods that we will need later as we progressively build our application.
            Right now, let’s quickly go over the ones that are essential and that directly relate to the
            document entry screen. Let’s first have a look at the ValidateTitle method.
            Code Listing 2-f: ValidateTitle method (utils.dart)

            static String ValidateTitle(String val) {
            return (val != null && val != "") ? null : "Title cannot be empty";
            }
            As we can see, this method is very simple—it basically evaluates, through a ternary conditional
            expression, if the value of the parameter val—which represents the name of the document
            entered through the document entry screen—is an empty String object.
            If it is not, then null is returned, which means that the validation has passed. If it is an empty
            String, then a message is returned, indicating that the string cannot be empty—this message
            is the one displayed in the document entry screen.

            40


                evince -p 41 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Now, let’s explore the GetExpiryStr method and what it does. We can see this in the listing
            that follows.
            Code Listing 2-g: GetExpiryStr method (utils.dart)

            static String GetExpiryStr(String expires) {
            var e = DateUtils.convertToDate(expires);
            var td = new DateTime.now();
            Duration dif = e.difference(td);
            int dd = dif.inDays + 1;
            return (dd > 0) ? dd.toString() : "0";
            }
            This method is also quite simple. The first instruction converts the document’s expiry date,
            represented by the expires variable, into a DateTime object by invoking the convertToDate
            method from the DateUtils class.
            What follows is that the current DateTime is obtained by calling the now method. Then, the
            difference between the document’s expiry date and the current date is calculated by calling the
            difference method.
            If the result of difference is positive, then that value is converted to a String by calling the
            toString method, and then returned. If the value is negative or zero, then “0” is returned as a
            String object.
            Now, let’s explore the convertToDate method from the DateUtils class—we can see this in
            the listing that follows.
            Code Listing 2-h: convertToDate method (utils.dart)

            static DateTime convertToDate(String input) {
            try {
            var d = new DateFormat("yyyy-MM-dd").parseStrict(input);
            return d;
            } catch (e) {
            return null;
            }
            }
            This method is also very simple—it basically takes the date as an input variable and attempts
            to parse it using the format “yyyy-MM-dd” by calling the parseStrict method.
            If successful, then the parsed value d is returned; otherwise, null is returned.
            Awesome—we are almost done covering all we need to know about the utils.dart code. There’s
            just one small piece missing: the first line of utils.dart.

            41
            www.dbooks.org


                evince -p 42 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Code Listing 2-i: Import statement (utils.dart)

            import 'package:intl/intl.dart';
            This line basically tells Flutter that utils.dart needs to import a package called intl.dart—
            which is a Dart library used for supporting internationalization and localization capabilities.
            The DateFormat method that is invoked from the convertToDate method is part of the
            intl.dart library.
            However, there’s still one thing missing—we need to import this package into our Flutter project.
            We can do this by opening the Pubspec.yaml file found within our main project folder, and then
            installing the package as follows.

            Figure 2-j: Adding the package to Pubspec.yaml

            Once the package has been added to the Pubspec.yaml file, we’ll need to run the flutter
            packages get command, which can be done within Android Studio directly with one click—this
            is highlighted in Figure 2-j.
            Once you’ve clicked the Packages get option, you should see the following output in the
            Android Studio messages window.

            42


                evince -p 43 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 2-k: Message output in Android Studio after adding a package

            Our utils.dart code can now use the DateFormat method, and we are done with utils.dart.

            Writing model.dart
            With utils.dart covered, let’s move on and create the model.dart file, which represents the data
            model that will be used for storing and retrieving document data.
            To keep things organized, let’s create a model subfolder under the lib folder of our application.
            Inside this model subfolder, let’s create the model.dart file—we can do this the same way we
            created the util subfolder and utils.dart with Android Studio.
            With the model.dart file created, let’s add the following code to it.
            Code Listing 2-j: Full model.dart code

            import '../util/utils.dart';
            class Doc
            {
            int id;
            String title;
            String expiration;
            int
            int
            int
            int

            fqYear;
            fqHalfYear;
            fqQuarter;
            fqMonth;

            Doc(this.title, this.expiration, this.fqYear,
            this.fqHalfYear, this.fqQuarter, this.fqMonth);
            Doc.withId(this.id, this.title, this.expiration, this.fqYear,
            this.fqHalfYear, this.fqQuarter, this.fqMonth);

            43
            www.dbooks.org


                evince -p 44 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Map<String, dynamic> toMap() {
            var map = Map<String, dynamic>();
            map["title"] = this.title;
            map["expiration"] = this.expiration;
            map["fqYear"] = this.fqYear;
            map["fqHalfYear"] = this.fqHalfYear;
            map["fqQuarter"] = this.fqQuarter;
            map["fqMonth"] = this.fqMonth;
            if (id != null) {
            map["id"] = id;
            }
            return map;
            }
            Doc.fromOject(dynamic o) {
            this.id = o["id"];
            this.title = o["title"];
            this.expiration = DateUtils.TrimDate(o["expiration"]);
            this.fqYear = o["fqYear"];
            this.fqHalfYear = o["fqHalfYear"];
            this.fqQuarter = o["fqQuarter"];
            this.fqMonth = o["fqMonth"];
            }
            }
            Let’s break this into smaller parts so we can understand what this code does.
            First, we import a reference to the utils.dart module we previously created—this is because the
            fromObject method invokes the TrimDate method from the DateUtils class.
            Code Listing 2-k: Importing utils.dart in model.dart

            import '../util/utils.dart';
            Then, we have a Doc class, which in our data model represents the document that will be
            written and read to the SQLite embedded database we will be using. Let’s first explore the
            properties of the Doc class.
            Code Listing 2-l: Doc class properties

            // Previous code…

            44


                evince -p 45 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            class Doc
            {
            int id;
            String title;
            String expiration;
            int
            int
            int
            int

            fqYear;
            fqHalfYear;
            fqQuarter;
            fqMonth;

            // The rest of the Doc class code
            }
            To better understand how these properties relate to a document database record, which is
            going to be stored within an SQLite table, let’s look at the following diagram.

            Figure 2-l: Data model fields

            We can clearly establish the relationship between each of the Doc class properties and each of
            the columns as they will be stored in the SQLite database.
            Our Doc class is the object representation of a document record stored in the database.
            Moving on, we can see that our class has two constructors—one that will be invoked when
            creating a new document, and the other for existing documents in the database. This is shown
            in the following code.
            Code Listing 2-m: Doc class constructors

            // Previous code…

            45
            www.dbooks.org


                evince -p 46 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            class Doc
            {
            // Doc class properties.
            // Constructor used if we don’t want to assign an id immediately.
            Doc(this.title, this.expiration, this.fqYear,
            this.fqHalfYear, this.fqQuarter, this.fqMonth);
            // Constructor used if we want to assign an id immediately
            Doc.withId(this.id, this.title, this.expiration, this.fqYear,
            this.fqHalfYear, this.fqQuarter, this.fqMonth);
            // Rest of the Doc class code.
            }
            The first constructor (Doc) is used when we want to create an instance of the Doc class and we
            don’t want to assign a value to the id property.
            The second constructor (Doc.withId) is used when we want to create an instance of the Doc
            class and we want to assign a value to the id property right away.
            When we create a new document or access an existing one, we’ll need to invoke one of these
            constructors to create an instance of the Doc class—which is how we represent a document
            within our application.
            Now, let’s explore the rest of the Doc class code.
            Code Listing 2-n: Rest of the Doc class code

            // Previous code…
            class Doc
            {
            // All the previous code
            Map<String, dynamic> toMap() {
            var map = Map<String, dynamic>();
            map["title"] = this.title;
            map["expiration"] = this.expiration;
            map["fqYear"] = this.fqYear;
            map["fqHalfYear"] = this.fqHalfYear;
            map["fqQuarter"] = this.fqQuarter;
            map["fqMonth"] = this.fqMonth;
            if (id != null) {
            map["id"] = id;

            46


                evince -p 47 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            }
            return map;
            }
            Doc.fromOject(dynamic o) {
            this.id = o["id"];
            this.title = o["title"];
            this.expiration = DateUtils.TrimDate(o["expiration"]);
            this.fqYear = o["fqYear"];
            this.fqHalfYear = o["fqHalfYear"];
            this.fqQuarter = o["fqQuarter"];
            this.fqMonth = o["fqMonth"];
            }
            }
            The rest of the code consists of two methods—the toMap and fromObject methods. Let’s see
            what each does. The toMap method is used when the document information needs to be written
            to the database.
            Code Listing 2-o: The toMap method

            Map<String, dynamic> toMap() {
            var map = Map<String, dynamic>();
            map["title"] = this.title;
            map["expiration"] = this.expiration;
            map["fqYear"] = this.fqYear;
            map["fqHalfYear"] = this.fqHalfYear;
            map["fqQuarter"] = this.fqQuarter;
            map["fqMonth"] = this.fqMonth;
            if (id != null) {
            map["id"] = id;
            }
            return map;
            }
            The first instruction of the toMap method is used to create an instance of Map<String,
            dynamic>. For further information regarding the usage of Map within the Dart programming
            language, please refer to the official documentation.
            Within the toMap method, the existing Doc instance property values are assigned to their
            equivalent properties within a Map object—which is convenient for writing the data to the

            47
            www.dbooks.org


                evince -p 48 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            database. The toMap method returns a Map object back to its invoker—which, as we will see
            later, is going to be a method that writes to the database.
            Let’s now have a look at the fromObject method, which does the opposite of what the toMap
            method does.
            Code Listing 2-p: The fromObject method

            Doc.fromOject(dynamic o) {
            this.id = o["id"];
            this.title = o["title"];
            this.expiration = DateUtils.TrimDate(o["expiration"]);
            this.fqYear = o["fqYear"];
            this.fqHalfYear = o["fqHalfYear"];
            this.fqQuarter = o["fqQuarter"];
            this.fqMonth = o["fqMonth"];
            }
            Essentially, the fromObject method receives a dynamic object as a parameter—which is
            retrieved from the database—and the properties of this object are then assigned to their
            respective counterpart properties within the Doc instance.
            To recap: the toMap method is used when writing to the database, and the fromObject method
            is used when reading from the database.

            Creating the database—dbhelper.dart
            With model.dart behind us, let’s now focus on an essential part of the application, which is the
            database access layer and helper functions. Let’s create the dbhelper.dart file within the util
            subfolder.
            As the code for the dbhelper.dart file is quite extensive, I won’t paste it all straight away, but
            instead we’ll take a look at each individual part, one by one.
            Code Listing 2-q: The import statements—dbhelper.dart

            import 'package:flutter/material.dart';
            import 'package:sqflite/sqflite.dart';
            import 'package:path_provider/path_provider.dart';
            import 'dart:async';
            import 'dart:io';
            import '../model/model.dart';

            48


                evince -p 49 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            In the import section, we can see that the first three instructions reference three packages that
            we haven’t seen before.
            The material.dart package is built into Flutter, and was automatically added to the
            Pubspec.yaml file when the project was created. We can see this in the Pubspec.yaml file as
            follows.

            Figure 2-m: Built-in material and Flutter package

            The following two lines refer to the sqflite.dart (a Flutter package used to access a SQLite
            database) and path_provider.dart packages, which have not been added to the
            Pubspec.yaml file yet. Let’s do this now.

            Figure 2-n: Adding the sqflite and path_provider packages

            All we’ve done is add both package names below intl, within the Pubspec.yaml file. After doing
            that, click on the Packages get option, so both packages can get installed.
            Following that are two import statements that reference the dart:async and dart:io libraries,
            which will be used for performing async and file operations.
            Finally, we can see the import statement that references the model.dart file, which we will need
            to read and write documents to the database.

            49
            www.dbooks.org


                evince -p 50 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Next, let’s create the DbHelper class, which will contain all the helper functions we need to work
            correctly with the database.
            For now, let’s just add the names of the properties for the database table and fields—we can
            see this as follows.
            Code Listing 2-r: DbHelper class—dbhelper.dart

            // Import statements… previous code.
            class DbHelper {
            // Tables
            static String tblDocs = "docs";
            // Fields of the 'docs' table.
            String docId = "id";
            String docTitle = "title";
            String docExpiration = "expiration";
            String
            String
            String
            String

            fqYear = "fqYear";
            fqHalfYear = "fqHalfYear";
            fqQuarter = "fqQuarter";
            fqMonth = "fqMonth";

            // More code will follow…
            }
            As you can see, the code is self-explanatory—we have tblDocs, which indicates the name of
            the table that will be used to store the documents, and following that, the names of each of the
            fields contained within that table.
            Next, let’s create the database entry point, which will be a singleton. This is because we want to
            limit the instantiation of the DbHelper class to one instance only. We can do this as follows.
            Code Listing 2-s: DbHelper class—dbhelper.dart (continued)

            // Import statements… previous code.
            class DbHelper {
            // Previous code
            // Singleton
            static final DbHelper _dbHelper = DbHelper._internal();
            // Factory constructor
            DbHelper._internal();
            factory DbHelper() {
            return _dbHelper;

            50


                evince -p 51 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            }
            // Database entry point
            static Database _db;
            }
            // More code will follow…
            The first thing we have done is declare the _dbHelper instance as a final variable, which
            means that it is a single-assignment variable. Once assigned, its value cannot change—this is
            what we want, as it needs to be a singleton.
            That variable is assigned to the value returned by the class’ internal constructor, also known
            as a Factory constructor, which is then declared.
            This Factory constructor pattern is quite common in Dart, and it is primarily used for creating
            singletons—this Stack Overflow thread explains this Dart pattern very well, in case you would
            like to know more about it.
            Next, we declare a static variable of type Database that will hold the reference to the
            database entry point. The Database class is part of the sqflite library that we added to the
            Pubspec.yaml file previously.
            Following this, we’ll need to get a runtime reference to the database and initialize it—we can do
            this as follows.
            Code Listing 2-t: DbHelper class—dbhelper.dart (continued)

            // Import statements… previous code.
            class DbHelper {
            // Previous code
            Future<Database> get db async {
            if (_db == null) {
            _db = await initializeDb();
            }
            return _db;
            }
            // Initialize the database
            Future<Database> initializeDb() async {
            Directory d = await getApplicationDocumentsDirectory();
            String p = d.path + "/docexpire.db";
            var db = await openDatabase(p, version: 1, onCreate: _createDb);
            return db;
            }

            51
            www.dbooks.org


                evince -p 52 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            }
            // More code will follow…
            We can get the runtime reference to the database by using an async getter called db, which
            returns a Future object that will reference the database. This is done by checking that _db is
            not null, and then invoking the initializeDb method, which is responsible for opening the
            database.
            The initializeDb method returns a Future, which is the runtime reference to the database. It
            does this by calling the openDatabase async method and passing the location of the database
            file on the device—Docexpire.db.
            The location of the file is determined by invoking the getApplicationDocumentsDirectory
            method and concatenating it to the actual file name on the device—docexpire.db.
            Notice how the openDatabase method has an onCreate parameter, which indicates the name
            of the method that will be invoked the first time the database is opened. This will create the
            actual database our app will need, the _createDb method, which we can see as follows.
            Code Listing 2-u: DbHelper class—dbhelper.dart (continued)

            // Import statements… previous code.
            class DbHelper {
            // Previous code
            // Create database table
            void _createDb(Database db, int version) async {
            await db.execute(
            "CREATE TABLE $tblDocs($docId INTEGER PRIMARY KEY, $docTitle TEXT, "
            + "$docExpiration TEXT, " +
            "$fqYear INTEGER, $fqHalfYear INTEGER, $fqQuarter INTEGER, " +
            "$fqMonth INTEGER)"
            );
            }
            }
            // More code will follow…
            As you can see, the _createDb method simply calls the db.execute method and passes a
            CREATE TABLE statement, which is responsible for creating the database table that will be used
            for storing the information our app will use.
            This is all the code required for initializing and creating the database. Next, we’ll explore how we
            can add extra functionality to be able to query the database, and insert and delete from the
            database.

            52


                evince -p 53 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Inserting a new document—dbhelper.dart
            The next thing we need to do is to write a method that allows us to save a document to the
            database. We can do this as follows.
            Code Listing 2-v: DbHelper class—dbhelper.dart (continued)

            // Import statements… previous code.
            class DbHelper {
            // Previous code
            // Insert a new doc
            Future<int> insertDoc(Doc doc) async {
            var r;
            Database db = await this.db;
            try {
            r = await db.insert(tblDocs, doc.toMap());
            }
            catch (e) {
            debugPrint("insertDoc: " + e.toString());
            }
            return r;
            }
            }
            // More code will follow…
            Notice that this insertDoc method reads the reference to the database (this.db), and then it
            calls the db.insert method and passes the result of the doc.toMap method, which was
            previously defined in model.dart.
            Since we are dealing with a database insert operation, we wrap this code in a try-catch
            block to prevent any unhandled exceptions from arising.
            As you have seen, adding an item to the database is not so difficult. Notice, though, that all
            database operations so far return a Future object, and the calls are async. The reason for this
            is that you don’t want to have the application blocked while waiting for a database operation to
            finish.

            Getting the list of documents—dbhelper.dart
            Now that we’ve seen how to insert a document, it’s important to understand how to we can
            retrieve any document stored within the database. We can do this as follows.
            Code Listing 2-w: DbHelper class—dbhelper.dart (continued)

            53
            www.dbooks.org


                evince -p 54 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            // Import statements…previous code.
            class DbHelper {
            // Previous code
            // Get the list of docs.
            Future<List> getDocs() async {
            Database db = await this.db;
            var r = await db.rawQuery(
            "SELECT * FROM $tblDocs ORDER BY $docExpiration ASC");
            return r;
            }
            }
            // More code will follow…
            As you can see, the getDocs method that retrieves the list of documents from the database is
            very simple. We can see a common pattern again—get the reference to the database using
            this.db.
            Then, the actual query to the database is executed by running the db.rawQuery method and
            passing it the SQL query as a string parameter.
            We can see that we are returning the result r in ascending order by the document’s expiration
            date—docExpiration.
            Next, let’s see how we can get a specific document from the database.

            Getting a specific document—dbhelper.dart
            Getting all the documents available in the database is useful when we want to build up the main
            list of documents in our UI. However, if we want to modify a specific document that we
            previously added, we’ll need to be able to retrieve that document from the database—this is
            what we’ll do next.
            Code Listing 2-x: DbHelper class—dbhelper.dart (continued)

            // Import statements… previous code.
            class DbHelper {
            // Previous code
            // Gets a Doc based on the id.
            Future<List> getDoc(int id) async {
            Database db = await this.db;
            var r = await db.rawQuery(

            54


                evince -p 55 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            "SELECT * FROM $tblDocs WHERE $docId = " + id.toString() + "" );
            return r;
            }
            // Gets a Doc based on a String payload
            Future<List> getDocFromStr(String payload) async {
            List<String> p = payload.split("|");
            if (p.length == 2) {
            Database db = await this.db;
            var r = await db.rawQuery(
            "SELECT * FROM $tblDocs WHERE $docId = " + p[0] +
            " AND $docExpiration = '" + p[1] + "'" );
            return r;
            }
            else
            return null;
            }
            }
            // More code will follow…
            We have two ways of retrieving a specific document. One way is to retrieve the document by its
            id (docId); this is what the getDoc method does. Another way is to retrieve it from the database
            by its id and by the document’s expiration date (docExpiration)—this is what the
            getDocFromString method does.
            The getDoc method simply calls the db.rawQuery method and runs a query on the tblDocs
            table. It retrieves the document where the docId has the same value as the id parameter—very
            straightforward.
            The getDocFromStr method is slightly more complex, but not too much. The difference is that
            this method receives a String object payload, which contains two important bits of data,
            separated by a pipe (|) character. The first part of the payload is docId, and the second part is
            docExpiration.
            The payload is split and each respective value concatenated onto the SQL query that gets
            passed to the db.rawQuery method. The SQL query retrieves the document by checking for the
            correct id and expiration date values.
            By using these two methods, we can retrieve any specific document we need.

            Counting documents—dbhelper.dart
            Now that we know how to retrieve specific documents, we’ll also need to count how many
            documents we have and retrieve the largest document ID from the database—this will be
            important for changing the UI state later. So, let’s see how we can do this.

            55
            www.dbooks.org


                evince -p 56 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Code Listing 2-y: DbHelper class—dbhelper.dart (continued)

            // Import statements… previous code.
            class DbHelper {
            // Previous code
            // Get the number of docs.
            Future<int> getDocsCount() async {
            Database db = await this.db;
            var r = Sqflite.firstIntValue(
            await db.rawQuery("SELECT COUNT(*) FROM $tblDocs")
            );
            return r;
            }
            // Get the max document id available on the database.
            Future<int> getMaxId() async {
            Database db = await this.db;
            var r = Sqflite.firstIntValue(
            await db.rawQuery("SELECT MAX(id) FROM $tblDocs")
            );
            return r;
            }
            }
            // More code will follow…
            The first method, getDocsCount, basically executes a SQL query that returns an int value,
            which counts how many documents there are on the tblDocs table.
            The second method, getMaxId, executes a SQL query that returns an int value, which
            represents the maximum value existing on the tblDocs table for the id field of all documents. In
            other words, it returns the largest existing document id value within the table.
            As you can see, the only difference between these methods is that one uses the SQL COUNT
            function and the other uses the SQL MAX function.
            To be able to change the state of the UI, it’s important we have these functions so we can get
            the number of documents in the database—this is main reason for having the getDocsCount
            function.
            We use the getMaxId function because when a new document is being added, we need to
            make sure that this new document gets assigned an id value larger than the largest one
            available on the tblDocs table. This is done so that each document has an id that is
            consecutive to the previous one and is not repeated.

            56


                evince -p 57 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Updating and deleting documents—dbhelper.dart
            We now almost have all the database functionality we require, but we are still missing an
            important part—this is the ability to delete and update documents. Let’s add this code as
            follows.
            Code Listing 2-z: DbHelper class—dbhelper.dart (continued)

            // Import statements… previous code.
            class DbHelper {
            // Previous code.
            // Update a doc.
            Future<int> updateDoc(Doc doc) async {
            var db = await this.db;
            var r = await db.update(tblDocs, doc.toMap(),
            where: "$docId = ?", whereArgs: [doc.id]);
            return r;
            }
            // Delete a doc.
            Future<int> deleteDoc(int id) async {
            var db = await this.db;
            int r = await db.rawDelete(
            "DELETE FROM $tblDocs WHERE $docId = $id");
            return r;
            }
            // Delete all docs.
            Future<int> deleteRows(String tbl) async {
            var db = await this.db;
            int r = await db.rawDelete("DELETE FROM $tbl");
            return r;
            }
            }
            The updateDoc method is responsible for updating a specific document on the database, based
            on the document’s id. This is done by invoking the db.update method by passing the resultant
            object of the call to doc.toMap, which converts the document from a Dart object to its database
            model equivalent.
            The deleteDoc method removes a document from the tblDocs table by running a scoped SQL
            DELETE statement, targeting a specific document id by invoking the db.rawDelete method.
            Finally, the deleteRows method removes all the documents from the database. This is done by
            calling the db.rawDelete method and running a SQL DELETE statement that is not scoped to
            any specific document id.

            57
            www.dbooks.org


                evince -p 58 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Awesome—that concludes our dbhelper.dart file, which is responsible for all our app’s database
            operations.

            Summary
            We’ve come a long way, and it’s been a detailed, but certainly interesting chapter. So far, we’ve
            managed to lay out the foundations of our application and how it will be able to interact with the
            database by adding the model and all the utilities and helper functions required.
            In the next chapter, we’ll implement the UI by creating the Document Details screen,
            docdetail.dart, and from there, we’ll move on to the main screen and finalize the application.
            There are still a lot of things to discover and learn with the amazing Flutter framework.

            58


                evince -p 59 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Chapter 3 App UI—Document Details
            Quick intro
            Throughout this chapter, we’ll look at how to create some of the required UI parts of our
            application, which is essentially the Document Details screen. Without further ado, let’s dive
            right in.

            Document Details
            We’ve reached quite a milestone! We’ve pretty much written all the utility and underlying
            database code that our application will use. But we are not done yet—we still need to create the
            UI logic that our application will use.
            We’ll start writing that UI logic by creating the Document Details window, which will contain the
            details of each document that our application will store.
            So, under the project’s lib folder, create a subfolder called ui, and under it, create a new file
            called docdetail.dart. This is how your lib folder structure should look so far.

            Figure 3-a: The project’s lib folder structure so far

            With the docdetail.dart file created, let’s add some code—we’ll start by importing the references
            to the libraries and packages we’ll need.
            Code Listing 3-a: Import statements—docdetail.dart

            import 'dart:async';
            import 'package:flutter/material.dart';
            import 'package:flutter/services.dart';
            import 'package:flutter_masked_text/flutter_masked_text.dart';

            59
            www.dbooks.org


                evince -p 60 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            import 'package:flutter_datetime_picker/flutter_datetime_picker.dart';
            import '../model/model.dart';
            import '../util/utils.dart';
            import '../util/dbhelper.dart';
            Okay—let’s check what references we’ve imported. First, we are importing the dart:async
            library, which we’ll need to make asynchronous calls to the database.
            Next, we reference the Flutter Material Design (package:flutter/material.dart) and
            Services (package:flutter/services.dart) packages. Material Design is used for the app’s
            UI layout, and the Services library exposes platform-specific services to Flutter apps, such as
            handling text input.
            Following that, notice how we are referencing two packages we have not come across before.
            The first one is going to be used for a masked text input field, which we will use for entering
            dates manually: flutter_masked_text.dart.
            The second is going to be used for selecting dates, as you would normally do using an iPhone.
            It is inspired by the Flutter Cupertino Date Picker component,
            flutter_datetime_picker.dart.
            We can see an example of it as follows.

            Figure 3-b: The Flutter Cupertino Date Picker

            The final three import statements refer to the code files we previously wrote and will need to
            use in docdetail.dart, These are: model.dart, utils.dart, and dbhelper.dart.
            Something very important we need to do is add a reference to the flutter_masked_text and
            flutter_datetime_picker packages to the Pubspec.yaml file, and then install the referenced
            packages using the Packages get option, which can be seen as follows.

            60


                evince -p 61 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 3-c: Adding the packages—Pubspec.yaml

            That wraps up the import statements that the docdetail.dart file needs. Next, let’s add a menu
            option that allows us to delete a document in case it was incorrectly entered.

            Menu options
            For every document that exists within the database that can be edited, we should also have the
            option to remove it. This is particularly useful if you’ve entered a document that is incorrect. We
            can do this as follows.
            Code Listing 3-b: Delete document menu option—docdetail.dart

            // Import statements… previous code.
            // Menu item
            const menuDelete = "Delete";
            final List<String> menuOptions = const <String> [
            menuDelete
            ];
            // More code will follow…
            As you can see, the Delete menu option is simply an element that is part of a menuOptions
            array that we’ll add to the Flutter UI shortly.
            We could add more menu options to this array, but the only one we really need is the option to
            delete an existing document, for which we’ll add the logic later.

            61
            www.dbooks.org


                evince -p 62 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Stateful widget
            We are now ready to create the base widget that will be used within docdetail.dart. This is going
            to be a stateful widget, which is a widget that describes part of the user interface by building a
            set of other widgets that describe the user interface more concretely.
            The stateful widget has a state that can change. The state is information that can be read
            synchronously when the widget is built and might change during its lifetime.
            Having a stateful widget is useful when part of the user interface that is being rendered can
            change dynamically. This is exactly our case, as docdetail.dart will contain document details
            that can vary.
            Let’s go ahead and define the stateful widget we will use for rendering the UI of docdetail.dart.
            Code Listing 3-c: Stateful widget class—docdetail.dart

            // Previous code…
            class DocDetail extends StatefulWidget {
            Doc doc;
            final DbHelper dbh = DbHelper();
            DocDetail(this.doc);
            @override
            State<StatefulWidget> createState() => DocDetailState();
            }
            // More code will follow…
            As we can see, a stateful widget is simply a Dart class—in this case called DocDetail—that
            inherits from the base StatefulWidget Flutter UI class.
            This class has a constructor called DocDetail that is initialized with an instance of the Doc
            class from model.dart.
            A very important part of the DocDetail class is the createState method inherited from the
            StatefulWidget class, which needs to be overridden—that’s why the @override attribute is
            used. The overriding is done by invoking an instance of the DocDetailState class using the
            lambda or arrow (=>) syntax.
            Notice that an instance of the DbHelper class is created and assigned to the dbh (database
            handler) variable, which will be used by the logic contained within docdetail.dart to read and
            write to the database.
            As you can see in Code Listing 3-c, there is a pattern—for each StatefulWidget class, there is
            a corresponding State class. Let’s go ahead and create that State class as follows.

            62


                evince -p 63 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Code Listing 3-d: State class—docdetail.dart

            // Previous code…
            class DocDetailState extends State<DocDetail> {
            final GlobalKey<FormState> _formKey = new GlobalKey<FormState>();
            final GlobalKey<ScaffoldState> _scaffoldKey =
            new GlobalKey<ScaffoldState>();
            final int daysAhead = 5475; // 15 years in the future.
            final TextEditingController titleCtrl = TextEditingController();
            final TextEditingController expirationCtrl = MaskedTextController(
            mask: '2000-00-00');
            bool
            bool
            bool
            bool
            bool

            fqYearCtrl = true;
            fqHalfYearCtrl = true;
            fqQuarterCtrl = true;
            fqMonthCtrl = true;
            fqLessMonthCtrl = true;

            // More code to follow…
            }
            Here we have our DocDetailState class declared. As you can see, it inherits from
            State<DocDetail>, which means that this class handles the state of the DocDetail stateful
            widget class we previously declared.
            Within the DocDetailState class, we have declared a set of variables that we will need, and
            they represent the state of a document being created or edited. Let’s explore these variables
            and what they are used for.
            The first two variables we have declared, _formKey and _scaffoldKey, are going to be used
            for keeping the state of the form once it has been submitted—when the data is saved.
            The FormState class in Flutter is associated with keeping the state of a Form widget, which we
            will add shortly to the DocDetailState class code.
            The ScaffoldState class in Flutter handles the state for a Scaffold object. The Scaffold widget
            will contain the Form widget—we’ll see this later.
            Next, we have declared a variable called daysAhead, which indicates how far into the future we
            can assign an expiration date to a document.
            This has been set to a maximum of 5,475 days (approximately 15 years) into the future, which is
            usually longer than the expiration date of standard types of documents such as passports, credit

            63
            www.dbooks.org


                evince -p 64 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            cards, and driver’s licenses. So, the expiration date of a document cannot be greater than the
            value of daysAhead.
            Following that, we have two TextEditingController variables: one for the document’s title (or
            description), titleCtrl, and another for the document’s expiration date, expirationCtrl.
            A TextEditingController represents a handy controller for a text field. So, when the text field
            associated with the TextEditingController has been modified, the text field updates its value
            property and the controller notifies its listeners. You can find more details on the official Flutter
            documentation.
            Given that both the document title and expiration date can be manually entered, it is logical to
            bind both to TextEditingController objects.
            The main difference between them is that the expiration date field, which binds to
            expirationCtrl, is instantiated as a MaskedTextController and assigned a default mask, so
            when the date is manually entered, it follows the date format YYYY-MM-DD (for example, 202010-12).
            Notice that, so far, all the variables declared within the DocDetailState class have been
            marked as final, which means that their value can only be set once.
            Finally, we have five variables (which are technically objects) that represent the specific alerts of
            when we would like the application to remind us that a document is going to expire.
            We won’t implement the alert mechanism itself within the scope of this book. However, by
            adding these variables (which already have their matching columns in the database), we leave
            these building blocks ready. So in the future, you could add your own alert mechanism using
            these variables:
            •

            •

            •

            •

            •

            The fqYearCtrl variable, when set to true, would indicate that we would like our app to
            remind us of the expiration date of a document when it’s due to expire within a year’s
            time.
            The fqHalfYearCtrl variable, when set to true, would indicate that we would like our
            app to remind us of the expiration date of a document when it’s due to expire within the
            next six months.
            The fqQuarterCtrl variable, when set to true, would indicate that we would like our
            app to remind us of the expiration date of a document when it’s due to expire within the
            next three months.
            The fqMonthCtrl variable, when set to true, would indicate that we would like our app
            to remind us of the expiration date of a document when it’s due to expire within the next
            month.
            The fqLessMonthCtrl variable, when set to true, would indicate that we would like our
            app to remind us of the expiration date of a document when it’s due to expire less than a
            month from now.

            64


                evince -p 65 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            These are all the variables needed within the DocDetailState class. Let’s move on with the
            rest of the code.

            Initializing text controllers and variables
            When the Document Details screen is shown, it is important that the right data is correctly
            displayed to the user—this could be data from an existing document on the database, or
            alternatively, blank data. Let’s see an example of each.
            Here’s an example of how the Document Details screen looks when loading data from an
            existing document.

            Figure 3-d: Document Details screen—Existing document

            As you can see, all the respective variables we previously described—represented by those UI
            widgets—have corresponding values assigned, which represent the value stored in the
            database for that document.
            Let’s now have a look at how this same screen would look for an empty document.

            65
            www.dbooks.org


                evince -p 66 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 3-e: Document Details screen—New document

            Notice that the Document Name and Expiry Date fields are empty; however, by default, the alert
            fields are all enabled, which is what the initialization code is responsible for.
            Code Listing 3-e: Initialization code—docdetail.dart

            // Previous code…
            class DocDetailState extends State<DocDetail> {
            // Previous code
            // Initialization code
            void _initCtrls() {
            titleCtrl.text = widget.doc.title != null ? widget.doc.title : "";
            expirationCtrl.text =
            widget.doc.expiration != null ? widget.doc.expiration : "";
            fqYearCtrl = widget.doc.fqYear != null ?
            Val.IntToBool(widget.doc.fqYear) : false;
            fqHalfYearCtrl = widget.doc.fqHalfYear != null ?
            Val.IntToBool(widget.doc.fqHalfYear) : false;
            fqQuarterCtrl = widget.doc.fqQuarter != null ?
            Val.IntToBool(widget.doc.fqQuarter) : false;
            fqMonthCtrl = widget.doc.fqMonth != null ?
            Val.IntToBool(widget.doc.fqMonth) : false;
            }
            // More code will follow…
            }

            66


                evince -p 67 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            As you can see, all we are doing is assigning a value to each of the variables that are
            represented on the screen by using a ternary conditional expression.
            This means that if there’s a value assigned to its corresponding doc property, then that value is
            assigned to the variable if no default value is assigned.
            In essence, if there’s a doc object with values, those values will be used and assigned to their
            corresponding variables (field widgets seen on the screen). But where is this doc object coming
            from?
            That doc object is the model representation of a document record stored in the database, if
            there is one. It’s the doc property of the DocDetail class. To understand this better, let’s have a
            look at the following diagram.

            Figure 3-f: Relationship among the code, screen and database—Document Details

            Now that we know how the initialization code relates to the Document Details screen, and how
            this relates to a record stored in the database, let’s move on and focus on how to create the
            required UI widgets and their underlying logic.

            Choosing a date
            One of the nicest features about the Document Details screen is the possibility to be able to
            either manually enter the document’s expiration date, or choose it from an iOS-styled date
            picker component, which looks like the following image.

            67
            www.dbooks.org


                evince -p 68 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 3-g: iOS-styled date-picker component

            Let’s write the code that displays this component and allows us to choose the date without
            having to write it manually.
            Code Listing 3-f: Date-picker code—docdetail.dart

            // Previous code…
            class DocDetailState extends State<DocDetail> {
            // Previous code
            // Date Picker & Date function
            Future _chooseDate(BuildContext context, String initialDateString)
            async {
            var now = new DateTime.now();
            var initialDate = DateUtils.convertToDate(initialDateString) ?? now;
            initialDate = (initialDate.year >= now.year &&
            initialDate.isAfter(now) ? initialDate : now);
            DatePicker.showDatePicker(context, showTitleActions: true,
            onConfirm: (date) {
            setState(() {
            DateTime dt = date;

            68


                evince -p 69 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            String r = DateUtils.ftDateAsStr(dt);
            expirationCtrl.text = r;
            });
            },
            currentTime: initialDate);
            }
            // More code to follow…
            }
            Let’s go over what this method does. The first thing we see is the _chooseDate method, which
            is marked as async and returns a Future object.
            This is because the _chooseDate method is going to be triggered when the “…” button on the
            Expiry Date field is tapped—this corresponds to an onPressed event, so the operation needs to
            be asynchronous.
            Notice the parameters being passed to the _chooseDate method. One is of type
            BuildContext, and the other of type initialDateString, which indicates an initialization date
            passed as a String object.
            The BuildContext class handles the location of the widget in Flutter’s internal widget tree. You
            can find additional information about this class here.
            In the _chooseDate method, the first thing that happens within the first two lines of code is that
            the initialDate is assigned to either the DateTime value of initialDateString, or to the
            current DateTime value, when the DateTime value of initialDateString is null.
            var now = new DateTime.now();
            var initialDate = DateUtils.convertToDate(initialDateString) ?? now;
            We need to ensure that the date-picker component doesn’t give us the possibility to choose a
            date that is in the past. Therefore, the code checks if the value of initialDate is in the future,
            or at least equal to the current date. If so, the value of initialDate is used; otherwise, the
            current date value is used, represented by the variable now. This then becomes the final value
            of the initialDate variable.
            initialDate = (initialDate.year >= now.year &&
            initialDate.isAfter(now) ? initialDate : now);
            The final value of initialDate is passed on to the showDatePicker method and assigned to
            the currentTime property of the DatePicker instance.
            The actual date assignment happens within the onConfirm event of the DatePicker instance.

            69
            www.dbooks.org


                evince -p 70 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            The onConfirm event gets triggered when a date is selected from the date-picker component
            and the Done button is tapped.
            The date parameter passed to the onConfirm event corresponds to the date chosen using the
            date-picker component.
            All the logic that follows is executed inside the setState method, which notifies the Flutter
            framework that the internal state of DocDetailState has changed.
            setState(() {
            DateTime dt = date;
            String r = DateUtils.ftDateAsStr(dt);
            expirationCtrl.text = r;
            });
            That selected date is converted to a DateTime value, formatted accordingly using the
            ftDateAsString method from the DateUtils class, and assigned to the Expiry Date field,
            which is represented by expirationCtrl.text.

            Deleting a document
            Remember the menu options array we previously created? We are now going to put it to use.
            The reason is that the application needs to give users the ability to be able to delete a
            document, in case it was entered incorrectly, or it is no longer valid (expired a long time ago).
            This option is accessed by clicking the “…” button on the top, next to the title of the document.

            Figure 3-h: The document menu

            Here is what the menu option to delete a document looks like.

            70


                evince -p 71 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 3-i: The delete document menu option

            Let’s explore the code-behind, to see what it does.
            Code Listing 3-g: Delete document code—docdetail.dart

            // Previous code…
            class DocDetailState extends State<DocDetail> {
            // Previous code
            // Upper Menu
            void _selectMenu(String value) async {
            switch (value) {
            case menuDelete:
            if (widget.doc.id == -1) {
            return;
            }
            await _deleteDoc(widget.doc.id);
            }
            }
            // Delete doc
            void _deleteDoc(int id) async {
            int r = await widget.dbh.deleteDoc(widget.doc.id);
            Navigator.pop(context, true);
            }
            // More code to follow…
            }
            If we inspect the code more closely, we can see that we have two methods, each responsible
            for an action. The _selectMenu method is invoked when the user selects the menuDelete
            option—we’ll look at that specific trigger later.
            This method invokes the _deleteDoc method when the active document on the Document
            Details screen is not empty, which means that it exists in the database—it has a corresponding
            record.

            71
            www.dbooks.org


                evince -p 72 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            When the document is new (empty), the method returns to its caller. This is what the
            widget.doc.id == -1 conditional check is for.
            The _deleteDoc method is very simple—all it does is invoke the deleteDoc method from the
            dbh (database helper) instance through the parent DocDetail stateful widget. This will remove
            the corresponding document record from the database.
            Then, the control is returned to the main screen by closing the current context (the Document
            Details screen) by calling the Navigator.pop method.
            You can find additional information about how to navigate between Flutter screens in the official
            documentation.
            Now that we know how to delete a document, let’s explore how we can save the data entered
            through the Document Details screen.

            Saving a document
            A fundamental part of the Document Details screen is the ability to save data that has been
            entered or has changed—this what the following code does.
            Code Listing 3-h: Save document code—docdetail.dart

            // Previous code…
            class DocDetailState extends State<DocDetail> {
            // Previous code
            // Save doc
            void _saveDoc() {
            widget.doc.title = titleCtrl.text;
            widget.doc.expiration = expirationCtrl.text;
            widget.doc.fqYear = Val.BoolToInt(fqYearCtrl);
            widget.doc.fqHalfYear = Val.BoolToInt(fqHalfYearCtrl);
            widget.doc.fqQuarter = Val.BoolToInt(fqQuarterCtrl);
            widget.doc.fqMonth = Val.BoolToInt(fqMonthCtrl);
            if (widget.doc.id > -1) {
            debugPrint("_update->Doc Id: " + widget.doc.id.toString());
            widget.dbh.updateDoc(widget.doc);
            Navigator.pop(context, true);
            }
            else {
            Future<int> idd = widget.dbh.getMaxId();
            idd.then((result) {
            debugPrint("_insert->Doc Id: " + widget.doc.id.toString());

            72


                evince -p 73 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            widget.doc.id = (result != null) ? result + 1 : 1;
            widget.dbh.insertDoc(widget.doc);
            Navigator.pop(context, true);
            });
            }
            }
            // More code to follow…
            }
            The first two lines of code read the values entered through titleCtrl.text and
            expirationCtrl.text fields, which correspond to the Document Name and Expiry Date
            fields seen on the screen, and assign them to their corresponding properties within the doc
            instance. This represents the object model that is stored in the database.
            The following four lines of code do the same for the alert properties. The only difference is that
            those widgets on the screen have a value of on (true) or off (false), which need to be
            converted to their integer equivalent, so they can be saved in the database. This Boolean-tointeger conversion is done by invoking the BoolToInt method from the Val class (found in
            utils.dart).
            To better understand this, let’s have a look at the following figure.

            73
            www.dbooks.org


                evince -p 74 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 3-j: The on and off alerts database values

            At this stage, we have assigned all the values to the doc instance that is going to be saved to
            the database. Next comes the most interesting part of the _saveDoc method.
            To be able to save the data correctly, we need to check if the data being entered corresponds to
            a new document or an existing one.
            If the condition (widget.doc.id > -1) evaluates to true, then we are modifying an existing
            document. Therefore, we invoke the updateDoc method from the dbh (database handler)
            instance and pass the document object model (doc) that is going to be updated.
            If the condition (widget.doc.id > -1) evaluates to false, then we are saving a new
            document to the database. Therefore, we invoke the insertDoc method from the dbh
            (database handler) instance and pass the document object model (doc) that is going to be
            inserted.
            Notice that when inserting a new document, we need to make sure that we assign a doc.id
            value that is larger than the largest doc.id value stored in the database table. Therefore, we
            invoke the getMaxId method.

            74


                evince -p 75 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Finally, to return the navigation control back to the main screen, we invoke Navigator.pop.

            Submitting the form
            We now know how we can save newly entered data, or data that has been modified from the
            Document Details screen—but how does that save action get triggered?
            Just like with HTML, Flutter has the concept of a form—and as you might have guessed, forms
            in Flutter can also be submitted. Submitting a form is what triggers the save action.
            Let’s look at the code to understand better how this works.
            Code Listing 3-i: Submitting a form code—docdetail.dart

            // Previous code…
            class DocDetailState extends State<DocDetail> {
            // Previous code
            // Submit form
            void _submitForm() {
            final FormState form = _formKey.currentState;
            if (!form.validate()) {
            showMessage('Some data is invalid. Please correct.');
            } else {
            _saveDoc();
            }
            }
            void showMessage(String message, [MaterialColor color = Colors.red]) {
            _scaffoldKey.currentState
            .showSnackBar(new SnackBar(backgroundColor: color,
            content: new Text(message)));
            }
            // More code to follow…
            }
            The _submitForm method is quite simple. First, we get the current state of the form. We do this
            by invoking _formKey.currentState and assigning that value to an instance of the FormState
            Flutter class.
            The great thing about forms in Flutter is that they are almost self-managed and keep their state,
            so to know if something has changed, all we need to do is invoke the validate method from
            the FormState instance.

            75
            www.dbooks.org


                evince -p 76 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            If the validate method returns true, it means that the field values on the form are valid and
            the data is okay to be saved, so the _saveDoc method can be invoked.
            If the validate method returns false, it means that one or more field values on the form are
            invalid and the data cannot be saved, so an alert message is displayed to the user. This is what
            the showMessage method does.
            The showMessage method displays a message—this is achieved by using a SnackBar widget,
            which we can see as follows.

            Figure 3-k: The SnackBar displayed—Invalid form data

            Now that we know how the save action gets triggered, let’s wrap this up and build the UI, which
            is what we’ll do next.

            Building the UI
            We’ve reached the last part of docdetail.dart, which is both a major milestone for us and exciting
            at the same time.
            Throughout this last part, our focus is going to be on how to build the UI and tie together all the
            previous docdetail.dart code parts we’ve written.
            Let’s start off by overriding a fundamental method of the inherited State class, which is the
            initState method.
            Code Listing 3-j: The initState method—docdetail.dart

            // Previous code…
            class DocDetailState extends State<DocDetail> {
            // Previous code
            @override
            void initState() {

            76


                evince -p 77 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            super.initState();
            _initCtrls();
            }
            // More code to follow…
            }
            The initState method is responsible for initializing the state of its class—in this case, the
            DocDetailState class. This is where we can do all initializations needed before building the UI.
            This method is described with the @override attribute, as it overrides the behavior of the
            initState method inherited from the State<DocDetail> class.
            Within the method, the inherited initState method from the State<DocDetail> class is
            called. This is done by invoking it as super.initState.
            Following that, the _initCtrls method is called, which, as you might remember, is responsible
            for initializing the values of the text controllers and alert reminder widgets.
            It’s important to note that the initState method gets triggered by the Flutter framework when
            the object is inserted into the widget tree. You can find more details about the initState
            method within the official Flutter documentation.
            With the initState method described, we are now ready to build the UI—this is done with the
            build method. The complete code of the build method for the DocDetailState class looks as
            follows.
            Code Listing 3-k: The build method—Docdetail.dart

            // Previous code…
            class DocDetailState extends State<DocDetail> {
            // Previous code
            @override
            Widget build(BuildContext context) {
            const String cStrDays = "Enter a number of days";
            TextStyle tStyle = Theme.of(context).textTheme.title;
            String ttl = widget.doc.title;
            return Scaffold(
            key: _scaffoldKey,
            resizeToAvoidBottomPadding: false,
            appBar: AppBar(
            title: Text(ttl != "" ? widget.doc.title : "New Document"),
            actions: (ttl == "") ? <Widget>[]: <Widget>[
            PopupMenuButton(

            77
            www.dbooks.org


                evince -p 78 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            onSelected: _selectMenu,
            itemBuilder: (BuildContext context) {
            return menuOptions.map((String choice) {
            return PopupMenuItem<String>(
            value: choice,
            child: Text(choice),
            );
            }).toList();
            },
            ),
            ]
            ),
            body: Form(
            key: _formKey,
            autovalidate: true,
            child: SafeArea(
            top: false,
            bottom: false,
            child: ListView(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            children: <Widget>[
            TextFormField (
            inputFormatters: [
            WhitelistingTextInputFormatter(
            RegExp("[a-zA-Z0-9 ]"))
            ],
            controller: titleCtrl,
            style: tStyle,
            validator: (val) => Val.ValidateTitle(val),
            decoration: InputDecoration(
            icon: const Icon(Icons.title),
            hintText: 'Enter the document name',
            labelText: 'Document Name',
            ),
            ),
            Row(children: <Widget>[
            Expanded(
            child: TextFormField(
            controller: expirationCtrl,
            maxLength: 10,
            decoration: InputDecoration(
            icon: const Icon(Icons.calendar_today),
            hintText: 'Expiry date (i.e. ' +
            DateUtils.daysAheadAsStr(daysAhead) + ')',
            labelText: 'Expiry Date'
            ),
            keyboardType: TextInputType.number,
            validator: (val) => DateUtils.isValidDate(val)
            ? null : 'Not a valid future date',

            78


                evince -p 79 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            )),
            IconButton(
            icon: new Icon(Icons.more_horiz),
            tooltip: 'Choose date',
            onPressed: (() {
            _chooseDate(context, expirationCtrl.text);
            }),
            )
            ]),
            Row(children: <Widget>[
            Expanded(child: Text(' ')),
            ]),
            Row(children: <Widget>[
            Expanded(child: Text('a: Alert @ 1.5 & 1 year(s)')),
            Switch(
            value: fqYearCtrl, onChanged: (bool value) {
            setState(() {
            fqYearCtrl = value;
            });
            }),
            ]),
            Row(children: <Widget>[
            Expanded(child: Text('b: Alert @ 6 months')),
            Switch(
            value: fqHalfYearCtrl, onChanged: (bool value) {
            setState(() {
            fqHalfYearCtrl = value;
            });
            }),
            ]),
            Row(children: <Widget>[
            Expanded(child: Text('c: Alert @ 3 months')),
            Switch(
            value: fqQuarterCtrl, onChanged: (bool value) {
            setState(() {
            fqQuarterCtrl = value;
            });
            }),
            ]),
            Row(children: <Widget>[
            Expanded(child: Text('d: Alert @ 1 month or less')),
            Switch(
            value: fqMonthCtrl, onChanged: (bool value) {
            setState(() {
            fqMonthCtrl = value;
            });
            }),
            ]),
            Container(

            79
            www.dbooks.org


                evince -p 80 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            padding: const EdgeInsets.only(
            left: 40.0, top: 20.0),
            child: RaisedButton(
            child: Text("Save"),
            onPressed: _submitForm,
            )
            ),
            ],
            ),
            )));
            }
            }
            The build method is what builds the UI—in this case, the UI of the Document Details window.
            That’s quite a bit of code, so to understand how the UI has been built using this method, it’s best
            to break the code into smaller chunks to describe how each individual part is composed. Let’s
            start from the top.
            The first thing to notice is that the build method has the @override attribute, which means that
            its logic will override any logic from the build method inherited from State<DocDetail>.
            Next, notice how the build method returns a type of Widget, which describes the configuration
            for an Element. You can find more details about the Widget class in the official documentation.
            Because the build method is going to return a Widget, it’s necessary to handle the location of
            the widget returned within the widget tree. Therefore, the BuildContext class is passed as a
            parameter.
            Next, let’s explore the following three lines, which correspond to internal initializations.
            const String cStrDays = "Enter a number of days";
            TextStyle tStyle = Theme.of(context).textTheme.title;
            String ttl = widget.doc.title;
            The first instruction declares and initializes a String object constant that is totally selfdescriptive.
            The second instruction basically initializes the TextStyle instance that will be used for this UI.
            You can find more details about text styling in Flutter in the official documentation.
            The third instruction, also self-descriptive, simply initializes the ttl variable with the value of the
            document title, accessible through widget.doc.title.

            80


                evince -p 81 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Scaffold
            With all the initializations ready, now comes the interesting part: the build method returns a
            Scaffold object, which implements a basic Material Design visual layout structure.
            You can think of the Scaffold object as a layout container that will contain the widgets
            displayed on the screen. The Scaffold object has two essential properties: appBar and body.
            The Scaffold object also has two other properties that are quite important: key and
            resizeToAvoidBottomPadding.
            The key property is assigned to the _scaffoldKey property, which is used for tracking the state
            of the Scaffold.
            The resizeToAvoidBottomPadding property is used to indicate whether the body or floating
            widgets should size themselves to avoid the window’s bottom padding.

            AppBar
            The appBar represents the uppermost area of the layout that includes the title and any menu
            options. The body represents the rest of the useable screen area, which contains all the other
            fields, such as the Document Name, Expiry Date, and the various alert reminders.
            The appBar section of the code is quite easy to understand without looking at a diagram, but the
            body section is more elaborate. To understand how the different parts of the screen are
            composed, it’s easier to associate the code with a diagram—which we’ll look at shortly.
            The appBar section is made of an AppBar Material Design-based Flutter object, which has
            title and actions properties.
            The actions property, which is a Widget array, represents possible menu options that the
            widget can have—in our case, the Delete option.
            In our case, we are doing something unconventional with the actions property—we are using a
            ternary conditional expression (?) and assigning an empty Widget array (Widget[]) if the
            title variable (ttl) contains an empty String value.
            An empty ttl indicates that we are working on a new document and are not editing an existing
            document. For a new document, there is no need to have a Delete option, as obviously there’s
            nothing to delete—the document hasn’t been created yet.
            For an existing document that is already present in the database, it is then logical to have the
            Delete menu option available, as we can then opt to remove the document from the database if
            we don’t need the document any longer, if its data is incorrect, or if it has expired.

            81
            www.dbooks.org


                evince -p 82 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            So, when ttl is not empty (the document exists in the database), we assign to the appBar
            property a Widget array (Widget[]), which contains a PopupMenuButton object that is
            responsible for building the Delete menu-option widget.
            The PopupMenuButton has two properties that are being used: the onSelected property, which
            is assigned to the _selectMenu method that we previously wrote, and itemBuilder, which is
            responsible for building the menu options and adding them to the appBar.

            Figure 3-l: The appBar actions property

            From the preceding diagram, we can see that the actual menu is built by converting the result of
            executing the menuOptions.map method to a list using the toList method.
            We can also see how each section of the actions property relates to what is seen on the
            screen when a new document is added, or an existing document is being edited.
            So, itemBuilder is assigned to an anonymous function, which receives a BuildContext
            parameter and returns a mapped list of items contained within the menuOptions array we
            previously declared. Each individual menu option is an instance of PopupMenuItem.

            Body
            Let’s now focus on the most extensive part of the Scaffold object, which is the body property.
            Given that the body code is quite long, we’ll have to break it down into chunks. To understand
            this better, let’s start off by looking at the following diagram.

            82


                evince -p 83 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 3-m: The main body section parts

            We can see that the body is nothing more than a Flutter Form, which includes a SafeArea
            object as a child, which includes a ListView.
            The reason for this nested layout is that we want to be able to have a list of widgets arranged
            one below the other. This is why we are using a ListView and have enough padding to avoid
            any visual intrusions from the device’s operating system—which is why we are using a
            SafeArea as the child of the Form.
            Notice that the key property of the Form object is assigned to the _formKey method that we
            previously wrote. The autovalidate property is set to true, which means that validation takes
            place when the form is submitted.
            With this well-organized, top-level layout, we have a good foundation on which to render and
            organize the rest of the widgets that are seen on the screen.

            Document Name and Expiry Date
            Given that the ListView object will contain all the widgets seen on the screen, let’s now explore
            how the ListView code is organized in more detail, by looking at the following diagram—this
            explains how the first two fields are composed.

            83
            www.dbooks.org


                evince -p 84 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 3-n: The first two data-entry widgets—Document Details screen

            We can see that the first widget within the ListView is the text input for the Document Name
            field.

            Document Name field
            This field is of type TextFormField, and it is basically a FormField that contains a TextField
            object.
            The TextFormField contains an inputFormatters array that includes a regular expression
            that specifies which characters can be typed within the field—these are assigned to the
            WhiteListingTextInputFormatter property.
            The controller property is used for indicating that this TextFormField binds to the
            titleCtrl variable (which is a TextEditingController).
            The validator property is used for running field validations; here the Val.ValidateTitle
            method is executed when the value of the field has changed.
            The decoration property, as its name implies, basically sets the icon, hint (hintText), and
            label text (labelText) messages that are seen on the screen.
            That wraps up the Document Name field—let’s now talk about the field that follows, the Expiry
            Date.

            Expiry Date field
            The Expiry Date field is slightly more complex, as it renders as a TextFormField contained
            within an Expanded object, which is part of a Row object.

            84


                evince -p 85 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            The reason for this composition is that the Row object also contains an IconButton object,
            which is used for displaying the Cupertino (iOS-styled) Date Picker widget that was previously
            explained.
            To get a better understanding of how the Expiry Date field is composed, let’s look at the
            following diagram.

            Figure 3-o: The Expiry Date field—Document Details screen

            You can clearly see that the Expanded widget corresponds to the area where the text can be
            manually entered.
            The decoration and validator properties of TextFormField work the same way as the
            Document Name field.
            Notice though, how TextFormField binds to the expirationCtrl variable, and the maximum
            number of characters that can be entered is set to 10—the maxLength property.
            For the Expiry Date, the DateUtils.isValidDate method gets triggered when the field value
            changes and checks if the expiration date is a future date or not.
            As for the IconButton object, you can clearly see in the diagram that its icon property renders
            the “…” button, and the onPressed event triggers the execution of the _chooseDate method,
            which we previously explored, and runs the iOS-styled Date Picker widget.
            With the main two fields explored, let’s move on to the alert fields of the form.

            Alert fields
            The way the alert fields are composed is almost the same for each one of them—the only
            difference is the text displayed on the screen and the variables to which they bind.

            85
            www.dbooks.org


                evince -p 86 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Let’s explore each one. Each alert field is composed within a Row object.
            I have intentionally left an empty Row object before the first alert field—this is to give enough
            space on the screen between the Expiry Date field and the first alert field. We can see this as
            follows.

            Figure 3-p: The empty row and first alert field—Document Details screen

            Let’s explore the details of how a Row object is composed. We can see that the empty Row
            object contains a children property, assigned to an Expanded object. The Expanded object
            has a child property that is assigned to a Text object containing an empty String value.
            As for the non-empty Row object, we can clearly see that the Expanded object contains a Text
            child object with the caption that is displayed on the screen.
            The Switch widget is used to toggle the on/off state of a single setting. The Switch widget is
            bound to the fqYearCtrl variable, which indicates that an alert would get triggered when
            there’s one year remaining for the document to expire.
            The Switch widget includes an onChanged event that gets triggered when its value changes
            (goes from on to off, or vice versa). When its value changes, the setState function is executed
            and notifies Flutter that the internal state of the object has changed; the changed value is
            assigned to fqYearCtrl.
            As for the other alerts seen on the screen (6 months, 3 months, and 1 month or less), the
            code is the same as this one. The only difference is that each binds to a different variable—to
            fqHalfYearCtrl, fqQuarterCtrl, and fqMonthCtrl, respectively.

            86


                evince -p 87 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 3-q: Last alert field—Document Details screen

            That wraps up the alert fields—let’s now finalize the form by exploring the Save button.

            Save button
            The Save button is the last part of the form that makes the Document Details screen. Let’s
            explore how it is composed—to wrap up the Docdetail.dart code.

            Figure 3-r: Save button—Document Details screen

            As we can see, the Save button itself is wrapped around a Container widget. It helps combine
            common painting, positioning, and decoration of child widgets with padding.
            The button is assigned to the child property of the Container widget, and it is a RaisedButton
            widget. The _submitForm event gets executed when the onPressed event occurs.

            87
            www.dbooks.org


                evince -p 88 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Summary
            This has been a long and challenging chapter, so if you’ve read this far—congrats! It’s quite
            interesting what we’ve been able to achieve so far with Flutter, with a relatively little amount of
            code.
            When I say it’s not that much code, we necessarily must praise the awesome framework that
            the engineers at Google have created, which is Flutter.
            As we’ve been able to see, the syntax feels familiar for any developer coming from a C or Java
            family-based language, and the constructs are easy to grasp and follow.
            Something I really enjoy about Flutter is that the UI can be written within Dart without the need
            to use a markup language.
            Normally, this is contrary to what most frameworks do, but with Flutter, it feels natural and
            enjoyable to create the UI using Dart code—which to me, was a very pleasant surprise.
            We’re almost at the end of our application, but we’ve got one final hurdle to overcome: creating
            the main screen and the logic behind it, which we will do in the next chapter.

            88


                evince -p 89 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Chapter 4 App UI—Main Screen
            Quick intro
            We’re just one step away from finishing our Flutter application, which I’m excited about and
            looking forward to accomplishing. In this final step, we need to create the main screen of our
            application. This screen will display the list of documents and allow the user to add new ones.
            This is how the finished screen will look.

            Figure 4-a: The main application screen

            The code for the app’s main screen will reside within the doclist.dart file, which you can create
            under the lib\ui subfolder of your app’s main project folder.

            89
            www.dbooks.org


                evince -p 90 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Getting started: main menu option
            Just like we have a menu option on the Document Details screen—which allows us to delete an
            existing document—we need to have the option to remove all documents from the list and
            delete them from the database. This is known as Reset Local Data.
            To add this option, we need to define a menuOptions array, just like we did with the details
            screen.
            Before doing that, let’s go ahead and reference all the modules and packages we’ll need.
            Code Listing 4-a: Creating the main menu—Doclist.dart

            import 'dart:async';
            import 'package:flutter/material.dart';
            import
            import
            import
            import

            '../model/model.dart';
            '../util/dbhelper.dart';
            '../util/utils.dart';
            './docdetail.dart';

            // Menu item
            const menuReset = "Reset Local Data";
            List<String> menuOptions = const <String> [
            menuReset
            ];
            In the first two lines of code, we import the Dart async package and the Material Design
            package that comes with the Flutter framework, which contains the UI widgets our application
            will use.
            Next, we import the other project modules we created previously—this is because we’ll need to
            reference various classes declared within those modules.
            Finally, we create menuOptions as a generic List collection (created from an array), which
            includes only the menuReset option.

            Main stateful widget
            Just like we did within Docdetail.dart, we are ready to create the base widget that will be used
            within the app’s main screen. This is going to be a stateful widget, which will describe the main
            screen’s user interface.
            As mentioned previously, a stateful widget has a state that can change, which is useful when
            parts of the user interface that are being rendered can change dynamically, given that the items
            on the list within the main screen can vary.

            90


                evince -p 91 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Let’s define the stateful widget that we will use for rendering the UI of the main screen.
            Code Listing 4-b: Stateful widget—main screen

            // Previous code…
            class DocList extends StatefulWidget {
            @override
            State<StatefulWidget> createState() => DocListState();
            }
            As we can see, it’s very simple—all we do is override the createState method, which will
            create an instance of the DocListState class.
            The DocListState class is where we are going to have the logic that creates and manipulates
            the main screen’s UI. Let’s explore that now.
            Code Listing 4-c: Stateful widget—main screen

            // Previous code…
            class DocListState extends State<DocList> {
            DbHelper dbh = DbHelper();
            List<Doc> docs;
            int count = 0;
            DateTime cDate;
            // More code to follow...
            }
            The DocListState class will not only be responsible for creating the main screen’s UI, but also
            for handling its state.
            To be able to do that, it’s important to keep track of a few things, such as the list of documents,
            represented by docs; the number of documents, represented by count; a reference to the
            database, represented by dbh; and the current datetime, represented by cDate.
            Now that we know which variables are going to keep track of the main screen’s state, let’s now
            initialize it. We can do this as follows.
            Code Listing 4-d: State initialization—main screen

            // Previous code…
            class DocListState extends State<DocList> {
            // Previous code
            @override

            91
            www.dbooks.org


                evince -p 92 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            void initState() {
            super.initState();
            }
            }
            All we are doing is overriding the implementation of the initState method, and within it,
            invoking the initState method from the inherited State<DocList> class.
            Awesome—we now have the foundation of our DocListState class laid out. Let’s move on to a
            more interesting aspect, which is retrieving the data needed to populate the list of documents.

            Getting a list of documents
            Possibly the most important aspect of the application—at least from a usage point of view—is
            retrieving the data needed to display the list of documents to expire or that have expired.
            Let’s explore the full code of the method that makes this happen.
            Code Listing 4-e: Retrieving the data—main screen

            // Previous code…
            class DocListState extends State<DocList> {
            // Previous code
            Future getData() async {
            final dbFuture = dbh.initializeDb();
            dbFuture.then(
            // result here is the actual reference to the database object.
            (result) {
            final docsFuture = dbh.getDocs();
            docsFuture.then(
            // result here is the list of docs in the database.
            (result) {
            if (result.length >= 0) {
            List<Doc> docList = List<Doc>();
            var count = result.length;
            for (int i = 0; i <= count - 1; i++) {
            docList.add(Doc.fromOject(result[i]));
            }
            setState(() {
            if (this.docs.length > 0) {
            this.docs.clear();
            }
            this.docs = docList;

            92


                evince -p 93 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            this.count = count;
            });
            }
            });
            });
            }
            }
            What is going on here? The first important aspect to consider is that the getData method is
            async (runs asynchronously), and it returns a Future object, which is the preferred way of
            handling data requests. This is done to avoid blocking the application when performing a
            computation that might be delayed.
            For those familiar with JavaScript web development, think of a Future as a construct very
            similar to a Promise.
            The first instruction within getData is to call the initializeDb method from the database
            helper class. This ensures that the connection with the database is established.
            final dbFuture = dbh.initializeDb();
            When the connection to the database is established, the then method of the Future object
            returned is executed.
            dbFuture.then(…)
            The result of that database connection is passed as a parameter—(result)— to an
            anonymous function that is executed within the scope of the then method of the Future object
            returned—dbFuture.
            (result) {…}
            Within this anonymous method scope, the next thing we do is retrieve the list of documents from
            the database—this is done by invoking the getDocs method, which also returns a Future
            object.
            final docsFuture = dbh.getDocs();
            When the retrieval of the list of documents has been finalized, the then method of the Future
            object returned is executed.
            docsFuture.then(…)
            The result of that action—(result)—is the list of documents, which is passed as a parameter
            to an anonymous function that is executed within the scope of the then method of the Future
            object returned—docsFuture.

            93
            www.dbooks.org


                evince -p 94 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            (result) {…}
            Within that anonymous function scope, we first check the length of the result returned, which
            indicates the number of documents in the database.
            if (result.length >= 0) {…}
            We then create a list of documents using the Doc class, which we will use to populate with the
            document data retrieved from the database.
            List<Doc> docList = List<Doc>();
            We also initialize the count variable to the value of result.length, which indicates how many
            documents were retrieved from the database.
            var count = result.length;
            Then, we loop through the result object obtained from the database—where each iteration
            represents a database row—and then convert each row into a Doc object, which we add to
            docList.
            for (int i = 0; i <= count - 1; i++) {
            docList.add(Doc.fromOject(result[i]));
            }
            With the database rows converted to a List<Doc> object, we need to change the state of our
            DocListState class so that the UI can be rendered. We do this by calling the setState
            method.
            setState(() {…} )
            Within setState, the first thing we do is empty the contents of this.docs, which is one of the
            variables we declared at the beginning of the DocListState class.
            if (this.docs.length > 0) {
            this.docs.clear();
            }
            Then, to this.count—which was also declared at the beginning of the DocListState class—
            we assign the value of count, obtained from result.length.
            this.docs = docList;
            this.count = count;

            94


                evince -p 95 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            As you can see, the logic behind getData is quite simple and easy to follow once you
            understand the concept of Future objects in Dart, and how results are returned.

            Checking dates
            Another intrinsic aspect of our application is checking dates, which is important because the
            goal of the app is to help us keep track of important documents before they expire.
            Let’s have a look at the following function, which periodically checks for date and time
            discrepancies, and if there are any (for example, the phone’s date-time is different the current
            date-time), executes the getDate method.
            This way, we can have the latest document data and expiration dates. Here is the function’s
            code.
            Code Listing 4-f: Check date—main screen

            // Previous code…
            class DocListState extends State<DocList> {
            // Previous code
            void _checkDate() {
            const secs = const Duration(seconds:10);
            new Timer.periodic(secs, (Timer t) {
            DateTime nw = DateTime.now();
            if (cDate.day != nw.day || cDate.month != nw.month ||
            cDate.year != nw.year) {
            getData();
            cDate = DateTime.now();
            }
            });
            }
            // More code will follow…
            }
            As we can see, the code is quite straightforward. It creates a Timer object that executes every
            10 seconds. The timer’s execution is performed by invoking the periodic method. Within this
            method, the cDate object represents the date-time from the moment the main screen widget
            was created (first rendered), and the current date-time is represented by the nw object.
            If there’s a difference between the day, month, or year of both DateTime objects, then the
            getData method is invoked.

            95
            www.dbooks.org


                evince -p 96 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Normally there shouldn’t be a difference between the day, month, or year of when the main
            screen widget was rendered (cDate) and the date-time of the nw object. This is because shortly
            after the screen is rendered, the current date-time should be calculated, and its value assigned
            to nw.
            However, there might be cases where the app runs for the first time on a phone that has the
            wrong date-time settings, and this would result in a wrong computation of the expiry dates for
            each document. So, the execution of the _checkDate function—after the phone date-time
            settings have been adjusted—would force a correct computation of the expiry date for each
            document.

            Navigating to the document details
            Given that the app’s main screen contains a list of the documents that are in the database, if we
            would like to edit or delete a specific document, we would need to navigate to it. To do this, we
            need to define a navigateToDetail method. Let’s see how it looks.
            Code Listing 4-g: Navigating to a document—main screen

            // Previous code…
            class DocListState extends State<DocList> {
            // Previous code
            void navigateToDetail(Doc doc) async {
            bool r = await Navigator.push(context,
            MaterialPageRoute(builder: (context) => DocDetail(doc))
            );
            if (r == true) {
            getData();
            }
            }
            // More code will follow…
            }
            The navigation works by displaying the details of the document tapped from the document list.
            This is achieved by using the Navigator.push method and passing a DocDetail instance of the
            document selected.
            If the result (r) of the push method is true—which means that the document has been
            modified—then the getData method is called to retrieve the latest document information from
            the database.

            96


                evince -p 97 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Resetting the local data
            Given that we want to have the option to delete all the data stored by the app, we need to add
            some code that will remove any data stored locally.
            Before any removal operations take place, we need to be able ask the user for confirmation,
            and if it is confirmed, then we can remove the data stored in the database. Let’s have a look at
            the code.
            Code Listing 4-h: Resetting the local data—main screen

            class DocListState extends State<DocList> {
            // Previous code
            void _showResetDialog() {
            showDialog(
            context: context,
            builder: (BuildContext context) {
            return AlertDialog(
            title: new Text("Reset"),
            content: new Text("Do you want to delete all local data?"),
            actions: <Widget>[
            FlatButton(
            child: new Text("Cancel"),
            onPressed: () {
            Navigator.of(context).pop();
            },
            ),
            FlatButton(
            child: new Text("OK"),

            97
            www.dbooks.org


                evince -p 98 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            onPressed: () {
            Future f = _resetLocalData();
            f.then(
            (result) {
            Navigator.of(context).pop();
            }
            );
            },
            ),
            ],
            );
            },
            );
            }

            // More code will follow…
            }

            Let’s have a look at what we are doing here. The _showResetDialog simply invokes the Flutter
            showDialog method.
            The builder property of the showDialog method is assigned to an anonymous method, which
            receives a BuildContext parameter and returns an AlertDialog instance.
            The AlertDialog object contains title, content, and actions properties. The title and
            content properties are self-explanatory, but the really interesting part is what happens within
            the actions property.

            98


                evince -p 99 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            The actions property is assigned to an array of type Widget, which contains two FlatButton
            objects. The first button represents the Cancel option, and the second one (OK) represents the
            reset data option.
            Both buttons have a child property that contains the Text object displayed on each. They also
            contain an onPressed event that triggers specific functionality.
            In the case of the Cancel button, the onPressed event executes code that returns the focus to
            the app’s main screen. This is done by invoking the pop method.
            As for the OK button, the onPressed event makes a call to the _resetLocalData method—
            which is responsible for removing the data from the database—and then returns the control to
            the app’s main screen, which is also done by invoking the pop method.
            Let’s have a look at the logic behind the _resetLocalData method.
            Code Listing 4-i: Resetting the local data (2)—main screen

            // Previous code…
            class DocListState extends State<DocList> {
            // Previous code
            Future _resetLocalData() async {
            final dbFuture = dbh.initializeDb();
            dbFuture.then(
            (result) {
            final dDocs = dbh.deleteRows(DbHelper.tblDocs);
            dDocs.then(
            (result) {
            setState(() {
            this.docs.clear();
            this.count = 0;
            });
            }
            );
            }
            );
            }
            // More code will follow…
            }
            A call is made to the initializeDb method, which establishes the connection to the database.
            When the connection is established, and within the anonymous function invoked within the then
            method of dbFuture, the deleteRows method is called, which is responsible for deleting the
            rows on the database.

            99
            www.dbooks.org


                evince -p 100 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            The setState function is called to reset the list of documents—this.docs—and set the
            number of documents to zero—this.count.

            Selecting the menu option
            Now that we’ve seen how we can reset the information stored in the database, let’s check how
            we can trigger this functionality manually by selecting the menu option associated with it. Here’s
            the code.
            Code Listing 4-j: Selecting the menu option—main screen

            // Previous code…
            class DocListState extends State<DocList> {
            // Previous code
            void _selectMenu(String value) async {
            switch (value) {
            case menuReset:
            _showResetDialog();
            }
            }
            // More code will follow…
            }
            We have a _selectMenu method that includes a switch statement with a condition when the
            menuReset option has been selected. When that happens, the _showResetDialog method is
            invoked—super simple.
            I decided to use a switch statement because if later there’s a need to add additional menu
            options, all that would be required would be to add additional case expressions to it.

            Building the list of documents
            We are now reaching one of the most interesting, useful, and important parts of our application:
            building the list of documents that are presented on the app’s main screen. Let’s look at the
            complete code for this and dissect it, piece by piece.
            Code Listing 4-k: Creating the list of documents—main screen

            // Previous code…
            class DocListState extends State<DocList> {
            // Previous code

            100


                evince -p 101 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            ListView docListItems() {
            return ListView.builder(
            itemCount: count,
            itemBuilder: (BuildContext context, int position) {
            String dd = Val.GetExpiryStr(this.docs[position].expiration);
            String dl = (dd != "1") ? " days left" : " day left";
            return Card(
            color: Colors.white,
            elevation: 1.0,
            child: ListTile(
            leading: CircleAvatar(
            backgroundColor:
            (Val.GetExpiryStr(this.docs[position].expiration) != "0") ?
            Colors.blue : Colors.red,
            child: Text(
            this.docs[position].id.toString(),
            ),
            ),
            title: Text(this.docs[position].title),
            subtitle: Text(
            Val.GetExpiryStr(this.docs[position].expiration) + dl +
            "\nExp: " + DateUtils.convertToDateFull(
            this.docs[position].expiration)),
            onTap: () {
            navigateToDetail(this.docs[position]);
            },
            ),
            );
            },
            );
            }
            // More code will follow…
            }
            To understand this better, let’s go over each part of the code. The first thing that is being done
            within the docListItems method is a returning of a ListView object that will contain the list of
            documents that the app is going to display.
            To create that list, we need to call the ListView.builder method, which has two important
            properties: itemCount and itemBuilder.
            The itemCount property indicates how many documents are going to be added to the list—
            notice how we are assigning the value of the count variable that was retrieved from the
            database.
            The itemBuilder property is the one used to build the document list; this is achieved with an
            anonymous function that receives a BuildContext object as one of its parameters.

            101
            www.dbooks.org


                evince -p 102 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Let’s explore the content of the anonymous function assigned to the itemBuilder property—
            this is where things get interesting.
            On the first two lines of the anonymous function, all we are doing is getting the expiry date of
            each document as a String—this is done by invoking the GetExpiryStr function—and then
            determining the remaining days left (that will be displayed on the screen).
            String dd = Val.GetExpiryStr(this.docs[position].expiration);
            String dl = (dd != "1") ? " days left" : " day left";
            Notice that the parameter position indicates the current document being added to the list.
            With the remaining days determined, the next thing we do is return a Card object, which will
            contain the document details. Each document is displayed within its own Card object.
            To understand better the composition of the Card object, let’s look at the following diagram.

            Figure 4-b: Card objects within the document list

            The first two properties of the Card object are self-descriptive. The first indicates the color
            used for the background of the Card, in this case white.
            The second indicates whether the Card object has a slight visual elevation with respect to the
            document list, which is seen as a thin, gray line below each Card object.
            The third property of the Card object is its child property, to which we assign a ListTile object.
            So basically, the actual content of the Card object is determined by a ListTile object.

            102


                evince -p 103 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            The ListTile object contains a CircleAvatar object that is red when the document has expired,
            and blue when the document has not expired. The backgroundColor of the CircleAvatar
            object is determined by the following ternary conditional expression.
            (Val.GetExpiryStr(this.docs[position].expiration) != "0") ?
            Colors.blue : Colors.red
            The Text (number) contained within the CircleAvatar object indicates the position (order) of
            the document within the database.
            Next, within the ListTile property we have the title property, which indicates the name of
            the document.
            Following that, there’s the subtitle property, which displays the remaining days a document
            before it expires.
            Text(Val.GetExpiryStr(this.docs[position].expiration) + dl +
            "\nExp: " + DateUtils.convertToDateFull(
            this.docs[position].expiration))
            Finally, the ListTile object has an event that gets triggered when a user taps on the
            document, the onTap event, which basically invokes the navigateToDetail method. This
            method opens the details of the document selected, which can then be edited.
            onTap: () {
            navigateToDetail(this.docs[position]);
            }

            Finalizing the main screen
            The biggest chunk of our main screen, the document list, is finished. However, we still need to
            wrap that document list around the main Scaffold object that will hold it, and then Stack it
            properly so that it displays correctly during runtime (both in portrait and landscape modes).
            We’ll also need to add an AppBar object and link our menu option to it. Let’s go ahead and do
            all this.
            Code Listing 4-l: Finishing the main screen

            // Previous code…

            103
            www.dbooks.org


                evince -p 104 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            class DocListState extends State<DocList> {
            // Previous code
            @override
            Widget build(BuildContext context) {
            this.cDate = DateTime.now();
            if (this.docs == null) {
            this.docs = List<Doc>();
            getData();
            }
            _checkDate();
            return Scaffold(
            resizeToAvoidBottomPadding: false,
            appBar: AppBar(
            title: Text("DocExpire"),
            actions: <Widget>[
            PopupMenuButton(
            onSelected: _selectMenu,
            itemBuilder: (BuildContext context) {
            return menuOptions.map((String choice) {
            return PopupMenuItem<String>(
            value: choice,
            child: Text(choice),
            );
            }).toList();
            },
            ),
            ]
            ),
            body: Center(
            child: Scaffold(
            body: Stack(
            children: <Widget>[
            docListItems(),
            ]),
            floatingActionButton: FloatingActionButton(
            onPressed: () {
            navigateToDetail(Doc.withId(-1, "", "", 1, 1, 1, 1));
            },
            tooltip: "Add new doc",
            child: Icon(Icons.add),
            ),
            ),
            ),
            );
            }

            104


                evince -p 105 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            }
            Just like we did with the Document Details screen, to render its content we need to override
            the build method inherited from the DocListState class. Let’s explore each part of the build
            method so we can understand exactly what it does.
            The first thing that happens within the build method is that we get the current date-time, which
            will represent the date-time when the main screen is rendered. This value is stored within the
            cDate variable we previously explained.
            Next, if the document list doesn’t exist yet—which means that no documents have ever been
            retrieved—then the list of documents is initialized, and a call to the getData method is made to
            check whether there are any documents within the database.
            if (this.docs == null) {
            this.docs = List<Doc>();
            getData();
            }
            Following that, we invoke the _checkDate method. This is to check that the current date-time is
            aligned with the date-time the screen was rendered, checking that the amount of days left for
            each document is accurate.
            Then, the build method returns a Scaffold object, which will render the main screen. The
            Scaffold object has two main properties that take most of the logic of the build method code:
            the appBar and the body.
            The appBar property is assigned to an AppBar object, which basically constitutes the
            application’s top navigation bar, including the app’s name and the menu option. To understand it
            better, let’s look at the following diagram.

            Figure 4-c: The main screen’s AppBar

            105
            www.dbooks.org


                evince -p 106 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            As we can see, the actions property of the AppBar object is nothing more than an array of type
            Widget, which includes a PopupMenuButton object.
            The PopupMenuButton object contains an onSelected property that is assigned to the
            _selectMenu method, which opens the Reset Local Data option.
            The menu itself is built by an anonymous function that is assigned to the itemBuilder property
            and returns a menuOptions array object as a list, with each menu item being a PopMenuItem
            object (in our case, there’s only one menu option).
            By doing it this way, we could expand the application later and add extra menu options to the
            menuOptions array without having to modify any of the rendering functionality.
            To better understand its composition of the body property, let’s have a look at the following
            diagram.

            Figure 4-d: The main screen’s body

            We can see that the Scaffold object contains the document list and a floating button. The
            Scaffold object is wrapped within a Center object, so that all the content is properly centered in
            any rotation that the device is used.
            The document list generated by the docListItems method is wrapped around a Stack widget,
            which is done to ensure that the list of documents is positioned correctly relative to the edges of
            its surrounding box.
            The floating button used to create a new document is created by the FloatingActionButton
            object—assigned to the floatingActionButton property—and it contains an Icon object, a
            tooltip property, and an onPressed event. This event calls the navigateToDetail method
            that displays an empty Document Details screen when creating a new document.

            106


                evince -p 107 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            That wraps up the app’s main screen. If you recall, the main screen (represented by the
            DocList class) is invoked within main.dart.
            If you have followed all the steps described, you should now be able to run the application from
            Android Studio (don’t forget to select an emulator device).
            A minute later (sometimes Android Studio takes a minute or so to resolve and update all the
            required dependencies), you’ll be able to see the app running with no documents in it.

            Figure 4-e: The finished app running (clean database)

            The first time it runs, the app shows no documents because the database is empty, and just
            newly created. You should now be able to add your own documents.
            I’m going to add a new test document with the following data. Let’s have a look.

            107
            www.dbooks.org


                evince -p 108 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 4-f: A new document

            If we click Save, the document will appear on the app’s main screen—we can see this in the
            following figure.

            Figure 4-g: The new cocument zdded

            Awesome—it’s working as expected. Now, let’s try the Reset Local Data menu option to see if
            the database is cleared.

            Figure 4-h: The reset cata option

            If we tap on the Reset Local Data menu option, we should see the following dialog box.

            108


                evince -p 109 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Figure 4-i: Confirming the reset data option

            If we now tap OK, the contents of the database should be deleted and the document list should
            appear empty. Let’s see if that’s the case.

            Figure 4-j: An empty document list

            Awesome—the Reset Local Data menu option worked, and we have a fully working application.
            You can find the full source code and Android Studio project for this application on the
            Syncfusion GitHub repository that comes along with this book. Alternatively, you may also get
            the full source code files here.

            Summary
            We’ve now explored the Flutter framework and built this cool application together—and although
            we’ve reached the end of the book, this is hopefully just the beginning of your journey with
            Flutter.
            Going forward, I encourage you to expand the capabilities of this application and, if I may, I’d
            like to suggest you add a cool feature to this application that I couldn’t cover in this book. That’s

            109
            www.dbooks.org


                evince -p 110 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            the ability to have a mechanism in place that allows the app to keep multiple document lists,
            each associated with an email address, which can be synced to the cloud (i.e. using Google’s
            Cloud Firestore database).
            Say, for instance, that I’d like to keep a list of documents for myself, but I’d also like to keep a
            list of documents for my wife—with documents that are relevant to her.
            If the app would give me the option to store two lists, each one associated with a different user
            (email address), I could keep track of multiple document lists and have them synced to the
            cloud in case my phone gets lost, damaged, or stolen.
            This would also give me the capability of installing the app on a new phone, and being able to
            retrieve those document lists by using the username (email address) each was saved with—
            wouldn’t that be cool?
            Also, why not add the alerting mechanism for which we built the UI—this would also be
            something very useful.
            So, there you go—a interesting challenge and problem to solve, which can be used to expand
            the code that has already been written for this application.
            Before you go, don’t forget to check the Appendix, where you can find the finished source code
            of each Dart file of the application.
            I’m keen to see what you will build. Until next time, have fun with Flutter. Thanks so much for
            reading!

            110


                evince -p 111 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Appendix—Full Code
            Full main.dart code
            Here’s the complete finished source code for our app’s main.dart file.
            Code Listing Appendix-a: Finished main.dart

            import 'package:flutter/material.dart';
            import './ui/doclist.dart';
            void main() => runApp(DocExpiryApp());
            class DocExpiryApp extends StatelessWidget
            {
            @override
            Widget build(BuildContext context) {
            return MaterialApp(
            debugShowCheckedModeBanner: false,
            title: 'DocExpire',
            theme: new ThemeData(
            primarySwatch: Colors.indigo,
            ),
            home: DocList(),
            );
            }
            }

            Full utils.dart code
            Here’s the complete finished source code for our app’s utils.dart file.
            Code Listing Appendix-b: Finished utils.dart

            import 'package:intl/intl.dart';
            class Val {
            // Validations
            static String ValidateTitle(String val) {
            return (val != null && val != "") ? null : "Title cannot be empty";
            }
            static String GetExpiryStr(String expires) {
            var e = DateUtils.convertToDate(expires);
            var td = new DateTime.now();

            111
            www.dbooks.org


                evince -p 112 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Duration dif = e.difference(td);
            int dd = dif.inDays + 1;
            return (dd > 0) ? dd.toString() : "0";
            }
            static bool StrToBool(String str) {
            return (int.parse(str) > 0) ? true : false;
            }
            static bool IntToBool(int val) {
            return (val > 0) ? true : false;
            }
            static String BoolToStr(bool val) {
            return (val == true) ? "1" : "0";
            }
            static int BoolToInt(bool val) {
            return (val == true) ? 1 : 0;
            }
            }
            class DateUtils {
            static DateTime convertToDate(String input) {
            try
            {
            var d = new DateFormat("yyyy-MM-dd").parseStrict(input);
            return d;
            } catch (e) {
            return null;
            }
            }
            static String convertToDateFull(String input) {
            try
            {
            var d = new DateFormat("yyyy-MM-dd").parseStrict(input);
            var formatter = new DateFormat('dd MMM yyyy');
            return formatter.format(d);
            } catch (e) {
            return null;
            }
            }
            static String convertToDateFullDt(DateTime input) {
            try
            {
            var formatter = new DateFormat('dd MMM yyyy');

            112


                evince -p 113 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            return formatter.format(input);
            } catch (e) {
            return null;
            }
            }
            static bool isDate(String dt) {
            try
            {
            var d = new DateFormat("yyyy-MM-dd").parseStrict(dt);
            return true;
            } catch (e) {
            return false;
            }
            }
            static bool isValidDate(String dt) {
            if (dt.isEmpty || !dt.contains("-") || dt.length < 10) return false;
            List<String> dtItems = dt.split("-");
            var d = DateTime(int.parse(dtItems[0]),
            int.parse(dtItems[1]), int.parse(dtItems[2]));
            return d != null && isDate(dt) &&
            d.isAfter(new DateTime.now());
            }
            // String functions
            static String daysAheadAsStr(int daysAhead) {
            var now = new DateTime.now();
            DateTime ft = now.add(new Duration(days: daysAhead));
            return ftDateAsStr(ft);
            }
            static String ftDateAsStr(DateTime ft) {
            return ft.year.toString() + "-" +
            ft.month.toString().padLeft(2, "0") + "-" +
            ft.day.toString().padLeft(2, "0");
            }
            static String TrimDate(String dt) {
            if (dt.contains(" ")) {
            List<String> p = dt.split(" ");
            return p[0];
            }
            else
            return dt;
            }
            }

            113
            www.dbooks.org


                evince -p 114 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Full dbhelper.dart code
            Here’s the complete finished source code for our app’s dbhelper.dart file.
            Code Listing Appendix-c: Finished dbhelper.dart

            import 'package:flutter/material.dart';
            import 'package:sqflite/sqflite.dart';
            import 'package:path_provider/path_provider.dart';
            import 'dart:async';
            import 'dart:io';
            import '../model/model.dart';
            class DbHelper {
            // Tables
            static String tblDocs = "docs";
            // Fields of the 'docs' table.
            String docId = "id";
            String docTitle = "title";
            String docExpiration = "expiration";
            String
            String
            String
            String

            fqYear = "fqYear";
            fqHalfYear = "fqHalfYear";
            fqQuarter = "fqQuarter";
            fqMonth = "fqMonth";

            // Singleton
            static final DbHelper _dbHelper = DbHelper._internal();
            DbHelper._internal();
            factory DbHelper() {
            return _dbHelper;
            }
            // Database entry point.
            static Database _db;
            Future<Database> get db async {
            if (_db == null) {
            _db = await initializeDb();
            }
            return _db;
            }

            114


                evince -p 115 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            // Initialize the database.
            Future<Database> initializeDb() async {
            Directory d = await getApplicationDocumentsDirectory();
            String p = d.path + "/docexpire.db";
            var db = await openDatabase(p, version: 1, onCreate: _createDb);
            return db;
            }
            // Create database tables.
            void _createDb(Database db, int version) async {
            await db.execute(
            "CREATE TABLE $tblDocs($docId INTEGER PRIMARY KEY, $docTitle TEXT, "
            + "$docExpiration TEXT, " +
            "$fqYear INTEGER, $fqHalfYear INTEGER, $fqQuarter INTEGER, " +
            "$fqMonth INTEGER)"
            );
            }
            // Insert a new doc.
            Future<int> insertDoc(Doc doc) async {
            var r;
            Database db = await this.db;
            try {
            r = await db.insert(tblDocs, doc.toMap());
            }
            catch (e) {
            debugPrint("insertDoc: " + e.toString());
            }
            return r;
            }
            // Get the list of docs.
            Future<List> getDocs() async {
            Database db = await this.db;
            var r = await db.rawQuery(
            "SELECT * FROM $tblDocs ORDER BY $docExpiration ASC");
            return r;
            }
            // Gets a Doc based on the id.
            Future<List> getDoc(int id) async {
            Database db = await this.db;
            var r = await db.rawQuery(
            "SELECT * FROM $tblDocs WHERE $docId = " + id.toString() + "" );
            return r;
            }
            // Gets a Doc based on a String payload.

            115
            www.dbooks.org


                evince -p 116 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Future<List> getDocFromStr(String payload) async {
            List<String> p = payload.split("|");
            if (p.length == 2) {
            Database db = await this.db;
            var r = await db.rawQuery(
            "SELECT * FROM $tblDocs WHERE $docId = " + p[0] +
            " AND $docExpiration = '" + p[1] + "'" );
            return r;
            }
            else
            return null;
            }
            // Get the number of docs.
            Future<int> getDocsCount() async {
            Database db = await this.db;
            var r = Sqflite.firstIntValue(
            await db.rawQuery("SELECT COUNT(*) FROM $tblDocs")
            );
            return r;
            }
            // Get the max document id available on the database.
            Future<int> getMaxId() async {
            Database db = await this.db;
            var r = Sqflite.firstIntValue(
            await db.rawQuery("SELECT MAX(id) FROM $tblDocs")
            );
            return r;
            }
            // Update a doc.
            Future<int> updateDoc(Doc doc) async {
            var db = await this.db;
            var r = await db.update(tblDocs, doc.toMap(),
            where: "$docId = ?", whereArgs: [doc.id]);
            return r;
            }
            // Delete a doc.
            Future<int> deleteDoc(int id) async {
            var db = await this.db;
            int r = await db.rawDelete(
            "DELETE FROM $tblDocs WHERE $docId = $id");
            return r;
            }
            // Delete all rows.
            Future<int> deleteRows(String tbl) async {

            116


                evince -p 117 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            var db = await this.db;
            int r = await db.rawDelete("DELETE FROM $tbl");
            return r;
            }
            }

            Full model.dart code
            Here’s the complete finished source code for our app’s model.dart file.
            Code Listing Appendix-d: Finished model.dart

            import '../util/utils.dart';
            class Doc
            {
            int id;
            String title;
            String expiration;
            int fqYear;
            int fqHalfYear;
            int fqQuarter;
            int fqMonth;
            Doc(this.title, this.expiration, this.fqYear,
            this.fqHalfYear, this.fqQuarter, this.fqMonth);
            Doc.withId(this.id, this.title, this.expiration, this.fqYear,
            this.fqHalfYear, this.fqQuarter, this.fqMonth);
            Map<String, dynamic> toMap() {
            var map = Map<String, dynamic>();
            map["title"] = this.title;
            map["expiration"] = this.expiration;
            map["fqYear"] = this.fqYear;
            map["fqHalfYear"] = this.fqHalfYear;
            map["fqQuarter"] = this.fqQuarter;
            map["fqMonth"] = this.fqMonth;
            if (id != null) {
            map["id"] = id;
            }

            117
            www.dbooks.org


                evince -p 118 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            return map;
            }
            Doc.fromOject(dynamic o) {
            this.id = o["id"];
            this.title = o["title"];
            this.expiration = DateUtils.TrimDate(o["expiration"]);
            this.fqYear = o["fqYear"];
            this.fqHalfYear = o["fqHalfYear"];
            this.fqQuarter = o["fqQuarter"];
            this.fqMonth = o["fqMonth"];
            }
            }

            Full docdetail.dart code
            Here’s the complete finished source code for our app’s docdetail.dart file.
            Code Listing Appendix-e: Finished docdetail.dart

            import 'dart:async';
            import
            import
            import
            import

            'package:flutter/material.dart';
            'package:flutter/services.dart';
            'package:flutter_masked_text/flutter_masked_text.dart';
            'package:flutter_datetime_picker/flutter_datetime_picker.dart';

            import '../model/model.dart';
            import '../util/utils.dart';
            import '../util/dbhelper.dart';
            // Menu item
            const menuDelete = "Delete";
            final List<String> menuOptions = const <String> [
            menuDelete
            ];
            class DocDetail extends StatefulWidget {
            Doc doc;
            final DbHelper dbh = DbHelper();
            DocDetail(this.doc);
            @override
            State<StatefulWidget> createState() => DocDetailState();
            }

            118


                evince -p 119 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            class DocDetailState extends State<DocDetail> {
            final GlobalKey<FormState> _formKey = new GlobalKey<FormState>();
            final GlobalKey<ScaffoldState> _scaffoldKey =
            new GlobalKey<ScaffoldState>();
            final int daysAhead = 5475; // 15 years in the future
            final TextEditingController titleCtrl = TextEditingController();
            final TextEditingController expirationCtrl =
            MaskedTextController(mask: '2000-00-00');
            bool
            bool
            bool
            bool
            bool

            fqYearCtrl = true;
            fqHalfYearCtrl = true;
            fqQuarterCtrl = true;
            fqMonthCtrl = true;
            fqLessMonthCtrl = true;

            // Initialization code
            void _initCtrls() {
            titleCtrl.text = widget.doc.title != null ? widget.doc.title : "";
            expirationCtrl.text =
            widget.doc.expiration != null ? widget.doc.expiration : "";
            fqYearCtrl = widget.doc.fqYear != null ?
            Val.IntToBool(widget.doc.fqYear) : false;
            fqHalfYearCtrl = widget.doc.fqHalfYear != null ?
            Val.IntToBool(widget.doc.fqHalfYear) : false;
            fqQuarterCtrl = widget.doc.fqQuarter != null ?
            Val.IntToBool(widget.doc.fqQuarter) : false;
            fqMonthCtrl = widget.doc.fqMonth != null ?
            Val.IntToBool(widget.doc.fqMonth) : false;
            }
            // Date Picker & Date functions
            Future _chooseDate(BuildContext context, String initialDateString)
            async {
            var now = new DateTime.now();
            var initialDate = DateUtils.convertToDate(initialDateString) ?? now;
            initialDate = (initialDate.year >= now.year &&
            initialDate.isAfter(now) ? initialDate : now);
            DatePicker.showDatePicker(context, showTitleActions: true,
            onConfirm: (date) {
            setState(() {
            DateTime dt = date;
            String r = DateUtils.ftDateAsStr(dt);
            expirationCtrl.text = r;

            119
            www.dbooks.org


                evince -p 120 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            });
            },
            currentTime: initialDate);
            }
            // Upper Menu
            void _selectMenu(String value) async {
            switch (value) {
            case menuDelete:
            if (widget.doc.id == -1) {
            return;
            }
            await _deleteDoc(widget.doc.id);
            }
            }
            // Delete doc
            void _deleteDoc(int id) async {
            int r = await widget.dbh.deleteDoc(widget.doc.id);
            Navigator.pop(context, true);
            }
            // Save doc
            void _saveDoc () {
            widget.doc.title = titleCtrl.text;
            widget.doc.expiration = expirationCtrl.text;
            widget.doc.fqYear = Val.BoolToInt(fqYearCtrl);
            widget.doc.fqHalfYear = Val.BoolToInt(fqHalfYearCtrl);
            widget.doc.fqQuarter = Val.BoolToInt(fqQuarterCtrl);
            widget.doc.fqMonth = Val.BoolToInt(fqMonthCtrl);
            if (widget.doc.id > -1) {
            debugPrint("_update->Doc Id: " + widget.doc.id.toString());
            widget.dbh.updateDoc(widget.doc);
            Navigator.pop(context, true);
            }
            else {
            Future<int> idd = widget.dbh.getMaxId();
            idd.then((result) {
            debugPrint("_insert->Doc Id: " + widget.doc.id.toString());
            widget.doc.id = (result != null) ? result + 1 : 1;
            widget.dbh.insertDoc(widget.doc);
            Navigator.pop(context, true);
            });
            }
            }
            // Submit form

            120


                evince -p 121 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            void _submitForm() {
            final FormState form = _formKey.currentState;
            if (!form.validate()) {
            showMessage('Some data is invalid. Please correct.');
            } else {
            _saveDoc();
            }
            }
            void showMessage(String message, [MaterialColor color = Colors.red]) {
            _scaffoldKey.currentState.showSnackBar(
            new SnackBar(backgroundColor: color, content: new Text(message)));
            }
            @override
            void initState() {
            super.initState();
            _initCtrls();
            }
            @override
            Widget build(BuildContext context) {
            const String cStrDays = "Enter a number of days";
            TextStyle tStyle = Theme.of(context).textTheme.title;
            String ttl = widget.doc.title;
            return Scaffold(
            key: _scaffoldKey,
            resizeToAvoidBottomPadding: false,
            appBar: AppBar(
            title: Text(ttl != "" ? widget.doc.title : "New Document"),
            actions: (ttl == "") ? <Widget>[]: <Widget>[
            PopupMenuButton(
            onSelected: _selectMenu,
            itemBuilder: (BuildContext context) {
            return menuOptions.map((String choice) {
            return PopupMenuItem<String>(
            value: choice,
            child: Text(choice),
            );
            }).toList();
            },
            ),
            ]
            ),
            body: Form(
            key: _formKey,
            autovalidate: true,

            121
            www.dbooks.org


                evince -p 122 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            child: SafeArea(
            top: false,
            bottom: false,
            child: ListView(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            children: <Widget>[
            TextFormField (
            inputFormatters: [
            WhitelistingTextInputFormatter(
            RegExp("[a-zA-Z0-9 ]"))
            ],
            controller: titleCtrl,
            style: tStyle,
            validator: (val) => Val.ValidateTitle(val),
            decoration: InputDecoration(
            icon: const Icon(Icons.title),
            hintText: 'Enter the document name',
            labelText: 'Document Name',
            ),
            ),
            Row(children: <Widget>[
            Expanded(
            child: TextFormField(
            controller: expirationCtrl,
            maxLength: 10,
            decoration: InputDecoration(
            icon: const Icon(Icons.calendar_today),
            hintText: 'Expiry date (i.e. ' +
            DateUtils.daysAheadAsStr(daysAhead) + ')',
            labelText: 'Expiry Date'
            ),
            keyboardType: TextInputType.number,
            validator: (val) => DateUtils.isValidDate(val)
            ? null :
            'Not a valid future date',
            )),
            IconButton(
            icon: new Icon(Icons.more_horiz),
            tooltip: 'Choose date',
            onPressed: (() {
            _chooseDate(context, expirationCtrl.text);
            }),
            )
            ]),
            Row(children: <Widget>[
            Expanded(child: Text(' ')),
            ]),
            Row(children: <Widget>[
            Expanded(child: Text('a: Alert @ 1.5 & 1 year(s)')),

            122


                evince -p 123 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Switch(
            value: fqYearCtrl, onChanged: (bool value) {
            setState(() {
            fqYearCtrl = value;
            });
            }),
            ]),
            Row(children: <Widget>[
            Expanded(child: Text('b: Alert @ 6 months')),
            Switch(
            value: fqHalfYearCtrl, onChanged: (bool value) {
            setState(() {
            fqHalfYearCtrl = value;
            });
            }),
            ]),
            Row(children: <Widget>[
            Expanded(child: Text('c: Alert @ 3 months')),
            Switch(
            value: fqQuarterCtrl, onChanged: (bool value) {
            setState(() {
            fqQuarterCtrl = value;
            });
            }),
            ]),
            Row(children: <Widget>[
            Expanded(child: Text('d: Alert @ 1 month or less')),
            Switch(
            value: fqMonthCtrl, onChanged: (bool value) {
            setState(() {
            fqMonthCtrl = value;
            });
            }),
            ]),
            Container(
            padding:
            const EdgeInsets.only(left: 40.0, top: 20.0),
            child: RaisedButton(
            child: Text("Save"),
            onPressed: _submitForm,
            )
            ),
            ],
            ),
            )));
            }
            }

            123
            www.dbooks.org


                evince -p 124 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            Full doclist.dart code
            Here’s the complete finished source code for our app’s doclist.dart file.
            Code Listing Appendix-f: Finished doclist.dart

            import 'dart:async';
            import 'package:flutter/material.dart';
            import
            import
            import
            import

            '../model/model.dart';
            '../util/dbhelper.dart';
            '../util/utils.dart';
            './docdetail.dart';

            // Menu item
            const menuReset = "Reset Local Data";
            List<String> menuOptions = const <String> [
            menuReset
            ];
            class DocList extends StatefulWidget {
            @override
            State<StatefulWidget> createState() => DocListState();
            }
            class DocListState extends State<DocList> {
            DbHelper dbh = DbHelper();
            List<Doc> docs;
            int count = 0;
            DateTime cDate;
            @override
            void initState() {
            super.initState();
            }
            Future getData() async {
            final dbFuture = dbh.initializeDb();
            dbFuture.then(
            // result here is the actual reference to the database object
            (result) {
            final docsFuture = dbh.getDocs();
            docsFuture.then(
            // result here is the list of docs in the database
            (result) {
            if (result.length >= 0) {
            List<Doc> docList = List<Doc>();
            var count = result.length;

            124


                evince -p 125 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            for (int i = 0; i <= count - 1; i++) {
            docList.add(Doc.fromOject(result[i]));
            }
            setState(() {
            if (this.docs.length > 0) {
            this.docs.clear();
            }
            this.docs = docList;
            this.count = count;
            });
            }
            });
            });
            }
            void _checkDate() {
            const secs = const Duration(seconds:10);
            new Timer.periodic(secs, (Timer t) {
            DateTime nw = DateTime.now();
            if (cDate.day != nw.day || cDate.month != nw.month ||
            cDate.year != nw.year) {
            getData();
            cDate = DateTime.now();
            }
            });
            }
            void navigateToDetail(Doc doc) async {
            bool r = await Navigator.push(context,
            MaterialPageRoute(builder: (context) => DocDetail(doc))
            );
            if (r == true) {
            getData();
            }
            }
            void _showResetDialog() {
            showDialog(
            context: context,
            builder: (BuildContext context) {
            return AlertDialog(
            title: new Text("Reset"),
            content: new Text("Do you want to delete all local data?"),
            actions: <Widget>[
            FlatButton(

            125
            www.dbooks.org


                evince -p 126 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            child: new Text("Cancel"),
            onPressed: () {
            Navigator.of(context).pop();
            },
            ),
            FlatButton(
            child: new Text("OK"),
            onPressed: () {
            Future f = _resetLocalData();
            f.then(
            (result) {
            Navigator.of(context).pop();
            }
            );
            },
            ),
            ],
            );
            },
            );
            }
            Future _resetLocalData() async {
            final dbFuture = dbh.initializeDb();
            dbFuture.then(
            (result) {
            final dDocs = dbh.deleteRows(DbHelper.tblDocs);
            dDocs.then(
            (result) {
            setState(() {
            this.docs.clear();
            this.count = 0;
            });
            }
            );
            }
            );
            }
            void _selectMenu(String value) async {
            switch (value) {
            case menuReset:
            _showResetDialog();
            }
            }
            ListView docListItems() {
            return ListView.builder(
            itemCount: count,

            126


                evince -p 127 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            itemBuilder: (BuildContext context, int position) {
            String dd = Val.GetExpiryStr(this.docs[position].expiration);
            String dl = (dd != "1") ? " days left" : " day left";
            return Card(
            color: Colors.white,
            elevation: 1.0,
            child: ListTile(
            leading: CircleAvatar(
            backgroundColor:
            (Val.GetExpiryStr(this.docs[position].expiration) != "0") ?
            Colors.blue : Colors.red,
            child: Text(
            this.docs[position].id.toString(),
            ),
            ),
            title: Text(this.docs[position].title),
            subtitle: Text(
            Val.GetExpiryStr(this.docs[position].expiration) + dl +
            "\nExp: " + DateUtils.convertToDateFull(
            this.docs[position].expiration)),
            onTap: () {
            navigateToDetail(this.docs[position]);
            },
            ),
            );
            },
            );
            }
            @override
            Widget build(BuildContext context) {
            this.cDate = DateTime.now();
            if (this.docs == null) {
            this.docs = List<Doc>();
            getData();
            }
            _checkDate();
            return Scaffold(
            resizeToAvoidBottomPadding: false,
            appBar: AppBar(
            title: Text("DocExpire"),
            actions: <Widget>[
            PopupMenuButton(
            onSelected: _selectMenu,
            itemBuilder: (BuildContext context) {
            return menuOptions.map((String choice) {

            127
            www.dbooks.org


                evince -p 128 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            return PopupMenuItem<String>(
            value: choice,
            child: Text(choice),
            );
            }).toList();
            },
            ),
            ]
            ),
            body: Center(
            child: Scaffold(
            body: Stack(
            children: <Widget>[
            docListItems(),
            ]),
            floatingActionButton: FloatingActionButton(
            onPressed: () {
            navigateToDetail(Doc.withId(-1, "", "", 1, 1, 1, 1));
            },
            tooltip: "Add new doc",
            child: Icon(Icons.add),
            ),
            ),
            ),
            );
            }
            }

            Full Pubspec.yaml code
            Here’s the complete finished code for our app’s Pubspec.yaml file.
            Code Listing Appendix-g: Finished Pubspec.yaml

            name: flutter_app
            description: A new Flutter application.
# The following defines the version and build number for your
            application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in Flutter
# build by specifying --build-name and --build-number, respectively.
# Read more about versioning at semver.org.
            version: 1.0.0+1
            environment:

            128


                evince -p 129 ~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf &

            sdk: ">=2.0.0-dev.68.0 <3.0.0"
            dependencies:
            flutter:
            sdk: flutter
            intl: ^0.15.7
            sqflite: any
            path_provider: any
            flutter_masked_text: ^0.6.0
            flutter_datetime_picker: ^1.0.1
# The following adds the Cupertino Icons font to your application.
# Use with the CupertinoIcons class for iOS style icons.
            cupertino_icons: ^0.1.2
            dev_dependencies:
            flutter_test:
            sdk: flutter
# For information on the generic Dart part of this file, see the
# following page: https://www.dartlang.org/tools/pub/pubspec
# The following section is specific to Flutter.
            flutter:
# The following line ensures that the Material Icons font is
# included with your application, so that you can use the icons in
# the material Icons class.
            uses-material-design: true

            Full Android Studio project
            Here’s the full Android Studio Project, which contains source files, plus all the build files for
            Android.

            129
            www.dbooks.org

~/Empire/Doks/Comp/lang/dart-flutter/flutterapprentice.pdf
~/Empire/Doks/Comp/lang/dart-flutter/flutter-exampleapps.pdf
~/Empire/Doks/Comp/lang/dart-flutter/flutterlayout.cheat.pdf
~/Empire/Doks/Comp/lang/dart-flutter/flutterlearnfast.pdf
~/Empire/Doks/Comp/lang/dart-flutter/flutterproj.pdf
~/Empire/Doks/Comp/lang/dart-flutter/flutter-succinct.pdf
----
~/Empire/Doks/Comp/lang/dart-flutter/firebasecb.pdf

