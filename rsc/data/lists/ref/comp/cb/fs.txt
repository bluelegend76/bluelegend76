vim: fdm=indent:fdl=2:
set fdm=indent fdl=2

@t: :set syntax= textwidth=35 nosi ai nojs spell shiftwidth=2 | colors ron
@c:
set syntax=fsharp textwidth=47 nosi ai nojs shiftwidth=2 | colors ron
  @c: :set syntax=fsharp textwidth=0 nosi ai nojs shiftwidth=2 | colors ron

Gemini: F# Data-Structures
                        Another question: I would like to get your help with looking at and drilling F# data-structures, essentially to the point where I 'get it'. Would you be able to help me with that, and do you have any ideas about how it could be done? + If I then have some ideas about how we could improve on that scheme, we can discuss it.

                        Excellent! I'm glad to hear you've got Common Lisp working in Emacs again.

                        I'd be happy to help you understand F# data structures. It's a fascinating language with a strong focus on immutability and functional programming, which leads to some elegant and powerful data structures.

                        Here's a potential approach we could take to "drill down" and help you "get it":

                        Phase 1: Foundational Concepts

                            Core Concepts of Immutability and Functional Programming: Before diving into specific data structures, we should briefly touch upon the core principles that heavily influence their design in F#:
                                Immutability: Data structures, once created, cannot be changed in place. Operations typically return new, modified copies.
                                Functional Programming: Emphasis on functions as first-class citizens, avoiding side effects, and using expressions over statements.

                            Basic F# Types as Building Blocks: We can start with the fundamental types and how they relate to building more complex structures:
                                Tuples: Fixed-size, ordered collections of elements (potentially of different types). We can explore how to create, access elements (using fst, snd, and pattern matching), and their common use cases.
                                Records: Similar to tuples but with named fields. We can discuss their advantages in terms of clarity and how to create and access fields.
                                Discriminated Unions: Powerful for representing data that can be one of several distinct cases, each potentially holding different data. We can look at defining them, creating instances, and using pattern matching to handle different cases.

                        Phase 2: Key F# Data Structures

                            Lists (list):
                                Characteristics: Ordered, immutable collections of elements of the same type.
                                Creation: Using [] and the :: (cons) operator.
                                Common Operations: head, tail, length, map, filter, fold, reduce, and recursion-based processing.
                                Performance Considerations: Understanding the implications of immutability for operations like adding or removing elements (often creating new lists).

                            Arrays (array):
                                Characteristics: Fixed-size, mutable collections of elements of the same type.
                                Creation: Using [| ... |].
                                Common Operations: Accessing elements by index, slicing, and the mutable nature (important to contrast with lists).
                                Performance Considerations: Efficient for random access and in-place modifications when mutability is needed.

                            Sequences (seq):
                                Characteristics: Logical series of elements that are computed on demand (lazy evaluation).
                                Creation: Using sequence expressions (seq { ... }).
                                Common Operations: Similar to lists (map, filter, fold), but operations are often deferred.
                                Benefits: Handling potentially infinite sequences and improving performance when not all elements need to be computed.

                            Maps (Map):
                                Characteristics: Immutable collections of key-value pairs, where keys are unique and ordered.
                                Creation: Using Map.empty and Map.add.
                                Common Operations: ContainsKey, TryFind, Add, Remove.
                                Underlying Implementation (briefly): Often implemented as balanced binary trees, which provides logarithmic time complexity for most operations.

                            Sets (Set):
                                Characteristics: Immutable collections of unique, unordered elements.
                                Creation: Using Set.empty and Set.add.
                                Common Operations: Contains, Add, Remove, set operations (union, intersection, difference).
                                Underlying Implementation (briefly): Similar to maps, often implemented using balanced binary trees.

                        Phase 3: "Getting It" - Interactive Exploration and Examples

                        For each data structure, we can:

                            Look at simple code examples: Illustrating creation and basic operations.
                            Discuss use cases: When would you choose a list over an array? When are sequences beneficial?
                            Explore the implications of immutability: How do you "modify" an immutable list?
                            Compare and contrast: Highlight the differences and similarities between different data structures.
                            Work through small, practical scenarios: For example, processing a list of numbers, looking up values in a map, or filtering elements in a sequence.

                        Phase 4: Your Ideas for Improvement

                        Once we've gone through the basics, I'd be very interested to hear your ideas on how we could improve this learning process. Perhaps you have specific areas you'd like to focus on more deeply, or you have a particular learning style that we can cater to.

                        How we can proceed:

                        We can tackle one data structure at a time. For each one, I can provide:

                            A concise explanation of its characteristics.
                            Code examples in F#.
                            Discussion of common operations and use cases.
                            Answers to your specific questions.

                        Does this initial plan sound good to you? Where would you like to start? Perhaps with the foundational concepts or directly with the list type? I'm open to your preferences!
                        Your saved info
                        Info you asked Gemini to save

                        Code we also before I give you more instructions run the same kind of overview of more advanced structures, like discriminated unions and such?

                        Yes, absolutely! I think that's a great idea. Seeing some code examples of the foundational concepts, especially tuples, records, and discriminated unions, will provide a solid base before we dive into the more complex collection types.

                        Let's do a quick code-focused overview of tuples, records, and discriminated unions in F#:

                        1. Tuples:

                            Characteristics: Fixed-size, ordered collection of elements that can be of different types.
                            Syntax: Elements are separated by commas within parentheses.

                        F#

                        // Creating tuples
                        let person = ("Alice", 30, true)
                        let coordinates = (10.5, -2.3)
                        let mixedData = (1, "hello", 3.14, 'c')

                        // Accessing elements (using fst, snd for pairs, or pattern matching for larger tuples)
                        let name = fst person // "Alice"
                        let age = snd (snd (1, (2, 3))) // 3 (less readable for larger tuples)

                        // Better way to access elements: Pattern Matching
                        let (name', age', isEmployed) = person
                        printfn "Name: %s, Age: %d, Employed: %b" name' age' isEmployed

                        let (x, y) = coordinates
                        printfn "X: %f, Y: %f" x y

                            Use Cases: Returning multiple values from a function, simple grouping of related data.

                        2. Records:

                            Characteristics: Similar to tuples but with named fields, providing better readability and clarity.
                            Syntax: Defined using the type keyword followed by the record name and field definitions within curly braces {}.

                        F#

                        // Defining a record type
                        type Person = { Name: string; Age: int; IsEmployed: bool }

                        // Creating record instances
                        let person1 = { Name = "Bob"; Age = 25; IsEmployed = false }
                        let person2 = { Name = "Charlie"; Age = 35; IsEmployed = true }

                        // Accessing record fields using dot notation
                        let name1 = person1.Name // "Bob"
                        let age2 = person2.Age   // 35

                        // Creating a new record with updated values (immutability in action)
                        let olderPerson1 = { person1 with Age = 26 }
                        printfn "Original age: %d, New age: %d" person1.Age olderPerson1.Age

                        // Pattern matching with records
                        let printPerson person =
                            printfn "Name: %s, Age: %d" person.Name person.Age

                        printPerson person1

                            Use Cases: Representing structured data with meaningful names for fields, making code more self-documenting.

                        3. Discriminated Unions:

                            Characteristics: Represent a value that can be one of several distinct cases, each potentially holding different types of data.
                            Syntax: Defined using the type keyword followed by the union name and the different cases separated by |. Each case can optionally hold data.

                        F#

                        // Defining a discriminated union type
                        type Result<'T, 'Error> =
                            | Success of 'T
                            | Failure of 'Error

                        type Shape =
                            | Circle of radius: float
                            | Rectangle of width: float * height: float
                            | Square of side: float

                        // Creating instances of the discriminated union
                        let successResult = Success 42
                        let errorResult = Failure "Something went wrong"
                        let circle = Circle 5.0
                        let rectangle = Rectangle (4.0, 6.0)
                        let square = Square 3.0

                        // Pattern matching to handle different cases
                        let printResult result =
                            match result with
                            | Success value -> printfn "Result: %A" value
                            | Failure error -> printfn "Error: %s" error

                        printResult successResult
                        printResult errorResult

                        let area shape =
                            match shape with
                            | Circle r -> System.Math.PI * r * r
                            | Rectangle (w, h) -> w * h
                            | Square s -> s * s

                        printfn "Circle area: %f" (area circle)
                        printfn "Rectangle area: %f" (area rectangle)
                        printfn "Square area: %f" (area square)

                            Use Cases: Representing data that can be in different states (e.g., success/failure), modeling algebraic data types, creating flexible and type-safe ways to handle different data structures within a single type.

                        Key Takeaways:

                            Immutability is central: Notice how "modifying" a record creates a new record. Tuples and discriminated unions are inherently immutable.
                            Pattern matching is powerful: It's a fundamental way to work with these data structures, allowing you to easily access their components and handle different cases in a type-safe manner.
                            Type safety: F#'s strong type system ensures that you're working with the data as intended based on its defined structure.

                        Do these code examples and explanations of tuples, records, and discriminated unions make sense? Would you like to explore any of them in more detail before we move on to the collection types like lists and arrays? Let me know your thoughts!


                        ___csharp_records_recordstructs
                        Could you tell me just a bit about records and record-structs (at least that's what I think they're called) in C#, and maybe you could also tell me a bit about their use-cases?

                        You're right! C# has both record types (introduced in C# 9) and struct types (which have been around much longer). record struct is a further combination introduced in C# 10. Let's break down each of these in C#:

                        1. record types (C# 9 and later):

                            Value-based equality: Unlike classes where equality by default checks for reference equality (whether two variables point to the same object in memory), records provide value-based equality. This means two record instances are considered equal if all their property values are the same.
                            Concise syntax for immutable data: Records are designed to make it easier to create immutable data transfer objects (DTOs) or data-centric types. They have a concise syntax for defining properties in the primary constructor.
                            with expression for non-destructive mutation: Records support a with expression that allows you to create a new record instance based on an existing one, but with some properties changed. This is a way to achieve a form of "mutation" while maintaining immutability of the original record.
                            Built-in ToString(): Records automatically generate a useful ToString() method that displays the property names and their values.
                            Deconstruction: Records automatically support deconstruction, allowing you to easily extract the values of their properties into separate variables.
                            Inheritance: Records can inherit from other records or classes.

                        Syntax Example:
                        C#

                        // Concise syntax with primary constructor
                        public record Person(string FirstName, string LastName, int Age);

                        // Creating instances
                        Person person1 = new Person("Alice", "Smith", 30);
                        Person person2 = new Person("Alice", "Smith", 30);

                        // Value-based equality
                        Console.WriteLine(person1 == person2); // Output: True

                        // with expression (non-destructive "mutation")
                        Person olderPerson = person1 with { Age = 31 };
                        Console.WriteLine(person1);      // Output: Person { FirstName = Alice, LastName = Smith, Age = 30 }
                        Console.WriteLine(olderPerson);  // Output: Person { FirstName = Alice, LastName = Smith, Age = 31 }

                        // Deconstruction
                        var (firstName, lastName, age) = person1;
                        Console.WriteLine($"{firstName} {lastName} is {age} years old."); // Output: Alice Smith is 30 years old.

                        Use Cases for record types:

                            Data Transfer Objects (DTOs): Representing data being passed between different parts of an application or across API boundaries. Their value-based equality makes it easy to compare if the data is the same.
                            Immutable Data Structures: Situations where you want to ensure that once an object is created, its state cannot be changed (except by creating a new instance with modifications using with). This can improve predictability and help avoid certain types of bugs.
                            Domain Entities with Value Semantics: When you want entities to be considered the same if their attributes are the same, rather than based on object identity.
                            Functional Programming Paradigms: Records align well with functional programming concepts that emphasize immutability.
                            Configuration Objects: Representing application settings where immutability can be beneficial.

                        2. struct types (C# 1.0 and later):

                            Value types: Structs are value types, meaning that variables of a struct type directly contain the data of the struct, rather than a reference to the data (which is the case with classes and records by default).
                            Stored on the stack (typically): Structs are usually allocated on the stack, which can offer performance benefits for small, short-lived objects by avoiding garbage collection overhead.
                            Default equality based on all fields: Structs also provide value-based equality by default, comparing all their fields. However, you can override the Equals method and == operator if needed.
                            Mutable by default: Unlike records, structs are mutable by default. You can change the values of their fields after creation.
                            No inheritance (except from System.ValueType): Structs cannot inherit from other classes or structs (other than implicitly inheriting from System.ValueType).

                        Syntax Example:
                        C#

                        public struct Point
                        {
                            public int X { get; set; }
                            public int Y { get; set; }
                        }

                        Point point1 = new Point { X = 10, Y = 20 };
                        Point point2 = point1; // Creates a copy (value type behavior)
                        point2.X = 30;

                        Console.WriteLine(point1); // Output: { X = 10, Y = 20 }
                        Console.WriteLine(point2); // Output: { X = 30, Y = 20 }

                        Use Cases for struct types:

                            Small, Value-Oriented Types: Representing simple data structures like points, coordinates, colors, or numerical values where the overhead of a reference type might be undesirable.
                            Performance-Critical Scenarios: When the allocation and deallocation costs of reference types become significant, using structs can sometimes offer performance improvements (though this should be carefully profiled).
                            Interoperability with Unmanaged Code: Structs are often used when interacting with native libraries or COM components.

                        3. record struct types (C# 10 and later):

                            Combination of record and struct: record struct combines the value-based equality, concise syntax, with expression, and built-in members of a record with the value type semantics and stack allocation (typically) of a struct.
                            Value type with record-like features: It's essentially a value type that gets all the convenient features of a reference record.

                        Syntax Example:
                        C#

                        public record struct Measurement(double Value, string Unit);

                        Measurement m1 = new Measurement(10.5, "cm");
                        Measurement m2 = new Measurement(10.5, "cm");

                        Console.WriteLine(m1 == m2); // Output: True (value-based equality)

                        Measurement m3 = m1 with { Value = 12.0 };
                        Console.WriteLine(m1); // Output: Measurement { Value = 10.5, Unit = cm }
                        Console.WriteLine(m3); // Output: Measurement { Value = 12, Unit = cm }

                        Use Cases for record struct types:

                            Value-Based Data Transfer Objects (DTOs) where stack allocation is desired: For small DTOs that are frequently created and destroyed, using a record struct can potentially reduce garbage collection pressure.
                            Immutable Value Types with Concise Syntax: When you need the benefits of immutability and the syntactic sugar of records but want value type semantics.
                            Performance-Sensitive Scenarios with Immutable Data: If you have immutable data structures that are small and frequently used, record struct can be a good choice for potential performance gains.

                        In summary:

                            Use record (reference type) when you need value-based equality, concise syntax for potentially more complex immutable data, and the benefits of reference types (like inheritance).
                            Use struct (value type) for small, simple value-oriented types where the overhead of a reference type might be a concern and mutability is acceptable or desired.
                            Use record struct (value type) when you want the value-based equality and concise syntax of records but also the value type semantics (potential stack allocation and reduced garbage collection) for smaller, immutable data structures.

                        The choice between these often depends on the specific requirements of your application, the size and complexity of the data, and performance considerations.


~/Empire/Doks/Comp/lang/clangs/csharp/fsharp/cheatsh-qref/fsharp.cheatsh.pdf
            F# Cheatsheet

            This cheatsheet glances over some
            of the common syntax of F# 3.0. If
            you have any comments, corrections,
            or suggested additions, please open
            an issue or send a pull request to
            https://github.com/dungpa/fsharp-cheatsheet


            Comments

            Block comments are placed between
            (* and *). Line comments start from
            // and continue until the end of
            the line.

            (* This is block comment *)
            // And this is line comment

            XML doc comments come after ///
            allowing us to use XML tags to
            generate documentation.

            /// The 'let' keyword defines an (immutable) value
            let result = 1 + 1 = 2


            Strings

            F# string type is an alias for System.String type.

            /// Create a string using string concatenation
            let hello = "Hello" + " World"

            Use verbatim strings preceded by @
            symbol to avoid escaping control
            characters (except escaping " by
            ""). "

            let verbatimXml = @"<book title=""Paradise Lost"">"

            We don't even have to escape " with
            triple-quoted strings. "

            let tripleXml = """<book title="Paradise Lost">"""

            Backslash strings indent string
            contents by stripping leading
            spaces.

            let poem =
              "The lesser world was daubed\n\
              By a colorist of modest skill\n\
              A master limned you in the finest inks\n\
              And with a fresh-cut quill."


            Basic Types and Literals

            Most numeric types have associated
            suffixes, e.g., uy for unsigned
            8-bit integers and L for signed
            64-bit integer.

            let b, i, l = 86uy, 86, 86L

            val b : byte = 86uy
            val i : int = 86
            val l : int64 = 86L

            Other common examples are F or f
            for 32-bit floating-point numbers,
            M or m for decimals, and I for big
            integers.

            let s, f, d, bi = 4.14F, 4.14, 0.7833M, 9999I

            val s : float32 = 4.14f
            val f : float = 4.14
            val d : decimal = 0.7833M
            val bi : System.Numerics.BigInteger = 9999

            Comment: See Literals (MSDN) for
            complete reference.


            Functions

            The let keyword also defines named
            functions.

            let negate x = x * -1
            let square x = x * x
            let print x = printfn "The number is: %d" x

            let squareNegateThenPrint x =
                print (negate (square x))


            Pipe and composition operators

            Pipe operator |> is used to chain
            functions and arguments together.
            Double-backtick identifiers are
            handy to improve readability
            especially in unit testing:

            let ''square, negate, then print'' x =
              x |> square |> negate |> print

            This operator is essential in
            assisting the F# type checker by
            providing type information before
            use:

            let sumOfLengths (xs : string []) =
              xs
              |> Array.map (fun s -> s.Length)
              |> Array.sum

            Composition operator >> is used to
            compose functions:

            let squareNegateThenPrint' =
              square >> negate >> print


            Recursive functions

            The rec keyword is used together
            with the let keyword to define a
            recursive function:

            let rec fact x =
              if x < 1 then 1
              else x * fact (x - 1)

            Mutually recursive functions (those
            functions which call each other)
            are indicated by the and keyword:

            let rec even x =
              if x = 0 then true
              else odd (x - 1)

            and odd x =
              if x = 1 then true
              else even (x - 1)


            Pattern Matching

            Pattern matching is often
            facilitated through the match
            keyword.

            let rec fib n =
              match n with
              | 0 -> 0
              | 1 -> 1
              | _ -> fib (n - 1) + fib (n - 2)

            In order to match sophisticated
            inputs, one can use when to create
            filters or guards on patterns:

            let sign x =
              match x with
              | 0 -> 0
              | x when x < 0 -> -1
              | x -> 1

            Pattern matching can be done
            directly on arguments:

            let fst' (x, _) = x

            or implicitly via the function
            keyword:

            /// Similar to 'fib'; using 'function' for pattern matching
            let rec fib' = function
              | 0 -> 0
              | 1 -> 1
              | n -> fib' (n - 1) + fib' (n - 2)

            For a more complete reference,
            visit Pattern Matching (MSDN).


            Collections

            Lists

            A list is an immutable collection
            of elements of the same type.

            // Lists use square brackets and the ';' delimiter
            let list1 = [ "a"; "b" ]
            T@// :: is prepending
            let list2 = "c" :: list1
            T@// @ is concat
            let list3 = list1 @ list2

            // Recursion on list using (::) operator
            let rec sum list =
              match list with
              | [] -> 0
              | x :: xs -> x + sum xs


            Arrays

            Arrays are fixed-size, zero-based,
            mutable collections of consecutive
            data elements.

            // Arrays use square brackets with bar
            let array1 = [| "a"; "b" |]
            // Indexed access using dot
            let first = array1.[0]


            Sequences

            A sequence is a logical series of
            elements of the same type.
            Individual sequence elements are
            computed only as required, so a
            sequence can provide better
            performance than a list in
            situations in which not all the
            elements are used.

            // Sequences can use yield and contain subsequences
            let seq1 =
              seq {
                // "yield" adds one element
                yield 1
                yield 2

                // "yield!" adds a whole subsequence
                yield! [5..10]
              }


            Higher-order functions on collections

            The same list [ 1; 3; 5; 7; 9 ] or
            array [| 1; 3; 5; 7; 9 |] can be
            generated in various ways.

              - Using the range operator ..

              let xs = [ 1..2..9 ]

              - Using list or array comprehensions

              let ys = [| for i in 0..4 -> 2 * i + 1 |]

              - Using the init function

              let zs = List.init 5 (fun i -> 2 * i + 1)

            Lists and arrays have comprehensive
            sets of higher-order functions for
            manipulation.

              - fold starts from the left of
                the list (or array) and
                foldBack goes in the opposite
                direction

              let xs' = Array.fold (fun str n ->
                  sprintf "%s,%i" str n) "" [| 0..9 |]

              - reduce doesn't require an
                initial accumulator

              let last xs = List.reduce (fun acc x -> x) xs

              - map transforms every element of
                the list (or array)

              let ys' = Array.map (fun x -> x * x) [| 0..9 |]

              - iterate through a list and
                produce side effects

              let _ = List.iter (printfn "%i") [ 0..9 ]

            All these operations are also
            available for sequences. The added
            benefits of sequences are laziness
            and uniform treatment of all
            collections implementing
            IEnumerable<'T>.

            let zs' =
              seq {
                for i in 0..9 do
                  printfn "Adding %d" i
                  yield i
              }


            Tuples and Records

            A tuple is a grouping of unnamed
            but ordered values, possibly of
            different types:

            // Tuple construction
            let x = (1, "Hello")

            // Triple
            let y = ("one", "two", "three")

            // Tuple deconstruction / pattern
            let (a', b') = x

            N@The first and second elements of a
            tuple can be obtained using fst,
            snd, or pattern matching:

            let c' = fst (1, 2)
            let d' = snd (1, 2)

            let print' tuple =
              match tuple with
              | (a, b) -> printfn "Pair %A %A" a b

            Records represent simple aggregates
            of named values, optionally with
            members:

            // Declare a record type
            type Person = { Name : string; Age : int }

            // Create a value via record expression
            let paul = { Name = "Paul"; Age = 28 }

            // 'Copy and update' record expression
            let paulsTwin = { paul with Name = "Jim" }

            Records can be augmented with
            properties and methods:

            type Person with
              member x.Info = (x.Name, x.Age)

            Records are essentially sealed
            classes with extra topping: default
            immutability, structural equality,
            and pattern matching support.

            let isPaul person =
              match person with
              | { Name = "Paul" } -> true
              | _ -> false


            Discriminated Unions

            Discriminated unions (DU) provide
            support for values that can be one
            of a number of named cases, each
            possibly with different values and
            types.

            HM@type Tree<'T> =
              | Node of Tree<'T> * 'T * Tree<'T>
              | Leaf

            let rec depth = function
              | Node(l, _, r) -> 1 + max (depth l) (depth r)
              | Leaf -> 0

            N@F# Core has a few built-in
            discriminated unions for error
            handling, e.g., Option and Choice.

            let optionPatternMatch input =
              match input with
                | Some i -> printfn "input is an int=%d" i
                | None -> printfn "input is missing"

            HM@Single-case discriminated unions
            are often used to create type-safe
            abstractions with pattern matching
            support:

            type OrderId = Order of string

            // Create a DU value
            let orderId = Order "12"

            // Use pattern matching to deconstruct single-case DU
            let (Order id) = orderId


            Exceptions

            The failwith function throws an
            exception of type Exception.

            let divideFailwith x y =
              if y = 0 then
                failwith "Divisor cannot be zero."
              else x / y

            Exception handling is done via
            try/with expressions.

            let divide x y =
              try
                Some (x / y)
              with :? System.DivideByZeroException ->
                printfn "Division by zero!"
                None

            The try/finally expression enables
            you to execute clean-up code even
            if a block of code throws an
            exception. Here's an example which
            also defines custom exceptions.

            exception InnerError of string
            exception OuterError of string

            let handleErrors x y =
              try
                try
                  if x = y then raise (InnerError("inner"))
                  else raise (OuterError("outer"))
                with InnerError(str) ->
                  printfn "Error1 %s" str
              finally
                printfn "Always print this."


            Classes and Inheritance

            This example is a basic class with
            (1) local let bindings, (2)
            properties, (3) methods, and (4)
            static members.

            type Vector(x : float, y : float) =
              let mag = sqrt(x * x + y * y) // (1)
              member this.X = x // (2)
              member this.Y = y
              member this.Mag = mag
              member this.Scale(s) = // (3)
                Vector(x * s, y * s)
              static member (+) (a : Vector, b : Vector) = // (4)
                Vector(a.X + b.X, a.Y + b.Y)

            Call a base class from a derived one.

            type Animal() =
              member __.Rest() = ()

            type Dog() =
              inherit Animal()
              member __.Run() =
                base.Rest()

            N@Upcasting is denoted by :>
            operator.

            let dog = Dog()
            let animal = dog :> Animal

            Dynamic downcasting (:?>) might
            throw an InvalidCastException if
            the cast doesn't succeed at
            runtime.

            let shouldBeADog = animal :?> Dog


            Interfaces and Object Expressions

            Declare IVector interface and
            implement it in Vector'.

            type IVector =
              abstract Scale : float -> IVector

            type Vector'(x, y) =
              interface IVector with
                member __.Scale(s) =
                  Vector'(x * s, y * s) :> IVector
              member __.X = x
              member __.Y = y

            Another way of implementing
            interfaces is to use object
            expressions.

            type ICustomer =
              abstract Name : string
              abstract Age : int

            let createCustomer name age =
              { new ICustomer with
                member __.Name = name
                member __.Age = age }


            Active Patterns

            Complete active patterns:

            let (|Even|Odd|) i =
              if i % 2 = 0 then Even else Odd

            let testNumber i =
              match i with
              | Even -> printfn "%d is even" i
              | Odd -> printfn "%d is odd" i

            Parameterized active patterns:

            let (|DivisibleBy|_|) by n =
              if n % by = 0 then Some DivisibleBy else None

            let fizzBuzz = function
              | DivisibleBy 3 & DivisibleBy 5 -> "FizzBuzz"
              | DivisibleBy 3 -> "Fizz"
              | DivisibleBy 5 -> "Buzz"
              | i -> string i

            Partial active patterns share the
            syntax of parameterized patterns
            but their active recognizers accept
            only one argument.


            Compiler Directives

            Load another F# source file into FSI.
            
            '#load "../lib/StringParsing.fs"

            Reference a .NET assembly (/ symbol
            is recommended for Mono
            compatibility).

            '#r "../lib/FSharp.Markdown.dll"

            Include a directory in assembly
            search paths.

            '#I "../lib"
            '#r "FSharp.Markdown.dll"

            Other important directives are
            conditional execution in FSI
            (INTERACTIVE) and querying current
            directory (__SOURCE_DIRECTORY__).

            '#if INTERACTIVE
            let path = __SOURCE_DIRECTORY__ + "../lib"
            '#else
            let path = "../../../lib"
            '#endif
~/Empire/Doks/Comp/lang/clangs/csharp/fsharp/cheatsh-qref/fsharp2.cheatsh.pdf
            F# Cheat Sheet

            This sheet glances over some of the
            common syntax of the F# language.
            It is designed to be kept close for
            those times when you need to jog
            your memory on something like loops
            or object-expressions. Everything
            is designed to be used with the
            #light syntax-directive. If you
            type any of these lines directly
            into the interactive command-shell,
            be sure to follow them up with two
            semicolons ";;". If you have any
            comments, corrections or suggested
            additions please send them to
            chance@a6systems.com.


            1 - Comments

            There are a few different kinds of
            comments in F#. Comment-blocks,
            which are placed between (* and *)
            markers.

            Line by line comments which follow
            // until the end of a line, and xml
            doc comments which follow /// and
            allow the programmer to place
            comments in xml tags that can be
            used to generate xml documents.


            2 - Strings

            In F# Code the type string is
            equivalent to System.String

            let s = "This is a string"
            let hello = "Hello"+" World"

            Preserve all characters

            let share = @"\\share"

            Use escape characters

            let shareln = "\\\\share\n"


            3 - Numbers

            type is int16 = System.Int16
            let int16num = 10s

            type is int32 = System.Int32
            let int32num = 10

            type is int64 = System.Int64
            let int64num = 10L

            type is float32, single or System.Single
            let float32num = 10.0f

            type is float, double or System.Double
            let floatnum = 10.0

            convert to int64
            let int64frm32 = int64 int32num

            Other conversion functions:
            float float32 int int16


            4 - Tuples

            Construction
            let x = (1,"Hello")

            Deconstruction
            let a,b = x

            Reconstruction and value reuse
            let y = (x,(a,b))

            Reconstruction into a 3 tuple
            (triple)
            let z = (x,y,a)

            Partial deconstruction triple
            let ((a',b'),y',a'') = z


            5 - Lists, Arrays, Seqs: Generation

            Creates the list [0 ; 2 ; 4]
            let lsinit = List.init 3
              (fun i -> i * 2)

            Creates same list as above
            let lsgen = [ 0 ; 2 ; 4]

            Creates the list [0;2;4;6;8]
            let lsgen2 = [0 .. 2 .. 8]

            Can also do above one increment at
            a time to get [0;1;2;3;4;5;6;7;8]
            let lsgen2' = [0..8]

            Creates a list [0.0; 0.5; 1.0; 1.5]
            let lsgen3 =
              [for i in 0..3 -> 0.5 * float i]

            Can also do above one increment at
            a time to get [0;1;2;3;4;5;6;7;8]
            let lsgen2' = [0..8]

            Creates a list [0.0; 0.5; 1.0; 1.5]
            let lsgen3 =
              [for i in 0..3 -> 0.5 * float i]

            Put other steps into a generator
            let lsgen3' =
              [for i in 0..3 ->
                printf "Adding %d\n" i
                0.5 * float i]

            Place -1 at the head of a list
            let inserted = -1 :: lsgen2'

            Concatenation
            let concat = lsgen2 @ lsgen2'

            Create an array [|0 ; 2 ; 4|]
            let arinit = Array.init 3
            (fun i -> i * 2)

            Create same array as above
            let argen = [| 0 ; 2 ; 4|]

            Create the array [|0;2;4;6;8|]
            let argen2 = [|0 .. 2 .. 8|]

            Same as above one increment at a
            time
            to get [|0;1;2;3;4;5;6;7;8|]
            let argen2' = [|0..8|]

            Create an array [0.0; 0.5; 1.0; 1.5]
            let argen3 =
              [|for i in 0..3 -> 0.5 * float i|]

            Put other computation steps into
            the generator
            let argen3' =
              [|for i in 0..3 ->
                printf "Adding %d\n" i
                0.5 * float i|]

            Creating a seq - remember these are
            lazy
            let s =
              seq { for i in 0 .. 10 do yield i }

            Illustrate laziness – consume the
            seq below and note the difference
            from the generated array.

            let s2 =
              seq { for i in 0 .. 10 do
                printf "Adding %d\n" i
                yield i }


            6 - Lists, Arrays, Seqs : Consuming

            "left" fold starts from the left of
            the list, the "right" fold does the
            opposite
            List.fold_left
              (fun state a -> state + 1 ) 0
              [ for i in 0 .. 9 -> true]

            Reduce doesn't require the starter
            argument
            List.reduce_left
              (fun accum a -> accum + a )
              [0..9]

            Square all of the elements in a list
            List.map (fun x -> x * x) [1..10]

            Prints all the items of a list
            List.iter
              (fun x -> printf "%d" x) [1..10]

            Same examples for arrays
            Array.fold_left
              (fun state a -> state + 1 ) 0
              [| for i in 0 .. 9 -> true|]

            Array.reduce_left
              (fun accum a -> accum + a )
              [|0..9|]

            Squares all the elements in the
            array Array.map
              (fun x -> x * x) [| 1 .. 10 |]

            Prints all the items of an array
            Array.iter
              (fun x -> printf "%d" x)
              [|1..10|]

            Access all elements of an array
            from 2 on
            let arr = [|for i in 0..3 -> i|]
            arr.[2..]

            Access elements between 2 and 4
            (inclusive)
            let arr = [|for i in 0..3 -> i|]
            arr.[2..4]

            Access all elements of an array up
            to 4
            let arr = [|for i in 0..3 -> i|]
            arr.[..4]

            Seq also has iter, fold, map and
            reduce
            Seq.reduce
              (fun accum a -> accum + a)
              (seq { for i in 0 .. 9 do
                yield i })


            7 - Arrays: Manipulating

            Array elements can be updated
            let arrayone = [|0..8|]
              arrayone.[0] <- 9


            8 - Composition Operators

            the |> operator is very helpful for
            chaining arguments and functions
            together
            let piped = [0..2] |> List.sum

            the >> operator is very helpful for
            composing functions
            open System
            let composedWriter =
              string >>
              Console.WriteLine


            9 Functions as values

            Create a function of 3 arguments
            let add x y z = x + y + z

            Currying example
            let addWithFour= add 4

            Apply remaining arguments
            addWithFour 2 10

            Take a function as an argument
            let runFuncTenTimes f a =
              [ for 0..9 -> f a]

            Return a list of functions as
            arguments
            let listOfPrintActions =
              [ for 0 .. 10 ->
                printf "%s\n"]

            Apply those functions iteratively
            listOfPrintActions
            |> List.iteri (fun i a -> a i)

            Anonymous function (applied to 2)
            (fun x -> x * x) 2

            Anonymous function (applied to
            tuple,which is deconstructed
            inside)
            let arg = (3,2)
            (fun (x,y) -> x * y) arg


            10 - Union Types

            Discriminated Union
            type option<'a> =
              | Some of 'a
              | None

            Augmented Discriminated Union
            type BinTree<‟a> =
              | Node of
                BinTree<‟a> * „a *
                BinTree<‟a>
              | Leaf
              with member self.Depth() =
                match self with
                | Leaf -> 0
                | Node(l,_,r) -> 1 +
                  l.Depth() +
                  r.Depth()


            11 - Types: Records

            type Person = {name:string;age:int}

            let paul = {name="Paul";age=35}

            let paulstwin =
              {paul with name="jim"}

            do printf "Name %s, Age %d"
                paul.name paul.age

            Augmenting Records
            type Person = {name:string;age:int}
              with member o.Tupilize() =
                (o.name,o.age)


            12 - Types: OOP

            Classes
            type BaseClass()=
              let mutable myIntValue=1
              member o.Number
                with get() = myIntValue
                and set v = myIntValue<-v
              abstract member
                InheritNum:unit->int
              default o.InheritNum() =
                  o.Number + 1

            Subclass
            type MyClass() =
              inherit BaseClass()
              let someval = "SomeVal"
              let mutable myIntValue = 1
              member self.SomeMethod(x,y) =
                gxy
              static member StaticMethod(x,y)=
                fxy
              member override o.InheritNum() =
                base.InheritNum()+
                myIntValue

            Interface
            type MyAbsFoo =
              abstract Foo:unit->string

            type MyFooClass() =
              let mutable myfoo ="Foo"
              member o.MyFoo
                with get () = myfoo
                and set v = myfoo<-v
              interface MyAbsFoo with
                member o.Foo() = myfoo
              end

            Object Expressions
            let foo =
              {new MyAbsFoo with
                member o.Foo()="Bar"}

            Augmenting Existing Objects (note:
            augmented members only available
            when augmenting module is opened)
            open System.Xml
            type XmlDocument() =
              member o.GetInnerXml() =
                self.InnerXml

            Static Upcasting
            let strAsObj =
              let str = "Hello"
              str :> obj

            Dynamic Downcasting
            let objSub (o:‟a when „a:>object) =
              o :?> SomeSubType


            13 - Pattern Matching

            Basic
            let f (x:option<int>) =
              match x with
              | None -> ()
              | Some(i) -> printf "%d" i

            As a function definition
            let f = function
              | None -> ()
              | Some(i) -> printf "%d" i

            With when operation
            let f = function
              | None -> ()
              | Some(i) when i=0 -> ()
              | Some(i) when i>0 ->printf"%d"i

            Common matches on a literal
            let f x =
              match x with
              | 0 | 1 as y -> f y
              | i -> printf "%d" i

            Wildcard
            let f = function
              | 0 | 1 as y -> printf "Nothing"
              | _ -> printf "Something"


            14 - Exceptions

            try
              obj.SomeOp()
            with | ex ->
              printf "%s\n" ex.Message

            With (exception) type test
            try
              obj.SomeOp()
            with
              | :? ArgumentException as ex ->
                printf "Bad Argument:\n"
              | exn -> printf "%s\n" exn.Message

            Add block that runs whether
            exception is thrown or not
            try
              obj.SomeOp()
            finally
              obj.Close()

            Raise an exception in code
            - Shorthand
            let f x =
              if not x.Valid then
                invalid_arg "f:x is not valid"
              else x.Process()

            - Full
            let f x =
              if not x.SupportsProcess() then
              raise
                (InvalidOperationException
                ("x must support process"))
              else x.Process()

            Create your own
            exception InvalidProcess of string

            try
              raise InvalidProcess("Raising Exn")
            with
              | InvalidProcess(str) ->
                printf "%s\n" str


            15 - Loops

            for i in 0..10 do
              printf "%d" i
            done

            Over an IEnumerable
            for x in xs do
              printf "%s\n"(x.ToString())
            done

            While
            let mutable mutVal = 0
            while mutVal<10 do
              mutVal <- mutVal + 1
            done


            16 - Async Computations

            (Note: FSharp.PowerPack.dll should
            be referenced in your project – as
            of the CTP - to get the augmented
            async methods available in existing
            IO operations)

            Basic computation that returns
            Async<int> that will yield 1 when
            executed
            let basic = async { return 1 }

            Composing expressions and applying
            to arguments
            let compound num =
              async {
                let! anum = basic
                return num + anum }

            Returning existing expressions
            let composedReturn =
              async { return! compound 2}

            Creating Primitives with existing
            Begin/End Async Calls
            let asyncCall args =
              Async.BuildPrimitive
                ((fun (callback,asyncState) ->
                  myService.BeginMethod(args,
                                        callback,
                                        asyncState)),
                  myService.EndMethod)

            Make your own primitive from scratch
            let asyncPrimitive args =
              Async.Primitive (fun (con,exn) ->
                let result = runSomething args
                if good result then con result
                else exn result)

            Other primitives
            Async.Parallel
            Async.Primitive
            Async.Catch

            Making sure I/O threads don't block
            (Note the MethodAsync convention in
            "Expert F#" seems to have changed
            to AsyncMethod)
            let asyncRead file (numBytes:int)=
              async {
                let inStr = File.OpenRead(file)
                let! data = inStr.AsyncRead numBytes
                return processData(data) }

            Execution Methods (apply the async
            computation as an argument to
            these)
            Async.Run
            Async.Spawn
            Async.SpawnFuture
            Async.SpawnThenPostBack


            17 - Active Patterns

            Basic
            let (|Xml|) doc = doc.InnerXml

            let getXml = function
              | Xml(xml) -> xml

            Multiple Patterns
            let (|Xml|NoXml|) doc =
              if doc.InnerXml="" then NoXml
              else Xml(doc.InnerXml)

            let getXml = function
              | Xml(xml) -> Some(xml)
              | NoXml -> None

            Partial Pattern
            let (|Xml|_|) doc =
              if doc.InnerXml="" then None
              else Some(doc.InnerXml)

            let getXml = function
              | Xml(xml) -> Some(xml) //Xml Matched
              | _ -> None // Xml did not match


            18 - Compiler Directives and Interop with other .NET Languages

            Make indentation significant in
            parsing (i.e. turn on light syntax)
            '#light

            Reference a DLL from another .NET
            library (interactive F# scripts
            only – in compiled code use normal
            interface for reference additions)
            '#r @".\src\bin\mylib.dll"

            Include a directory in the
            reference search (also in
            interactive scripts only)
            '#I @"[dir path]"

            For a C# class Foo in a dll with a
            method ToString(), invoke just as
            you would an F# class.
            let foo = Foo()
            let s = foo.ToString()

            To have code run only in when
            working with the compiled version
            '#if COMPILED
            ...code
            '#endif

            For example, when writing a
            windowed application that you test
            in script, but eventually compile
            to run
            let window =
              Window(Title="My Window")
            '#if COMPILED
            [<STAThread>]
            do
              let app = Application in
              app.Run(window) |> ignore
            '#endif
            ... later in script (.fsx) file ...
            window.Show()
            
            Version 1.01
            You can always get the most recent
            updates to this cheat sheet from
            http://a6systems.com/fsharpcheatsheet.pdf
            
            A6 Systems, LLC is an Austin, TX
            based company that provides
            consulting services and F#
            QuickStart training.
            
            http://a6systems.com


gvim ~/gdrive/rsc/Doks/taskuj/Cs/Fs/{Fable/Fable-framew,Fabulous/Fabulous-framew}.txt
    https://suave.io/

gvim ~/Dropbox/Udt/rsc/doks/comp/lang/clangs/cs/fs/{fsfunprofit-FsAtWork,devlife-fsscripting}.txt

  gvim ~/Empire/Doks/Comp/lang/clangs/csharp/fsharp/{fsdeepdives_2015,fs-domainmodel_2018,fs-ess_2023,FsharpRealworld,fsharp-survguide,fswebmob-netmvtazurewbebsock_2013,functprogr-realworld_2010}.txt

  gvim ~/Empire/Doks/Comp/lang/clangs/csharp/fsharp/{fs-domainmodel_2018,fs-datastructsalgos_2015,FsharpDocs_2022plus,FsharpRealworld,fsharp-survguide,FsGetprogr_2018}.txt

  F# for Devops ----
  https://fsharpforfunandprofit.com/posts/low-risk-ways-to-use-fsharp-at-work/#explore-net-interactively
  https://fsharpforfunandprofit.com/posts/low-risk-ways-to-use-fsharp-at-work-2//

  https://mallibone.com/post/fsharp-scripting

