set fdm=indent fdl=2
vim: fdm=indent:fdl=2:
___zzzz

~/Dropbox/rsc/Doks/phone/Comp/lang/py/funct/FuncPy.binder.Tags1.txt  ¤¤¤
   .  ~/gdrive/FuncPy.binder.Tags1.txt
----
~/gdrive/JupNoteb.binder.Tags1.txt  ¤¤¤

    ## ~/Dropbox/rsc/data/lists/ref/comp/lang/py/py.txt
~/Dropbox/rsc/data/lists/ref/comp/lang/py/pyfuncts-mostused.txt
--
~/Dropbox/rsc/data/lists/ref/comp/lang/py/pyessref-beaz.txt
~/Dropbox/rsc/data/lists/ref/comp/lang/py/pystdlib3.txt  ¤¤(¤)
~/Dropbox/rsc/data/lists/ref/comp/lang/py/PyStdLib.txt  ¤¤¤
~/Dropbox/rsc/data/lists/ref/comp/lang/py/PyPackagesIndex-pypi.txt

~/Dropbox/rsc/samples/code/py/abcode-pyfiltering.py

~/Empire/Doks/Comp/lang/py/pycb3.pdf
~/Empire/Doks/Comp/lang/py/pycb3.txt
~/Empire/Doks/Comp/lang/py/pycb3kil.pdf
    ~/Dropbox/rsc/Doks/phone.fmt35/pycb3kil.fmt35.txt  ¤¤¤
~/Empire/Doks/Comp/lang/py/mpycb.pdf
----

pycb3-orig
(TODO: Pull in Chapter-headings one indent(!))
            1. Data Structures and Algorithms
                1.1. Unpacking a Sequence into Separate Variables 1
                1.2. Unpacking Elements from Iterables of Arbitrary Length 3
                1.3. Keeping the Last N Items 5
                1.4. Finding the Largest or Smallest N Items 7
                1.5. Implementing a Priority Queue 8
                1.6. Mapping Keys to Multiple Values in a Dictionary lt
                1.7. Keeping Dictionaries in Order 12
                1.8. Calculating with Dictionaries 13
                1.9. Finding Commonalities in Two Dictionaries 15
                1.10. Removing Duplicates from a Sequence while Maintaining Order 17
                1.11. Naming a Slice 18
                1.12. Determining the Most Frequently Occurring Items in a Sequence 20
                1.13. Sorting a List of Dictionaries by a Common Key 21
                1.14. Sorting Objects Without Native Comparison Support 23
                1.15. Grouping Records Together Based on a Field 24
                1.16. Filtering Sequence Elements  26
                1.17. Extracting a Subset of a Dictionary 28
                1.18. Mapping Names to Sequence Elements 29
                1.19. Transforming and Reducing Data at the Same Time 32
                1.20. Combining Multiple Mappings into a Single Mapping 33
            2 Strings and Text
                2.1. Splitting Strings on Any of Multiple Delimiters 37
                2.2. Matching Text at the Start or End of a String 38
                2.3. Matching Strings Using Shell Wildcard Patterns 40
                2.4. Matching and Searching for Text Patterns 42

                evince -p 2 doc_newest2019/pycb3.pdf & 

                2.6. Searching and Replacing Case-Insensitive Text 46
                2.7. Specifying a Regular Expression for the Shortest Match 47
                2.8. Writing a Regular Expression for Multiline Patterns Ag
                2.9. Normalizing Unicode Text to a Standard Representation 50
                2.10. Working with Unicode Characters in Regular Expressions 52
                2.11. Stripping Unwanted Characters from Strings 53
                2.12. Sanitizing and Cleaning Up Text 54
                2.13. Aligning Text Strings 57
                2.14. Combining and Concatenating Strings 38
                2.15. Interpolating Variables in Strings 61
                2.16. Reformatting Text to a Fixed Number of Columns 64
                2.17. Handling HTML and XML Entities in Text 65
                2.18. Tokenizing Text 66
                2.19. Writing a Simple Recursive Descent Parser 69
                2.20. Performing Text Operations on Byte Strings 78
            3. Numbers, Dates, and Times
                3.1. Rounding Numerical Values 83
                3.2. Performing Accurate Decimal Calculations 84
                3.3. Formatting Numbers for Output 87
                3.4. Working with Binary, Octal, and Hexadecimal Integers 89
                3.5. Packing and Unpacking Large Integers from Bytes 90
                3.6. Performing Complex-Valued Math 92
                3.7. Working with Infinity and NaNs 94
                3.8. Calculating with Fractions 96
                3.9. Calculating with Large Numerical Arrays 97
                3.10. Performing Matrix and Linear Algebra Calculations 100
                3.11. Picking Things at Random 102
                3.12. Converting Days to Seconds, and Other Basic Time Conversions 104
                3.13. Determining Last Friday's Date 106
                3.14. Finding the Date Range for the Current Month 107
                3.15. Converting Strings into Datetimes 109
                3.16. Manipulating Dates Involving Time Zones 110
            4. Iterators and Generators
                4.1. Manually Consuming an Iterator 113
                4.2. Delegating Iteration 114
                4.3. Creating New Iteration Patterns with Generators 115
                4.4. Implementing the Iterator Protocol 117
                4.5. Iterating in Reverse 119
                4.6. Defining Generator Functions with Extra State 120

                evince -p 3 doc_newest2019/pycb3.pdf & 

                4.7. Taking a Slice of an Iterator a
                4.8. Skipping the First Part of an Iterable 123
                4.9. Iterating Over All Possible Combinations or Permutations 125
                4.10. Iterating Over the Index-Value Pairs of a Sequence 127
                4.11. Iterating Over Multiple Sequences Simultaneously 129
                4.12. Iterating on Items in Separate Containers 131
                4.13. Creating Data Processing Pipelines 132
                4.14, Flattening a Nested Sequence 135
                4.15, Iterating in Sorted Order Over Merged Sorted Iterables 136
                4.16. Replacing Infinite while Loops with an Iterator 138
            5. Files and I/O
                5.1. Reading and Writing Text Data 141
                5.2. Printing to a File 144
                5.3. Printing with a Different Separator or Line Ending 144
                5.4. Reading and Writing Binary Data 145
                5.5. Writing to a File That Doesn't Already Exist 147
                5.6. Performing I/O Operations on a String 148
                5.7. Reading and Writing Compressed Datafiles 149
                5.8. Iterating Over Fixed-Sized Records 151
                5.9. Reading Binary Data into a Mutable Buffer 152
                5.10. Memory Mapping Binary Files 153
                5.11. Manipulating Pathnames 156
                5.12. Testing for the Existence of a File 157
                5.13. Getting a Directory Listing 158
                5.14. Bypassing Filename Encoding 159
                5.15. Printing Bad Filenames 161
                5.16. Adding or Changing the Encoding of an Already Open File 163
                5.17. Writing Bytes to a Text File 165
                5.18. Wrapping an Existing File Descriptor As a File Object 166
                5.19. Making Temporary Files and Directories 167
                5.20. Communicating with Serial Ports 170
                5.21. Serializing Python Objects 171
            6. Data Encoding and Processing
                6.1. Reading and Writing CSV Data 175
                6.2. Reading and Writing JSON Data 179
                6.3. Parsing Simple XML Data 183
                6.4. Parsing Huge XML Files Incrementally 186
                6.5. Turning a Dictionary into XML 189
                6.6. Parsing, Modifying, and Rewriting XML 191
                6.7. Parsing XML Documents with Namespaces 193

                evince -p 4 doc_newest2019/pycb3.pdf & 

                6.8. Interacting with a Relational Database
                6.9. Decoding and Encoding Hexadecimal Digits
                6.10. Decoding and Encoding Base64
                6.11. Reading and Writing Binary Arrays of Structures
                6.12. Reading Nested and Variable-Sized Binary Structures
                6.13. Summarizing Data and Performing Statistics
            7. Functions
                7.1. Writing Functions That Accept Any Number of Arguments
                7.2. Writing Functions That Only Accept Keyword Arguments
                7.3. Attaching Informational Metadata to Function Arguments
                7.4. Returning Multiple Values from a Function
                7.5. Defining Functions with Default Arguments
                7.6. Defining Anonymous or Inline Functions
                7.7. Capturing Variables in Anonymous Functions
                7.8. Making an N-Argument Callable Work As a Callable with Fewer Arguments
                7.9. Replacing Single Method Classes with Functions
                7.10. Carrying Extra State with Callback Functions
                7.11. Inlining Callback Functions
                7.12. Accessing Variables Defined Inside a Closure
            8. Classes and Objects
                8.1. Changing the String Representation of Instances
                8.2. Customizing String Formatting
                8.3. Making Objects Support the Context-Management Protocol
                8.4. Saving Memory When Creating a Large Number of Instances
                8.5. Encapsulating Names in a Class
                8.6. Creating Managed Attributes
                8.7. Calling a Method on a Parent Class
                8.8. Extending a Property in a Subclass
                8.9. Creating a New Kind of Class or Instance Attribute
                8.10. Using Lazily Computed Properties
                8.11. Simplifying the Initialization of Data Structures
                8.12. Defining an Interface or Abstract Base Class
                8.13. Implementing a Data Model or Type System
                8.14. Implementing Custom Containers
                8.15. Delegating Attribute Access
                8.16. Defining More Than One Constructor in a Class
                8.17. Creating an Instance Without Invoking init
                8.18. Extending Classes with Mixins
                8.19. Implementing Stateful Objects or State Machines

                evince -p 5 doc_newest2019/pycb3.pdf & 

                8.20. Calling a Method on an Object Given the Name As a String 305
                8.21. Implementing the Visitor Pattern 306
                8.22. Implementing the Visitor Pattern Without Recursion 311
                8.23. Managing Memory in Cyclic Data Structures 317
                8.24. Making Classes Support Comparison Operations 321
                8.25. Creating Cached Instances 323
            9. Metaprogramming
                9.1. Putting a Wrapper Around a Function 329
                9.2. Preserving Function Metadata When Writing Decorators 331
                9.3. Unwrapping a Decorator 333
                9.4. Defining a Decorator That Takes Arguments 334
                9.5. Defining a Decorator with User Adjustable Attributes 336
                9.6. Defining a Decorator That Takes an Optional Argument 339
                9.7. Enforcing Type Checking on a Function Using a Decorator 341
                9.8. Defining Decorators As Part of a Class
                9.9. Defining Decorators As Classes 347
                9.10. Applying Decorators to Class and Static Methods 350
                9.11. Writing Decorators That Add Arguments to Wrapped Functions 352
                9.12. Using Decorators to Patch Class Definitions 355
                9.13. Using a Metaclass to Control Instance Creation 356
                9.14. Capturing Class Attribute Definition Order 359
                9.15. Defining a Metaclass That Takes Optional Arguments 362
                9.16. Enforcing an Argument Signature on *args and **kwargs 364
                9.17. Enforcing Coding Conventions in Classes 367
                9.18. Defining Classes Programmatically 370
                9.19. Initializing Class Members at Definition Time 374
                9.20. Implementing Multiple Dispatch with Function Annotations 376
                9,21. Avoiding Repetitive Property Methods 382
                9.22. Defining Context Managers the Easy Way 384
                9,23. Executing Code with Local Side Effects 386
                9,24. Parsing and Analyzing Python Source 389
                9.25. Disassembling Python Byte Code 393
            10. Modules and Packages
                10.1. Making a Hierarchical Package of Modules 397
                10.2. Controlling the Import of Everything 398
                10.3. Importing Package Submodules Using Relative Names 399
                10.4. Splitting a Module into Multiple Files 401
                10.5. Making Separate Directories of Code Import Under a Common Namespace 404
                10.6. Reloading Modules 406

                evince -p 6 doc_newest2019/pycb3.pdf & 

                10.7. Making a Directory or Zip File Runnable As a Main Script 407
                10.8. Reading Datafiles Within a Package 408
                10.9. Adding Directories to sys.path 409
                10.10. Importing Modules Using a Name Given in a String 411
                10.11. Loading Modules from a Remote Machine Using Import Hooks 412
                10.12. Patching Modules on Import 428
                10.13. Installing Packages Just for Yourself 431
                10.14. Creating a New Python Environment 432
                10.15. Distributing Packages 433
            11. Network and Web Programming
                11.1. Interacting with HTTP Services As a Client 437
                11.2. Creating a TCP Server 441
                11.3. Creating a UDP Server 445
                11.4. Generating a Range of IP Addresses from a CIDR Address 447
                11.5. Creating a Simple REST-Based Interface 449
                11.6. Implementing a Simple Remote Procedure Call with XML-RPC 454
                11.7. Communicating Simply Between Interpreters 456
                11.8. Implementing Remote Procedure Calls 458
                11.9. Authenticating Clients Simply 461
                11.10. Adding SSL to Network Services 464
                11.11. Passing a Socket File Descriptor Between Processes 470
                11.12. Understanding Event-Driven I/O 475
                11.13. Sending and Receiving Large Arrays 481
            12. Concurrency
                12.1. Starting and Stopping Threads 485
                12.2. Determining If a Thread Has Started 488
                12.3. Communicating Between Threads 49]
                12.4. Locking Critical Sections 497
                12.5. Locking with Deadlock Avoidance 500
                12.6. Storing Thread-Specific State 504
                12.7. Creating a Thread Pool 505
                12.8. Performing Simple Parallel Programming 509
                12.9. Dealing with the GIL (and How to Stop Worrying About It) 513
                12.10. Defining an Actor Task 516
                12.11. Implementing Publish/Subscribe Messaging 520
                12.12. Using Generators As an Alternative to Threads 524
                12.13. Polling Multiple Thread Queues 531
                12.14. Launching a Daemon Process on Unix 534

                evince -p 7 doc_newest2019/pycb3.pdf & 

            13. Utility Scripting and System Administration  @@
                13.1. Accepting Script Input via Redirection, Pipes, or Input Files
                13.2. Terminating a Program with an Error Message
                13.3. Parsing Command-Line Options
                13.4. Prompting for a Password at Runtime
                13.5. Getting the Terminal Size
                13.6. Executing an External Command and Getting Its Output
                13.7. Copying or Moving Files and Directories
                13.8. Creating and Unpacking Archives
                13.9. Finding Files by Name
                13.10. Reading Configuration Files
                13.11. Adding Logging to Simple Scripts
                13.12. Adding Logging to Libraries
                13.13. Making a Stopwatch Timer
                13.14. Putting Limits on Memory and CPU Usage
                13.15. Launching a Web Browser
            14. Testing, Debugging, and Exceptions
                14.1. Testing Output Sent to stdout
                14.2. Patching Objects in Unit Tests
                14.3. Testing for Exceptional Conditions in Unit Tests
                14.4. Logging Test Output to a File
                14.5. Skipping or Anticipating Test Failures
                14.6. Handling Multiple Exceptions
                14.7. Catching All Exceptions
                14.8. Creating Custom Exceptions
                14.9. Raising an Exception in Response to Another Exception
                14.10. Reraising the Last Exception
                14.11. Issuing Warning Messages
                14,12. Debugging Basic Program Crashes
                14.13. Profiling and Timing Your Program
                14.14. Making Your Programs Run Faster
            15. C Extensions
                15.1. Accessing C Code Using ctypes
                15.2. Writing a Simple C Extension Module
                15.3. Writing an Extension Function That Operates on Arrays
                15.4. Managing Opaque Pointers in C Extension Modules
                15.5. Defining and Exporting C APIs from Extension Modules
                15.6. Calling Python from C
                15.7. Releasing the GIL in C Extensions
                15.8. Mixing Threads from C and Python
                15.9. Wrapping C Code with Swig

                evince -p 8 doc_newest2019/pycb3.pdf & 

                15.10. Wrapping Existing C Code with Cython
                15.11. Using Cython to Write High-Performance Array Operations
                15.12. Turning a Function Pointer into a Callable
                15.13. Passing NULL-Terminated Strings to C Libraries
                15.14. Passing Unicode Strings to C Libraries 648
                15.15. Converting C Strings to Python 653
                15.16. Working with C Strings of Dubious Encoding 654
                15.17. Passing Filenames to C Extensions 657
                15.18. Passing Open Files to C Extensions 658
                15.19. Reading File-Like Objects from C 659
                15.20. Consuming an Iterable from C 662
                15.21. Diagnosing Segmentation Faults 663
pycb3-kil21
TODO: REVERSE REFLINKS-ORDER (=SHOULD BE PUT BELOW ITS' HEADING)
            Chapter 1 - Data Structures and Algorithms ----
                    evince -p 17 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.1. Unpacking a Sequence into Separate Variables
                    evince -p 20 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.2. Unpacking Elements from Iterables of Arbitrary Length
                    evince -p 26 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.3. Keeping the Last N Items
                    evince -p 29 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.4. Finding the Largest or Smallest N Items
                    evince -p 32 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.5. Implementing a Priority Queue
                    evince -p 37 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.6. Mapping Keys to Multiple Values in a Dictionary
                    evince -p 41 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.7. Keeping Dictionaries in Order
                    evince -p 43 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.8. Calculating with Dictionaries
                    evince -p 47 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.9. Finding Commonialities in Two Dictionaries
                    evince -p 49 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.10. Removing Duplicates from a Sequence while Maintaining Order
                    evince -p 52 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.11. Naming a Slice
                    evince -p 56 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.12. Determining the Most Frequently Occurring Items in a Sequence
                    evince -p 59 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.13. Sorting a List of Dictionaries by a Common Key
                    evince -p 63 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.14. Sorting Objects Without Native Comparison Support
                    evince -p 65 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.15. Grouping Records Together Based on a Field
                    evince -p 68 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                    1.6. For example:
                    evince -p 69 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.16. Filtering Sequence Elements
                    evince -p 73 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.17. Extracting a Subset of a Dictionary
                    evince -p 75 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.18. Mapping Names to Sequence Elements
                    evince -p 81 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.19. Transforming and Reducing Data at the Same Time
                    evince -p 84 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                1.20. Combining Multiple Mappings into a Single Mapping
                    evince -p 89 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            2 Strings
                    evince -p 93 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.1. Splitting Strings on Any of Multiple Delimiters
                    evince -p 94 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.2. Matching Text at the Start or End of a String
                    evince -p 97 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.3. Matching Strings Using Shell Wildcard Patterns
                    evince -p 100 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.4. Matching and Searching for Text Patterns
                    evince -p 107 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.5. Searching and Replacing Text
                    evince -p 110 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.6. Searching and Replacing Case-Insensitive Text
                    evince -p 112 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.7. Specifying a Regular Expression for the Shortest Match
                    evince -p 114 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.8. Writing a Regular Expression for Multiline Patterns
                    evince -p 116 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.9. Normalizing Unicode Text to a Standard Representation
                    evince -p 121 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.10. Working with Unicode Characters in Regular Expressions
                    evince -p 123 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.11. Stripping Unwanted Characters from Strings Problem
                    evince -p 126 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.12. Sanitizing and Cleaning Up Text
                    evince -p 131 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.13. Aligning Text Strings
                    evince -p 134 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.14. Combining and Concatenating Strings
                    evince -p 137 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                    1.19. For example:
                    evince -p 140 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.15. Interpolating Variables in Strings
                    evince -p 145 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.16. Reformatting Text to a Fixed Number of Columns
                    evince -p 148 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.17. Handling HTML and XML Entities in Text
                    evince -p 151 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.18. Tokenizing Text
                    evince -p 156 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.19. Writing a Simple Recursive Descent Parser
                    evince -p 176 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                2.20. Performing Text Operations on Byte Strings
                evince -p 183 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            3 Numbers
                    evince -p 183 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.1. Rounding Numerical Values
                    evince -p 186 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.2. Performing Accurate Decimal Calculations
                    evince -p 191 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.3. Formatting Numbers for Output
                    evince -p 194 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.4. Working with Binary, Octal, and Hexadecimal Integers
                    evince -p 198 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.5. Packing and Unpacking Large Integers from Bytes
                    evince -p 201 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.6. Performing Complex-Valued Math
                    evince -p 205 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.7. Working with Infinity and NaNs
                    evince -p 208 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.8. Calculating with Fractions
                    evince -p 210 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.9. Calculating with Large Numerical Arrays
                    evince -p 218 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.10. Performing Matrix and Linear Algebra Calculations
                    evince -p 221 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.11. Picking Things at Random
                    evince -p 225 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.12. Converting Days to Seconds, and Other Basic Time Conversions
                    evince -p 229 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.13. Determining Last Friday's Date
                    evince -p 232 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.14. Finding the Date Range for the Current Month
                    evince -p 236 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.15. Converting Strings into Datetimes
                    evince -p 239 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                3.16. Manipulating Dates Involving Time Zones
                    evince -p 243 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            4 Iterators
                    evince -p 243 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.1. Manually Consuming an Iterator
                    evince -p 246 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.2. Delegating Iteration
                    evince -p 248 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.3. Creating New Iteration Patterns with Generators
                    evince -p 251 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.4. Implementing the Iterator Protocol
                    evince -p 256 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.5. Iterating in Reverse
                    evince -p 258 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.6. Defining Generator Functions with Extra State
                    evince -p 261 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.7. Taking a Slice of an Iterator
                    evince -p 263 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.8. Skipping the First Part of an Iterable
                    evince -p 268 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.9. Iterating Over All Possible Combinations or Permutations
                    evince -p 271 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.10. Iterating Over the Index-Value Pairs of a Sequence
                    evince -p 276 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.11. Iterating Over Multiple Sequences Simultaneously
                    evince -p 280 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.12. Iterating on Items in Separate Containers
                    evince -p 283 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.13. Creating Data Processing Pipelines
                    evince -p 289 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.14. Flattening a Nested Sequence
                    evince -p 292 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.15. Iterating in Sorted Order Over Merged Sorted Iterables
                    evince -p 294 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                4.16. Replacing Infinite while Loops with an Iterator
            5 Files and IO
                    evince -p 297 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.1. Reading and Writing Text Data
                    evince -p 303 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.2. Printing to a File
                    evince -p 304 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.3. Printing with a Different Separator or Line Ending
                    evince -p 306 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.4. Reading and Writing Binary Data
                    evince -p 310 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.5. Writing to a File That Doesn't Already Exist
                    evince -p 312 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.6. Performing I/O Operations on a String
                    evince -p 314 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.7. Reading and Writing Compressed Datafiles
                    evince -p 317 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.8. Iterating Over Fixed-Sized Records
                    evince -p 318 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.9. Reading Binary Data into a Mutable Buffer
                    evince -p 322 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.10. Memory Mapping Binary Files
                    evince -p 327 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.11. Manipulating Pathnames
                    evince -p 329 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.12. Testing for the Existence of a File
                    evince -p 331 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.13. Getting a Directory Listing
                    evince -p 335 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.14. Bypassing Filename Encoding
                    evince -p 337 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.15. Printing Bad Filenames
                    evince -p 341 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.16. Adding or Changing the Encoding of an Already Open File
                    evince -p 346 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.17. Writing Bytes to a Text File
                    evince -p 347 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.18. Wrapping an Existing File Descriptor As a File Object
                    evince -p 351 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.19. Making Temporary Files and Directories
                    evince -p 356 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.20. Communicating with Serial Ports
                    evince -p 358 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                5.21. Serializing Python Objects
                evince -p 367 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            6 Data Encoding and Processing
                    evince -p 367 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                6.1. Reading and Writing CSV Data
                    evince -p 375 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                6.2. Reading and Writing JSON Data
                    evince -p 384 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                6.3. Parsing Simple XML Data
                    evince -p 391 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                6.4. Parsing Huge XML Files Incrementally
                    evince -p 399 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                6.5. Turning a Dictionary into XML
                    evince -p 403 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                6.6. Parsing, Modifying, and Rewriting XML
                    evince -p 406 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                6.7. Parsing XML Documents with Namespaces
                    evince -p 411 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                6.8. Interacting with a Relational Database Problem
                    evince -p 416 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                6.9. Decoding and Encoding Hexadecimal Digits
                    evince -p 418 ~/empire/doks/comp/lang/py/pycb3kil.pdf &
                6.10. Decoding and Encoding Base64
                    evince -p 420 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                6.11. Reading and Writing Binary Arrays of Structures
                    evince -p 429 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                6.12. Reading Nested and Variable-Sized Binary Structures
                    evince -p 451 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                6.13. Summarizing Data and Performing Statistics
            7 Functions
                    evince -p 457 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                7.1. Writing Functions That Accept Any Number of Arguments
                    evince -p 460 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                7.2. Writing Functions That Only Accept Keyword Arguments
                    evince -p 462 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                7.3. Attaching Informational Metadata to Function Arguments
                    evince -p 464 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                7.4. Returning Multiple Values from a Function
                    evince -p 466 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                7.5. Defining Functions with Default Arguments
                    evince -p 472 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                7.6. Defining Anonymous or Inline Functions
                    evince -p 474 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                7.7. Capturing Variables in Anonymous Functions
                    evince -p 477 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                7.8. Making an N-Argument Callable Work As a Callable with Fewer Arguments
                    evince -p 485 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                7.9. Replacing Single Method Classes with Functions
                    evince -p 487 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                7.10. Carrying Extra State with Callback Functions
                    evince -p 494 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                7.11. Inlining Callback Functions
                    evince -p 500 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                7.12. Accessing Variables Defined Inside a Closure
            8 Classes and Objects
                    evince -p 507 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.1. Changing the String Representation of Instances
                    evince -p 510 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.2. Customizing String Formatting
                    evince -p 513 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.3. Making Objects Support the Context-Management Protocol
                    evince -p 518 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.4. Saving Memory When Creating a Large Number of Instances
                    evince -p 520 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.5. Encapsulating Names in a Class
                    evince -p 524 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.6. Creating Managed Attributes
                    evince -p 533 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.7. Calling a Method on a Parent Class
                    evince -p 542 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.8. Extending a Property in a Subclass
                    evince -p 550 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.9. Creating a New Kind of Class or Instance Attribute
                    evince -p 557 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.10. Using Lazily Computed Properties
                    evince -p 563 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.11. Simplifying the Initialization of Data Structures
                    evince -p 572 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.12. Defining an Interface or Abstract Base Class
                    evince -p 577 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.13. Implementing a Data Model or Type System
                    evince -p 590 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.14. Implementing Custom Containers
                    evince -p 598 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.15. Delegating Attribute Access
                    evince -p 608 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.16. Defining More Than One Constructor in a Class
                    evince -p 611 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.17. Creating an Instance Without Invoking init
                    evince -p 614 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.18. Extending Classes with Mixins
                    evince -p 625 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.19. Implementing Stateful Objects or State Machines
                    evince -p 637 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.20. Calling a Method on an Object Given the Name As a String
                    evince -p 639 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.21. Implementing the Visitor Pattern
                    evince -p 649 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.22. Implementing the Visitor Pattern Without Recursion
                    evince -p 663 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.23. Managing Memory in Cyclic Data Structures
                    evince -p 670 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.24. Making Classes Support Comparison Operations
                    evince -p 675 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                8.25. Creating Cached Instances
            9 Metaprogramming
                    evince -p 685 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.1. Putting a Wrapper Around a Function
                    evince -p 689 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.2. Preserving Function Metadata When Writing Decorators
                    evince -p 693 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.3. Unwrapping a Decorator
                    evince -p 696 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.4. Defining a Decorator That Takes Arguments
                    evince -p 699 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.5. Defining a Decorator with User Adjustable Attributes
                    evince -p 705 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.6. Defining a Decorator That Takes an Optional Argument
                    evince -p 709 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.7. Enforcing Type Checking on a Function Using a Decorator
                    evince -p 718 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.8. Defining Decorators As Part of a Class
                    evince -p 722 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.9. Defining Decorators As Classes
                    evince -p 727 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.10. Applying Decorators to Class and Static Methods Problem
                    evince -p 732 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.11. Writing Decorators That Add Arguments to Wrapped Functions
                    evince -p 737 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.12. Using Decorators to Patch Class Definitions
                    evince -p 740 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.13. Using a Metaclass to Control Instance Creation
                    evince -p 746 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.14. Capturing Class Attribute Definition Order
                    evince -p 752 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.15. Defining a Metaclass That Takes Optional Arguments
                    evince -p 756 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.16. Enforcing an Argument Signature on *args and **kwargs
                    evince -p 764 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.17. Enforcing Coding Conventions in Classes
                    evince -p 770 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.18. Defining Classes Programmatically
                    evince -p 777 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.19. Initializing Class Members at Definition Time
                    evince -p 781 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.20. Implementing Multiple Dispatch with Function Annotations
                    evince -p 795 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.21. Avoiding Repetitive Property Methods
                    evince -p 799 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.22. Defining Context Managers the Easy Way
                    evince -p 803 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.23. Executing Code with Local Side Effects
                    evince -p 808 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.24. Parsing and Analyzing Python Source
                    evince -p 817 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
                9.25. Disassembling Python Byte Code
                    evince -p 1515 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            --
            1.1. Unpacking a Sequence into Separate Variables
            1.2. Unpacking Elements from Iterables of Arbitrary Length
            1.3. Keeping the Last N Items
            1.4. Finding the Largest or Smallest N Items
            1.5. Implementing a Priority Queue
            1.6. Mapping Keys to Multiple Values in a Dictionary
                evince -p 1516 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            1.7. Keeping Dictionaries in Order
            1.8. Calculating with Dictionaries
            1.9. Finding Commonalities in Two Dictionaries
            1.10. Removing Duplicates from _a Sequence while Maintainin:
            1.11. Naming a Slice
            1.12. Determining the Most Frequently Occurring Items in a
            1.13. Sorting a List of Dictionaries by a Common Key
            1.14. Sorting Objects Without Native Comparison Support
            1.15. Grouping Records Together Based on a Field
            1.16. Filtering Sequence Elements
            1.17. Extracting a Subset of a Dictionary
            1.18. Mapping Names to Sequence Elements
            1.19. Transforming and Reducing Data at the Same Time
            1.20. Combining Multiple Mappings into a Single Mapping
            2.1. Splitting Strings on Any of Multiple Delimiters
            2.2. Matching Text at the Start or End of a String
                evince -p 1517 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            2.3. Matching Strings Using Shell Wildcard Patterns
            2.4. Matching and Searching for Text Patterns
            2.5. Searching and Replacing Text
            2.6. Searching and Replacing Case-Insensitive Text
            2.7. Specifying a Regular Expression for the Shortest Match
            2.8. Writing a Regular Expression for Multiline Patterns
            2.9. Normalizing Unicode Text to a Standard Representation
            2.10. Working with Unicode Characters in Regular Expressions
            2.11. Stripping Unwanted Characters from Strings
            2.12. Sanitizing and Cleaning Up Text
            2.13. Aligning Text Strings
            2.14. Combining and Concatenating Strings
            2.15. Interpolating Variables in Strings
            2.16. Reformatting Text to a Fixed Number of Columns
            2.17. Handling HTML and XML Entities in Text
            2.18. Tokenizing Text
            2.19. Writing a Simple Recursive Descent Parser
            2.20. Performing Text Operations on Byte Strings
                evince -p 1518 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            3.1. Rounding Numerical Values
            3.2. Performing Accurate Decimal Calculations
            3.3. Formatting Numbers for Output
            3.4. Working with Binary, Octal, and Hexadecimal Integers
            3.5. Packing and Unpacking Large Integers from Bytes
            3.6. Performing Complex-Valued Math
            3.7. Working with Infinity and NaNs
            3.8. Calculating with Fractions
            3.9. Calculating with Large Numerical Arrays
            3.10. Performing Matrix and Linear Algebra Calculations
            3.11. Picking Things at Random
            3.12. Converting Days to Seconds, and Other Basic Time
            3.13. Determining Last Friday's Date
            3.14. Finding the Date Range for the Current Month
            3.15. Converting Strings into Datetimes
            3.16. Manipulating Dates Involving Time Zones
            4.1. Manually Consuming an Iterator
                evince -p 1519 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            4.2. Delegating Iteration
            4.3. Creating New Iteration Patterns with Generators
            4.4. Implementing the Iterator Protocol
            4.5. Iterating in Reverse
            4.6. Defining Generator Functions with Extra State
            4.7. Taking a Slice of an Iterator
            4.8. Skipping the First Part of an Iterable
            4.9. Iterating Over All Possible Combinations or Permutations
            4.10. Iterating Over the Index-Value Pairs of a Sequence
            4.11. Iterating Over Multiple Sequences Simultaneously
            4.12. Iterating on Items in Separate Containers
            4.13. Creating Data Processing Pipelines
            4.14. Flattening a Nested Sequence
            4.15. Iterating in Sorted Order Over Merged Sorted Iterables
            4.16. Replacing Infinite while Loops with an Iterator
            5.1. Reading and Writing Text Data
            5.2. Printing to a File
            5.3. Printing with a Different Separator or Line Ending
                evince -p 1520 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            5.4. Reading and Writing Binary Data
            5.5. Writing to a File That Doesn't Already Exist
            5.6. Performing I/O Operations on a String
            5.7. Reading and Writing Compressed Datafiles
            5.8. Iterating Over Fixed-Sized Records
            5.9. Reading Binary Data into a Mutable Buffer
            5.10. Memory Mapping Binary Files
            5.11. Manipulating Pathnames
            5.12. Testing for the Existence of a File
            5.13. Getting a Directory Listing
            5.14. Bypassing Filename Encoding
            5.15. Printing Bad Filenames
            5.16. Adding or Changing the Encoding of an Already Open File
            5.17. Writing Bytes to a Text File
            5.18. Wrapping an Existing File Descriptor As a File Object
            5.19. Making Temporary Files and Directories
            5.20. Communicating with Serial Ports
            5.21. Serializing Python Objects
                evince -p 1521 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            6.1. Reading and Writing CSV Data
            6.2. Reading and Writing JSON Data
            6.3. Parsing Simple XML Data
            6.4. Parsing Huge XML Files Incrementally
            6.5. Turning a Dictionary into XML
            6.6. Parsing, Modifying, and Rewriting XML
            6.7. Parsing XML Documents with Namespaces
            6.8. Interacting with a Relational Database
            6.9. Decoding and Encoding Hexadecimal Digits
            6.10. Decoding and Encoding Base64
            6.11. Reading and Writing Binary Arrays of Structures
            6.12. Reading Nested and Variable-Sized Binary Structures
            6.13. Summarizing Data and Performing Statistics
            7.1. Writing Functions That Accept Any Number of Arguments
            7.2. Writing Functions That Only Accept Keyword Arguments
            7.3. Attaching Informational Metadata to Function Arguments
            7.4. Returning Multiple Values from a Function
            7.5. Defining Functions with Default Arguments
                evince -p 1522 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            7.6. Defining Anonymous or Inline Functions
            7.7. Capturing Variables in Anonymous Functions
            7.8. Making an N-Argument Callable Work As a Callable with
            7.9. Replacing Single Method Classes with Functions
            7.10. Carrying Extra State with Callback Functions
            7.11. Inlining Callback Functions
            7.12. Accessing Variables Defined Inside a Closure
            8.1. Changing the String Representation of Instances
            8.2. Customizing String Formatting
            8.3. Making Objects Support the Context-Management Protocol
            8.4. Saving Memory When Creating a Large Number of Instances
            8.5. Encapsulating Names in a Class
            8.6. Creating Managed Attributes
            8.7. Calling a Method on a Parent Class
            8.8. Extending a Property in a Subclass
            8.9. Creating a New Kind of Class or Instance Attribute
            8.10. Using Lazily Computed Properties
                evince -p 1523 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            8.11. Simplifying the Initialization of Data Structures
            8.12. Defining an Interface or Abstract Base Class
            8.13. Implementing a Data Model or Type System
            8.14. Implementing Custom Containers
            8.15. Delegating Attribute Access
            8.16. Defining More Than One Constructor in a Class
            8.17. Creating an Instance Without Invoking init
            8.18. Extending Classes with Mixins
            8.19. Implementing Stateful Objects or State Machines
            8.20. Calling a Method on an Object Given the Name As a String
            8.21. Implementing the Visitor Pattern
            8.22. Implementing the Visitor Pattern Without Recursion
            8.23. Managing Memory in Cyclic Data Structures
            8.24. Making Classes Support Comparison Operations
            8.25. Creating Cached Instances
            9.1. Putting a Wrapper Around a Function
            9.2. Preserving Function Metadata When Writing Decorators
            9.3. Unwrapping a Decorator
                evince -p 1524 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            9.4. Defining a Decorator That Takes Arguments
            9.5. Defining a Decorator with User Adjustable Attributes
            9.6. Defining a Decorator That Takes an Optional Argument
            9.7. Enforcing Type Checking on a Function Using a Decorator
            9.8. Defining Decorators As Part of a Class
            9.9. Defining Decorators As Classes
            9.10. Applying Decorators to Class and Static Methods
            9.11. Writing Decorators That Add Arguments to Wrapped
            9.12. Using Decorators to Patch Class Definitions
            9.13. Using a Metaclass to Control Instance Creation
            9.14. Capturing Class Attribute Definition Order
            9.15. Defining a Metaclass That Takes Optional Arguments
            9.16. Enforcing an Argument Signature on 'args and **kwargs
            9.17. Enforcing Coding Conventions in Classes
            9.18. Defining Classes Programmatically
            9.19. Initializing Class Members at Definition Time
            9.20. Implementing Multiple Dispatch with Function Annotations
            9.21. Avoiding Repetitive Property Methods
                evince -p 1525 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
            9.22. Defining Context Managers the Easy Wa
            9.23. Executing Code with Local Side Effects
            9.24. Parsing and Analyzing Python Source
            9.25. Disassembling Python Byte Code
                evince -p 1526 ~/Empire/Doks/Comp/lang/py/pycb3kil.pdf &
modpy-cb
            Chapter 1: Numbers, Strings, and Tuples  1
            Introduction  6
            Creating meaningful names and using variables  6
            Choosing names wisely  7
            Assigning names to objects  7
            Working with large and small integers  8
            Choosing between float, decimal, and fraction  8
            Doing currency calculations  10
            Fraction calculations  11
            Floating-point approximations  12
            Converting numbers from one type to another  12
            Choosing between true division and floor division  13
            Doing floor division  13
            Doing true division  13
            Rational fraction calculations  14
            Rewriting an immutable string  16
            Slicing a piece of a string
            Updating a string with a replacement
            Making a string all lowercase
            Removing extra punctuation marks
            String parsing with regular expressions
            Building complex strings with “template”.format()
            Building complex strings from lists of characters
            Using the Unicode characters that aren't on our keyboards
            Encoding strings - creating ASCII and UTF-8 bytes
            Decoding bytes - how to get proper characters from some bytes
            Using tuples of items
            Creating tuples
            Extracting items from a tuple
            Chapter 2: Statements and Syntax
            Writing Python script and module files - syntax basics
            Writing long lines of code
            Using backslash to break a long statement into logical lines
            Using the () characters to break a long statement into sensible pieces
            Using string literal concatenation
            Assigning intermediate results to separate variables
            Including descriptions and documentation
            Writing docstrings for scripts
            Writing docstrings for library modules
            Writing better RST markup in docstrings
            Using directives
            Using inline markup
            Designing complex if…elif chains
            Designing a while statement which terminates properly
            Avoiding a potential problem with break statements
            Leveraging the exception matching rules
            Avoiding a potential problem with an except: clause
            Chaining exceptions with the raise from statement
            Managing a context using the with statement
            Chapter 3: Function Definitions  111
            Designing functions with optional parameters
            Particular to General Design
            General to Particular design
            Using super flexible keyword parameters
            Forcing keyword-only arguments with the * separator
            Writing explicit types on function parameters
            Picking an order for parameters based on partial functions
            Wrapping a function
            Creating a partial function with keyword parameters
            Creating a partial function with positional parameters
            Writing clear documentation strings with RST markup
            Designing recursive functions around Python's stack limits
            Writing reusable scripts with the script library switch
            Chapter 4: Built-in Data Structures - list, set, dict
            Building lists - literals, appending, and comprehensions
            Building a list with the append() method
            Writing a list comprehension
            Using the list function on a generator expression
            Other ways to extend a list
            Slicing and dicing a list
            Deleting from a list - deleting, removing, popping, and filtering
            Deleting items from a list
            The remove() method
            The pop() method
            The filter() function
            Reversing a copy of a list
            Using set methods and operators
            Removing items from a set - remove(), pop(), and difference
            Creating dictionaries - inserting and updating
            Removing from dictionaries - the pop() method and the del statement
            Controlling the order of dict keys
            Handling dictionaries and sets in doctest examples
            Understanding variables, references, and assignment
            Making shallow and deep copies of objects
            Avoiding mutable default values for function parameters
            Chapter 5: User Inputs and Outputs
            Using features of the print() function
            Using input() and getpass() for user input
            Input string parsing
            Interaction via the cmd module
            Debugging with “format”.format_map(vars())
            Using argparse to get command-line input
            Using cmd for creating command-line applications
            Using the OS environment settings
            Chapter 6: Basics of Classes and Objects
            Using a class to encapsulate data and processing
            Designing classes with lots of processing
            Designing classes with little unique processing
            Stateful objects with a new class
            Stateful objects using an existing class
            Optimizing small objects with __slots__
            Using more sophisticated collections
            Extending a collection - a list that does statistics
            Using properties for lazy attributes
            Using settable properties to update eager attributes
            Chapter 7: More Advanced Class Design
            Choosing between inheritance and extension - the is-a question
            Wrapping - aggregation and composition
            Extending - inheritance
            Separating concerns via multiple inheritance
            Leveraging Python's duck typing
            Managing global and singleton objects
            Module global variable
            Class-level static variable
            Using more complex structures - maps of lists
            Creating a class that has orderable objects
            Defining an ordered collection
            Deleting from a list of mappings
            Chapter 8: Functional and Reactive Programming Features
            Writing generator functions with the yield statement
            Using stacked generator expressions
            Namespace instead of list
            Applying transformations to a collection
            Chapter 9: Input/Output, Physical Format, and Logical Layout
            Using pathlib to work with filenames
            Making the output filename by changing the input suffix
            Making a number of sibling output files with distinct names
            Creating a directory and a number of files
            Comparing file dates to see which is newer
            Removing a file
            Finding all files that match a given pattern
            Reading and writing files with context managers
            Replacing a file while preserving the previous version
            Reading delimited files with the CSV module
            Reading complex formats using regular expressions
            Chapter 10: Statistical Programming and Linear Regression
            Using the built-in statistics library
            Average of values in a Counter
            Computing the coefficient of a correlation
            Computing regression parameters
            Computing an autocorrelation
            Long-term model
            Confirming that the data is random - the null hypothesis
            Locating outliers
            Analyzing many variables in one pass
            Using map()
            Chapter 11: Testing
            Introduction
            Using docstrings for testing
            Writing examples for stateless functions
            Writing examples for stateful objects
            Testing functions that raise exceptions
            Handling common doctest issues
            Writing doctest examples for mapping or set values
            Writing doctest examples for floating-point values
            Creating separate test modules and packages
            Some other assertions
            Separate tests directory
            Combining unittest and doctest tests
            Testing things that involve dates or times
            Testing things that involve randomness
            Mocking external resources
            Creating an entry document in the entrylog collection
            Seeing a typical response
            Client class for database access
            Creating a context manager
            Creating a dynamic, stateful test
            Mocking a complex object
            Using the load_tests protocol
            Chapter 12: Web Services
            Implementing web services with WSGI
            Using the Flask framework for RESTful APIs
            Parsing the query string in a request
            Making REST requests with urllib
            The OpenAPI (Swagger) specification
            Adding Swagger to the server
            Parsing the URL path
            Server
            Client
            Deck slicing
            Client side
            Providing a Swagger specification
            Using a Swagger specification
            Parsing a JSON request
            Swagger specification
            Client
            Location header
            Additional resources
            Query for a specific player
            Exception handling
            Implementing authentication for web services
            Configuring SSL
            Users and credentials
            Flask view function decorator
            Defining the User class
            Defining a view decorator
            Creating the server
            Creating an example client
            Creating a command-line interface
            Building the Authentication header
            Chapter 13: Application Integration
            Finding configuration files
            Getting ready
            Why so many choices?
            Using YAML for configuration files
            Using Python for configuration files
            Using class-as-namespace for configuration
            Configuration representation
            Designing scripts for composition
            Designing as a class hierarchy
            Using logging for control and audit output
            Combining two applications into one
            Concurrency
            Logging
            Combining many applications using the Command design pattern
            Managing arguments and configuration in composite applications
            The Command design pattern
            Wrapping and combining CLI applications
            Wrapping a program and checking the output
            Controlling complex sequences of steps
            Building conditional processing

~/Dropbox/rsc/Doks/phone/Comp/lang/py/py3aut.tags1.txt  ¤¤¤
            Part I: Python Programming Basics   11
            1 - Python Basics   13 ----
            Entering Expressions into the Interactive Shell  14
            The Integer, Floating-Point, and String Data Types  16
            String Concatenation and Replication   17
            Storing Values in Variables   18
              Assignment Statements  18
              Variable Names   20
            Your First Program  21
            Dissecting Your Program   22
              Comments  23
              The print() Function  23
              The input() Function   23
              Printing the User’s Name  24
              The len() Function  24
              The str(), int(), and float() Functions  25
            2 - Flow Control  31 ----
            Boolean Values  32
            Comparison Operators   33
            Boolean Operators  35
              Binary Boolean Operators  35
              The not Operator  36
            Mixing Boolean and Comparison Operators   36
            Elements of Flow Control  37
              Conditions   37
              Blocks of Code   37
            Program Execution   38
            Flow Control Statements  38
              if Statements   38
              else Statements   39
              elif Statements  40
              while Loop Statements   45
              break Statements  49
              continue Statements   50
              for Loops and the range() Function  53
            Importing Modules   57
              from import Statements  58
            Ending a Program Early with sys.exit()  58
            3 - Functions   61 ----
            def Statements with Parameters  63
            Return Values and return Statements   63
            The None Value  65
            Keyword Arguments and print()   65
              Local and Global Scope   67
              Local Variables Cannot Be Used in the Global Scope  67
              Local Scopes Cannot Use Variables in Other Local Scopes  68
              Global Variables Can Be Read from a Local Scope  69
              Local and Global Variables with the Same Name   69
            The global Statement  70
            Exception Handling  72
            A Short Program: Guess the Number  74
            Summary  76
            Practice Questions  76
            Practice Projects  77
              The Collatz Sequence  77
              Input Validation  77
            4 - Lists   79 ----
            The List Data Type  80
              Getting Individual Values in a List with Indexes   80
              Negative Indexes  82
              Getting Sublists with Slices   82
              Getting a List’s Length with len()  83
              Changing Values in a List with Indexes  83
              List Concatenation and List Replication  83
              Removing Values from Lists with del Statements  84
            Working with Lists  84
              Using for Loops with Lists   86
              The in and not in Operators   87
              The Multiple Assignment Trick   87
            Augmented Assignment Operators   88
            Methods   89
              Finding a Value in a List with the index() Method  89
              Adding Values to Lists with the append() and insert() Methods  89
              Removing Values from Lists with remove()   90
              Sorting the Values in a List with the sort() Method  91
            Example Program: Magic 8 Ball with a List  92
            List-like Types: Strings and Tuples   93
              Mutable and Immutable Data Types  94
              The Tuple Data Type  96
              Converting Types with the list() and tuple() Functions  97
            References  97
              Passing References  100
              The copy Module’s copy() and deepcopy() Functions  100
            Summary  101
            Practice Questions  102
            Practice Projects  102
              Comma Code  102
              Character Picture Grid  103
            5 - Dictionaries and Structuring Data   105 ----
            The Dictionary Data Type  105
              Dictionaries vs. Lists  106
              The keys(), values(), and items() Methods  107
              Checking Whether a Key or Value Exists in a Dictionary  109
              The get() Method  109
              The setdefault() Method  110
            Pretty Printing  111
            Using Data Structures to Model Real-World Things   112
              A Tic-Tac-Toe Board  113
              Nested Dictionaries and Lists  117
            Summary  119
            Practice Questions  119
            Practice Projects  120
              Fantasy Game Inventory  120
              List to Dictionary Function for Fantasy Game Inventory   120
            6 - Manipulating Strings   123 ----
            Working with Strings  123
              String Literals  124
              Indexing and Slicing Strings   126
              The in and not in Operators with Strings  127
            Useful String Methods  127
              The upper(), lower(), isupper(), and islower() String Methods  128
              The isX String Methods  129
              The startswith() and endswith() String Methods  131
              The join() and split() String Methods  131
              Justifying Text with rjust(), ljust(), and center()  133
              Removing Whitespace with strip(), rstrip(), and lstrip()  134
              Copying and Pasting Strings with the pyperclip Module  135
            Project: Password Locker   136
              Step 1: Program Design and Data Structures  136
              Step 2: Handle Command Line Arguments   137
              Step 3: Copy the Right Password  137
            Project: Adding Bullets to Wiki Markup  139
              Step 1: Copy and Paste from the Clipboard   139
              Step 2: Separate the Lines of Text and Add the Star  140
              Step 3: Join the Modified Lines   141
            Summary  141
            Practice Questions  142
            Practice Project  142
              Table Printer   142
            Part II: Automating Tasks   145
            7 - Pattern Matching with Regular Expressions  147 ----
            Finding Patterns of Text Without Regular Expressions  148
            Finding Patterns of Text with Regular Expressions   150
              Creating Regex Objects   150
              Matching Regex Objects   151
              Review of Regular Expression Matching   152
            More Pattern Matching with Regular Expressions   152
              Grouping with Parentheses  152
              Matching Multiple Groups with the Pipe  153
              Optional Matching with the Question Mark  154
              Matching Zero or More with the Star  155
              Matching One or More with the Plus   155
              Matching Specific Repetitions with Curly Brackets   156
            Greedy and Nongreedy Matching   156
            The findall() Method   157
            Character Classes  158
            Making Your Own Character Classes  159
            The Caret and Dollar Sign Characters  159
            The Wildcard Character   160
              Matching Everything with Dot-Star   161
              Matching Newlines with the Dot Character  162
            Review of Regex Symbols  162
            Case-Insensitive Matching   163
            Substituting Strings with the sub() Method  163
            Managing Complex Regexes  164
            Combining re.IGNORECASE, re.DOTALL, and re.VERBOSE  164
            Project: Phone Number and Email Address Extractor  165
              Step 1: Create a Regex for Phone Numbers   166
              Step 2: Create a Regex for Email Addresses  166
              Step 3: Find All Matches in the Clipboard Text   167
              Step 4: Join the Matches into a String for the Clipboard  168
              Running the Program   169
              Ideas for Similar Programs   169
            Summary  169
            Practice Questions  170
            Practice Projects  171
              Strong Password Detection   171
              Regex Version of strip()  171
            8 - Reading and Writing Files  173 ----
            Files and File Paths  173
              Backslash on Windows and Forward Slash on OS X and Linux  174
              The Current Working Directory   175
              Absolute vs. Relative Paths   175
              Creating New Folders with os.makedirs()   176
            The os.path Module  177
              Handling Absolute and Relative Paths  177
              Finding File Sizes and Folder Contents  179
              Checking Path Validity  180
            The File Reading/Writing Process  180
              Opening Files with the open() Function  181
              Reading the Contents of Files  182
              Writing to Files   183
            Saving Variables with the shelve Module  184
            Saving Variables with the pprint.pformat() Function  185
            Project: Generating Random Quiz Files  186
              Step 1: Store the Quiz Data in a Dictionary  187
              Step 2: Create the Quiz File and Shuffle the Question Order  188
              Step 3: Create the Answer Options   189
              Step 4: Write Content to the Quiz and Answer Key Files   189
            Project: Multiclipboard  191
              Step 1: Comments and Shelf Setup  192
              Step 2: Save Clipboard Content with a Keyword  192
              Step 3: List Keywords and Load a Keyword’s Content  193
            Summary  194
            Practice Questions  194
            Practice Projects  194
              Extending the Multiclipboard  194
              Mad Libs  195
              Regex Search   195
            9 - Organizing Files  197 ----
            The shutil Module   198
              Copying Files and Folders  198
              Moving and Renaming Files and Folders  199
              Permanently Deleting Files and Folders  200
              Safe Deletes with the send2trash Module   201
            Walking a Directory Tree  202
            Compressing Files with the zipfile Module  203
              Reading ZIP Files  204
              Extracting from ZIP Files   205
              Creating and Adding to ZIP Files  205
            Project: Renaming Files with American-Style Dates to
             European-Style Dates   206
              Step 1: Create a Regex for American-Style Dates  206
              Step 2: Identify the Date Parts from the Filenames   207
              Step 3: Form the New Filename and Rename the Files  209
              Ideas for Similar Programs   209
            Project: Backing Up a Folder into a ZIP File   209
              Step 1: Figure Out the ZIP File’s Name  210
              Step 2: Create the New ZIP File  211
              Step 3: Walk the Directory Tree and Add to the ZIP File  211
              Ideas for Similar Programs   212
            Summary  212
            Practice Questions  213
            Practice Projects  213
              Selective Copy  213
              Deleting Unneeded Files  213
              Filling in the Gaps  214
            10 - Debugging  215 ----
            Raising Exceptions   216
            Getting the Traceback as a String  217
            Assertions   219
              Using an Assertion in a Traffic Light Simulation   219
              Disabling Assertions  221
            Logging  221
              Using the logging Module  221
              Don’t Debug with print()  223
              Logging Levels  223
              Disabling Logging   224
              Logging to a File   225
            IDLE’s Debugger  225
              Go  226
              Step  226
              Over   226
              Out   227
              Quit  227
              Debugging a Number Adding Program   227
              Breakpoints  229
            Summary  231
            Practice Questions  231
            Practice Project  232
              Debugging Coin Toss  232
            11 - Web Scraping  233 ----
            Project: mapIt.py with the webbrowser Module  234
              Step 1: Figure Out the URL   234
              Step 2: Handle the Command Line Arguments  235
              Step 3: Handle the Clipboard Content and Launch the Browser  236
              Ideas for Similar Programs   236
            Downloading Files from the Web with the requests Module  237
              Downloading a Web Page with the requests.get() Function  237
              Checking for Errors   238
            Saving Downloaded Files to the Hard Drive  239
            HTML  240
              Resources for Learning HTML   240
              A Quick Refresher   240
              Viewing the Source HTML of a Web Page  241
              Opening Your Browser’s Developer Tools  242
              Using the Developer Tools to Find HTML Elements   244
            Parsing HTML with the BeautifulSoup Module  245
              Creating a BeautifulSoup Object from HTML  245
              Finding an Element with the select() Method   246
              Getting Data from an Element’s Attributes  248
            Project: “I’m Feeling Lucky” Google Search   248
              Step 1: Get the Command Line Arguments and Request the Search Page  249
              Step 2: Find All the Results   249
              Step 3: Open Web Browsers for Each Result  250
              Ideas for Similar Programs   251
            Project: Downloading All XKCD Comics  251
              Step 1: Design the Program  252
              Step 2: Download the Web Page  253
              Step 3: Find and Download the Comic Image  254
              Step 4: Save the Image and Find the Previous Comic  255
              Ideas for Similar Programs   256
            Controlling the Browser with the selenium Module  256
              Starting a Selenium-Controlled Browser  256
              Finding Elements on the Page   257
              Clicking the Page  259
              Filling Out and Submitting Forms  259
              Sending Special Keys  260
              Clicking Browser Buttons  261
              More Information on Selenium  261
            Summary  261
            Practice Questions  261
            Practice Projects  262
              Command Line Emailer  262
              Image Site Downloader   263
              2048  263
              Link Verification  263
            12 - Working with Excel Spreadsheets  265 ----
            Excel Documents  266
            Installing the openpyxl Module  266
            Reading Excel Documents   266
              Opening Excel Documents with OpenPyXL   267
              Getting Sheets from the Workbook  268
              Getting Cells from the Sheets  268
              Converting Between Column Letters and Numbers  270
              Getting Rows and Columns from the Sheets  270
              Workbooks, Sheets, Cells  272
            Project: Reading Data from a Spreadsheet  272
              Step 1: Read the Spreadsheet Data   273
              Step 2: Populate the Data Structure   274
              Step 3: Write the Results to a File  275
              Ideas for Similar Programs   276
            Writing Excel Documents  277
              Creating and Saving Excel Documents  277
              Creating and Removing Sheets   278
              Writing Values to Cells  278
            Project: Updating a Spreadsheet  279
              Step 1: Set Up a Data Structure with the Update Information  280
              Step 2: Check All Rows and Update Incorrect Prices  281
              Ideas for Similar Programs   281
            Setting the Font Style of Cells  282
            Font Objects  282
            Formulas   284
            Adjusting Rows and Columns  285
              Setting Row Height and Column Width  285
              Merging and Unmerging Cells  286
              Freeze Panes  287
            Charts  288
            Summary  290
            Practice Questions  291
            Practice Projects  291
              Multiplication Table Maker  291
              Blank Row Inserter  292
              Spreadsheet Cell Inverter   292
              Text Files to Spreadsheet  293
              Spreadsheet to Text Files  293
            13 - Working with PDF and Word Documents  295 ----
            PDF Documents  295
              Extracting Text from PDFs   296
              Decrypting PDFs  297
              Creating PDFs  298
            Project: Combining Select Pages from Many PDFs  303
              Step 1: Find All PDF Files   304
              Step 2: Open Each PDF   304
              Step 3: Add Each Page   305
              Step 4: Save the Results   305
              Ideas for Similar Programs   306
            Word Documents   306
              Reading Word Documents   307
              Getting the Full Text from a .docx File  308
              Styling Paragraph and Run Objects  309
              Creating Word Documents with Nondefault Styles  310
              Run Attributes   311
              Writing Word Documents  312
              Adding Headings  314
              Adding Line and Page Breaks  315
              Adding Pictures  315
            Summary  316
            Practice Questions  316
            Practice Projects  317
              PDF Paranoia   317
              Custom Invitations as Word Documents  317
              Brute-Force PDF Password Breaker  318
            14 - Working with CSV Files and JSON Data  319 ----
            The csv Module  320
              Reader Objects  321
              Reading Data from Reader Objects in a for Loop  322
              Writer Objects  322
              The delimiter and lineterminator Keyword Arguments  323
            Project: Removing the Header from CSV Files  324
              Step 1: Loop Through Each CSV File   325
              Step 2: Read in the CSV File  325
              Step 3: Write Out the CSV File Without the First Row  326
              Ideas for Similar Programs   327
            JSON and APIs  327
            The json Module  328
              Reading JSON with the loads() Function  328
              Writing JSON with the dumps() Function  329
            Project: Fetching Current Weather Data  329
              Step 1: Get Location from the Command Line Argument  330
              Step 2: Download the JSON Data  330
              Step 3: Load JSON Data and Print Weather  331
              Ideas for Similar Programs   332
            Summary  333
            Practice Questions  333
            Practice Project  333
              Excel-to-CSV Converter  333
            15 - Keeping Time, Scheduling Tasks, and Launching Programs  335 --
            The time Module  336
              The time.time() Function  336
              The time.sleep() Function  337
            Rounding Numbers  338
            Project: Super Stopwatch  338
              Step 1: Set Up the Program to Track Times   339
              Step 2: Track and Print Lap Times   339
              Ideas for Similar Programs   340
            The datetime Module  341
              The timedelta Data Type  342
              Pausing Until a Specific Date  344
              Converting datetime Objects into Strings  344
              Converting Strings into datetime Objects  345
            Review of Python’s Time Functions  346
            Multithreading   347
              Passing Arguments to the Thread’s Target Function  348
              Concurrency Issues  349
            Project: Multithreaded XKCD Downloader   350
              Step 1: Modify the Program to Use a Function  350
              Step 2: Create and Start Threads  351
              Step 3: Wait for All Threads to End  352
            Launching Other Programs from Python  352
              Passing Command Line Arguments to Popen()   354
              Task Scheduler, launchd, and cron  354
              Opening Websites with Python   355
              Running Other Python Scripts  355
              Opening Files with Default Applications  355
            Project: Simple Countdown Program  357
              Step 1: Count Down  357
              Step 2: Play the Sound File  357
              Ideas for Similar Programs   358
            Summary  358
            Practice Questions  359
            Practice Projects  359
              Prettified Stopwatch  360
              Scheduled Web Comic Downloader  360
            16 - Sending Email and Text Messages  361 ----
            SMTP  362
            Sending Email   362
              Connecting to an SMTP Server  363
              Sending the SMTP “Hello” Message  364
              Starting TLS Encryption  364
              Logging in to the SMTP Server  364
              Sending an Email  365
              Disconnecting from the SMTP Server  366
            IMAP  366
            Retrieving and Deleting Emails with IMAP   366
              Connecting to an IMAP Server  367
              Logging in to the IMAP Server  368
              Searching for Email   368
              Fetching an Email and Marking It As Read   372
              Getting Email Addresses from a Raw Message   373
              Getting the Body from a Raw Message  374
              Deleting Emails   375
              Disconnecting from the IMAP Server  375
            Project: Sending Member Dues Reminder Emails  376
              Step 1: Open the Excel File  376
              Step 2: Find All Unpaid Members   378
              Step 3: Send Customized Email Reminders  378
            Sending Text Messages with Twilio  380
              Signing Up for a Twilio Account   380
              Sending Text Messages   381
            Project: “Just Text Me” Module  383
            Summary  384
            Practice Questions  384
            Practice Projects  385
              Random Chore Assignment Emailer   385
              Umbrella Reminder  385
              Auto Unsubscriber  385
              Controlling Your Computer Through Email  386
            17 - Manipulating Images  387 ----
            Computer Image Fundamentals  388
              Colors and RGBA Values   388
              Coordinates and Box Tuples   389
            Manipulating Images with Pillow  390
              Working with the Image Data Type   392
              Cropping Images  393
              Copying and Pasting Images onto Other Images  394
              Resizing an Image  397
              Rotating and Flipping Images   398
              Changing Individual Pixels   400
            Project: Adding a Logo   401
              Step 1: Open the Logo Image  401
              Step 2: Loop Over All Files and Open Images  402
              Step 3: Resize the Images  403
              Step 4: Add the Logo and Save the Changes   404
              Ideas for Similar Programs   406
            Drawing on Images  406
              Drawing Shapes   406
              Drawing Text  408
            Summary  410
            Practice Questions  410
            Practice Projects  411
              Extending and Fixing the Chapter Project Programs  411
              Identifying Photo Folders on the Hard Drive  411
              Custom Seating Cards   412
            18 - Controlling the Keyboard and Mouse with GUI Automation  413 ----
            Installing the pyautogui Module   414
            Staying on Track  414
              Shutting Down Everything by Logging Out  414
              Pauses and Fail-Safes  415
            Controlling Mouse Movement  415
              Moving the Mouse  416
              Getting the Mouse Position   417
            Project: “Where Is the Mouse Right Now?”   417
              Step 1: Import the Module  418
              Step 2: Set Up the Quit Code and Infinite Loop  418
              Step 3: Get and Print the Mouse Coordinates   418
            Controlling Mouse Interaction  419
              Clicking the Mouse  420
              Dragging the Mouse  420
              Scrolling the Mouse  422
            Working with the Screen  423
              Getting a Screenshot   423
              Analyzing the Screenshot   424
            Project: Extending the mouseNow Program   424
            Image Recognition   425
            Controlling the Keyboard  426
              Sending a String from the Keyboard  426
              Key Names  427
              Pressing and Releasing the Keyboard  428
              Hotkey Combinations  429
            Review of the PyAutoGUI Functions  430
            Project: Automatic Form Filler  430
              Step 1: Figure Out the Steps  432
              Step 2: Set Up Coordinates  432
              Step 3: Start Typing Data   434
              Step 4: Handle Select Lists and Radio Buttons   435
              Step 5: Submit the Form and Wait  436
            Summary  437
            Practice Questions  438
            Practice Projects  438
              Looking Busy  438
              Instant Messenger Bot  438
              Game-Playing Bot Tutorial  439
            A - Installing Third-Party Modules  441 ----
            The pip Tool  441
            Installing Third-Party Modules  442
            B - Running Programs  443 ----
            Shebang Line  443
            Running Python Programs on Windows  444
            Running Python Programs on OS X and Linux  445
            Running Python Programs with Assertions Disabled  445
            C - Answers to the Practice Questions  447 ----
            Chapter 1   448
            Chapter 2   448
            Chapter 3   450
            Chapter 4   450
            Chapter 5   451
            Chapter 6   451
            Chapter 7   452
            Chapter 8   453
            Chapter 9   453
            Chapter 10   454
            Chapter 11   455
            Chapter 12   456
            Chapter 13   456
            Chapter 14   457
            Chapter 15   457
            Chapter 16   458
            Chapter 17   458
            Chapter 18   458
[TODO =MAYBE MOVE INTO STDLIB-REF (OR MOVE LOWER STDLIB-PART OF TOC(!!))]
Contents at a Glance + Table of Contents
            --
              Part I: The Python Language --
              1 A Tutorial Introduction
              2 Lexical Conventions and Syntax
              3 Types and Objects
              4 Operators and Expressions
              5 Program Structure and Control Flow
              6 Functions and Functional Programming
              7 Classes and Object-Oriented Programming
              8 Modules, Packages, and Distribution
              9 Input and Output
              10 Execution Environment
              11 Testing, Debugging, Profiling, and Tuning
              Part II: The Python Library --
              12 Built-In Functions
              13 Python Runtime Services
              14 Mathematics
              15 Data Structures, Algorithms, and Code Simplification
              16 String and Text Handling 277
              17 Python Database Access 297
              18 File and Directory Handling 313
              19 Operating System Services 331
              20 Threads and Concurrency
              21 Network Programming and Sockets
              22 Internet Application Programming
              23 Web Programming
              24 Internet Data Handling and Encoding
              25 Miscellaneous Library Modules
              Part III: Extending and Embedding --
              26 Extending and Embedding Python
              Appendix: Python 3
            --
            I: The Python Language
            1 - A Tutorial Introduction ----
            Running Python 5
            Variables and Arithmetic Expressions
            Conditionals
            File Input and Output
            Strings
            Lists
            Tuples
            Sets
            Dictionaries
            Iteration and Looping
            Functions
            Generators 19
            Coroutines 20
            Objects and Classes
            Exceptions
            Modules
            Getting Help
            2 - Lexical Conventions and Syntax 25 ----
            Line Structure and Indentation 25
            Identifiers and Reserved Words
            Numeric Literals
            String Literals
            Containers
            Operators, Delimiters, and Special Symbols
            Documentation Strings
            Decorators
            Source Code Encoding
            3 - Types and Objects ----
            Terminology 33
            Object Identity and Type
            Reference Counting and Garbage Collection
            References and Copies
            First-Class Objects
            Built-in Types for Representing Data
              The None Type 38
              Numeric Types 38
              Sequence Types
              Mapping Types
              Set Types
            Built-in Types for Representing Program Structure
              Callable Types
              Classes, Types, and Instances
              Modules
            Built-in Types for Interpreter Internals
              Code Objects
              Traceback Objects 52
              Generator Objects 53
              Slice Objects
              Frame Objects
              Ellipsis Object 54
            Object Behavior and Special Methods
              Object Creation and Destruction
              Object String Representation
              Object Comparison and Ordering
              Type Checking
              Attribute Access
              Attribute Wrapping and Descriptors
              Sequence and Mapping Methods
              Iteration
              Mathematical Operations
              Callable Interface
              Context Management Protocol
              Object Inspection and dir()
            4 - Operators and Expressions 65 ----
            Operations on Numbers 65
            Operations on Sequences
            String Formatting
            Advanced String Formatting
            Operations on Dictionaries
            Operations on Sets
            Augmented Assignment
            The Attribute (.) Operator
            The Function Call () Operator
            Conversion Functions
            Boolean Expressions and Truth Values
            Object Equality and Identity
            Order of Evaluation
            Conditional Expressions
            5 - Program Structure and Control Flow ----
            Program Structure and Execution 81
            Conditional Execution
            Loops and Iteration
            Exceptions
              Built-in Exceptions
              Defining New Exceptions
            Context Managers and the with Statement
            Assertions and _ _debug_ _
            Parameter Passing and Return Values
            Scoping Rules
            Functions as Objects and Closures
            Generators and yield
            Coroutines and yield Expressions 104
            Using Generators and Coroutines 106
            List Comprehensions
            Generator Expressions
            Declarative Programming
            The lambda Operator
            Recursion
            6 - Functions and Functional Programming ----
            Functions 93
            Decorators
            Documentation Strings
            Function Attributes
            eval() , exec() , and compile()
            7 - Classes and Object-Oriented Programming ----
            The class Statement 117
            Class Instances
            Scoping Rules
            Inheritance
            Polymorphism Dynamic Binding and Duck Typing
            Static Methods and Class Methods
            Properties
            Descriptors
            Data Encapsulation and Private Attributes
            Object Memory Management
            Object Representation and Attribute Binding
            _ _slots_ _
            Operator Overloading
            Types and Class Membership Tests
            Abstract Base Classes
            Metaclasses
            Class Decorators
            8 - Modules, Packages, and Distribution 143 ----
            Modules and the import Statement 143
            Importing Selected Symbols from a Module
            Execution as the Main Program
            The Module Search Path
            Module Loading and Compilation 147
            Module Reloading and Unloading 149
            Packages
            Distributing Python Programs and Libraries
            Installing Third-Party Libraries
            Environment Variables 158
            Files and File Objects 158
            Standard Input, Output, and Error
            The print Statement
            The print() Function
            Variable Interpolation in Text Output
            Generating Output
            9 - Input and Output 157 ----
            Reading Command-Line Options
            Unicode String Handling
            Unicode I/O
            Unicode Data Encodings
            Unicode Character Properties
            Object Persistence and the pickle Module
            10 - Execution Environment 173 ----
            Interpreter Options and Environment
            Interactive Sessions
            Launching Python Applications
            Site Configuration Files 177
            Per-user Site Packages 177
            Enabling Future Features
            Program Termination
            11 - Testing, Debugging, Profiling, and Tuning 181 ----
            Documentation Strings and the doctest Module 181
            Unit Testing and the unittest Module
            The Python Debugger and the pdb Module
              Debugger Commands
              Debugging from the Command Line
              Configuring the Debugger
            Program Profiling 190
            Tuning and Optimization
            Making Memory Measurements
            II: The Python Library --
            12 - Built-In Functions and Exceptions ----
            Built-in Functions and Types 201
            Built-In Exceptions
              Exception Base Classes
              Exception Instances
              Predefined Exception Classes
            Built-In Warnings 216
            13 - Python Runtime Services ----
            atexit 219
            copy
            Tuning Strategies
            future_builtins
            Making Timing Measurements
            Disassembly
            gc
            Notes 222
            inspect 222
            marshal
            pickle
            sys
            Variables
            Functions 233
            traceback
            types
            warnings
            weakref
            14 - Mathematics 243 ----
            decimal 243
              Decimal Objects 244
              Context Objects 244
              Functions and Constants
              Examples
              Notes 249
            fractions 250
            math
            numbers 252
            random 254
            Seeding and Initialization
            Random Integers
            Random Sequences
            Real-Valued Random Distributions
            15 - Data Structures, Algorithms, and Code Simplification ----
            abc 257
            array
            bisect 261
            collections
              deque and defaultdict
              Named Tuples
              Abstract Base Classes
            contextlib
            functools
            heapq
            itertools
              Examples 273
            operator
            16 - String and Text Handling ----
            codecs 277
              Low-Level codecs Interface
              I/O-Related Functions
              Useful Constants
              Standard Encodings
            re
              Pattern Syntax
              Functions
              Regular Expression Objects
              Match Objects
              Example
              Notes 287
            string 287
              Constants
              Formatter Objects
              Template Strings
              Utility Functions
            struct
              Packing and Unpacking Functions
              Struct Objects
              Format Codes
            unicodedata
            17 - Python Database Access 297 ----
            Relational Database API Specification
              Connections
              Cursors
              Forming Queries
              Type Objects
              Error Handling 302
              Multithreading 302
              Mapping Results into Dictionaries
              Database API Extensions
            sqlite3 Module 303
              Module-Level Functions
              Connection Objects
              Cursors and Basic Operations 308
            DBM-Style Database Modules 310
            shelve Module
            18 - File and Directory Handling ----
            bz2 313
            filecmp
            fnmatch
            glob
            gzip 317
            shutil 318
            tarfile
              Exceptions
              Example 322
            tempfile 323
            zipfile
            zlib
            19 - Operating System Services ----
            commands 331
            configParser, Configparser
              The ConfigParser Class
              Example
            datetime 336
              date Objects 336
              time Objects 338
              datetime objects 339
              timedelta objects 340
              Mathematical Operations Involving Dates
              tzinfo Objects
              Date and Time Parsing
            errno
              POSIX Error Codes
              Windows Error Codes
            fcntl 347
            io 349
              Base I/O Interface
              Raw I/O
              Buffered Binary I/O
              Text I/O
              The open() Function
              Abstract Base Classes
            logging
              Logging Levels
              Basic Configuration
              Logger Objects
              Handler Objects
              Message Formatting
              Miscellaneous Utility Functions
              Logging Configuration
              Performance Considerations
            mmap
            msvcrt 372
            optparse
            os 378
              Process Environment
              File Creation and File Descriptors
              Files and Directories
              Process Management 390
              System Configuration 395
              Exceptions
            os.path
            signal
            subprocess 402
            time
            winreg
            20 - Threads and Concurrency ----
            Basic Concepts 413
            Concurrent Programming and Python
            multiprocessing
              Processes
              Interprocess Communication
              Process Pools
              Shared Data and Synchronization
              Managed Objects
              Connections
              Miscellaneous Utility Functions
              General Advice on Multiprocessing
            threading
              Thread Objects
              Timer Objects
              Lock Objects
              RLock
              Semaphore and Bounded Semaphore
              Events
              Condition Variables 441
              Working with Locks 442
              Thread Termination and Suspension
              Utility Functions
              The Global Interpreter Lock
              Programming with Threads
            queue, Queue
              Queue Example with Threads 445
            Coroutines and Microthreading 446
            21 - Network Programming and Sockets ----
            Network Programming Basics 449
            asynchat 452
            asyncore 455
            select 459
              Advanced Module Features
              Advanced Asynchronous I/O Example
              When to Consider Asynchronous Networking
            socket 469
              Address Families
              Socket Types
              Addressing
              Functions
              Exceptions
            ssl 486
            SocketServer 489
              Handlers
              Servers
              Defining Customized Servers
              Customization of Application Servers
            22 - Internet Application Programming ----
            ftplib 497
            http Package
              http.client (httplib)
              http.server (BaseHTTPServer, CGIHTTPServer,
              SimpleHTTPServer) 506
              http.cookies (Cookie)
              http.cookiejar (cookielib)
            smtplib 513
            urllib Package
              urllib.request (urllib2)
              urllib.response
              urllib.parse
              urllib.error
              urllib.robotparser (robotparser)
            xmlrpc Package 524
              xmlrpc.client (xmlrpclib)
              xmlrpc.server (SimpleXMLRPCServer, DocXMLRPCServer)
            23 - Web Programming ----
            cgi 533
              CGI Programming Advice
            cgitb
            wsgiref
              The WSGI Specification
              wsgiref Package
            webbrowser
            24 - Internet Data Handling and Encoding ----
            base64 545
            binascii
            csv
              Dialects 551
            email Package
              Parsing Email
              Composing Email
            hashlib 559
            hmac
            HTMLParser
            json
            mimetypes
            quopri
            xml Package
              XML Example Document
              xml.dom.minidom
              xml.etree.ElementTree
              xml.sax
              xml.sax.saxutils
            25 - Miscellaneous Library Modules ----
            Python Services 585
            String Processing
            Operating System Modules
            Network
            Internet Data Handling
            Internationalization
            Multimedia Services
            Miscellaneous
            III: Extending and Embedding
            26 - Extending and Embedding Python ----
            Extension Modules 591 591
              An Extension Module Prototype 593
              Naming Extension Modules
              Compiling and Packaging Extensions
              Type Conversion from Python to C 597
              Type Conversion from C to Python 602
              Adding Values to a Module
              Error Handling
              Reference Counting
              Threads
            Embedding the Python Interpreter
              An Embedding Template 608
              Compilation and Linking 608
              Basic Interpreter Operation and Setup
              Accessing Python from C
              Converting Python Objects to C
            ctypes 612
              Loading Shared Libraries
              Foreign Functions
              Datatypes
              Calling Foreign Functions
              Alternative Type Construction Methods
              Utility Functions
            Advanced Extending and Embedding
            Jython and IronPython
            Appendix Python 3 ----
            Who Should Be Using Python 3?
            New Language Features
              Source Code Encoding and Identifiers
              Set Literals
              Set and Dictionary Comprehensions
              Extended Iterable Unpacking
              Nonlocal Variables
              Keyword-Only Arguments
              Ellipsis as an Expression
              Chained Exceptions 626
              Improved super() 627
              Advanced Metaclasses
            Common Pitfalls 629
              Text Versus Bytes
              New I/O System
              ????? Function Annotations
              print() and exec() Functions
              Use of Iterators and Views
              Integers and Integer Division
              Comparisons
              Iterators and Generators
              File Names, Arguments, and Environment Variables
              Library Reorganization
              Absolute Imports
            Code Migration and 2to3
              Porting Code to Python 2.6
              Providing Test Coverage
              Using the 2to3 Tool
              A Practical Porting Strategy
              Simultaneous Python 2 and Python 3 Support
              Participate


--
~/Empire/Doks/Comp/lang/py/cheatsh-qref/py2-2-py3.cheatsh.pdf
~/Empire/Doks/Comp/lang/py/cheatsh-qref/py2-2-py3.cheatsh.txt
            fr. Programming in Python 3 (Second Edition) by Mark Summerfield, ISBN 0321680561 (www.qtrac.eu/py3book.html).

            Strings and String Formatting

            Printing and Executing

            Python 3 strings are Unicode; unicode() is gone
            Python 2            Python 3.1

            New functions print(), exec(); execfile() is gone
            Python 2
            Python 3.1

            s = unicode(x)      s = str(x)

            print a, b, c

            print(a, b, c)

            s = u"\u20AC"

            s = "\u20AC"

            print "%03d" % 7

            print("{:03d}".format(7))

            s = ur"\w"

            s = r"\w"

            print x,

            print(x, end=" ")

            String % operator is deprecated; use str.format()
            "%d %s" % (i, s)

            "%(i)d %(s)s" % (
            {'i':i, 's':s})

            print>>sys.stderr, x

            print(x, file=sys.stderr)

            "{} {}".format(i, s)

            exec code

            exec(code)

            "{0} {1}".format(i, s)

            exec code in globals exec(code, globals)

            "{i} {s}".format(i=i, s=s)

            exec code in (
            globals, locals)

            exec(code,
            globals, locals)

            execfile(file)

            with open(file) as fh:
            exec(fh.read())

            "{0[i]} {0[s]}".format(
            {'i':i, 's':s})
            "{i} {s}".format(
            **{'i':i, 's':s})

            "{i} {s}".format(
            **locals())
            "%s-%s" % ("X", "X") "{0}-{0}".format("X")
            "%(i)d %(s)s" % (
            locals())

            "{:.2f}".format(3.142)
            "%.2f" % 3.142

            "{0:.2f}".format(3.142)
            "{π:.2f}".format(π=3.142)

            "%.4s" % "Prime"

            "{:.4}".format("Prime")

            "{%d%%}" % 20

            "{{{}%}}".format(20)

            "%0*d" % (3, 7)

            "{:0{}}".format(7, 3)

            Representational Form

            Backticks are gone; use repr() or str.format()
            Python 2
            Python 3.1

            s = `x`

            Division doesn’t truncate; long() is gone; octal
            literals must start with 0o (zero-oh)
            Python 2
            Python 3.1
            x = 5 / 2.0 # x==2.5

            x = 5 / 2

            x = 5 / 2

            x = 5 // 2 # x==2

            = x==2

            = x==2.5

            i = 2147483648L

            i = 2147483648

            j = long(i * 2)

            j = int(i * 2)

            x = 0123

            x = 0o123

            = x==83

            = x==83

            Iterators

            New next(); iterators must have __next__()
            Python 2
            Python 3.1

            s = repr(x)

            x = iterator.next()

            s = "{!r}".format(x)

            class Iterator:
            class Iterator:
            def __init__(self):
            def __init__(self):
            self.i = -1
            self.i = -1
            def next(self):
            def __next__(self):
            self.i += 1
            self.i += 1
            return self.i
            return self.i

            s = "{0!r}".format(x)
            s = "{z!r}".format(z=x)

            Force ASCII representation with ascii()
            s = `x`

            Numbers

            s = ascii(x)
            s = "{!a}".format(x)

            x = next(iterator)

            fn.func_defaults

            fn.__defaults__

            An operator, an exception, a constant, some types,
            several global functions, several dictionary methods, and some itertools functions are gone
            Python 2
            Python 3.1

            fn.func_dict

            fn.__dict__

            fn.func_doc

            fn.__doc__

            fn.func_globals

            fn.__globals__

            fn.func_name

            fn.__name__

            if a <> b:

            obj.method.im_func

            obj.method.__func__

            obj.method.im_self

            obj.method.__self__

            Removals and Replacements

            if a != b:
            fn(*args)

            apply(fn, args)

            apply(fn, args, kwargs) fn(*args, **kwargs)

            obj.method.im_class obj.method.__class__

            if isinstance(x,
            basestring):

            string.letters

            string.ascii_letters

            string.lowercase

            string.ascii_lowercase

            string.uppercase

            string.ascii_uppercase

            threading.Lock. \
            acquire_lock()

            threading.Lock. \
            acquire()

            threading.Lock. \
            release_lock()

            threading.Lock. \
            release()

            class Thing:
            def __init__(
            self, x):
            self.x = x
            def __nonzero__(
            self):
            return \
            bool(self.x)

            class Thing:
            def __init__(
            self, x):
            self.x = x
            def __bool__(self):
            return bool(self.x)

            if isinstance(x, str):
            x = memoryview(y)
            = this is similar
            if hasattr(x,
            "__call__"):

            x = buffer(y)
            if callable(x):
            fh = file(fname, mode)

            fh = open(fname, mode)

            if d.has_key(k):

            if k in d:

            for k, v in \
            d.iteritems():

            for k, v in d.items():

            for k in d.iterkeys():

            for k in d.keys():
            for k in d:

            for v in \
            d.itervalues():

            for v in d.values():

            for line in \
            file.xreadlines():

            for line in file:

            x = input(msg)

            x = eval(input(msg))

            intern(s)

            sys.intern(s)

            f = itertools.ifilter(
            f = filter(fn, seq)
            fn, seq)
            m = itertools.imap(
            fn, seq)

            m = map(fn, seq)

            z = itertools.izip(
            seq1, seq2)

            z = zip(seq1, seq2)

            dir = os.getcwdu()

            dir = os.getcwd()

            s = raw_input(msg)

            s = input(msg)

            r = reduce(fn, seq)

            r = functools.reduce(
            fn, seq)

            reload(module)

            imp.reload(module)

            class MyErr(
            StandardError):

            class MyErr(
            Exception):

            sys.maxint

            sys.maxsize

            for i in xrange(n):

            for i in range(n):

            Exceptions

            Catching exception objects requires the as keyword; raising exceptions with arguments requires
            parentheses; strings cannot be used as exceptions
            Python 2
            Python 3.1
            try:
            process()
            except ValueError, \
            err:
            print err

            try:
            process()
            except ValueError \
            as err:
            print(err)

            try:
            try:
            process()
            process()
            except (MyErr1,
            except (MyErr1,
            MyErr2), err:
            MyErr2) as err:
            print err
            print(err)
            raise MyErr, msg

            raise MyErr(msg)

            raise MyErr, msg, tb

            raise MyErr(msg). \
            with_traceback(tb)

            Implement __bool__() instead of __nonzero__() to
            return a custom class’s truth value
            Python 2
            Python 3.1

            raise "Error"

            raise Exception(
            "Error")

            generator.throw(
            MyErr, msg)

            generator.throw(
            MyErr(msg))

            fn.func_closure

            fn.__closure__

            fn.func_code

            fn.__code__

            generator.throw(
            "Error")

            generator.throw(
            Exception("Error"))

            Renamed Attributes and Methods

            Renamed Modules

            Python 3.1Idioms

            Data read from a URL, e.g., using urllib.request.
            urlopen() is returned as a bytes object; use
            bytes.decode(encoding) to convert it to a string.
            The bsddb (Berkeley DB library) is gone—but is
            avaliable from pypi.python.org/pypi/bsddb3. See
            PEP 3108 (www.python.org/dev/peps/pep-3108)
            for module renaming details
            Python 2
            Python 3.1

            Tuples need parentheses in comprehensions; metaclasses are set with the metaclass keyword; import
            the pickle and string I/O modules directly; lambda doesn’t unpack tuples; set literals are supported
            (the empty set is set(); {} is an empty dict); sorting is fastest using a key function; super() is better;
            type-testing is more robust with isinstance(); use
            True and False rather than 1 and 0
            Python 2
            Python 3.1

            import anydbm
            import whichdb

            import dbm

            import BaseHTTPServer
            import \
            SimpleHTTPServer

            import http.server

            import CGIHTTPServer
            import __builtin__

            import builtins

            import commands

            import subprocess

            import ConfigParser

            import configparser

            import Cookie

            import http.cookies

            import cookielib

            import http.cookiejar

            import copy_reg

            import copyreg

            import dbm

            import dbm.ndbm

            import DocXMLRPCServer
            import \
            SimpleXMLRPCServer

            import xmlrpc.server

            import dumbdbm

            import dbm.dumb

            import gdbm

            import dbm.gnu

            import httplib

            import http.client

            import Queue

            import queue

            import repr

            import reprlib

            import robotparser
            import SocketServer
            import \
            test.test_support
            import Tkinter

            class A:
            __metaclass__ = \
            MyMeta
            class B(MyBase):
            __metaclass__ = \
            MyMeta

            class A(
            metaclass=MyMeta):
            pass
            class B(MyBase,
            metaclass=MyMeta):
            pass

            try:
            import cPickle \
            as pickle
            except ImportError:
            import pickle

            import pickle

            try:
            import cStringIO \
            as StringIO
            except ImportError:
            import StringIO

            import io

            fn = lambda (a,): \
            abs(a)
            fn = lambda (a, b): \
            a + b

            fn = lambda t: \
            abs(t[0])
            fn = lambda a: abs(a)
            fn = lambda t: \
            t[0] + t[1]
            fn = lambda a, b: a + b

            urllib.robotparser

            S = set((2, 4, 6))

            import socketserver

            S = set([2, 4, 6])

            import test.support

            L = list(seq)
            L.sort()

            L = sorted(seq)

            words.sort(
            lambda x, y:
            cmp(x.lower(),
            y.lower()))

            words.sort(
            key=lambda x:
            x.lower())

            urllib.request, \

            class B(A):
            def __init__(self):
            super(B, self). \
            __init__()

            class B(A):
            def __init__(self):
            super(). \
            __init__()

            urllib.error

            if type(x) == X:

            import tkinter
            urllib.request, \
            urllib.parse, \
            urllib.error
            import \

            import urllib2

            L = [x for x in (3, 6)]

            import \

            import \
            import urllib

            L = [x for x in 3, 6]

            import urlparse

            import urllib.parse

            import xmlrpclib

            import xmlrpc.client

            if type(x) is X:
            while 1:
            process()

            S = {2, 4, 6}

            if isinstance(x, X):
            while True:
            process()

            New in Python 3.1

            General Notes

            Dictionary and set comprehensions; * unpacking; binary literals; bytes and bytearray types;
            bz2.BZ2File and gzip.GzipFile are context managers; collections.Counter dictionary type;
            collections.OrderedDict insertion-ordered dictionary type; decimal.Decimals can be created from
            floats
            Python 2
            Python 3.1

            Python 3 often returns iterables where Python 2 returned lists. This is usually fine, but if a list is really needed, use the list() factory function. For example, given dictionary, d, list(d.keys()) returns
            its keys as a list. Affected functions and methods
            include dict.items(), dict.keys(), dict.values(),
            filter(), map(), range(), and zip().
            Most of the types module’s types (such as types.
            LongType) have gone. Use the factory function
            instead. For example, replace if isinstance(x,
            types.IntType) with if isinstance(x, int).
            Comparisons are strict—x < y will work for compatible types (e.g., x and y are both numbers or
            both strings); otherwise raises a TypeError.
            Some doctests involving floating point numbers might break because Python 3.1 uses David
            Gay’s algorithm to show the shortest representation that preserves the number’s value. For example, 1.1 in Python 2 and 3.0 is displayed as
            1.1000000000000001, and in Python 3.1 as 1.1.

            d = {}
            for x in range(5):
            d[x] = x**3

            d = {x: x**3
            for x in range(5)}

            S = set(
            S = {x for x in seq}
            [x for x in seq])

            Python 3.1
            a, *b = (1, 2, 3)

            = a==1; b==[2, 3]

            = a==[1, 2]; b==3
            *a, b = (1, 2, 3)
            a, *b, c = (1, 2, 3, 4) # a==1; b==[2, 3]; c==4
            x = 0b1001001
            s = bin(97)
            y = int(s, 2)

            = x==73
            = s=='0b1100001'
            = y==97

            u = "The

            " # or: u = "The \u20ac"
            = or: u = "The \N{euro sign}"
            v = u.encode("utf8") # v==b'The \xe2\x82\xac'
            w = v.decode("utf8") # w=='The '
            x = bytes.fromhex("54 68 65 20 E2 82 AC")
            = x==b'The \xe2\x82\xac'
            y = x.decode("utf8") # y=='The '
            z = bytearray(y)
            z[-3:] = b"$"
            = z==bytearray(b'The $')
            with bz2.BZ2File(filename) as fh:
            data = fh.read()
            counts = collections.Counter("alphabetical")
            = counts.most_common(2)==[('a', 3), ('l', 2)]
            d = collections.OrderedDict(
            (("x", 1), ("k", 2), ("q", 3)))
            = list(d.keys())==['x', 'k', 'q']
            dec = decimal.Decimal.from_float(3.75)
            = dec==Decimal('3.75')

            Special Methods

            The slice methods (__delslice()__, __getslice()__, __setslice__) are gone; instead __delitem()__, __getitem()__, and __setitem__ are
            called with a slice object.
            The methods __hex__() and __oct__() are gone;
            use hex() and oct(). To provide an integer, implement __index__().

            String Format Specifications
            str.format() strings have one or more replacement fields of form: {Name!Conv:Spec}. Name identifies the object to format. Optional !Conv is: !a
            (ASCII repr() format), !r (repr() format), or !s
            (string format). Optional :Spec is of form:
            : Fill Align Sign # 0 Width , .Prec Type
            Fill is any character except }. Align is: < (left), >
            (right), ^ (center), or = (pad between sign and number). Sign is: + (force), - (- if needed), or “ ” (space
            or -). # prefixes ints with 0b, 0o, or 0x. 0 means
            0-pad numbers. Width is the minimum width. The
            , means use grouping commas. .Prec is the maximum width for strs and number of decimal places
            for floats. Type is: % (percent), b (binary), d (decimal), e or E (exponential), f (float) g or G (general
            float) n (localized) o (octal), x or X (hex). Everything is optional, except that Fill requires Align.
            "{:*=+10.1f}".format(12345.67) # '+**12345.7'
            "{:*>+10.1f}".format(12345.67) # '**+12345.7'
            "{:+010.1f}".format(12345.67) # '+0012345.7'
            "{:,.2f}".format(12345.678)
            = '12,345.68'
            An informIT.com
            publication by
            Mark Summerfield.
            =3

            Copyright  Qtrac Ltd. 2009.

            License: Creative Commons Attribution-Share Alike 3.0 U.S.

            
  ~/Empire/Doks/Comp/lang/py/cheatsh-qref/Python2-Refcard.pdf
  ~/Empire/Doks/Comp/lang/py/cheatsh-qref/Python2-Refcard.txt
--
~/Empire/Doks/Comp/lang/py/cheatsh-qref/Python_qr.pdf      #2.7
~/Empire/Doks/Comp/lang/py/cheatsh-qref/Python_qr.txt      #2.7
            Python  2.7  Quick  Reference  Sheet  

            Interactive  Help  in  Python  Shell  
            help()  
            Invoke  interactive  help  
            help(m)  
            Display  help  for  module  m  
            help(f)  
            Display  help  for  function  f  
            dir(m)  
            Display  names  in  module  m  

            Small  Operator  Precedence  Table  
            func_name(args,  ͙)   Function  call  
            x[index  :  index]  
            Slicing  
            x[index]  
            Indexing  
            x.attribute  
            Attribute  reference  
            **  
            Exponentiation  
            *,    /,  %  
            Multiply,  divide,  mod  
            +,  -­‐  
            Add,  subtract  
            >,  <,  <=,  >=,  !=,  ==  
            Comparison  
            in,  not  in  
            Membership  tests  
            not,  and,  or  
            Boolean  operators  
            NOT,  AND,  OR    

            Module  Import  
            import  module_name  
            from  module_name  import  name  ,  ͙  
            from  module_name  import  *  

            Common  Data  Types  
            Type  
            Description  
            Literal  Ex  
            int  
            32-­‐bit  Integer  
            3,  -­‐4  
            long  
            Integer  >  32  bits  
            101L  
            float  
            Floating  point  number   3.0,  -­‐6.55  
            complex   Complex  number  
            1.2J  
            bool  
            Boolean  
            True,  False  
            str  
            Character  sequence  
            ͞Python͟  
            tuple  
            Immutable  sequence   (2,  4,  7)  
            list  
            Mutable  sequence  
            [2,  x,  3.1]  
            dict  
            Mapping  
            {  x:2,  y:5  }  

            Common  Syntax  Structures  
            Assignment  Statement  
            var  =  exp  
            Console  Input/Output  
            var  =  input(  [prompt]  )  
            var  =  raw_input(  [prompt]  )  
            print  exp[,]  ͙  
            Selection  
            if  (boolean_exp):  
                    stmt  ͙  
            [elif  (boolean_exp):  
                    stmt  ͙]  ͙  
            [else:  
                    stmt  ͙]  
            Repetition  
            while  (boolean_exp):  
                    stmt  ͙  
            Traversal  
            for  var  in  traversable_object:  
                    stmt  ͙  
            Function  Definition  
            def  function_name(  parmameters  ):  
                    stmt  ͙  
            Function  Call  
            function_name(  arguments  )  
            Class  Definition  
            class  Class_name  [  (super_class)  ]:  
                    [  class  variables  ]  
                    def  method_name(  self,    parameters  ):  
                            stmt  
            Object  Instantiation  
            obj_ref  =  Class_name(  arguments  )  
            Method  Invocation  
            obj_ref.method_name(  arguments  )  
            Exception  Handling  
            try:  
                    stmt  ͙  
            except  [exception_type]  [,  var]:  
                    stmt  ͙  

            Common  Built-­‐in  Functions  
            Function  
            Returns  
            abs(x)  
            Absolute  value  of  x  
            dict()  
            Empty  dictionary,  eg:  d  =  dict()  
            float(x)  
              int  or  string  x  as  float  
            id(obj)  
            memory  addr  of  obj  
            int  (x)  
            float  or  string  x  as  int  
            len(s)  
            Number  of  items  in  sequence  s    
            list()  
            Empty  list,  eg:  m  =  list()  
            max(s)  
            Maximum  value  of  items  in  s  
            min(s)  
            Minimum  value  of  items  in  s  
            open(f)  
            Open  filename  f  for  input  
            ord(c)  
            ASCII  code  of  c  
            pow(x,y)  
            x  **  y  
            range(x)  
            A  list  of  x  ints  0  to  x  -­‐  1  
            round(x,n)   float  x  rounded  to  n  places  
            str(obj)  
            str  representation  of  obj  
            sum(s)  
            Sum  of  numeric  sequence  s  
            tuple(items)   tuple  of  items  
            type(obj)  
            Data  type  of  obj  

            Common  Math  Module  Functions  
            Function  
            Returns  (all  float)  
            ceil(x)  
            Smallest  whole  nbr  >=    x  
            cos(x)  
            Cosine  of  x  radians  
            degrees(x)  
            x  radians  in  degrees  
            radians(x)  
            x  degrees  in  radians  
            exp(x)  
            e  **  x  
            floor(x)  
            Largest  whole  nbr  <=  x  
            hypot(x,  y)  
            sqrt(x  *  x  +  y  *  y)  
            log(x  [,  base])   Log  of  x  to  base  or  natural  log  if  
            base  not  given  
            pow(x,  y)  
            x  **  y  
            sin(x)  
            Sine  of  x  radians  
            sqrt(x)  
            Positive  square  root  of  x  
            tan(x)  
            Tangent  of  x  radians  
            pi  
            Math  constant  pi  to  15  sig  figs  
            e  
            Math  constant  e  to  15  sig  figs  

            Common  String  Methods  
            S.method()  
            Returns  (str  unless  noted)  
            capitalize  
            S  with  first  char  uppercase  
            center(w)  
            S  centered  in  str  w  chars  wide  
            count(sub)  
            int  nbr  of  non-­‐overlapping  
            occurrences  of  sub  in  S  
            find(sub)  
            int  index  of  first  occurrence  of  
            sub  in  S  or  -­‐1  if  not  found    
            isdigit()  
            bool  True  if  S  is  all  digit  chars,  
            False  otherwise  
            islower()  
            bool  True  if  S  is  all  lower/upper  
            isupper()  
            case  chars,  False  otherwise    
            join(seq)  
            All  items  in  seq  concatenated  
            into  a  str,  delimited  by  S  
            lower()  
            Lower/upper  case  copy  of  S  
            upper()  
            lstrip()  
            Copy  of  S  with  leading/  trailing  
            rstrip()  
            whitespace  removed,  or  both  
            split([sep])  
            List  of  tokens  in  S,  delimited  by  
            sep;  if  sep  not  given,  delimiter  
            is  any  whitespace  

            Formatting    Numbers  as  Strings  
            Syntax:    ͞format_spec͟  %  numeric_exp  
            format_spec  syntax:    %  width.precision  type  
            x width  (optional):  align  in  number  of  colums  
            specified;  negative  to  left-­‐align,  precede  with  
            0  to  zero-­‐fill  
            x precision  (optional):  show  specified  digits  of  
            precision  for  floats;  6  is  default  
            x type  (required):  d  (decimal  int),  f  (float),  s  
            (string),  e  (float  ʹ  exponential  notation)  
            x Examples  for  x  =  123,  y  =  456.789  
            ͞йϲĚ͟  %  x  -­‐>  .  .  .  123  
            ͞йϬϲĚ͟  %  x  -­‐>  000123    
            ͞%8.2f  %  y  -­‐>  .  .  456.79  
            ͞ϴ͘ϮĞ͟йǇ-­‐>  4.57e+02  
            ͞-­‐8s͟й͞,ĞůůŽ͟-­‐>  Hello  .  .  .  

            Common  List  Methods  
            L.method()   Result/Returns  
            append(obj)   Append  obj  to  end  of  L  
            count(obj)  
            Returns  int  nbr  of  occurrences  of  
            obj  in  L  
            index(obj)  
            Returns  index  of  first  occurrence  
            of  obj  in  L;  raises  ValueError  if  
            obj  not  in  L  
            pop([index])   Returns  item  at  specified  index  
            or  item  at  end  of  L  if  index  not  
            given;  raises  IndexError  if  L  is  
            empty  or  index  is  out  of  range  
            remove(obj)   Removes  first  occurrence  of  obj  
            from  L;  raises  ValueError  if  obj  is  
            not  in  L  
            reverse()  
            Reverses  L  in  place  
            sort()  
            Sorts  L  in  place  

            Common  Tuple  Methods  
            T.method()   Returns  
            count(obj)  
            Returns  nbr  of  occurrences  of  
            obj  in  T  
            index(obj)  
            Returns  index  of  first  occurrence  
            of  obj  in  T;  raises  ValueError  if  
            obj  is  not  in  T  

            Common  Dictionary  Methods  
            D.method()   Result/Returns  
            clear()  
            Remove  all  items  from  D  
            get(k  [,val])   Return  D[k]  if  k  in  D,  else  val  
            has_key(k)  
            Return  True  if  k  in  D,  else  False  
            items()  
            Return  list  of  key-­‐value  pairs  in  
            D;    each  list  item  is  2-­‐item  tuple  
            keys()  
            Return  list  of  D͛ƐŬĞǇƐ  
            pop(k,  [val])   Remove  key  k,  return  mapped  
            value  or  val  if  k  not  in  D  
            values()  
            Return  list  of  D͛s  values  

            Common  File  Methods  
            F.method()   Result/Returns  
            read([n])  
            Return  str  of  next  n  chars  from  F,  
            or  up  to  EOF  if  n  not  given  
            readline([n])   Return  str  up  to  next  newline,  or  
            at  most  n  chars  if  specified  
            readlines()   Return  list  of  all  lines  in  F,  where  
            each  item  is  a  line  
            write(s)  
            Write  str  s  to  F  
            writelines(L)   Write  all  str  in  seq  L  to  F  
            close()  
            Closes  the  file  

            Other  Syntax  
            Hold  window  for  user  keystroke  to  close:  
            raw_input(͞Press    <Enter>  to  quit.͟)  
            Prevent  execution  on  import:  
            ŝĨͺͺŶĂŵĞͺͺсс͞ͺͺŵĂŝŶͺͺ͗͟  
                      main()  

            Displayable  ASCII  Characters  
            32   SP   48   0   64   @   80   P   96   `   112   p  
            33   !   49   1   65   A   81   Q   97   a   113   q  
            34   ͞   50   2   66   B   82   R   98   b   114   r  
            35   #   51   3   67   C   83   S   99   c   115   s  
            36   $   52   4   68   D   84   T   100   d   116   t  
            37   %   53   5   69   E   85   U   101   e   117   u  
            38   &   54   6   70   F   86   V   102   f   118   v  
            39   ͚   55   7   71   G   87   W   103   g   119   w  
            40   (   56   8   72   H   88   X   104   h   120   x  
            41   )   57   9   73   I   89   Y   105   i   121   y  
            42   *   58   :   74   J   90   Z   105   j   122   z  
            43   +   59   ;   75   K   91   [   107   k   123   {  
            44   ,   60   <   76   L   92   \   108   l   124   |  
            45   -­‐   61   =   77   M   93   ]   109   m   125   }  
            46   .   62   >   78   N   94   ^   110   n   126   ~  
            47   /   63   ?   79   O   95   _   111   o   127   DEL  
            µ\¶ µ\W¶ µ\n¶  =  10  

~/Empire/Doks/Comp/lang/py/cheatsh-qref/py2-2-py3.cheatsh.pdf
@(@) ~/Empire/Doks/Comp/lang/py/cheatsh-qref/py3kickstart.cheatsh.pdf
~/Empire/Doks/Comp/lang/py/cheatsh-qref/py3kickstart.cheatsh.txt
            PYTHON - Kickstart Coding
            Types

            Branching

            Functions

            str, int, float

            Basic if Conditionally execute indent

            Return value w/ positional param

            a = "hello!"
            count = 3
            pi = 3.14

            string
            integer
            float

            list ordered collection
            a = ["a", "b", 3]
            a[0]
            = "a"
            a[1]
            = "b"
            a[-1]
            = "3"
            a[1:2]
            = ["b", 3]
            tuple same as list, but immutable
            a = ("a", "b", 3)
            dict collection of keys and values

            if cost < 10:
            print("impulse buy")
            Boolean operators “and”, “or”

            if age > 17 and place == "UK": Keyword parameters
            print("can buy alcohol")
            def greet(name="Jack"):
            if age < 18 or s == "student":
            print("Hello", name)
            print("can get discount")
            greet(name="Jill")
            If-elif-else
            if beer == "Darkwing":
            print("IPA")
            elif beer == "Stonehenge":
            print("Stout")
            else:
            print("Unknown beer")

            a = {"test": 1, "b": "hello"}
            a["test"]
            = 1
            a["b"]
            = "hello"
            del a["test"] # delete "test"
            a["c"] = 3 # add "c" to dict Pass placeholder that does nothing
            sets “keys-only dict”, with operations
            a = {"a", 1, 4, "b"}
            b = {"a", "b"}
            print(a - b) # {1, 4}

            def in_file(name):
            path = "./src/" + name
            return path + ".html"
            path = in_file("home")
            html = open(path).read()

            if cost > 1.99:
            pass # TODO: finish this

            Iteration

            Variable length arguments
            def do_all(*args, **kwargs):
            print(kwargs) # kwargs is dict
            return sum(args)
            do_all(3, 5, b=3)
            Comment aka “docstring”
            def plural(word):
            """
            Return the plural of
            an English word.
            """
            if word.endswith("s"):
            return word + "es"
            return word + "s"
            print("Many", plural("cat"))

            list methods

            Lambda alternative syntax for oneWhile loop Repeat indented code unliners
            a = ["a", "b", 3]
            til condition is no longer true
            a.append(4) # ["a", "b", 3, 4]
            cubed = lambda i: i ** 3
            a.reverse() # [4, 3, "b", "a"]
            print("5^3 is ", cubed(5))
            i = 2
            dict methods
            while i < 10000:
            print("square:", i)
            a = {"a": 1, "b": 2}
            i = i ** 2
            More
            a.get("c", 3) # 3 as default
            a.update({"d": 4}) # add more For loop Repeat for each item in itera.keys()
            = iterable of keys
            Try / except Handle or ignore errors.
            able
            a.values() # ... of values
            a.items() # ... of both
            try: big_number = 1 / 0
            names = ["John", "Paul", "G"]
            except Exception as e:
            for name in names:
            print("It broke:", e)
            print("name:", name)
            Input/Output
            for x in range(0, 100):
            With Execute code in a context
            print("x:", x)
            Prompt user
            with open("file.txt") as f:
            List comprehension Create a new list
            f.write("test")
            name = input("Name? ")
            while looping
            print("Hi ", name)
            Unpacking assignment Assign
            to
            two or more, good for loops
            names
            =
            ["John",
            "Paul",
            "G"]
            Read from file and convert to str
            long_names = [
            x, y = [35, 15]
            n.lower() for n in names
            a = open("file.txt").read()
            pairs = [(10, 5), (8, 100)]
            if
            len(n)
            >
            2
            print("data:", a.decode("utf-8")) ]
            for left, right in pairs:
            = ["john", "paul"]
            print(left * right)
            Write to file creating if none
            Interruption Exit loops prematurely
            with break, skip to next iteration
            a = "Some text for o.txt"
            open("o.txt", "w+").write(a)
            with continue
            Python (3 and later)
            A cheatsheet by Kickstart Coding
 ~/Empire/Doks/Comp/lang/py/cheatsh-qref/PythonCheatSheet.pdf
 ~/Empire/Doks/Comp/lang/py/cheatsh-qref/PythonCheatSheet.txt
            Python Language & Syntax Cheat Sheet
            Python is white-space dependent; code blocks are indented 4 spaces (not tabs)
            Variable Assignment
            Accessing Variable Values
            integer = 1
            value = dictionary[key]
            string = “string”
            value = dictionary.get(key, default_value)
            unicode_string = u”unicode string”
            value = list[index]
            e.g. [5,6,7][2] → 7
            mutli_line_string = “““ multi-line
            value = string[start:end]
            e.g “string”[0:3] → “str”
            string
            value = list[start:end]
            e.g. [1,2,3][1:2] → [2]
            ”””
            value = ClassName.class_variable
            tuple = (element1, element2, element3, …)
            value = class_instance.instance_variable
            list = [ element1, element2, element3, ... ]
            value = class_instance.function(args)
            dictionary = { key1 : value1, key2 : value2, ... }
            dictionary[key] = value
            Comparisons
            class_instance = ClassName(init_args)
            value1 == value2
            “str” == “str” → True
            value1 != value2
            “str” != “str” → False
            Frequently Used Built-in Types
            value1 < value2
            1 < 2 → True
            True
            False
            None
            value1 <= value2
            2 <= 2 → True
            str
            unicode
            int
            value1 > value2
            2 > 3 → False
            float
            list
            dict
            value1 >= value2
            3 >= 3 → True
            Other than True, False and None, these can also be used as value is [not] None
            functions to explicitly cast a value to that type
            value in list
            1 in [2,3,4] → False
            isinstance(class_instance, ClassName)
            Functions
            def function_name(arg1, arg2,
            Basic Arithmetic
            keyword1=val1, keyword2=val2, ...):
            i=a+b
            i=a-b
            <function body>
            i=a/b
            i=a*b
            return return_value
            i=a%b
            e.g. 11 % 3 → 2
            e.g.
            def my_function(x, y, z=0):
            my_function(1, 2) → 3
            Comments
            sum = x + y + z
            my_function(1, 2, 3) → 6
            """
            = Line Comment
            return sum
            my_function(1, 2, y=4) → 7
            Multi-line comment
            """
            Classes
            class ClassName(SuperClass):
            Control Flow
            class_variable = static_value
            if conditional:
            if i == 7:
            def __init__(self, value1, <...>):
            <body>
            print “seven”
            self.instance_variable1 = value1
            elif conditional:
            e.g. elif i == 8:
            self.instance_function()
            <body>
            print “eight”
            def instance_function(self, arg1, <...>):
            else:
            else:
            <function body>
            <body>
            print str(i)
            return return_value
            for value in list:
            for i in [1, 2, 3, 4]:
            e.g.
            <body>
            e.g. if i == 2: continue
            class MyClass(object):
            MyClass.offset → 1
            continue
            if i == 3: break
            offset = 1
            break
            print i
            def __init__(self, value):
            c = MyClass(2)
            while conditional:
            while True:
            self.value = value
            c.value → 2
            <body>
            e.g. print “infinity”
            def get_offset_value(self): c.get_offset_value() → 3
            continue
            return MyClass.offset +
            break
            self.value
            Exceptions
            Imports
            try:
            try:
            import module
            <body>
            database.update()
            from module import class, function, variable
            raise Exception()
            e.g. except Exception as e:
            except Exception as e:
            log.error(e.msg)
            Frequently Used String Manipulations
            <exception handling>
            database.abort()
            string1 + string1
            “str” + “ing” → “string”
            finally:
            finally:
            "%s%s" % (string1, string2)
            “%s%s” % (“s”, “g”) → “sg”
            <clean-up>
            database.commit()
            string.split("delim", limit)
            “s/g”.split(“/”) → [“s”, “g”]
            string.strip()
            “ string “.strip() → “string”
            File & Path Manipulation
            string.startswith("prefix")
            “str”.startswith(“s”) → True
            import os # import the os module first
            substring in string
            “str” in “string” → True
            os.path.join(path_segment1, path_segment2, ...)
            print string
            os.path.exists(path)
            os.listdir(directory_path)
            List Comprehension
            os.remove(file_path)
            [ value for value in list if condition ]
            os.rmdir(directory_path)
            e.g.
            file = open(path, "rw")
            [x for x in [1,2,3,4,5,6,7,8,9] if x % 2 == 0] → [2,4,6,8]
            file.read()
            string.write("string")
            by Cottage Labs (http://cottagelabs.com)
            for Dev8D (http://www.dev8d.org/)

            
~/Empire/Doks/Comp/lang/py/cheatsh-qref/pynotes-ess.pdf
~/Empire/Doks/Comp/lang/py/cheatsh-qref/pynotes-ess.txt
            Python Notes/Cheat Sheet
            Comments
            = from the hash symbol to the end of a line
            Code blocks
            Delineated by colons and indented code; and not the
            curly brackets of C, C++ and Java.
            def is_fish_as_string(argument):
            if argument:
            return ‘fish’
            else:
            return ‘not fish’
            Note: Four spaces per indentation level is the Python
            standard. Never use tabs: mixing tabs and spaces
            produces hard-to-find errors. Set your editor to convert
            tabs to spaces.
            Line breaks
            Typically, a statement must be on one line. Bracketed
            code - (), [] or {} - can be split across lines; or (if you
            must) use a backslash \ at the end of a line to continue a
            statement on to the next line (but this can result in hard
            to debug code).
            Naming conventions
            Style
            Use
            StudlyCase
            Class names
            joined_lower
            Identifiers, functions; and class
            methods, attributes
            _joined_lower
            Internal class attributes
            __joined_lower
            Private class attributes
            = this use not recommended
            joined_lower
            Constants
            ALL_CAPS
            Basic object types (not a complete list)
            Type
            Examples
            None
            None
            = singleton null object
            Boolean
            True, False
            integer
            -1, 0, 1, sys.maxint
            long
            1L, 9787L
            = arbitrary length ints
            float
            3.14159265
            inf, float('inf')
            = infinity
            -inf
            = neg infinity
            nan, float('nan') # not a number
            complex
            2+3j
            = note use of j
            string
            'I am a string', "me too"
            '''multi-line string''', """+1"""
            r'raw string', b'ASCII string'
            u'unicode string'
            tuple
            empty = ()
            = empty tuple
            (1, True, 'dog') # immutable list
            list
            empty = []
            = empty list
            [1, True, 'dog'] # mutable list
            set
            empty = set() # the empty set
            set(1, True, 'a') # mutable
            dictionary
            empty = {}
            = mutable object
            {'a': 'dog', 7: 'seven’, True: 1}
            file
            f = open('filename', 'rb')
            Note: Python has four numeric types (integer, float, long
            and complex) and several sequence types including
            strings, lists, tuples, bytearrays, buffers, and xrange
            objects.

            Operators
            Operator
            +
            *
            /
            %
            //
            **
            =, -=, +=, /=,
            *=, %=, //=,
            **=
            ==, !=, <, <=,
            >=, >
            and, or, not
            in, not in
            is, is not
            |, ^, &, ~
            <<, >>
            ;

            Functionality
            Addition (also string, tuple, list
            concatenation)
            Subtraction (also set difference)
            Multiplication (also string, tuple, list
            replication)
            Division
            Modulus (also a string format function,
            but use deprecated)
            Integer division rounded towards minus
            infinity
            Exponentiation
            Assignment operators
            Boolean comparisons

            Boolean operators
            Membership test operators
            Object identity operators
            Bitwise: or, xor, and, compliment
            Left and right bit shift
            Inline statement separator
            = inline statements discouraged
            Hint: float('inf') always tests as larger than any number,
            including integers.
            Modules
            Modules open up a world of Python extensions that can
            be imported and used. Access to the functions, variables
            and classes of a module depend on how the module
            was imported.
            Import method
            Access/Use syntax
            import math
            math.cos(math.pi/3)
            import math as m
            m.cos(m.pi/3)
            = import using an alias
            from math import cos,pi
            cos(pi/3)
            = only import specifics
            from math import *
            log(e)
            = BADish global import
            Global imports make for unreadable code!!!
            Oft used modules
            Module
            Purpose
            datetime
            Date and time functions
            time
            math
            Core math functions and the constants pi
            and e
            pickle
            Serialise objects to a file
            os
            Operating system interfaces
            os.path
            re
            A library of Perl-like regular expression
            operations
            string
            Useful constants and classes
            sys
            System parameters and functions
            numpy
            Numerical python library
            pandas
            R DataFrames for Python
            matplotlib
            Plotting/charting for Python

            Version 14 March 2015 - [Draft – Mark Graph – mark dot the dot graph at gmail dot com – @Mark_Graph on twitter]

            1"

            If - flow control
            if condition:
            = for example: if x < 5:
            statements
            elif condition: # optional – can be multiple
            statements
            else:
            = optional
            statements
            For - flow control
            for x in iterable:
            statements
            else:
            = optional completion code
            statements
            While - flow control
            while condition:
            statements
            else:
            = optional completion code
            statements
            Ternary statement
            id = expression if condition else expression
            x = y if a > b else z - 5
            Some useful adjuncts:
            • pass - a statement that does nothing
            • continue - moves to the next loop iteration
            • break - to exit for and while loop
            Trap: break skips the else completion code
            Exceptions – flow control
            try:
            statements
            except (tuple_of_errors): # can be multiple
            statements
            else:
            = optional no exceptions
            statements
            finally:
            = optional all
            statements
            Common exceptions (not a complete list)
            Exception
            Why it happens
            AsserionError
            Assert statement failed
            AttributeError
            Class attribute assignment or
            reference failed
            IOError
            Failed I/O operation
            ImportError
            Failed module import
            IndexError
            Subscript out of range
            KeyError
            Dictionary key not found
            MemoryError
            Ran out of memory
            NameError
            Name not found
            TypeError
            Value of the wrong type
            ValueError
            Right type but wrong value
            Raising errors
            Errors are raised using the raise statement
            raise ValueError(value)
            Creating new errors
            class MyError(Exception):
            def __init__(self, value):
            self.value = value
            def __str__(self):
            return repr(self.value)

            Objects and variables (AKA identifiers)
            • Everything is an object in Python (in the sense that it
            can be assigned to a variable or passed as an
            argument to a function)
            • Most Python objects have methods and attributes.
            For example, all functions have the built-in attribute
            __doc__, which returns the doc string defined in the
            function's source code.
            • All variables are effectively "pointers", not "locations".
            They are references to objects; and often called
            identifiers.
            • Objects are strongly typed, not identifiers
            • Some objects are immutable (int, float, string, tuple,
            frozenset). But most are mutable (including: list, set,
            dictionary, NumPy arrays, etc.)
            • You can create our own object types by defining a
            new class (see below).
            Booleans and truthiness
            Most Python objects have a notion of "truth".
            False
            True
            None
            0
            Any number other than 0
            int(False) # ! 0
            int(True) # ! 1
            ""
            " ", 'fred', 'False'
            = the empty string
            = all other strings
            () [] {} set()
            [None], (False), {1, 1}
            = empty containers
            = non-empty containers,
            including those containing
            False or None.
            You can use bool() to discover the truth status of an
            object.
            a = bool(obj)
            = the truth of obj
            It is pythonic to use the truth of objects.
            if container:
            = test not empty
            = do something
            while items:
            = common looping idiom
            item = items.pop()
            = process item
            Specify the truth of the classes you write using the
            __nonzero__() magic method.
            Comparisons
            Python lets you compare ranges, for example
            if 1 < x < 100: # do something ...
            Tuples
            Tuples are immutable lists. They can be searched,
            indexed and iterated much like lists (see below). List
            methods that do not change the list also work on tuples.
            a = ()
            = the empty tuple
            a = (1,) # " note comma # one item tuple
            a = (1, 2, 3)
            = multi-item tuple
            a = ((1, 2), (3, 4))
            = nested tuple
            a = tuple(['a', 'b'])
            = conversion
            Note: the comma is the tuple constructor, not the
            parentheses. The parentheses add clarity.
            The Python swap variable idiom
            a, b = b, a
            = no need for a temp variable
            This syntax uses tuples to achieve its magic.

            Version 14 March 2015 - [Draft – Mark Graph – mark dot the dot graph at gmail dot com – @Mark_Graph on twitter]

            2"

            String (immutable, ordered, characters)
            s = 'string'.upper()
            = STRING
            s = 'fred'+'was'+'here'
            = concatenation
            s = ''.join(['fred', 'was', 'here']) # ditto
            s = 'spam' * 3
            = replication
            s = str(x)
            = conversion
            String iteration and sub-string searching
            for character in 'str':
            = iteration
            print (ord(character))
            = 115 116 114
            for index, character in enumerate('str')
            print (index, character)
            if 'red' in 'Fred':
            = searching
            print ('Fred is red')
            = it prints!
            String methods (not a complete list)
            capitalize, center, count, decode, encode, endswith,
            expandtabs, find, format, index, isalnum, isalpha, isdigit,
            islower, isspace, istitle, isupper, join, ljust, lower, lstrip,
            partition, replace, rfind, rindex, rjust, rpartition, rsplit,
            rstrip, split, splitlines, startswith, strip, swapcase, title,
            translate, upper, zfill
            String constants (not a complete list)
            from string import *
            = I'm bad ...
            print ((digits, hexdigits, letters,
            lowercase, uppercase, punctuation))
            Old school string formatting (using % oper)
            print ("It %s %d times" % ['occurred', 5])
            = prints: 'It occurred 5 times'
            Code
            s
            c
            d
            u
            H or h
            f
            E or e
            G or g
            %

            Meaning
            String or string conversion
            Character
            Signed decimal integer
            Unsigned decimal integer
            Hex integer (upper or lower case)
            Floating point
            Exponent (upper or lower case E)
            The shorter of e and f (u/l case)
            Literal '%'

            '%s' % math.pi
            '%f' % math.pi
            '%.2f' % math.pi
            '%.2e' % 3000
            '%03d' % 5

            = --> '3.14159265359'
            = --> '3.141593'
            = --> '3.14'
            = --> '3.00e+03'
            = --> '005'

            New string formatting (using format method)
            Uses: 'template-string'.format(arguments)
            Examples (using similar codes as above):
            'Hello {}'.format('World')# 'Hello World'
            '{}'.format(math.pi)
            = ' 3.14159265359'
            '{0:.2f}'.format(math.pi) # '3.14'
            '{0:+.2f}'.format(5)
            = '+5.00'
            '{:.2e}'.format(3000)
            = '3.00e+03'
            '{:0>2d}'.format(5)
            = '05' (left pad)
            '{:x<3d}'.format(5)
            = '5xx' (rt. pad)
            '{:,}'.format(1000000)
            = '1,000,000'
            '{:.1%}'.format(0.25)
            = '25.0%'
            '{0}{1}'.format('a', 'b') # 'ab'
            '{1}{0}'.format('a', 'b') # 'ba'
            '{num:}'.format(num=7)
            = '7' (named args)

            List (mutable, indexed, ordered container)
            Indexed from zero to length-1
            a = []
            = the empty list
            a = ['dog', 'cat', 'bird'] # simple list
            a = [[1, 2], ['a', 'b']]
            = nested lists
            a = [1, 2, 3] + [4, 5, 6]
            = concatenation
            a = [1, 2, 3] * 456
            = replication
            a = list(x)
            = conversion
            List comprehensions (can be nested)
            Comprehensions: a tight way of creating lists
            t3 = [x*3 for x in [5, 6, 7]] # [15, 18, 21]
            z = [complex(x, y) for x in range(0, 4, 1)
            for y in range(4, 0, -1) if x > y]
            = z --> [(2+1j), (3+2j), (3+1j)]
            Iterating lists
            L = ['dog', 'cat', 'turtle']
            for item in L
            print (item)
            for index, item in enumerate(L):
            print (index, item)
            Searching lists
            L = ['dog', 'cat', 'turtle']; value = 'cat'
            if value in L:
            count = L.count(value)
            first_occurrence = L.index(value)
            if value not in L:
            print 'list is missing {}'.format(value)
            List methods (not a complete list)
            Method
            What it does
            l.append(x)
            Add x to end of list
            l.extend(other)
            Append items from other
            l.insert(pos, x)
            Insert x at position
            del l[pos]
            Delete item at pos
            l.remove(x)
            Remove first occurrence of x; An
            error if no x
            l.pop([pos])
            Remove last item from list (or
            item from pos); An error if empty
            list
            l.index(x)
            Get index of first occurrence of
            x; An error if x not found
            l.count(x)
            Count the number of times x is
            found in the list
            l.sort()
            In place list sort
            l.reverse(x)
            In place list reversal
            List slicing
            x = [0, 1, 2, 3, 4, 5, 6, 7, 8] # play data
            x[2]
            = 3rd element - reference not slice
            x[1:3]
            = 2nd to 3rd element (1, 2)
            x[:3]
            = The first three elements (0,1,2)
            x[-3:]
            = last three elements
            x[:-3]
            = all but the last three elements
            x[:]
            = every element of x – copies x
            x[1:-1] # all but first and last element
            x[::3] # (0, 3, 6, 9, …) 1st then every 3rd
            x[1:5:2]# (1,3) start 1, stop >= 5, every2nd
            Note: All Python sequence types support the above
            index slicing (strings, lists, tuples, bytearrays, buffers,
            and xrange objects)

            Version 14 March 2015 - [Draft – Mark Graph – mark dot the dot graph at gmail dot com – @Mark_Graph on twitter]

            3"

            Set (unique, unordered container)
            A Python set is an unordered, mutable collection of
            unique hashable objects.
            a = set()
            = empty set
            a = {'red', 'white', 'blue'} # simple set
            a = set(x)
            = convert list
            Trap: {} creates empty dict, not an empty set
            Set comprehensions
            = a set of selected letters...
            s = {e for e in 'ABCHJADC' if e not in 'AB'}
            = --> {'H', 'C', 'J', 'D'}
            = a set of tuples ...
            s = {(x,y) for x in range(-1,2)
            for y in range (-1,2)}
            Trap: set contents need to be immutable to be
            hashable. So you can have a set of
            tuples, but not a set of lists.
            Iterating a set
            for item in set:
            print (item)
            Searching a set
            if item in set:
            print (item)
            if item not in set:
            print ('{} is missing'.format(item))
            Set methods (not a complete list)
            Method
            What it does
            len(s)
            Number of items in set
            s.add(item)
            Add item to set
            s.remove(item)
            Remove item from set. Raise
            KeyError if item not found.
            s.discard(item)
            Remove item from set if present.
            s.pop()
            Remove and return an arbitrary
            item. Raise KeyError on empty
            set.
            s.clear()
            Remove all items from set
            item in s
            True or False
            item not in s
            True or False
            iter(s)
            An iterator over the items in the
            set (arbitrary order)
            s.copy()
            Get shallow copy of set
            s.isdisjoint(o)
            True if s has not items in
            common with other set o
            s.issubset(o)
            Same as set <= other
            s.issuperset(o)
            Same as set >= other
            s.union(o[, ...])
            Return new union set
            s.intersection(o)
            Return new intersection
            s.difference(o)
            Get net set of items in s but not
            others (Same as set – other)
            Frozenset
            Similar to a Python set above, but immutable (and
            therefore hashable).
            f = frozenset(s)
            = convert set
            f = frozenset(o)
            = convert other

            Dictionary (indexed, unordered map-container)
            A mutable hash map of unique key=value pairs.
            a = {}
            = empty dictionary
            a = {1: 1, 2: 4, 3: 9} # simple dict
            a = dict(x)
            = convert paired data
            = next example – create from a list
            l = ['alpha', 'beta', 'gamma', 'delta']
            a = dict(zip(range(len(l)), l))
            = Example using string & generator
            expression
            s = 'a=apple,b=bird,c=cat,d=dog,e=egg'
            a = dict(i.split("=") for i in s.split(","))
            = {'a': 'apple', 'c': 'cat', 'b': 'bird',
            = 'e': 'egg', 'd': 'dog'}
            Dictionary comprehensions
            Conceptually like list comprehensions; but it constructs a
            dictionary rather than a list
            a = { n: n*n for n in range(7) }
            = a -> {0:0, 1:1, 2:4, 3:9, 4:16, 5:25,6:36}
            odd_sq = { n: n*n for n in range(7) if n%2 }
            = odd_sq -> {1: 1, 3: 9, 5: 25}
            = next example -> swaps the key:value pairs
            a = { val: key for key, val in a.items() }
            = next example -> count list occurrences
            l = [1,2,9,2,7,3,7,1,22,1,7,7,22,22,9,0,9,0]
            c = { key: l.count(key) for key in set(l) }
            = c -> {0:2, 1:3, 2:2, 3:1, 7:4, 9:3, 22:3}
            Iterating a dictionary
            for key in dictionary:
            print (key)
            for key, value in dictionary.items():
            print (key, value)
            Searching a dictionary
            if key in dictionary:
            print (key)
            Merging two dictionaries
            merged = dict_1.copy()
            merged.update(dict_2)
            Dictionary methods (not a complete list)
            Method
            What it does
            len(d)
            Number of items in d
            d[key]
            Get value for key or raise the
            KeyError exception
            d[key] = value
            Set key to value
            del d[key]
            deletion
            key in d
            True or False
            key not in d
            True or False
            iter(d)
            An iterator over the keys
            d.clear()
            Remove all items from d
            d.copy()
            Shallow copy of dictionary
            d.get(key[, def])
            Get value else default
            d.items()
            Dictionary's (k,v) pairs
            d.keys()
            Dictionary's keys
            d.pop(key[, def])
            Get value else default; remove
            key from dictionary
            d.popitem()
            Remove and return an arbitrary
            (k, v) pair
            d.setdefault(k[,def]))
            If k in dict return its value
            otherwise set def
            d.update(other_d)
            Update d with key:val pairs
            from other
            d.values()
            The values from dict

            Version 14 March 2015 - [Draft – Mark Graph – mark dot the dot graph at gmail dot com – @Mark_Graph on twitter]

            4"

            Key functions (not a complete list)
            Function
            What it does
            abs(num)
            Absolute value of num
            all(iterable)
            True if all are True
            any(iterable)
            True if any are True
            bytearray(source)
            A mutable array of bytes
            callable(obj)
            True if obj is callable
            chr(int)
            Character for ASCII int
            complex(re[, im])
            Create a complex number
            divmod(a, b)
            Get (quotient, remainder)
            enumerate(seq)
            Get an enumerate object, with
            next() method returns an (index,
            element) tuple
            eval(string)
            Evaluate an expression
            filter(fn, iter)
            Construct a list of elements from
            iter for which fn() returns True
            float(x)
            Convert from int/string
            getattr(obj, str)
            Like obj.str
            hasattr(obj, str)
            True if obj has attribute
            hex(x)
            From in to hex string
            id(obj)
            Return unique (run-time)
            identifier for an object
            int(x)
            Convert from float/string
            isinstance(o, c)
            Eg. isinstance(2.1, float)
            len(x)
            Number of items in x; x is string,
            tuple, list, dict
            list(iterable)
            Make a list
            long(x)
            Convert a string or number to a
            long integer
            map(fn, iterable)
            Apply fn() to every item in
            iterable; return results in a list
            max(a,b)
            What it says on the tin
            max(iterable)
            min(a,b)
            Ditto
            min(iterable)
            next(iterator)
            Get next item from an iter
            open(name[,mode]) Open a file object
            ord(c)
            Opposite of chr(int)
            pow(x, y)
            Same as x ** y
            print (objects)
            What it says on the tin
            takes end arg (default \n)
            and sep arg (default ' ')
            range(stop)
            integer list; stops < stop
            range(start,stop)
            default start=0;
            range(fr,to,step)
            default step=1
            reduce(fn, iter)
            Applies the two argument fn(x, y)
            cumulatively to the items of iter.
            repr(object)
            Printable representation of an
            object
            reversed(seq)
            Get a reversed iterator
            round(n[,digits])
            Round to number of digits after
            the decimal place
            setattr(obj,n,v)
            Like obj.n = v #name/value
            sorted(iterable)
            Get new sorted list
            str(object)
            Get a string for an object
            sum(iterable)
            Sum list of numbers
            type(object)
            Get the type of object
            xrange()
            Like range() but better: returns
            an iterator
            zip(x, y[, z])
            Return a list of tuples

            Using functions
            When called, functions can take positional and named
            arguments.
            For example:
            result = function(32, aVar, c='see', d={})
            Arguments are passed by reference (ie. the objects are
            not copied, just the references).
            Writing a simple function
            def funct(arg1, arg2=None, *args, **kwargs):
            """explain what this function does"""
            statements
            return x
            = optional statement
            Note: functions are first class objects that get
            instantiated with attributes and they can be referenced
            by variables.
            Avoid named default mutable arguments
            Avoid mutable objects as default arguments.
            Expressions in default arguments are evaluated when
            the function is defined, not when it’s called. Changes to
            mutable default arguments survive between function
            calls.
            def nasty(value=[]):
            = <-- mutable arg
            value.append('a')
            return value
            print (nasty ()) # --> ['a']
            print (nasty ()) # --> ['a', 'a']
            def better(val=None):
            val = [] if val is None else val
            value.append('a')
            return value

            Lambda (inline expression) functions:
            g = lambda x: x ** 2
            = Note: no return
            print(g(8))
            = prints 64
            mul = lambda a, b: a * b # two arguments
            mul(4, 5) == 4 * 5
            = --> True
            Note: only for expressions, not statements.
            Lambdas are often used with the Python functions
            filter(), map() and reduce().
            = get only those numbers divisible by three
            div3 = filter(lambda x: x%3==0,range(1,101))
            Typically, you can put a lambda function anywhere you
            put a normal function call.
            Closures
            Closures are functions that have inner functions with
            data fixed in the inner function by the lexical scope of
            the outer. They are useful for avoiding hard constants.
            Wikipedia has a derivative function for changeable
            values of dx, using a closure.
            def derivative(f, dx):
            """Return a function that approximates
            the derivative of f using an interval
            of dx, which should be appropriately
            small.
            """
            def _function(x):
            return (f(x + dx) - f(x)) / dx
            return _function #from derivative(f, dx)
            f_dash_x = derivative(lambda x: x*x,0.00001)
            f_dash_x(5) # yields approx. 10 (ie. y'=2x)

            Version 14 March 2015 - [Draft – Mark Graph – mark dot the dot graph at gmail dot com – @Mark_Graph on twitter]

            5"

            An iterable object
            The contents of an iterable object can be selected one
            at a time. Such objects include the Python sequence
            types and classes with the magic method __iter__(),
            which returns an iterator. An iterable object will produce
            a fresh iterator with each call to iter().
            iterator = iter(iterable_object)
            Iterators
            Objects with a next() (Python 2) or __next__() (Python
            3) method, that:
            • returns the next value in the iteration
            • updates the internal note of the next value
            • raises a StopIteration exception when done
            Note: with the loop for x in y: if y is not an iterator;
            Python calls iter() to get one. With each loop, it calls
            next() on the iterator until a StopIteration exception.
            x = iter('XY') # iterate a string by hand
            print (next(x)) # --> X
            print (next(x)) # --> Y
            print (next(x)) # --> StopIteration
            Generators
            Generator functions are resumable functions that work
            like iterators. They can be more space or time efficient
            than iterating over a list, (especially a very large list), as
            they only produce items as they are needed.
            def fib(max=None):
            """ generator for Fibonacci sequence"""
            a, b = 0, 1
            while max is None or b <= max:
            yield b
            = " yield is like return
            a, b = b, a+b
            [i for i in fib(10)] # ! [1, 1, 2, 3, 5, 8]

            Note: a return statement (or getting to the end of the
            function) ends the iteration.
            Trap: a yield statement is not allowed in the try clause of
            a try/finally construct.
            Messaging the generator
            def resetableCounter(max=None):
            j = 0
            while max is None or j <= max:
            x = yield j # " x gets the sent arg
            j = j+1 if x is None else x
            x = resetableCounter(10)
            print x.send(None) # ! 0
            print x.send(5)
            = ! 5
            print x.send(None) # ! 6
            print x.send(11)
            = ! StopIteration

            Classes
            Python is an object-oriented language with a multiple
            inheritance class mechanism that encapsulates program
            code and data.
            Methods and attributes
            Most objects have associated functions or “methods”
            that are called using dot syntax:
            obj.method(arg)
            Objects also often have attributes or values that are
            directly accessed without using getters and setters
            (most unlike Java or C++)
            instance = Example_Class()
            print (instance.attribute)
            Simple example
            import math
            class Point:
            = static class variable, point count
            count = 0
            def __init__(self, x, y):
            self.x = float(x)
            self.y = float(y)
            Point.count += 1
            def __str__(self):
            return \
            '(x={}, y={})'.format(self.x,
            self.y)
            def to_polar(self):
            r = math.sqrt(self.x**2 + self.y**2)
            theta = math.atan2(self.y, self.x)
            return(r, theta)
            = static method – trivial example ...
            def static_eg(n):
            print ('{}'.format(n))
            static_eg = staticmethod(static_eg)
            = Instantiate 9 points & get polar coords
            for x in range(-1, 2):
            for y in range(-1, 2):
            p = Point(x, y)
            print (p) # uses __str__() method
            print (p.to_polar())
            print (Point.count) # check static variable
            Point.static_eg(9) # check static method

            Trap: must send None on first send() call

            The self
            Class methods have an extra argument over functions.
            Usually named 'self'; it is a reference to the instance. It
            is not used in the method call; and is provided by Python
            to the method. Self is like 'this' in C++ & Java

            Generator expressions
            Generator expressions build generators, just like
            building a list from a comprehension. You can turn a list
            comprehension into a generator expression simply by
            replacing the square brackets [] with parentheses ().
            [i for i in xrange(10)] # list comprehension
            list(i for i in xrange(10)) # generated list

            Public and private methods and variables
            Python does not enforce the public v private data
            distinction. By convention, variables and methods that
            begin with an underscore should be treated as private
            (unless you really know what you are doing). Variables
            that begin with double underscore are mangled by the
            compiler (and hence more private).

            Version 14 March 2015 - [Draft – Mark Graph – mark dot the dot graph at gmail dot com – @Mark_Graph on twitter]

            6"

            Inheritance
            class DerivedClass1(BaseClass):
            statements
            class DerivedClass2(module_name.BaseClass):
            statements
            Multiple inheritance
            class DerivedClass(Base1, Base2, Base3):
            statements
            Decorators
            Technically, decorators are just functions (or classes),
            that take a callable object as an argument, and return an
            analogous object with the decoration. We will skip how
            to write them, and focus on using a couple of common
            built in decorators.
            Practically, decorators are syntactic sugar for more
            readable code. The @wrapper is used to transform the
            existing code. For example, the following two method
            definitions are semantically equivalent.
            def f(...):
            ...
            f = staticmethod(f)
            @staticmethod
            def f(...):
            ...

            Getters and setters
            Although class attributes can be directly accessed, the
            property function creates a property manager.
            class Example:
            def __init__(self):
            self._x = None
            def getx(self):
            return self._x
            def setx(self, value):
            self._x = value
            def delx(self):
            del self._x
            x = property(getx, setx, delx,"Doc txt")

            Which can be rewritten with decorators as:
            class Example:
            def __init__(self):
            self._x = None
            @property
            def x(self):
            """Doc txt: I'm the 'x' property."""
            return self._x
            @x.setter
            def x(self, value):
            self._x = value
            @x.deleter
            def x(self):
            del self._x

            Magic class methods (not a complete list)
            Magic methods (which begin and end with double
            underscore) add functionality to your classes consistent
            with the broader language.
            Magic method
            What it does
            __init__(self,[...])
            Constructor
            __del__(self)
            Destructor pre-garbage
            collection
            __str__(self)
            Human readable string for
            class contents. Called by
            str(self)
            __repr__(self)
            Machine readable
            unambiguous Python
            string expression for class
            contents. Called by
            repr(self) Note: str(self)
            will call __repr__ if
            __str__ is not defined.
            __eq__(self, other)
            Behaviour for ==
            __ne__(self, other)
            Behaviour for !=
            __lt__(self, other)
            Behaviour for <
            __gt__(self, other)
            Behaviour for >
            __le__(self, other)
            Behaviour for <=
            __ge__(self, other)
            Behaviour for >=
            __add__(self, other)
            Behaviour for +
            __sub__(self, other)
            Behaviour for __mul__(self, other)
            Behaviour for *
            __div__(self, other)
            Behaviour for /
            __mod__(self, other)
            Behaviour for %
            __pow__(self, other)
            Behaviour for **
            __pos__(self, other)
            Behaviour for unary +
            __neg__(self, other)
            Behaviour for unary __hash__(self)
            Returns an int when
            hash() called. Allows class
            instance to be put in a
            dictionary
            __len__(self)
            Length of container
            __contains__(self, i)
            Behaviour for in and not in
            operators
            __missing__(self, i)
            What to do when dict key i
            is missing
            __copy__(self)
            Shallow copy constructor
            __deepcopy__(self,
            Deep copy constructor
            memodict={})
            __iter__(self)
            Provide an iterator
            __nonzero__(self)
            Called by bool(self)
            __index__(self)
            Called by x[self]
            __setattr__(self,
            Called by
            name, val)
            self.name = val
            __getattribute__(self,
            Called by self.name
            name)
            __getattr__(self,
            Called when self.name
            name)
            does not exist
            __delattr__(self,
            Called by
            name)
            del self.name
            __getitem__(self, key)
            Called by self[key]
            __setitem__(self, key,
            Called by
            val)
            self[key] = val
            __delitem__(self, key)
            del self[key]

            Version 14 March 2015 - [Draft – Mark Graph – mark dot the dot graph at gmail dot com – @Mark_Graph on twitter]

            7"

            
--
 ~/Empire/Doks/Comp/lang/py/cheatsh-qref/py-whirlwindtour.pdf  #Toc
 ~/Empire/Doks/Comp/lang/py/cheatsh-qref/py-whirlwindtour.txt
            Introduction
            Using Code Examples
            How to Run Python Code
            A Quick Tour of Python Language Syntax
            Basic Python Semantics: Variables and Objects
            Basic Python Semantics: Operators
            Built-In Types: Simple Values
            Built-In Data Structures
            Control Flow
            Defining and Using Functions
            Errors and Exceptions
            Iterators
            List Comprehensions
            Generators
            Modules and Packages
            String Manipulation and Regular Expressions
            A Preview of Data Science Tools
            Resources for Further Learning

~/Empire/Doks/Comp/lang/py/cheatsh-qref/cheatsheet.pdf
~/Empire/Doks/Comp/lang/py/cheatsh-qref/cheatsheet.txt
            Python 3 Cheat Sheet

            Base Types

            integer, float, boolean, string

            int
            float
            bool
            str

            783
            0
            -192
            9.23 0.0
            -1.7e-6
            10-6
            True False
            "One\nTwo" 'I\'m'
            new line
            multiline

            immutable,
            ordered sequence of chars

            str

            as an ordered sequence of chars

            dict {"key":"value"}
            {}
            {1:"one",3:"three",2:"two",3.14:"π"}

            dictionary

            key/value associations

            set {"key1","key2"}

            Identifiers

            {1,9,3,0}

            set()

            type(expression)

            Conversions

            int("15") can specify integer number base in 2nd parameter
            int(15.56) truncate decimal part (round(15.56) for rounded integer)
            float("-11.24e8")
            str(78.3) and for litteral representation
            repr("Text")
            see other side for string formating allowing finer control
            use comparators (with ==, !=, <, >, …), logical boolean result
            bool
            use each element
            list("abc")
            ['a','b','c']

            Variables assignment

            from sequence

            x = 1.2+8+sin(0)

            dict([(3,"three"),(1,"one")])

            value or computed expression
            variable name (identifier)

            y,z,r = 9.2,-7.6,"bad"

            {1:'one',3:'three'}

            use each element
            from sequence

            set(["one","two"])

            container with several
            values (here a tuple)
            increment
            x-=2
            decrement
            « undefined » constant value

            {'one','two'}

            ":".join(['toto','12','pswd'])
            joining string

            positive index

            -6
            0

            -5
            1

            spaces".split()

            ['words','with','spaces']

            "1,4,8,2".split(",")

            ['1','4','8','2']

            splitting string

            -4
            2

            -3
            3

            -2
            4

            len(lst)

            -1
            5

            lst=[11, 67, "abc", 3.14, 42, 1968]
            0
            negative slice -6
            positive slice

            1
            -5

            2
            -4

            'toto:12:pswd'

            sequence of strings

            "words with

            for lists, tuples, strings, …
            negative index

            []
            ()

            ◾ no a priori order, unique key, fast key access ; keys = base types or tuples

            tab char

            ☺ a toto x7 y_max BigOne
            ☹ 8y and

            x+=3
            x=None

            ["x",11,8.9] ["word"]
            11,"y",7.4
            ("word",)
            expression with just comas

            immutable

            """X\tY\tZ
            1\t2\t3"""

            a‥zA‥Z_ followed by a‥zA‥Z_0‥9
            ◽ diacritics allowed but should be avoided
            ◽ language keywords forbidden
            ◽ lower/UPPER case discrimination

            variables
            names

            Container Types

            ◾ ordered sequence, fast index access, repeatable values

            list [1,5,9]
            tuple (1,5,9)

            ' escaped

            for variables, functions,
            modules, classes… names

            Official Python documentation on
            http://docs.python.org/py3k

            Python 3 Cheat Sheet

            3
            -3

            4
            -2

            5
            -1

            6

            6

            Sequences indexing

            individual access to items via [index]

            lst[1]→67
            lst[-2]→42

            lst[0]→11 first one
            lst[-1]→1968 last one

            access to sub-sequences via [start slice:end slice:step]

            lst[:-1]→[11,67,"abc",3.14,42]
            lst[1:-1]→[67,"abc",3.14,42]
            lst[::2]→[11,"abc",42]
            lst[:]→[11,67,"abc",3.14,42,1968]

            lst[1:3]→[67,"abc"]
            lst[-3:-1]→[3.14,42]
            lst[:3]→[11,67,"abc"]
            lst[4:]→[42,1968]

            Missing slice indication → from start / up to end.
            On mutable sequences, usable to remove del lst[3:5] and to modify with assignment lst[1:4]=['hop',9]

            both simultaneously

            a or b logical or
            one or other or both
            logical not
            not a
            True true constant value
            False false constant value

            Statements Blocks
            parent statement:
            statements block 1…
            ⁝
            parent statement:
            statements block 2…
            ⁝
            indentation !

            Boolean Logic
            Comparators: < > <= >= == !=
            ≤ ≥ = ≠
            a and b logical and

            next statement after block 1

            ☝ floating point numbers… approximated values!

            angles in radians

            Maths

            Operators: + - * / // % **

            from math import sin,pi…

            (1+5.3)*2→12.6
            abs(-3.2)→3.2
            round(3.57,1)→3.6

            sin(pi/4)→0.707…
            cos(2*pi/3)→-0.4999…
            acos(0.5)→1.0471…
            sqrt(81)→9.0
            √
            log(e**2)→2.0 etc. (cf doc)

            × ÷
            ab
            integer ÷ ÷ remainder

            statements block executed
            only if a condition is true

            Conditional Statement

            if logical expression:
            statements block
            can go with several elif, elif... and only one final else,
            example :

            if x==42:
            = block if logical expression x==42 is true
            print("real truth")
            elif x>0:
            = else block if logical expression x>0 is true
            print("be positive")
            elif bFinished:
            = else block if boolean variable bFinished is true
            print("how, finished")
            else:
            = else block for other cases
            print("when it's not")

            Conditional loop statement

            while logical expression:
            statements block

            Loop control

            s = 0
            i = 1 initializations before the loop

            break

            condition with at least one variable value (here i)

            continue

            immediate exit

            while i <= 100:
            = statement executed as long as i ≤ 100
            i=100
            s = s + i**2
            s=
            i2
            i = i + 1 ☝ make condition variable change
            i=1

            next iteration

            print("sum:",s) computed result after the loop
            Display / Input

            print("v=",3,"cm :",x,",",y+4)

            s = input("Instructions:")
            ☝ input always returns a string, convert it to required type
            (cf boxed Conversions on on ther side).

            Go simultaneously over sequence's index and values:

            for idx,val in enumerate(lst):

            Special for sequence containeurs (lists, tuples, strings) :

            reversed(c)→ reverse iterator c*5 → duplicate c+c2 → concatenate
            c.index(val) → position
            c.count(val)→ events count
            Operations on lists
            add item at end
            lst.append(item)
            add sequence of items at end
            lst.extend(seq)
            insert item at index
            lst.insert(idx,val)
            remove first item with value
            lst.remove(val)
            remove item at index and return its value
            lst.pop(idx)
            sort / reverse list in place
            lst.sort() lst.reverse()
            ☝ modify original list

            Operations on sets

            Operators:
            | → union (vertical bar char)
            & → intersection
            - ^ → difference/symetric diff
            < <= > >= → inclusion relations

            s.update(s2)
            s.add(key) s.remove(key)
            s.discard(key)
            Files

            storing data on disk, and reading it back

            f = open("fil.txt","w",encoding="utf8")

            writing

            f.write("hello")

            encoding of
            chars for text
            files:
            uft8 ascii
            latin1 …

            empty string if end of file

            reading

            s = f.read(4)if char count not

            read next
            specified, read
            ☝ text file → read /write only
            line
            whole file
            strings, convert from/to required
            type.
            s = f.readline()
            f.close() ☝ don't forget to close file after use
            Pythonic automatic close : with open(…) as f:
            very common: iterative loop reading lines of a text file

            for line in f :
            = line processing block

            loop variable, value managed by for statement

            Go over sequence's index
            ◽ modify item at index
            ◽ access items around index (before/after)

            len(c)→ items count
            Operations on containers
            Note: For dictionaries and set, these
            min(c) max(c) sum(c)
            operations use keys.
            sorted(c) → sorted copy
            val in c → boolean, membersihp operator in (absence not in)
            enumerate(c)→ iterator on (index,value)

            cf functions in modules os and os.path

            s = "Some text" initializations before the loop
            cnt = 0

            lst = [11,18,9,12,23,4,17]
            lost = []
            for idx in range(len(lst)):
            val = lst[idx]
            Limit values greater
            than 15, memorization
            if val > 15:
            of lost values.
            lost.append(val)
            lst[idx] = 15
            print("modif:",lst,"-lost:",lost)

            items to display: litteral values, variables, expressions
            print options:
            ◽ sep=" " (items separator, default space)
            ◽ end="\n" (end of print, default new line)
            ◽ file=f (print to file, default standard output)

            opening mode
            ◽ 'r' read
            ◽ 'w' write
            ◽ 'a' append…

            Go over sequence's values

            loop on dict/set = loop on sequence of keys
            use slices to go over a subset of the sequence

            ☝ be careful of inifinite loops !

            file variable name of file
            for operations on disk
            (+path…)

            for variable in sequence:
            statements block

            for c in s:
            Count number of
            if c == "e":
            e in the string
            cnt = cnt + 1
            print("found",cnt,"'e'")

            ∑

            Operations on dictionaries
            d[key]=value
            d.clear()
            d[key]→value
            del d[clé]
            d.update(d2) update/add
            associations
            d.keys()
            d.values() views on keys, values
            d.items() associations
            d.pop(clé)

            Iterative loop statement

            statements block executed for each
            item of a container or iterator

            Generator of int sequences

            frequently used in
            for iterative loops

            default 0

            not included

            range([start,]stop [,step])
            range(5)
            0 1 2 3 4
            range(3,8)
            3 4 5 6 7
            range(2,12,3)
            2 5 8 11
            range returns a « generator », converts it to list to see
            the values, example:
            print(list(range(4)))
            function name (identifier)
            Function definition
            named parameters

            def fctname(p_x,p_y,p_z):
            """documentation"""
            = statements block, res computation, etc.
            result value of the call.
            return res
            ☝ parameters and all of this bloc
            only exist in the block and during
            the function call ("black box")

            if no computed result to
            return: return None

            r = fctname(3,i+2,2*i)

            Function call

            one argument per parameter
            retrieve returned result (if necessary)
            formating directives

            Strings formating

            values to format

            "model {} {} {}".format(x,y,r)
            "{selection:formating!conversion}"

            str

            ◽ Selection :
            "{:+2.3f}".format(45.7273)
            2
            →'+45.727'
            x
            "{1:>10s}".format(8,"toto")
            0.nom
            →'
            toto'
            4[key]
            "{!r}".format("I'm")
            0[2]
            →'"I\'m"'
            ◽ Formating :
            fillchar alignment sign minwidth.precision~maxwidth type
            Examples

            statements block executed as long
            as condition is true

            <>^=
            + - space
            0 at start for filling with 0
            integer: b binary, c char, d decimal (default), o octal, x or X hexa…
            float: e or E exponential, f or F fixed point, g or G appropriate (default),
            % percent
            string : s …
            ◽ Conversion : s (readable text) or r (litteral representation)

            
~/Empire/Doks/Comp/lang/py/cheatsh-qref/mementopython3-english.pdf
~/Empire/Doks/Comp/lang/py/cheatsh-qref/mementopython3-english.txt
            Python 3 Cheat Sheet

            Base Types
            integer, float, boolean, string, bytes
            int 783 0 -192 0b010 0o642 0xF3
            binary

            zero

            octal

            float 9.23 0.0 -1.7e-6
            -6
            ×10
            bool True False
            str "One\nTwo"
            Multiline string:
            escaped new line

            hexa

            """X\tY\tZ
            1\t2\t3"""

            escaped '

            escaped tab

            a…zA…Z_ followed by a…zA…Z_0…9
            ◽ diacritics allowed but should be avoided
            ◽ language keywords forbidden
            ◽ lower/UPPER case discrimination

            ☺ a toto x7 y_max BigOne
            ☹ 8y and for

            Variables assignment

            =

            ☝ assignment ⇔ binding of a name with a value
            1) evaluation of right side expression value
            2) assignment in order with left side names

            x=1.2+8+sin(y)
            a=b=c=0 assignment to same value
            y,z,r=9.2,-7.6,0 multiple assignments
            a,b=b,a values swap
            a,*b=seq unpacking of sequence in
            *a,b=seq item and list
            and
            x+=3
            increment ⇔ x=x+3
            *=
            x-=2
            /=
            decrement ⇔ x=x-2
            %=
            x=None « undefined » constant value
            del x

            …

            remove name x

            negative index
            positive index

            -5
            0

            ◾ key containers, no a priori order, fast key access, each key is unique
            dictionary

            0
            -5

            1
            -4

            set {"key1","key2"}

            2
            -3

            3
            -2

            {}

            {1,9,3,0}

            set()

            frozenset immutable set

            empty

            Conversions
            type(expression)
            int("15") → 15
            nd
            int("3f",16) → 63
            can specify integer number base in 2 parameter
            int(15.56) → 15
            truncate decimal part
            float("-11.24e8") → -1124000000.0
            round(15.56,1)→ 15.6
            rounding to 1 decimal (0 decimal → integer number)
            bool(x) False for null x, empty container x , None or False x ; True for other x
            str(x)→ "…" representation string of x for display (cf. formatting on the back)
            chr(64)→'@' ord('@')→64
            code ↔ char
            repr(x)→ "…" literal representation string of x
            bytes([72,9,64]) → b'H\t@'
            list("abc") → ['a','b','c']
            dict([(3,"three"),(1,"one")]) → {1:'one',3:'three'}
            set(["one","two"]) → {'one','two'}
            separator str and sequence of str → assembled str
            ':'.join(['toto','12','pswd']) → 'toto:12:pswd'
            str splitted on whitespaces → list of str
            "words with spaces".split() → ['words','with','spaces']
            str splitted on separator str → list of str
            "1,4,8,2".split(",") → ['1','4','8','2']
            sequence of one type → list of another type (via list comprehension)
            [int(x) for x in ('1','29','-3')] → [1,29,-3]

            for lists, tuples, strings, bytes…
            Items count
            -3
            -2
            -1
            2
            3
            4
            len(lst)→5

            -4
            1

            dict(a=3,b=4,k="v")

            ☝ keys=hashable values (base types, immutables…)

            lst=[10, 20, 30, 40, 50]

            positive slice
            negative slice

            dict {"key":"value"}

            collection

            Identifiers

            for variables, functions,
            modules, classes… names

            ""
            b""

            (key/value associations) {1:"one",3:"three",2:"two",3.14:"π"}

            ☝ immutables

            hexadecimal octal

            Container Types
            ["mot"]
            []
            ("mot",)
            ()

            ◾ ordered sequences, fast index access, repeatable values
            ["x",11,8.9]
            list [1,5,9]
            11,"y",7.4
            tuple (1,5,9)

            Non modifiable values (immutables)
            ☝ expression with only comas →tuple
            str bytes (ordered sequences of chars / bytes)

            'I\'m'

            bytes b"toto\xfe\775"

            Latest version on :
            https://perso.limsi.fr/pointal/python:memento

            4
            -1

            5

            ☝ index from 0
            (here from 0 to 4)

            Access to sub-sequences via lst[start slice:end slice:step]

            Sequence Containers Indexing
            Individual access to items via lst[index]

            lst[0]→10
            lst[-1]→50

            ⇒ first one
            ⇒ last one

            lst[1]→20
            lst[-2]→40

            On mutable sequences (list), remove with
            del lst[3] and modify with assignment
            lst[4]=25

            lst[:3]→[10,20,30]
            lst[:-1]→[10,20,30,40] lst[::-1]→[50,40,30,20,10] lst[1:3]→[20,30]
            lst[1:-1]→[20,30,40]
            lst[-3:-1]→[30,40] lst[3:]→[40,50]
            lst[::-2]→[50,30,10]
            lst[::2]→[10,30,50]
            lst[:]→[10,20,30,40,50] shallow copy of sequence
            Missing slice indication → from start / up to end.
            On mutable sequences (list), remove with del lst[3:5] and modify with assignment lst[1:4]=[15,25]

            -neously

            a or b

            logical or one or other

            or both
            ☝ pitfall : and and or return value of a or
            of b (under shortcut evaluation).
            ⇒ ensure that a and b are booleans.

            logical not

            True
            False

            True and False constants

            ☝ floating numbers… approximated values

            integer ÷ ÷ remainder

            @ → matrix × python3.5+numpy
            (1+5.3)*2→12.6
            abs(-3.2)→3.2
            round(3.57,1)→3.6
            pow(4,3)→64.0
            ☝ usual order of operations

            parent statement:
            statement block 1…
            ⁝
            parent statement:
            statement block2…
            ⁝
            next statement after block 1

            not a

            Operators: + - * / // % **
            ab
            Priority (…) × ÷

            Statements Blocks

            indentation !

            Boolean Logic
            Comparisons : < > <= >= == !=
            (boolean results)
            ≤ ≥ = ≠
            both simultalogical
            and
            a and b

            ☝ configure editor to insert 4 spaces in
            place of an indentation tab.

            Maths
            from math import sin,pi…
            angles in radians

            sin(pi/4)→0.707…
            cos(2*pi/3)→-0.4999…
            sqrt(81)→9.0
            √
            log(e**2)→2.0
            ceil(12.5)→13
            floor(12.5)→12

            modules math, statistics, random,
            decimal, fractions, numpy, etc. (cf. doc)

            Modules/Names Imports
            from monmod import nom1,nom2 as fct

            module truc⇔file truc.py

            →direct access to names, renaming with as

            import monmod →access via monmod.nom1 …

            ☝ modules and packages searched in python path (cf sys.path)

            statement block executed only
            if a condition is true

            Conditional Statement
            yes

            if logical condition:
            statements block

            ?

            no

            yes

            ?
            no

            Can go with several elif, elif... and only one
            final else. Only the block of first true
            condition is executed.

            if age<=18:
            state="Kid"
            elif age>65:
            state="Retired"
            ☝ with a var x:
            else:
            if bool(x)==True: ⇔ if x:
            state="Active"
            if bool(x)==False: ⇔ if not x:

            Signaling an error:
            raise ExcClass(…)
            Errors processing:
            try:
            normal procesising block
            except Exception as e:
            error processing block

            Exceptions on Errors
            normal
            raise X()

            processing

            error
            processing
            errorraise
            processing

            ☝ finally block for final processing
            in all cases.

            yes

            ?

            Loop Control
            break
            immediate exit
            continue next iteration

            no

            s = 0 initializations before the loop
            i = 1 condition with a least one variable value (here i)
            while i <= 100:
            s = s + i**2
            i = i + 1
            print("sum:",s)

            ☝ else block for normal
            loop exit.

            Algo:

            ☝ make condition variable change !

            i=100

            s= ∑ i 2

            print("v=",3,"cm :",x,",",y+4)

            i=1

            Display

            Input

            s = input("Instructions:")
            ☝ input always returns a string, convert it to required type
            (cf. boxed Conversions on the other side).

            len(c)→ items count
            Generic Operations on Containers
            min(c) max(c) sum(c)
            Note: For dictionaries and sets, these
            sorted(c)→ list sorted copy
            operations use keys.
            val in c → boolean, membership operator in (absence not in)
            enumerate(c)→ iterator on (index, value)
            zip(c1,c2…)→ iterator on tuples containing ci items at same index
            all(c)→ True if all c items evaluated to true, else False
            any(c)→ True if at least one item of c evaluated true, else False
            Specific to ordered sequences containers (lists, tuples, strings, bytes…)
            reversed(c)→ inversed iterator c*5→ duplicate
            c+c2→ concatenate
            c.index(val)→ position
            c.count(val)→ events count
            import copy
            copy.copy(c)→ shallow copy of container
            copy.deepcopy(c)→ deep copy of container

            Operations on Lists
            lst.append(val)
            add item at end
            lst.extend(seq)
            add sequence of items at end
            lst.insert(idx,val)
            insert item at index
            lst.remove(val)
            remove first item with value val
            lst.pop([idx])→value
            remove & return item at index idx (default last)
            lst.sort() lst.reverse() sort / reverse liste in place
            ☝ modify original list

            Operations on Sets

            Operators:
            | → union (vertical bar char)
            & → intersection
            - ^ → difference/symmetric diff.
            < <= > >= → inclusion relations
            Operators also exist as methods.

            d.setdefault(key[,default])→value

            s.update(s2) s.copy()
            s.add(key) s.remove(key)
            s.discard(key) s.clear()
            s.pop()

            storing data on disk, and reading it back

            Files

            f = open("file.txt","w",encoding="utf8")
            file variable
            for operations

            name of file
            on disk
            (+path…)

            opening mode
            encoding of
            ◽ 'r' read
            chars for text
            ◽ 'w' write
            files:
            ◽ 'a' append
            utf8 ascii
            cf. modules os, os.path and pathlib ◽ …'+' 'x' 'b' 't' latin1 …

            writing

            ☝ read empty string if end of file

            f.write("coucou")

            f.read([n])

            → next chars

            reading

            if n not specified, read up to end !
            f.readlines([n]) → list of next lines
            f.readline()
            → next line
            ☝ text mode t by default (read/write str), possible binary
            mode b (read/write bytes). Convert from/to required type !
            f.close()
            ☝ dont forget to close the file after use !
            f.truncate([size]) resize
            write
            cache
            f.flush()
            reading/writing progress sequentially in the file, modifiable with:
            f.writelines(list of lines)

            f.tell()→position

            Iterative Loop Statement
            next

            for var in sequence:
            statements block

            …
            finish

            Go over sequence's values

            s = "Some text" initializations before the loop
            cnt = 0
            loop variable, assignment managed by for statement
            for c in s:
            Algo: count
            if c == "e":
            number of e
            cnt = cnt + 1
            print("found",cnt,"'e'")
            in the string.
            loop on dict/set ⇔ loop on keys sequences
            use slices to loop on a subset of a sequence

            Go over sequence's index
            ◽ modify item at index
            ◽ access items around index (before / after)

            items to display : literal values, variables, expressions
            print options:
            ◽ sep=" "
            items separator, default space
            ◽ end="\n"
            end of print, default new line
            ◽ file=sys.stdout print to file, default standard output

            Operations on Dictionaries
            d.clear()
            d[key]=value
            del d[key]
            d[key]→ value
            d.update(d2) update/add
            associations
            d.keys()
            d.values() →iterable views on
            d.items() keys/values/associations
            d.pop(key[,default])→ value
            d.popitem()→ (key,value)
            d.get(key[,default])→ value

            statements block executed for each
            item of a container or iterator

            f.seek(position[,origin])
            Very common: opening with a guarded block
            with open(…) as f:
            (automatic closing) and reading loop on lines
            for line in f :
            of a text file:
            = processing ofline

            lst = [11,18,9,12,23,4,17]
            lost = []
            Algo: limit values greater
            for idx in range(len(lst)):
            than 15, memorizing
            val = lst[idx]
            of lost values.
            if val > 15:
            lost.append(val)
            lst[idx] = 15
            print("modif:",lst,"-lost:",lost)

            ☝ good habit : don't modify loop variable

            while logical condition:
            statements block

            Conditional Loop Statement

            Go simultaneously over sequence's index and values:
            for idx,val in enumerate(lst):

            range([start,] end [,step])

            Integer Sequences

            function name (identifier)
            named parameters

            Function Definition

            ☝ start default 0, end not included in sequence, step signed, default 1
            range(5)→ 0 1 2 3 4
            range(2,12,3)→ 2 5 8 11
            range(3,8)→ 3 4 5 6 7
            range(20,5,-5)→ 20 15 10
            range(len(seq))→ sequence of index of values in seq
            ☝ range provides an immutable sequence of int constructed as needed

            def fct(x,y,z):
            fct
            """documentation"""
            = statements block, res computation, etc.
            result value of the call, if no computed
            return res

            result to return: return None
            ☝ parameters and all
            variables of this block exist only in the block and during the function
            call (think of a “black box”)
            Advanced: def fct(x,y,z,*args,a=3,b=5,**kwargs):
            *args variable positional arguments (→tuple), default values,
            **kwargs variable named arguments (→dict)

            Function Call

            r = fct(3,i+2,2*i)
            storage/use of
            returned value

            one argument per
            parameter

            ☝ this is the use of function
            name with parentheses
            which does the call

            Advanced:
            *sequence
            **dict

            fct()

            fct

            Operations on Strings
            s.startswith(prefix[,start[,end]])
            s.endswith(suffix[,start[,end]]) s.strip([chars])
            s.count(sub[,start[,end]]) s.partition(sep)→ (before,sep,after)
            s.index(sub[,start[,end]]) s.find(sub[,start[,end]])
            s.is…() tests on chars categories (ex. s.isalpha())
            s.upper()
            s.lower()
            s.title()
            s.swapcase()
            s.casefold()
            s.capitalize()
            s.center([width,fill])
            s.ljust([width,fill]) s.rjust([width,fill]) s.zfill([width])
            s.encode(encoding)
            s.split([sep]) s.join(seq)
            formating directives

            values to format

            "modele{} {} {}".format(x,y,r)
            "{selection:formatting!conversion}"

            Formatting
            str

            ◽ Selection :
            "{:+2.3f}".format(45.72793)
            2
            →'+45.728'
            nom
            "{1:>10s}".format(8,"toto")
            0.nom
            →'
            toto'
            4[key]
            "{x!r}".format(x="I'm")
            0[2]
            →'"I\'m"'
            ◽ Formatting :
            fill char alignment sign mini width.precision~maxwidth type
            Examples

            ☝ beware of infinite loops!

            statements block executed as long as
            condition is true

            <>^=
            0 at start for filling with 0
            + - space
            integer: b binary, c char, d decimal (default), o octal, x or X hexa…
            float: e or E exponential, f or F fixed point, g or G appropriate (default),
            string: s …
            % percent
            ◽ Conversion : s (readable text) or r (literal representation)

            
~/Empire/Doks/Comp/lang/py/cheatsh-qref/cheatsheet-python-grok.pdf
~/Empire/Doks/Comp/lang/py/cheatsh-qref/cheatsheet-python-grok.txt
            GROK - Python 3 cheatsheet (the basics)
            Interact with the user (input and output)

            Print a message
            print('Hello, world!')

            Text (strings)

            LEARNING
            Variables

            Single quoted

            Creating a variable

            'perfect'

            celsius = 25

            Print multiple values (of different types)

            Double quoted

            Using a variable

            ndays = 365
            print('There are', ndays, 'in a year')

            "credit"

            celsius*9/5 + 32

            Asking the user for a string

            Multi-line

            name = input('What is your name? ')

            '''Hello,
            World!'''

            Asking the user for a whole number (an integer)

            Add (concatenate) strings

            Addition and subtraction

            num = int(input('Enter a number: '))

            'Hello' + 'World'

            365 + 1 - 2

            Multiply string by integer

            Multiplication and division

            'Echo...'*4

            25*9/5 + 32

            Decide between options

            Whole numbers (integers)

            Decide to run a block (or not)

            Are two values equal?

            Length of a string

            Powers (2 to the power of 8)

            x = 3
            if x == 3:
            print('x is 3')

            x == 3

            len('Hello')

            2**8

            ⚠ two equals signs, not one

            Convert string to integer

            Convert integer to string

            Decide between two blocks

            Are two values not equal?

            int('365')

            str(365)

            mark = 80
            if mark >= 50:
            print('pass')
            else:
            print('fail')

            x != 3

            Decide between many blocks
            mark = 80
            if mark >= 65:
            print('credit')
            elif mark >= 50:
            print('pass')
            else:
            print('fail')

            Less than another?

            Repeat a block (a fixed number of times)

            x < 3

            Repeat a block 10 times

            Count from 0 to 9

            Greater than another?

            for i in range(10):
            print(i)

            range(10)

            x > 3
            Less than or equal to?
            x <= 3
            Greater than or equal to?
            x >= 3

            ‣elif can be used without else The answer is a Boolean:
            ‣elif can be used many times
            or False
            True

            String manipulation

            Sum the numbers 0 to 9
            total = 0
            for i in range(10):
            total = total + i
            print(total)

            ⚠ range starts from 0 and goes
            up to, but not including, 10

            Count from 1 to 10
            range(1, 11)

            Repeat a block over a string

            Count from 10 down to 1

            for c in 'Hello':
            print(c)

            range(10, 0, -1)
            Count 2 at a time to 10

            Keep printing on one line

            range(0, 11, 2)
            Count down 2 at a time

            Compare two strings

            Convert to uppercase

            for c in 'Hello':
            print(c, end=' ')
            print('!')

            msg = 'hello'
            if msg == 'hello':
            print('howdy')

            msg.upper()

            Repeat a block over list (or string) indices

            also lower and title

            msg = 'I grok Python!'
            for i in range(len(msg)):
            print(i, msg[i])

            Less than another string?

            Count a character in a string

            if msg < 'n':
            print('a-m')
            else:
            print('n-z')

            msg.count('l')
            Replace a character or string
            msg.replace('l','X')

            ⚠ strings are compared character Delete a character or string
            at a time (lexicographic order)

            Is a character in a string?

            msg.replace('l','')

            range(10, 0, -2)

            Putting it together: Celsius to Fahrenheit converter
            Ask the user for a temperature in degrees Celsius
            celsius = int(input('Temp. in Celsius: '))
            Calculate the conversion

            'e' in msg

            Is the string all lowercase?

            fahrenheit = celsius*9/5 + 32

            Is a string in another string?

            msg.islower()

            Output the result

            'ell' in msg

            also isupper and istitle

            print(farenheit, 'Fahrenheit')

            s = [datetime.
            hs.insert(0, lamb
            f __init__(self, format
            self.format = format
            def __getitem__(self, i):
            funcs = self._months[i]
            if isinstance(i, slice)
            return [f(self.for
            else:
            return funcs(sel
            n__(self):

            Learn more in Intro. to Programming @ groklearning.com

            
~/Empire/Doks/Comp/lang/py/cheatsh-qref/quickpybook_2010.pdf  #Toc
~/Empire/Doks/Comp/lang/py/cheatsh-qref/quickpybook_2010.txt
            1 - Why should I use Python? 3 ----
            What Python does well 4
              Python is easy to use 4
              Python is expressive 4
              Python is readable 5
              Python is complete - “batteries included” 6
              Python is cross-platform 6
              Python is free 6
            What Python doesn’t do as well
              Python is not the fastest language 7
              Python doesn’t have the most libraries 8
              Python doesn’t check variable types at compile time 8
            Why learn Python 3?
            2 - Getting started 10 ----
            Installing Python 10
            IDLE and the basic interactive mode
            The basic interactive mode 12
            The IDLE integrated development
            environment 13
            Choosing between basic interactive mode and IDLE 14
            Using IDLE’s Python Shell window 14
            Hello, world 15
            Using the interactive prompt to explore Python
            3 - The Quick Python overview ----
            Python synopsis 19
            Built-in data types 19
            Numbers 19
            Lists 21
            Tuples 22
            Strings
            Dictionaries 24
            Sets 24
            File objects 25
            Control flow structures
            Boolean values and expressions 25
            The if-elif-else
            statement 26
            The while loop 26
            The for
            loop 27
            Function definition 27
            Exceptions 28
            Module creation 29
            Object-oriented programming
            Summary 31
            PART 2 THE ESSENTIALS ............................................. 33
            4 - The absolute basics ----
            Indentation and block structuring
            Differentiating comments 37
            Variables and assignments 37
            Expressions 38
            Strings 39
            Numbers 40
            Built-in numeric functions 41
            Advanced numeric
            functions 41
            Numeric computation 41
            Complex
            numbers 41
            Advanced complex-number functions 42
            The None value
            Getting input from the user
            Built-in operators 43
            Basic Python style 43
            Summary 44
            5 - Lists, tuples, and sets ----
            Lists are like arrays 46
            List indices 46
            Modifying lists 48
            Sorting lists 50
            Custom sorting
            The sorted() function
            Other common list operations
            List membership with the in operator 52
            List concatenation with the + operator 53
            List initialization with the * operator 53
            List minimum or maximum with min and max 53
            List search with index 53
            List matches with count 54
            Summary of list operations 54
            Nested lists and deep copies
            Tuples 57
            Tuple basics 57
            One-element tuples need a comma 58
            Packing and unpacking tuples 58
            Converting between lists and tuples 60
            Sets
            Set operations 60
            Summary
            6 - Strings ----
            Frozensets 61
            Strings as sequences of characters 63
            Basic string operations 64
            Special characters and escape sequences
            Basic escape sequences 65
            Numeric (octal and hexadecimal) and
            Unicode escape sequences 65
            Printing vs. evaluating strings
            with special characters 66
            String methods
            The split and join string methods 67
            Converting strings to
            numbers 68
            Getting rid of extra whitespace 69
            String
            searching 70
            Modifying strings 71
            Modifying strings with
            list manipulations 73
            Useful methods and constants 73
            Converting from objects to strings
            Using the format method 76
            The format method and positional parameters 76
            The format
            method and named parameters 76
            Format specifiers 77
            Formatting strings with %
            Using formatting sequences
            formatting sequences 78
            Named parameters and
            Bytes 80
            Summary 80
            7 - Dictionaries ----
            What is a dictionary?
            Why dictionaries are called dictionaries
            Other dictionary operations 83
            Word counting 86
            What can be used as a key? 86
            Sparse matrices 88
            Dictionaries as caches 88
            Efficiency of dictionaries 89
            8 - Control flow ----
            The while loop
            The break and continue statements 91
            The if-elif-else statement
            The for loop 92
            The range function 93
            Using break and continue in for loops 94
            The for loop and tuple unpacking 94
            The enumerate function 94
            The zip function 95
            List and dictionary comprehensions 95
            Statements, blocks, and indentation 96
            Boolean values and expressions 99
            Most Python objects can be used as Booleans
            Boolean operators 100
            Comparison and
            Writing a simple program to analyze a text file
            9 - Functions ----
            Basic function definitions 103
            Function parameter options 105
            Positional parameters 105
            Passing arguments by parameter
            name 106
            Variable numbers of arguments 107
            Mixing
            argument-passing techniques 108
            Mutable objects as arguments 108
            Local, nonlocal, and global variables 109
            Assigning functions to variables 111
            lambda expressions 111
            Generator functions 112
            Decorators 113
            10 - Modules and scoping rules ----
            What is a module? 115
            A first module 116
            The import statement 119
            The module search path 119
            Where to place your own modules
            Private names in modules 121
            Library and third-party modules 122
            Python scoping rules and namespaces 123
            11 - Python programs ----
            Creating a very basic program
            Starting a script from a command line 130
            Command-line arguments 131
            Redirecting the input and output of a script 131
            The optparse module 132
            Using the fileinput module 133
            Making a script directly executable on UNIX
            Scripts on Mac OS X 135
            Script execution options in Windows 135
            Starting a script as a document or shortcut 136
            Starting a script from the Windows Run box 137
            Starting a script from a command window 137
            Other Windows options 138
            Scripts on Windows vs. scripts on UNIX
            Programs and modules 140
            Distributing Python applications 145
            distutils 145
            py2exe and py2app programs with freeze 145
            Creating executable
            12 - Using the filesystem ----
            Paths and pathnames
            Absolute and relative paths 148
            The current working directory 149
            Manipulating pathnames 150
            Useful constants and functions 153
            Getting information about files 154
            More filesystem operations 155
            Processing all files in a directory subtree Summary 157
            13 - Reading and writing files ----
            Screen input/output and redirection 163
            Reading structured binary data with the struct module
            Pickling objects into files 167
            Shelving objects 170
            14 - Exceptions ----
            Opening files and file objects 159
            Closing files 160
            Opening files in write or other modes 160
            Functions to read and write text or binary data
            Using binary mode
            Introduction to exceptions
            General philosophy of errors and exception handling 173 A more
            formal definition of exceptions 175
            User-defined exceptions 176
            Exceptions in Python
            Types of Python exceptions 177
            Raising exceptions 178
            Catching and handling exceptions 179
            Defining new exceptions 180
            Debugging programs with the assert statement 181
            The exception inheritance hierarchy 182
            Example: a disk-writing program in Python 182
            Example: exceptions in normal evaluation 183
            Where to use exceptions 184
            Using with 184
            15 - Classes and object-oriented programming ----
            Defining classes
            Using a class instance as a structure or record
            Instance variables 188
            Methods 188
            Class variables 190
            An oddity with class variables
            Class methods
            Installing Tkinter 210
            Starting Tk and using Tkinter
            Principles of Tkinter 212
            Widgets 212
            Named attributes
            and widget placement 213
            Inheritance 194
            Inheritance with class and instance variables 196
            Private variables and private methods 197
            Using @property for more flexible instance variables 198
            Scoping rules and namespaces for class instances 199
            Destructors and memory management 203
            Multiple inheritance 207
            16 - Graphical user interfaces ----
            Static methods and class methods
            Static methods
            Geometry management
            A simple Tkinter application 214
            Creating widgets 215
            Widget placement 216
            Using classes to manage Tkinter applications
            What else can Tkinter do? 219
            Event handling
            Canvas and text widgets
            Alternatives to Tkinter
            Summary 222
            PART 3 ADVANCED LANGUAGE FEATURES ................... 223
            17 - Regular expressions ----
            What is a regular expression? 225
            Regular expressions with special characters
            Regular expressions and raw strings 227
            Raw strings to the rescue 228
            Extracting matched text from strings 229
            Substituting text with regular expressions 232
            18 - Packages ----
            What is a package? 234
            A first example 235
            A concrete example 236
            Basic use of the mathproj package 237
            Loading subpackages and submodules 238
            import statements within packages 239
            __init__.py files in packages 239
            The __all__ attribute 240
            Proper use of packages 241
            19 - Data types as objects ----
            Types are objects, too 242
            Using types 243
            Types and user-defined classes
            Duck typing 245
            Summary 246
            20 - Advanced object-oriented features ----
            What is a special method attribute? 248
            Making an object behave like a list 249
            The __getitem__ special method attribute 249
            How it
            works 250
            Implementing full list functionality 251
            Giving an object full list capability 252
            Subclassing from built-in types 254
            Subclassing list
            Subclassing UserList
            When to use special method attributes
            Metaclasses 256
            Abstract base classes 258
            Using abstract base classes for type checking 259
            Creating
            abstract base classes 260
            Using the @abstractmethod and
            @abstractproperty decorators 260
            Summary
            PART 4 WHERE CAN YOU GO FROM HERE? ................. 263
            21 - Testing your code made easy(-er) 265 ----
            Why you need to have tests
            The assert statement 266
            Python’s __debug__ variable 266
            Tests in docstrings: doctests
            Avoiding doctest traps 269
            Tweaking doctests with
            directives 269
            Pros and cons of doctests 270
            Using unit tests to test everything, every time
            Setting up and running a single test case 270
            Running the test 272
            Running multiple tests 272
            Unit tests vs.
            doctests 273
            22 - Moving from Python 2 to Python 3 ----
            Porting from 2 to 3
            Steps in porting from Python 2.x to 3.x 275
            Testing with Python 2.6 and -3 276
            Using 2to3 to convert the code 277
            Testing and common problems 279
            Using the same code for 2 and 3 280
            Using Python 2.5 or earlier 280
            converting back 281
            Writing for Python 3.x and
            23 - Using Python libraries ----
            "Batteries included" - the standard library
            Managing various data types 283
            Manipulating files and
            storage 284
            Accessing operating system services 285
            Using internet protocols and formats 286
            Development and debugging
            tools and runtime services 286
            Moving beyond the standard library 287
            Adding more Python libraries 287
            Installing Python libraries using setup.py 288
            Installing under the home scheme 288
            Other installation options 289
            PyPI, a.k.a. “the Cheese Shop”
            24 - Network, web, and database programming ----
            Accessing databases in Python
            Using the sqlite3 database 291
            Network programming in Python
            Creating an instant HTTP server
            Writing an HTTP client 294
            Creating a Python web application
            Using the web server gateway interface 295
            Using the wsgi
            library to create a basic web app 295
            Using frameworks to create advanced web apps 296
            Sample project - creating a message wall
            Creating the database 297
            Creating an application object 298
            Adding a form and retrieving its contents 298
            Saving the form’s contents 299
            Parsing the URL and
            retrieving messages 300
            Adding an HTML wrapper 303
--
            ~/Empire/Doks/Comp/lang/py/cheatsh-qref/python_cheat_sheet.pdf
            ~/Empire/Doks/Comp/lang/py/cheatsh-qref/python_cheat_sheet.txt
            ~/Empire/Doks/Comp/lang/py/cheatsh-qref/python_2.pdf
            ~/Empire/Doks/Comp/lang/py/cheatsh-qref/python_2.txt
            ~/Empire/Doks/Comp/lang/py/cheatsh-qref/Python-Cheat-Sheet.pdf
            ~/Empire/Doks/Comp/lang/py/cheatsh-qref/Python-Cheat-Sheet.txt
            ~/Empire/Doks/Comp/lang/py/cheatsh-qref/python_cheat_sheet_v1.pdf
            ~/Empire/Doks/Comp/lang/py/cheatsh-qref/python_cheat_sheet_v1.txt
----
~/Empire/Doks/Comp/lang/py/phraseb-py.pdf
~/Empire/Doks/Comp/lang/py/phraseb-py.txt
            Contents At A Glance
            Understanding Python
            2 Manipulating Strings
            3 Managing Data Types
            4 Managing Files
            5 Managing Threads
            6 Managing Databases
            7 Implementing Internet Communication
            8 Processing HTML
            9 Processing XML
            10 Programming Web Services
            --
            Table of Contents
            Introduction 1
            1 - Understanding Python 3 ----
            Why Use Python? 3
            Invoking the Interpreter 4
            Built-In Types 5
            Understanding Python Syntax 10
            Python Objects, Modules, Classes, and Functions 16
            Error Handling 28
            Using System Tools 30
            2 - Manipulating Strings 37 ----
            Comparing Strings 37
            Joining Strings 39
            Splitting Strings 41
            Searching Strings for Substrings 42
            Search and Replace in Strings 43
            Searching Strings for Specific Endings/ Beginnings 44
            Trimming Strings 46
            Aligning/ Formatting Strings 47
            Executing Code Inside Strings 49
            interpolating Variables Inside Strings 50
            Converting Unicode to Local Strings 52
            3 - Managing Data Types 55 ----
            Defining a List 56
            Accessing a List 57
            Slicing a List 59
            Adding and Removing Items in a List 61
            Sorting a List 63
            Using Tuples 66
            Constructing a Dictionary 68
            Adding a Value to a Dictionary 69
            Retrieving a Value from a Dictionary 71
            Slicing a Dictionary 73
            Swapping Keys for Values in a Dictionary 75
            4 - Managing Files 77 ----
            Opening and Closing Files 77
            Reading an Entire File 80
            Reading a Single Line from a File 82
            Accessing Each Word in a File 83
            Writing a File 84
            Determining the Number of Lines in a File 86
            Walking the Directory Tree 87
            Renaming Files 88
            Recursively Deleting Files and Subdirectories 90
            Searching for Files Based on Extension 92
            Creating a TAR File 94
            Extracting a File from a TAR File 97
            Adding Files to a ZIP File 98
            Retrieving Files from a ZIP File 100
            5 - Managing Threads 103 ----
            Starting a New Thread 104
            Creating and Exiting Threads 106
            Synchronizing Threads 108
            Implementing a Multithreaded Priority Queue 110
            Initiating a Timer-Interrupted Thread 113
            6 - Managing Databases 117 ----
            Adding Entries to a DBM File 118
            Retrieving Entries from a DBM File 120
            Updating Entries in a DBM File 122
            Pickling Objects to a File 124
            Unpickling Objects from a File 126
            Storing Objects in a Shelve File 128
            Retrieving Objects from a Shelve File 131
            Changing Objects in a Shelve File 133
            Connecting to a MySQL Database Server 135
            Creating a MySQL Database 138
            Adding Entries to a MySQL Database 140
            Retrieving Entries from a MySQL Database 142
            7 - Implementing Internet Communication 145 ----
            Opening a Server-Side Socket for Receiving Data 145
            Opening a Client-Side Socket for Sending Data 149
            Receiving Streaming Data Using the ServerSocket Module 151
            Sending Streaming Data 153
            Sending Email Using SMTP 154
            Retrieving Email from a POP3 Server 157
            Using Python to Fetch Files from an FTP Server 159
            8 - Processing HTML 163 ----
            Parsing URLs 164
            Opening HTML Documents 167
            Retrieving Links from HTML Documents 169
            Retrieving Images from HTML Documents 171
            Retrieving Text from HTML Documents 174
            Retrieving Cookies in HTML Documents 176
            Adding Quotes to Attribute Values in HTML Documents 179
            9 - Processing XML 185 ----
            Loading an XML Document 186
            Checking for Well-Formed XML Documents 188
            Accessing Child Nodes 190
            Accessing Element Attributes 194
            Adding a Node to a DOM Tree 196
            Removing a Node from a DOM Tree 199
            Searching XML Documents 202
            Extracting Text from XML Documents 205
            Parsing XML Tags 208
            10 - Programming Web Services 211 ----
            Adding HTML to Web Pages Using CGI Scripts 212
            Processing Parameters Passed to CGI Scripts 214
            Creating Self-Posting CGI Scripts 217
            Allowing Users to Upload Files via CGI Scripts 221
            Creating an HTTP Server to Handle GET Requests 224
            Creating an HTTP Server to Handie POST Requests 228
            Creating an HTTP Server to Process CGI Scripts 233
            Sending an HTTP GET Request from a Python Script 235
            Sending an HTTP POST Request from a Python Script 238
            Creating an XML-RPC Server 241
            Creating an XML-RPC Client 243
            Using SOAPpy to Access SOAP Web
            Services Through a WSDL File 245
            Index 249
## ~/Empire/Doks/Comp/lang/py/PY3HARDWAY.pdf
## ~/Empire/Doks/Comp/lang/py/PY3HARDWAY.txt
            3 - The Hard Way Is Easier ----
            3.1 Reading and Writing 
            3.2 Attention to Detail 
            3.3 Spotting Differences 
            3.4 Ask, Don’t Stare 
            3.5 Do Not Copy-Paste 
            3.6 Using the Included Videos 
            3.7 A Note on Practice and Persistence 
            0 - The Setup ----
            0.1 macOS
            0.1.1 macOS: What You Should See 
            0.2 Windows 
            0.2.1 Windows: What You Should See 
            0.3 Linux 
            0.3.1 Linux: What You Should See
            0.4 Finding Things on the Internet 
            0.5 Warnings for Beginners
            0.6 Alternative Text Editors 
            1 - A Good First Program ----
            1.1 What You Should See 
            1.2 Study Drills 
            1.3 Common Student Questions 
            2 - Comments and Pound Characters ----
            2.1 What You Should See 
            2.2 Study Drills 
            2.3 Common Student Questions 
            3 - Numbers and Math ----
            3.1 What You Should See 
            3.2 Study Drills 
            3.3 Common Student Questions 
            4 - Variables and Names ----
            4.1 What You Should See 
            4.2 Study Drills 
            4.3 Common Student Questions 
            5 - More Variables and Printing ----
            5.1 What You Should See 
            5.2 Study Drills 
            5.3 Common Student Questions 
            6 - Strings and Text ----
            6.1 What You Should See 
            6.2 Study Drills 
            6.3 Break It 
            6.4 Common Student Questions 
            7 - More Printing ----
            7.1 What You Should See 
            7.2 Study Drills 
            7.3 Break It 
            7.4 Common Student Questions 
            8 - Printing, Printing ----
            8.1 What You Should See 
            8.2 Study Drills 
            8.3 Common Student Questions 
            9 - Printing, Printing, Printing ----
            9.1 What You Should See 
            9.2 Study Drills 
            9.3 Common Student Questions 
            10 - What Was That? ----
            10.1 What You Should See 
            10.2 Escape Sequences 
            10.3 Study Drills 
            10.4 Common Student Questions 
            11 - Asking Questions ----
            11.1 What You Should See 
            11.2 Study Drills 
            11.3 Common Student Questions 
            12 - Prompting People ----
            12.1 What You Should See 
            12.2 Study Drills 
            12.3 Common Student Questions 
            13 - Parameters, Unpacking, Variables ----
            13.1 Hold Up! Features Have Another Name 
            13.2 What You Should See 
            13.3 Study Drills 
            13.4 Common Student Questions 
            14 - Prompting and Passing ----
            14.1 What You Should See 
            14.2 Study Drills 
            14.3 Common Student Questions 
            15 - Reading Files ----
            15.1 What You Should See 
            15.2 Study Drills 
            15.3 Common Student Questions 
            16 - Reading and Writing Files ----
            16.1 What You Should See 
            16.2 Study Drills 
            16.3 Common Student Questions 
            17 - More Files ----
            17.1 What You Should See 
            17.2 Study Drills 
            17.3 Common Student Questions 
            18 - Names, Variables, Code, Functions ----
            18.1 What You Should See 
            18.2 Study Drills 
            18.3 Common Student Questions 
            19 - Functions and Variables ----
            19.1 What You Should See 
            19.2 Study Drills 
            19.3 Common Student Questions 
            20 - Functions and Files ----
            20.1 What You Should See  101
            20.2 Study Drills  101
            20.3 Common Student Questions  101
            21 - Functions Can Return Something ----
            21.1 What You Should See  105
            21.2 Study Drills  105
            21.3 Common Student Questions  106
            22 - What Do You Know So Far? ----
            22.1 What You Are Learning  108
            23 - Strings, Bytes, and Character Encodings ----
            23.1 Initial Research  110
            23.2 Switches, Conventions, and Encodings  112
            23.3 Disecting the Output  114
            23.4 Disecting the Code  114
            23.5 Encodings Deep Dive  116
            23.6 Breaking It  117
            24 - More Practice ----
            24.1 What You Should See  119
            24.2 Study Drills  120
            24.3 Common Student Questions  120
            25 - Even More Practice ----
            25.1 What You Should See  123
            25.2 Study Drills  125
            25.3 Common Student Questions  125
            26 - Congratulations, Take a Test! ----
            26.1 Common Student Questions  126
            27 - Memorizing Logic ----
            27.1 The Truth Terms  128
            27.2 The Truth Tables
            27.3 Common Student Questions  130
            28 - Boolean Practice ----
            28.1 What You Should See  134
            28.2 Study Drills  134
            28.3 Common Student Questions  134
            29 - What If ----
            29.1 What You Should See  136
            29.2 Study Drills  137
            29.3 Common Student Questions  137
            30 - Else and If ----
            30.1 What You Should See  139
            30.2 Study Drills  139
            30.3 Common Student Questions  140
            31 - Making Decisions ----
            31.1 What You Should See  143
            31.2 Study Drills  143
            31.3 Common Student Questions  144
            32 - Loops and Lists ----
            32.1 What You Should See  147
            32.2 Study Drills  148
            32.3 Common Student Questions  148
            33 - While Loops ----
            33.1 What You Should See  151
            33.2 Study Drills  152
            33.3 Common Student Questions  152
            34 - Accessing Elements of Lists ----
            34.1 Study Drills  155
            35 - Branches and Functions ----
            35.1 What You Should See  158
            35.2 Study Drills  158
            35.3 Common Student Questions  158
            36 - Designing and Debugging ----
            36.1 Rules for If-Statements  160
            36.2 Rules for Loops  160
            36.3 Tips for Debugging  161
            36.4 Homework  161
            37 - Symbol Review ----
            37.1 Keywords  162
            37.2 Data Types
            37.3 String Escape Sequences  163
            37.4 Old Style String Formats  164
            37.5 Operators  165
            37.6 Reading Code  166
            37.7 Study Drills  166
            37.8 Common Student Questions  167
            38 - Doing Things to Lists ----
            38.1 What You Should See  169
            38.2 What Lists Can Do
            38.3 When to Use Lists  171
            38.4 Study Drills  171
            38.5 Common Student Questions  172
            39 - Dictionaries, Oh Lovely Dictionaries ----
            39.1 A Dictionary Example  175
            39.2 What You Should See  177
            39.3 What Dictionaries Can Do
            39.4 Study Drills  178
            39.5 Common Student Questions  179
            40 - Modules, Classes, and Objects ----
            40.1 Modules Are Like Dictionaries  180
            40.1.1 Classes Are Like Modules  182
            40.1.2 Objects Are Like Import  182
            40.1.3 Getting Things from Things  183
            40.1.4 A First Class Example
            40.2 What You Should See  185
            40.3 Study Drills  185
            40.4 Common Student Questions  185
            41 - Learning to Speak Object-Oriented ----
            41.1 Word Drills  186
            41.2 Phrase Drills  186
            41.3 Combined Drills  187
            41.4 A Reading Test  188
            41.5 Practice English to Code  190
            41.6 Reading More Code
            41.7 Common Student Questions  191
            42 - Is-A, Has-A, Objects, and Classes ----
            42.1 How This Looks in Code
            42.2 About class Name(object)  195
            42.3 Study Drills  195
            42.4 Common Student Questions  196
            43 - Basic Object-Oriented Analysis and Design ----
            43.1 The Analysis of a Simple Game Engine  199
            43.1.1 Write or Draw About the Problem  199
            43.1.2 Extract Key Concepts and Research Them  200
            43.1.3 Create a Class Hierarchy and Object Map for the Concepts  201
            43.1.4 Code the Classes and a Test to Run Them  202
            43.1.5 Repeat and Refine  203
            43.2 Top Down versus Bottom Up  203
            43.3 The Code for ”Gothons from Planet Percal #25”  204
            43.4 What You Should See  211
            43.5 Study Drills  212
            43.6 Common Student Questions  212
            44 - Inheritance Versus Composition ----
            44.1 What Is Inheritance?  214
            44.1.1 Implicit Inheritance  215
            44.1.2 Override Explicitly  216
            44.1.3 Alter Before or After  216
            44.1.4 All Three Combined  218
            44.2 The Reason for super()  219
            44.2.1 Using super() with __init__  219
            44.3 Composition
            44.4 When to Use Inheritance or Composition  221
            44.5 Study Drills  222
            44.6 Common Student Questions  222
            45 - You Make a Game ----
            45.1 Evaluating Your Game  224
            45.2 Function Style  225
            45.3 Class Style  225
            45.4 Code Style  226
            45.5 Good Comments  226
            45.6 Evaluate Your Game  227
            46 A Project Skeleton
            46.1 macOS/Linux Setup  228
            46.2 Windows 10 Setup  230
            46.3 Creating the Skeleton Project Directory  231
            46.3.1 Final Directory Structure
            46.4 Testing Your Setup  234
            46.5 Using the Skeleton  234
            46.6 Required Quiz
            46.7 Common Student Questions  235
            47 - Automated Testing ----
            47.1 Writing a Test Case  236
            47.2 Testing Guidelines
            47.3 What You Should See  239
            47.4 Study Drills  239
            47.5 Common Student Questions  239
            48 - Advanced User Input ----
            48.1 Our Game Lexicon  240
            48.1.1 Breaking Up a Sentence  241
            48.1.2 Lexicon Tuples  241
            48.1.3 Scanning Input
            48.1.4 Exceptions and Numbers  242
            48.2 A Test First Challenge  243
            48.3 What You Should Test
            48.4 Study Drills  245
            48.5 Common Student Questions  246
            49 - Making Sentences ----
            49.1 Match and Peek  248
            49.2 The Sentence Grammar  249
            49.3 A Word On Exceptions  249
            49.4 The Parser Code  249
            49.5 Playing With The Parser
            49.6 What You Should Test
            49.7 Study Drills  254
            49.8 Common Student Questions  254
            50 - Your First Website ----
            50.1 Activating Your Virtual Environment  256
            50.2 Installing Flask  256
            50.3 Make a Simple ”Hello World” Project  257
            50.4 What’s Going On?
            50.5 Fixing Errors
            50.6 Create Basic Templates  260
            50.7 Study Drills  262
            50.8 Common Student Questions  262
            51 - Getting Input from a Browser ----
            51.1 How the Web Works  264
            51.2 How Forms Work  266
            51.3 Creating HTML Forms  267
            51.4 Creating a Layout Template
            51.5 Writing Automated Tests for Forms
            51.6 Study Drills  272
            51.7 Breaking It  273
            52 - The Start of Your Web Game ----
            52.1 Refactoring the Exercise 43 Game  274
            52.2 Creating an Engine  279
            52.3 Your Final Exam  282
            52.4 Common Student Questions  283
            53 - Next Steps ----
            53.1 How to Learn Any Programming Language  285
            54 - Advice from an Old Programmer ----
            55 - Appendix A: Command Line Crash Course ----
            55.1 Introduction: Shut Up and Shell  288
            55.1.1 How to Use This Appendix
            55.1.2 You Will Be Memorizing Things  289
            55.2 The Setup  290
            55.2.1 Do This
            55.2.2 You Learned This  291
            55.2.3 Do More  291
            55.3 Paths, Folders, Directories (pwd)  294
            55.3.1 Do This
            55.3.2 You Learned This  295
            55.3.3 Do More  295
            55.4 If You Get Lost  295
            55.4.1 Do This
            55.4.2 You Learned This  296
            55.5 Make a Directory (mkdir)  296
            55.5.1 Do This
            55.5.2 You Learned This  298
            55.5.3 Do More  298
            55.6 Change Directory (cd)  299
            55.6.1 Do This
            55.6.2 You Learned This  302
            55.6.3 Do More  302
            55.7 List Directory (ls)  303
            55.7.1 Do This
            55.7.2 You Learned This  307
            55.7.3 Do More  307
            55.8 Remove Directory (rmdir)  308
            55.8.1 Do This
            55.8.2 You Learned This  310
            55.8.3 Do More  310
            55.9 Moving Around (pushd, popd)  310
            55.9.1 Do This
            55.9.2 You Learned This  313
            55.9.3 Do More  313
            55.10 Making Empty Files (Touch, New-Item)  313
            55.10.1 Do This
            55.10.2 You Learned This  314
            55.10.3 Do More  314
            55.11 Copy a File (cp)  315
            55.11.1 Do This
            55.11.2 You Learned This  318
            55.11.3 Do More  318
            55.12 Moving a File (mv)  318
            55.12.1 Do This
            55.12.2 You Learned This  320
            55.12.3 Do More  321
            55.13 View a File (less, MORE)
            55.13.1 Do This
            55.13.2 You Learned This  322
            55.13.3 Do More  322
            55.14 Stream a File (cat)  322
            55.14.1 Do This
            55.14.2 You Learned This  323
            55.14.3 Do More  323
            55.15 Removing a File (rm)  324
            55.15.1 Do This
            55.15.2 You Learned This  326
            55.15.3 Do More  326
            55.16 Exiting Your Terminal (exit)  326
            55.16.1 Do This
            55.16.2 You Learned This  326
            55.16.3 Do More  326
            55.17 Command Line Next Steps  327
            55.17.1 Unix Bash References  327
            55.17.2 PowerShell References
~/Empire/Doks/Comp/lang/py/py-aut.pdf


vim: fdm=indent:fdl=2:
