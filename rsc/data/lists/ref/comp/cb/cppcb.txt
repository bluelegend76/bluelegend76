set foldmethod=indent foldlevel=2
vim: fdm=indent:fdl=2:

Style ----
~/Empire/Doks/Comp/lang/clangs/cpp/cppstyle.pdf
~/Empire/Doks/Comp/lang/clangs/cpp/cppstyle.txt
            vi C++ Programming Style

            Consistent Use of Dynamic Memory ..............02seeeeeeeeseeeeeeeeee 35
            Deallocating Dynamic Memory ...........:0:0sseeeeeseeeeeseeeeeeeeenes 37
            Style Example: A Second Approach ............:.::seeseeseeeneneeeenes 38
            SUEMMIMY 2. sccrecccccsccscnccccscccaccccncccsccscovccscccecsecescesescenss 45
            Bibliographic Notes .........:scsssscsseesecsccecerseeececeeeeeeceseeeeens 45
            Bceschsee asiewecivael dcicctidtiveocccsassacsacsdaronsneiccscncsesascnesnsans 4
            3 Unnecessary Inheritance 49
            Style Example: Stacks ........cscsccesecsceeseeceesensceeeeeseeeneneseens 49
            Inheritance Scope Rules ..............ccccccesceseceseeeececeeceseceeneeeee $3
            Inheritance Relationships ................c.cscecesceeeeesceeeeseeeeeeeees &4
            ERRCAUIMION 00. cesrcccccccccscoscnsccccscscqncagnagsdacpensscasesadibaseans 59
            Interface versus Implementation ................ccsceeseeseeseceeeeeeee 62
            PTUIEMNON Seo ccc A sscdadstuccccveccydst adunanudunaremuapnesomsbocaiteniien 66
            SIO. ns san decinageunanase sass sacdecavisanhse¥ubniedhanbiunedthieaiht 68
            EDO RTA NORGE oo occ cine cancabichasearpishoNianaiuanahencttaitine Wain 68
            EROOIOG aa ncaucre’aupas neat aed) dncaad <0 chelcunamnnevivynntt babe esr eat ies inet 69
            4 Virtual Functions 71
            Style Example: Vehicles and Garages ..............sscsceeeeeeeeeeeees 71
            COORONG 1, aeicdesccivscvcdsnnsevectecnuseusteiscleGuteetastvescuusectens 75
            Fane DSGTCHOGR, oct viisnsnngscasisntnaddansnspippodivucndtnsaseditngsbuveaas 77
            SINR acs ts sce ctneannat pans ectoesonoasanauanaeenaxenvakunakibeeiaas 79
            COMIN cinch canntunstivtpachanschoupiseuas¥iaseiiains hues backeadenls MRUHINE 82
            SOOMENATY.-:. 5 iivn dnciansisvhanedhasan ieiiaanchs tulsa: auvUunkéaveltstinensind 89
            Belo erage Notes | oo 0cs cei sac cesnee Suisopteasect csctesenscyeeuapupey 89
            Contents vii

            5 Operator Overloading 91
            Operator Overloading Basics .............sssssscssscesscssecsceseeecenses 91
            Style Example: Class FileArray  ........csccssecsceeeensneneeecerees 96
            Inheritance for Implementation ...............ccscesseeseeeceeseeseees 104
            A Programming Tradeoff: Overloaded Operators
            versus Member Functions ...........ccsceceescesseescenseesenseeseens 109
            SUOMI Fa cicsin cnasdductcncencicncndssvenivauceiseyecusacasascsaatnenetede 111
            Bibliographic Notes ..........sscsseseesseesensceesersseeceeseceseessenece 111
            ESRORCISCG 5. cnveccessce<gspapacnace <bynrpes emeaeh oases an ncnccebeensevacke 112

            6 Wrappers 113
            ALC Library, 62: Jans scan sesevudasih cndlouattivedibts Ihe spp unyins diesy ganado mis 113
            Style Example: A C++ Wrapper for dirent .........::cscceserseees 114
            Multiple Directory Objects ..........ccssececesseescneceesececeseeeseees 116
            Constructor Failure ..........sscesscssersersnssecssecseeeseseceseceseces 119
            Public Access to Failure State ..........cscesssesseesecseensereeeseeeses 121
            Error Condition Argument ............ccscccscesccsseeeccsseseeeseenees 123
            SOMA, saccevact duracks qapaisdeubaunvis ante dlenadanscasssuscusnedschas tne 128
            Bibliographic Notes ............sscccceescececssnssecscessenseesenscensees 128
            Exercise ert Ser ci asikachasngisitensimalppaaecss sctesesestens scorers 128

            7 Efficiency 129
            Style Example: Class BigInt..........csscssesesensceceeeeesseneeeseees 130
            Brercising BAGINE. ,...4.0cascssassacscnggdesnetidundepnesseqevonnsoncuses 137
            The Length of Dynamic Strings ............csscesecerenerereeeseeeeees 138
            The Number of Dynamic StringS ...............cesecssensceneeesenenees 140
            Ths Client Goda tits recs. 08 ee Re ies saa te reesei ce ccec eae eesenet 144
            SORTING ESS CET ay sca cucassvacsssssosccacacccccsncconscnsceccevsusasas 146

            viii C++ Programming Style

            Bibliographic Notes ...........:sccccessessecsceecesceseeceeescescesneees 153
            BxeTCiOOS |. 6c) 00 se vnnithd’ ocd Vecsajneatedcushaagpetd>cscccsccccnccsconnioons 153
            8 =A Case Study 155
            Style Example: Finite State Machines ..............:sccsceseeeeeseeees 155
            RRR aaiyet aes inaslangeSoncepanmpippasvifiaghocsccscucscnesescsvedsse 161
            COUN calasissscreectecsevestesctesseesrtetentncscarznepncetereeriaees 169
            CRORE caticer tees twits accetneusccscoceeerecucevenvessscdsnwesyeeunyenys 174
            Modules versus Abstract Data Types ..........cccccsccsseseensenenees 177
            Value versus Behavior ...........cccccscoccsosccccscccsscccccsccsscccoees 180
            Gomera thon «sits caisiividescocccscocsecsansenescorettdectenseccanccatasens 185
            Bibliggsaphic Notes isis séicsticci a leeree tie leTtecnociecsuvctgoadacncast 190
            ESMCBCHOGS ate cvandestancudadsvectneWeed: soncctecs Weteccccnsnsientausauuseeen 190
            9 = Multiple Inheritance 191
            Ambiguities under Multiple Inheritance ................scsseeseeeeeee 191
            Directed Acyclic Inheritance Graphs .................sccsceeseeeeees 194
            Exploring Virtual Base Classes  .............cssessceseeseesceseensenes 197
            Style Example: Class Monitor ........cccccceecescesececeseeeeceseees 204
            Style Example: A Virtual Base Class ...................c.eceeeeeeees 209
            Multiple Protocol Inheritance .............csccseeseeeseeseeseceeeeeeees 215
            SUMMMIOEY eisitdiacrcesccccccssccnctcacsccscscecnedinebrentbstvecscascerseaes 218
            Bibliographic Notes .................c.cceceecsececeeceeceesecscescesceces 219
            RIGOR Siics inci dcssntccntcthectecandlvcsizeteeeiecsoanscatencénsounivace 219
            10 Summary of Rules 221
~/Empire/Doks/Comp/lang/clangs/cpp/cppstyleelem.pdf
~/Empire/Doks/Comp/lang/clangs/cpp/cppstyleelem.txt
            Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . vii
            Audience . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . vii
            1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
            Disclaimer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
            Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
            2. General Principles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
            3. Formatting Conventions . . . . . . . . . . . . . . . . . . . . . . . 7
            3.1 Indentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
            4. Naming Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . 17
            4.1 Preprocessor Macro Names . . . . . . . . . . . . . . . . . . . . . . . . . 17
            4.2 Type and Constant Names . . . . . . . . . . . . . . . . . . . . . . . . . . 18
            4.3 Function Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
            4.4 Variable and Parameter Names . . . . . . . . . . . . . . . . . . . . . . 21
            4.5 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
            5. Documentation Conventions . . . . . . . . . . . . . . . . . 29
            6. Programming Principles . . . . . . . . . . . . . . . . . . . . . . 41
            6.1 Engineering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
            6.2 Class Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
            6.3 Thread Safety and Concurrency . . . . . . . . . . . . . . . . . . . . . 53
            TEAM LinG
            vvi CONTENTS
            7. Programming Conventions . . . . . . . . . . . . . . . . . . . 58
            7.1 Preprocessor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
            7.2 Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
            7.3 Scoping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
            7.4 Functions and Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
            7.5 Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
            7.6 Class Members . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
            7.7 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
            7.8 Templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
            7.9 Type Safety, Casting, and Conversion . . . . . . . . . . . . . . 102
            7.10 Initialization and Construction . . . . . . . . . . . . . . . . . . . . 112
            7.11 Statements and Expressions . . . . . . . . . . . . . . . . . . . . . . . 119
            7.12 Control Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
            7.13 Error and Exception Handling . . . . . . . . . . . . . . . . . . . . 129
            7.14 Efﬁciency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
            8. Packaging Conventions . . . . . . . . . . . . . . . . . . . . . 141
            8.1 Scoping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
            8.2 Organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
            8.3 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
            Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
            Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
            Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
            Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
~/Empire/Doks/Comp/lang/clangs/cpp/google-cpp_styleguide.pdf
~/Dropbox/rsc/data/lists/ref/comp/lang/cpp/cpp_coreguidelines.txt
~/Dropbox/rsc/data/lists/ref/comp/lang/cpp/cpp_coreguidelines.txt
google coding guidelines
            Google C++ Style Guide
            Table of Contents
            C++
            Version
            Header
            FilesSelf-contained Headers The #define Guard
            Forward Declarations Inline Functions
            Names and Order of Includes
            ScopingNamespaces Unnamed Namespaces and Static Variables
            Nonmember, Static Member, and Global Functions
            Local Variables Static and Global Variables
            thread_local Variables
            ClassesDoing Work in Constructors Implicit Conversions
            Copyable and Movable Types Structs vs. Classes Inheritance
            Operator Overloading Access Control Declaration Order
            FunctionsOutput Parameters Write Short Functions
            Reference Arguments Function Overloading
            Default Arguments Trailing Return Type Syntax
            Google-
            Specific
            MagicOwnership and Smart Pointers
            Other C++
            FeaturesRvalue References Friends Exceptions noexcept
            Run-Time Type Information (RTTI) Casting Streams
            Preincrement and Predecrement Use of const
            Use of constexpr Integer Types 64-bit Portability
            Preprocessor Macros 0 and nullptr/NULL sizeof auto
            Braced Initializer List Lambda expressions
            Template metaprogramming Boost std::hash C++11
            Nonstandard Extensions Aliases
            NamingGeneral Naming Rules File Names Type Names
            Variable Names Constant Names Function Names
            Namespace Names Enumerator Names Macro Names
            Exceptions to Naming Rules
            CommentsComment Style File Comments Class Comments
            Function Comments Variable Comments
            Implementation Comments Punctuation, Spelling and Grammar
            TODO Comments Deprecation Comments
            https://google.github.io/styleguide/cppguide.html
            cpplint
            1/742019/5/23
            FormattingGoogle C++ Style Guide
            Line Length Non-ASCII Characters
            Spaces vs. Tabs
            Function Declarations and Definitions Lambda Expressions
            Function Calls Braced Initializer List Format Conditionals
            Loops and Switch Statements Pointer and Reference Expressions
            Boolean Expressions Return Values
            Variable and Array Initialization Preprocessor Directives
            Class Format Constructor Initializer Lists
            Namespace Formatting Horizontal Whitespace
            Vertical Whitespace
            Exceptions
            to the
            RulesExisting Non-conformant Code
            Windows Code
            Parting
            Words


C ----
~/Empire/Doks/Comp/lang/clangs/c/cheatsh-qref/c.cheatsh.pdf
~/Empire/Doks/Comp/lang/clangs/c/cheatsh-qref/c.cheatsh.txt
~/Empire/Doks/Comp/lang/clangs/c/cheatsh-qref/c2.cheatsh.pdf
~/Empire/Doks/Comp/lang/clangs/c/cheatsh-qref/c2.cheatsh.txt
--
https://en.cppreference.com/w/c/header  #=C Standard Library Headers
            <assert.h>	Conditionally compiled macro that compares its argument to zero
            <complex.h> (since C99)	Complex number arithmetic
            <ctype.h>	Functions to determine the type contained in character data
            <errno.h>	Macros reporting error conditions
            <fenv.h> (since C99)	Floating-point environment
            <float.h>	Limits of floating-point types
            <inttypes.h> (since C99)	Format conversion of integer types
            <iso646.h> (since C95)	Alternative operator spellings
            <limits.h>	Ranges of integer types
            <locale.h>	Localization utilities
            <math.h>	Common mathematics functions
            <setjmp.h>	Nonlocal jumps
            <signal.h>	Signal handling
            <stdalign.h> (since C11)	alignas and alignof convenience macros
            <stdarg.h>	Variable arguments
            <stdatomic.h> (since C11)	Atomic operations
            <stdbit.h> (since C23)	Macros to work with the byte and bit representations of types
            <stdbool.h> (since C99)	Macros for boolean type
            <stdckdint.h> (since C23)	macros for performing checked integer arithmetic
            <stddef.h>	Common macro definitions
            <stdint.h> (since C99)	Fixed-width integer types
            <stdio.h>	Input/output
            <stdlib.h>	General utilities: memory management, program utilities, string conversions, random numbers, algorithms
            <stdnoreturn.h> (since C11)	noreturn convenience macro
            <string.h>	String handling
            <tgmath.h> (since C99)	Type-generic math (macros wrapping math.h and complex.h)
            <threads.h> (since C11)	Thread library
            <time.h>	Time/date utilities
            <uchar.h> (since C11)	UTF-16 and UTF-32 character utilities
            <wchar.h> (since C95)	Extended multibyte and wide character utilities
            <wctype.h> (since C95)	Functions to determine the type contained in wide character data

~/Empire/Doks/Comp/lang/clangs/c/cprogr40-cb_2019.pdf
~/Empire/Doks/Comp/lang/clangs/c/C Programming Tutorial.pdf
~/Empire/Doks/Comp/lang/clangs/c/21st Century C, 2nd Edition_2015.pdf
~/Empire/Doks/Comp/lang/clangs/c/C.Primer.Plus_6th-Edition_en-US_2014.pdf
~/Empire/Doks/Comp/lang/clangs/c/c-allref.pdf
~/Empire/Doks/Comp/lang/clangs/c/c-allref.txt
~/Empire/Doks/Comp/lang/clangs/c/ccpp-styleguidel.pdf
~/Empire/Doks/Comp/lang/clangs/c/ccpp-styleguidel.txt
~/Empire/Doks/Comp/lang/clangs/c/cfrb.pdf
~/Empire/Doks/Comp/lang/clangs/c/cfrb_2015ca.txt
~/Empire/Doks/Comp/lang/clangs/c/C in a Nutshell, Second Edition_2016.pdf
~/Empire/Doks/Comp/lang/clangs/c/cpractprogr.pdf
~/Empire/Doks/Comp/lang/clangs/c/cpractprogr.txt
~/Empire/Doks/Comp/lang/clangs/c/cprogr-learn_2020.pdf
~/Empire/Doks/Comp/lang/clangs/c/cprogr-primer.pdf
~/Empire/Doks/Comp/lang/clangs/c/gnu-codingstandards.pdf
~/Empire/Doks/Comp/lang/clangs/c/modernc.pdf
~/Empire/Doks/Comp/lang/clangs/c/modernc_2020.txt
 ~/Empire/Doks/Comp/lang/clangs/c/notes4pros-c.pdf
~/Empire/Doks/Comp/lang/clangs/c/cprogr-begguide_2022.pdf
--
~/Empire/Doks/Comp/lang/clangs/c/cindepth.txt
~/Empire/Doks/Comp/lang/clangs/c/cindepth-2e_2009.pdf
~/Empire/Doks/Comp/lang/clangs/c/cpractprogr_3ed_1997.pdf
 ~/Empire/Doks/Comp/lang/clangs/c/C The Complete Reference 4th Ed Herbert Schildt.pdf
~/Empire/Doks/Comp/lang/clangs/c/cavanc-ouall_1992.pdf
~/Empire/Doks/Comp/lang/clangs/c/cavanc-ouall_1992.txt
~/Empire/Doks/Comp/lang/clangs/c/expert-c-programming_1993plus.pdf


---- C++
https://stackoverflow.com/questions/2027991/list-of-standard-header-files-in-c-and-c/
            <ccomplex>     ___deprec=17++
            <cstdalign>    ___deprec=17+
            <cstdbool>    ___deprec=17+
            <ctgmath> (and not <ciso646>)    ___deprec=17+
            <codecvt>     ___deprec=17+
            -------------------
            cpp 98 headers ----
            <algorithm>
            <iomanip>
            <list>
            <ostream>
            <streambuf>
            <bitset>
            <ios>
            <locale>
            <queue>
            <string>
            <complex>
            <iosfwd>
            <map>
            <set>
            <typeinfo>
            <deque>
            <iostream>
            <memory>
            <sstream>
            <utility>
            <exception>
            <istream>
            <new>
            <stack>
            <valarray>
            <fstream>
            <iterator>
            <numeric>
            <stdexcept>
            <vector>
            <functional>
            <limits>
            (+18 headers corresponding to available c headers)
            cpp 11 additions ----
            <algorithm>
            <iomanip>
            <list>
            <ostream>
            <streambuf>
            <bitset>
            <ios>
            <locale>
            <queue>
            <string>
            <complex>
            <iosfwd>
            <map>
            <set>
            <typeinfo>
            <deque>
            <iostream>
            <memory>
            <sstream>
            <utility>
            <exception>
            <istream>
            <new>
            <stack>
            <valarray>
            <fstream>
            <iterator>
            <numeric>
            <stdexcept>
            <vector>
            <functional>
            <limits>
            cpp 14 addition ----
            <shared_mutex>
            cpp 17 additions ----
            <any>
            <execution>
            <filesystem>
            <memory_resource>
            <optional>
            <string_view>
            <variant>

~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf
~/Dropbox/rsc/Doks/phone.fmt35/cpc.txt
cpc(!)
                evince -p 19 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.0 Introduction to Building
                evince -p 33 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.1 Obtaining and Installing GCC
                evince -p 36 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.2 Building a Simple "Hello, World"
                evince -p 51 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.5 Building a Complex Application
                evince -p 56 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.6 Installing Boost.Build
                evince -p 58 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.7 Building a Simple "Hello, World" Application Using Boost.Build
                evince -p 62 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.9 Building a Dynamic Library Using Boost.Build
                evince -p 64 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.10 Building a Complex Application Using Boost.Build
                evince -p 68 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.11 Building a Static Library with an IDE
                evince -p 71 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.12 Building a Dynamic Library with an IDE Problem
                evince -p 75 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.13 Building a Complex Application with an IDE Problem
                evince -p 80 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.14 Obtaining GNU make
                evince -p 82 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.15 Building A Simple "Hello, World" Application with GNU make
                evince -p 90 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.16 Building a Static Library with GNU Make
                evince -p 95 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.17 Building a Dynamic Library with GNU Make
                evince -p 96 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.18 Building a Complex Application with GNU make
                evince -p 100 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.19 Defining a Macro
                evince -p 102 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.20 Specifying a Command-Line
                evince -p 103 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.21 Producing a Debug Build
                evince -p 107 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.22 Producing a Release Build
                evince -p 110 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.23 Specifying a Runtime Library Variant
                evince -p 113 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.24 Enforcing Strict Conformance to the C++ Standard
                evince -p 117 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.25 Causing a Source File to Be Linked Automatically Against a Specified Library
                evince -p 119 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            1.26 Using Exported Templates

                evince -p 123 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            2.0 Introduction
                evince -p 125 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            2.1 Making Sure a Header File Gets Included Only Once
                evince -p 126 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            2.2 Ensuring You Have Only One Instance of a Variable Across Multiple Source Files
                evince -p 128 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            2.3 Reducing #includes with Forward Class Declarations
                evince -p 129 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            2.4 Preventing Name Collisions with Namespaces
                evince -p 136 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            2.5 Including an Inline File

                evince -p 138 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            3.1 Converting a String to a Numeric Type
                evince -p 141 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            3.2 Converting Numbers to Strings
                evince -p 144 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            3.3 Testing Whether a String Contains a Valid Number
                evince -p 147 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            3.4 Comparing Floating-Point Numbers with Bounded Accuracy
                evince -p 149 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            3.5 Parsing a String Containing a Number in Scientific Notation
                evince -p 151 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            3.6 Converting Between Numeric Types
                evince -p 154 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            3.7 Getting the Minimum and Maximum Values for a Numeric Type

                evince -p 158 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.1 Padding a String
                evince -p 160 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.2 Trimming a String
                evince -p 165 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.3 Storing Strings in a Sequence
                evince -p 169 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.4 Getting the Length of a String
                evince -p 171 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.5 Reversing a String
                evince -p 172 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.6 Splitting a String
                evince -p 175 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.7 Tokenizing a String
                evince -p 177 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.8 Joining a Sequence of Strings
                evince -p 180 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.9 Finding Things in Strings
                evince -p 183 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.10 Finding the nth Instance of a Substring
                evince -p 185 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.11 Removing a Substring from a String
                evince -p 186 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.12 Converting a String to Lower- or Uppercase
                evince -p 189 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.13 Doing a Case-Insensitive String Comparison
                evince -p 191 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.14 Doing a Case-Insensitive String Search
                evince -p 193 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.15 Converting Between Tabs and Spaces in a Text File
                evince -p 196 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.16 Wrapping Lines in a Text File
                evince -p 198 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.17 Counting the Number of Characters, Words, and Lines in a Text File
                evince -p 201 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.18 Counting Instances of Each Word in a Text File
                evince -p 203 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.19 Add Margins to a Text File
                evince -p 206 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.20 Justify a Text File
                evince -p 208 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.21 Squeeze Whitespace to Single Spaces in a Text File
                evince -p 209 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.22 Autocorrect Text as a Buffer Changes
                evince -p 212 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.23 Reading a Comma-Separated Text File
                evince -p 214 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            4.24 Using Regular Expressions to Split a String

                evince -p 216 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            5.1 Obtaining the Current Date and Time
                evince -p 219 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            5.2 Formatting a Date/Time as a String
                evince -p 222 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            5.3 Performing Date and Time Arithmetic
                evince -p 223 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            5.4 Converting Between Time Zones
                evince -p 225 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            5.5 Determining a Day's Number Within a Given Year
                evince -p 226 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            5.6 Defining Constrained Value Types

                evince -p 231 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            6.0 Introduction
                evince -p 232 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            6.1 Using vectors Instead of Arrays
                evince -p 236 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            6.2 Using vectors Efficiently
                evince -p 240 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            6.3 Copying a vector
                evince -p 242 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            6.4 Storing Pointers in a vector
                evince -p 244 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            6.5 Storing Objects in a list
                evince -p 249 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            6.6 Mapping strings to Other Things
                evince -p 255 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            6.7 Using Hashed Containers
                evince -p 260 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            6.8 Storing Objects in Sorted Order
                evince -p 263 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            6.9 Storing Containers in Containers

                evince -p 266 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            7.0 Introduction
                evince -p 267 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            7.1 Iterating Through a Container
                evince -p 274 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            7.2 Removing Objects from a Container
                evince -p 277 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            7.3 Randomly Shuffling Data
                evince -p 278 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            7.4 Comparing Ranges
                evince -p 282 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            7.5 Merging Data
                evince -p 286 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            7.6 Sorting a Range
                evince -p 289 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            7.7 Partitioning a Range
                evince -p 290 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            7.8 Performing Set Operations on Sequences
                evince -p 294 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            7.9 Transforming Elements in a Sequence
                evince -p 296 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            7.10 Writing Your Own Algorithm
                evince -p 299 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            7.11 Printing a Range to a Stream

                evince -p 303 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.0 Introduction
                evince -p 304 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.1 Initializing Class Member Variables
                evince -p 307 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.2 Using a Function to Create Objects (a.k.a. Factory Pattern)
                evince -p 309 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.3 Using Constructors and Destructors to Manage Resources (or RAII)
                evince -p 312 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.4 Automatically Adding New Class Instances to a Container
                evince -p 314 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.5 Ensuring a Single Copy of a Member Variable
                evince -p 315 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.6 Determining an Object's Type at Runtime
                evince -p 317 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.7 Determining if One Object's Class Is a Subclass of Another
                evince -p 319 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.8 Giving Each Instance of a Class a Unique Identifier
                evince -p 321 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.9 Creating a Singleton Class
                evince -p 324 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.10 Creating an Interface with an Abstract Base Class
                evince -p 328 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.11 Writing a Class Template
                evince -p 333 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.12 Writing a Member Function Template
                evince -p 336 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.13 Overloading the Increment and Decrement Operators
                evince -p 338 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.14 Overloading Arithmetic and Assignment Operators for Intuitive Class Behavior
                evince -p 346 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            8.15 Calling a Superclass Virtual Function

                evince -p 348 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            9.0 Introduction
                evince -p 353 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            9.2 Making a Constructor Exception-Safe
                evince -p 356 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            9.3 Making an Initializer List Exception-Safe
                evince -p 359 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            9.4 Making Member Functions Exception-Safe
                evince -p 364 ~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf &
            9.5 Safely Copying an Object
~/Dropbox/rsc/data/lists/ref/comp/lang/cpp/cppcb.txt

~/Empire/Doks/Comp/lang/clangs/cpp/cppdir2def.txt  #=HAS FUNCT/METHODS-LIST

~/Dropbox/rsc/data/lists/ref/comp/lang/cpp/scottm-cpp_modcpp.txt
--
~/Empire/Doks/Comp/lang/clangs/cpp/c-cpp-tutorial.pdf
            Table of contents ...............................................................................................................................3
            Introduction ......................................................................................................................................5
            Instructions for use ................................................................................................................................... 5
            Basics of C++ ......................................................................................................................................7
            Structure of a program ............................................................................................................................. 7
            Variables. Data Types. ............................................................................................................................. 11
            Constants ................................................................................................................................................ 17
            Operators ................................................................................................................................................ 21
            Basic Input/Output.................................................................................................................................. 29
            Control Structures ............................................................................................................................ 34
            Control Structures ................................................................................................................................... 34
            Functions (I) ............................................................................................................................................ 41
            Functions (II) ........................................................................................................................................... 47
            Compound data types ...................................................................................................................... 54
            Arrays ...................................................................................................................................................... 54
            Character Sequences .............................................................................................................................. 60
            Pointers ................................................................................................................................................... 63
            Dynamic Memory.................................................................................................................................... 74
            Data structures........................................................................................................................................ 77
            Other Data Types .................................................................................................................................... 82
            Object Oriented Programming.......................................................................................................... 86
            Classes (I)................................................................................................................................................. 86
            Classes (II) ............................................................................................................................................... 95
            Friendship and inheritance ................................................................................................................... 100
            Polymorphism ....................................................................................................................................... 107
            Advanced concepts ........................................................................................................................ 113
            Templates.............................................................................................................................................. 113
            Namespaces .......................................................................................................................................... 120
            Exceptions ............................................................................................................................................. 123
            Type Casting .......................................................................................................................................... 127
            3
            © cplusplus.com 2008. All rights reservedThe C++ Language Tutorial
            Preprocessor directives......................................................................................................................... 133
            C++ Standard Library ...................................................................................................................... 138
            Input/Output with files ......................................................................................................................... 138
~/Empire/Doks/Comp/lang/clangs/cpp/cpc.pdf
            Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xi
            1. Building C++ Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
            1.1 Obtaining and Installing GCC
            1.2 Building a Simple “Hello, World” Application
            from the Command Line
            1.3 Building a Static Library from the Command Line
            1.4 Building a Dynamic Library from the Command Line
            1.5 Building a Complex Application from the Command Line
            1.6 Installing Boost.Build
            1.7 Building a Simple “Hello, World” Application Using Boost.Build
            1.8 Building a Static Library Using Boost.Build
            1.9 Building a Dynamic Library Using Boost.Build
            1.10 Building a Complex Application Using Boost.Build
            1.11 Building a Static Library with an IDE
            1.12 Building a Dynamic Library with an IDE
            1.13 Building a Complex Application with an IDE
            1.14 Obtaining GNU make
            1.15 Building A Simple “Hello, World” Application with GNU make
            1.16 Building a Static Library with GNU Make
            1.17 Building a Dynamic Library with GNU Make
            1.18 Building a Complex Application with GNU make
            1.19 Defining a Macro
            1.20 Specifying a Command-Line Option from Your IDE
            1.21 Producing a Debug Build
            1.22 Producing a Release Build
            1.23 Specifying a Runtime Library Variant
            15
            18
            23
            25
            33
            38
            40
            44
            45
            46
            50
            53
            57
            62
            64
            72
            77
            78
            82
            84
            85
            89
            92
            v
            www.it-ebooks.info1.24 Enforcing Strict Conformance to the C++ Standard
            1.25 Causing a Source File to Be Linked Automatically Against
            a Specified Library
            1.26 Using Exported Templates
            95
            99
            101
            2. Code Organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
            2.1 Making Sure a Header File Gets Included Only Once
            2.2 Ensuring You Have Only One Instance of a Variable
            Across Multiple Source Files
            2.3 Reducing #includes with Forward Class Declarations
            2.4 Preventing Name Collisions with Namespaces
            2.5 Including an Inline File
            107
            108
            110
            111
            118
            3. Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
            3.1 Converting a String to a Numeric Type
            3.2 Converting Numbers to Strings
            3.3 Testing Whether a String Contains a Valid Number
            3.4 Comparing Floating-Point Numbers with Bounded Accuracy
            3.5 Parsing a String Containing a Number in Scientific Notation
            3.6 Converting Between Numeric Types
            3.7 Getting the Minimum and Maximum Values for a Numeric Type
            120
            123
            126
            129
            131
            133
            136
            4. Strings and Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
            4.1 Padding a String
            4.2 Trimming a String
            4.3 Storing Strings in a Sequence
            4.4 Getting the Length of a String
            4.5 Reversing a String
            4.6 Splitting a String
            4.7 Tokenizing a String
            4.8 Joining a Sequence of Strings
            4.9 Finding Things in Strings
            4.10 Finding the nth Instance of a Substring
            4.11 Removing a Substring from a String
            4.12 Converting a String to Lower- or Uppercase
            4.13 Doing a Case-Insensitive String Comparison
            4.14 Doing a Case-Insensitive String Search
            4.15 Converting Between Tabs and Spaces in a Text File
            4.16 Wrapping Lines in a Text File
            vi
            | Table of Contents
            www.it-ebooks.info
            140
            142
            147
            151
            153
            154
            157
            159
            162
            165
            167
            168
            171
            173
            175
            178
            4.17 Counting the Number of Characters, Words, and Lines
            in a Text File
            4.18 Counting Instances of Each Word in a Text File
            4.19 Add Margins to a Text File
            4.20 Justify a Text File
            4.21 Squeeze Whitespace to Single Spaces in a Text File
            4.22 Autocorrect Text as a Buffer Changes
            4.23 Reading a Comma-Separated Text File
            4.24 Using Regular Expressions to Split a String
            180
            183
            185
            188
            190
            191
            194
            196
            5. Dates and Times . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
            5.1 Obtaining the Current Date and Time
            5.2 Formatting a Date/Time as a String
            5.3 Performing Date and Time Arithmetic
            5.4 Converting Between Time Zones
            5.5 Determining a Day’s Number Within a Given Year
            5.6 Defining Constrained Value Types
            198
            201
            204
            205
            207
            208
            6. Managing Data with Containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
            6.1 Using vectors Instead of Arrays
            6.2 Using vectors Efficiently
            6.3 Copying a vector
            6.4 Storing Pointers in a vector
            6.5 Storing Objects in a list
            6.6 Mapping strings to Other Things
            6.7 Using Hashed Containers
            6.8 Storing Objects in Sorted Order
            6.9 Storing Containers in Containers
            214
            218
            222
            224
            226
            231
            237
            242
            245
            7. Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
            7.1 Iterating Through a Container
            7.2 Removing Objects from a Container
            7.3 Randomly Shuffling Data
            7.4 Comparing Ranges
            7.5 Merging Data
            7.6 Sorting a Range
            7.7 Partitioning a Range
            7.8 Performing Set Operations on Sequences
            7.9 Transforming Elements in a Sequence
            249
            256
            259
            260
            264
            268
            271
            272
            276
            Table of Contents
            www.it-ebooks.info
            |
            vii7.10 Writing Your Own Algorithm
            7.11 Printing a Range to a Stream
            278
            281
            8. Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285
            8.1 Initializing Class Member Variables
            8.2 Using a Function to Create Objects (a.k.a. Factory Pattern)
            8.3 Using Constructors and Destructors to Manage Resources (or RAII)
            8.4 Automatically Adding New Class Instances to a Container
            8.5 Ensuring a Single Copy of a Member Variable
            8.6 Determining an Object’s Type at Runtime
            8.7 Determining if One Object’s Class Is a Subclass of Another
            8.8 Giving Each Instance of a Class a Unique Identifier
            8.9 Creating a Singleton Class
            8.10 Creating an Interface with an Abstract Base Class
            8.11 Writing a Class Template
            8.12 Writing a Member Function Template
            8.13 Overloading the Increment and Decrement Operators
            8.14 Overloading Arithmetic and Assignment Operators
            for Intuitive Class Behavior
            8.15 Calling a Superclass Virtual Function
            286
            289
            291
            294
            296
            297
            299
            301
            303
            306
            310
            315
            318
            320
            328
            9. Exceptions and Safety . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330
            9.1 Creating an Exception Class
            9.2 Making a Constructor Exception-Safe
            9.3 Making an Initializer List Exception-Safe
            9.4 Making Member Functions Exception-Safe
            9.5 Safely Copying an Object
            330
            335
            338
            341
            346
            10. Streams and Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
            10.1 Lining Up Text Output
            10.2 Formatting Floating-Point Output
            10.3 Writing Your Own Stream Manipulators
            10.4 Making a Class Writable to a Stream
            10.5 Making a Class Readable from a Stream
            10.6 Getting Information About a File
            10.7 Copying a File
            10.8 Deleting or Renaming a File
            10.9 Creating a Temporary Filename and File
            10.10 Creating a Directory
            viii
            | Table of Contents
            www.it-ebooks.info
            352
            356
            359
            363
            366
            368
            370
            374
            376
            37810.11 Removing a Directory
            10.12 Reading the Contents of a Directory
            10.13 Extracting a File Extension from a String
            10.14 Extracting a Filename from a Full Path
            10.15 Extracting a Path from a Full Path and Filename
            10.16 Replacing a File Extension
            10.17 Combining Two Paths into a Single Path
            380
            383
            385
            386
            388
            389
            390
            11. Science and Mathematics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394
            11.1 Computing the Number of Elements in a Container
            11.2 Finding the Greatest or Least Value in a Container
            11.3 Computing the Sum and Mean of Elements in a Container
            11.4 Filtering Values Outside a Given Range
            11.5 Computing Variance, Standard Deviation,
            and Other Statistical Functions
            11.6 Generating Random Numbers
            11.7 Initializing a Container with Random Numbers
            11.8 Representing a Dynamically Sized Numerical Vector
            11.9 Representing a Fixed-Size Numerical Vector
            11.10 Computing a Dot Product
            11.11 Computing the Norm of a Vector
            11.12 Computing the Distance Between Two Vectors
            11.13 Implementing a Stride Iterator
            11.14 Implementing a Dynamically Sized Matrix
            11.15 Implementing a Constant-Sized Matrix
            11.16 Multiplying Matricies
            11.17 Computing the Fast Fourier Transform
            11.18 Working with Polar Coordinates
            11.19 Performing Arithmetic on Bitsets
            11.20 Representing Large Fixed-Width Integers
            11.21 Implementing Fixed-Point Numbers
            395
            396
            399
            402
            403
            407
            409
            410
            412
            415
            416
            417
            419
            423
            426
            429
            431
            433
            435
            439
            443
            12. Multithreading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 446
            12.1 Creating a Thread
            12.2 Making a Resource Thread-Safe
            12.3 Notifying One Thread from Another
            12.4 Initializing Shared Resources Once
            12.5 Passing an Argument to a Thread Function
            447
            450
            458
            462
            463
            Table of Contents
            www.it-ebooks.info
            |
            ix13. Internationalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 466
            13.1 Hardcoding a Unicode String
            13.2 Writing and Reading Numbers
            13.3 Writing and Reading Dates and Times
            13.4 Writing and Reading Currency
            13.5 Sorting Localized Strings
            467
            468
            472
            477
            481
            14. XML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 484
            14.1 Parsing a Simple XML Document
            14.2 Working with Xerces Strings
            14.3 Parsing a Complex XML Document
            14.4 Manipulating an XML Document
            14.5 Validating an XML Document with a DTD
            14.6 Validating an XML Document with a Schema
            14.7 Transforming an XML Document with XSLT
            14.8 Evaluating an XPath Expression
            14.9 Using XML to Save and Restore a Collection of Objects
            485
            494
            496
            508
            512
            517
            520
            527
            533
            15. Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
            15.1 Using Function Pointers for Callbacks
            15.2 Using Pointers to Class Members
            15.3 Ensuring That a Function Doesn’t Modify an Argument
            15.4 Ensuring That a Member Function Doesn’t Modify Its Object
            15.5 Writing an Operator That Isn’t a Member Function
            15.6 Initializing a Sequence with Comma-Separated Values
            539
            541
            544
            546
            548
            550
            Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 555
~/Empire/Doks/Comp/lang/clangs/cpp/scottm/effcpp-scottm.chm
~/Empire/Doks/Comp/lang/clangs/cpp/scottm/effcpp-scottm.txt
            Basics

            Item 1:

            Item 2:

            Item 3:

            Item 4:

            Operators

            Item 5:

            Item 6:

            Item 7:

            Item 8:

            Distinguish between pointers and references
            Prefer C++-style casts
            Never treat arrays polymorphically

            Avoid gratuitous default constructors

            Be wary of user-defined conversion functions

            Distinguish between prefix and postfix forms of
            increment and decrement operators

            Never overload &&, | |, or,

            Understand the different meanings ofnew and delete
            Exceptions

            Item 9:

            Item 10:

            Item 11:

            Item 12:

            Item 13:

            Item 14:

            Item 15:

            Efficiency

            Item 16:

            Use destructors to prevent resource leaks
            Prevent resource leaks in constructors
            Prevent exceptions from leaving destructors

            Understand how throwing an exception differs from
            passing a parameter or calling a virtual function

            Catch exceptions by reference
            Use exception specifications judiciously

            Understand the costs of exception handling

            Remember the 80-20 rule
            Item 17:

            Item 18:

            Item 19:

            Item 20:

            Item 21:

            Item 22:

            Item 23:

            Item 24:

            Consider using lazy evaluation

            Amortize the cost of expected computations
            Understand the origin of temporary objects
            Facilitate the return value optimization
            Overload to avoid implicit type conversions
            Consider using op= instead of stand-aloneop
            Consider alternative libraries

            Understand the costs of virtual functions, multiple
            inheritance, virtual base classes, and RTTI
             

            Techniques

            Item 25:

            Item 26:

            Item 27:

            Item 28:

            Item 29:

            Item 30:

            Item 31:

            Miscellany

            Item 32:

            Virtualizing constructors and non-member functions
            Limiting the number of objects of a class

            Requiring or prohibiting heap-based objects

            Smart pointers

            Reference counting

            Proxy classes

            Making functions virtual with respect to more than
            one object

            Program in the future tense
            Item 33: Make non-leaf classes abstract

            Item 34: Understand how to combine C++ and C in the same
            program
            Item 35: Familiarize yourself with the language standard

            Contents of Effective STL

            Chapter 1: Containers

            Item 1: Choose your containers with care.

            Item 2: Beware the illusion of container-independent code.

            Item 3: Make copying cheap and correct for objects in
            containers.

            Item 4: Call empty instead of checkingsize() against zero.
            Item 5:

            Item 6:

            Item 7:

            Item 8:

            Item 9:

            Item 10:

            Item 11:

            Item 12:

            Prefer range member functions to their single-element
            counterparts.

            Be alert for C++'s most vexing parse.

            When using containers ofnewed pointers, remember to
            deletethe pointers before the container is destroyed.

            Never create containers ofauto_ptss.

            Choose carefully among erasing options.

            Be aware of allocator conventions and restrictions.

            Understand the legitimate uses of custom allocators.

            Have realistic expectations about the thread safety of
            STL containers.

            Chapter 2: vectorand string
            Item 13:

            Item 14:

            Item 15:

            Item 16:

            Item 17:

            Item 18:

            Prefer vectorand stringto dynamically allocated
            arrays.

            Use reserveto avoid unnecessary reallocations.

            Be aware of variations instringimplementations.

            Know how to pasSvectorand string data to legacy
            APIs.

            Use "the swap TRick" to trim excess capacity.

            Avoid using vector<bool>

            Chapter 3: Associative Containers

            Item 19:

            Understand the difference between equality and
            equivalence.
            Item 20:

            Item 21:

            Item 22:

            Item 23:

            Item 24:

            Item 25:

            Specify comparison types for associative containers of
            pointers.

            Always have comparison functions returnfalse for
            equal values.

            Avoid in-place key modification inset and multiset

            Consider replacing associative containers with sorted
            vectors.

            Choose carefully betweenmap: : operator []Jand
            map: :insertwhen efficiency is important.

            Familiarize yourself with the nonstandard hashed
            containers.

            Chapter 4: Iterators
            Item 26:

            Item 27:

            Item 28:

            Item 29:

            Prefer iteratorto const_iterator
            reverse_iteratoy and const_reverse_iterator

            Use distanceand advanceto convert a container's
            const_iteratos toO iteratoxs.

            Understand how to use areverse_iteratots base
            iteraton

            Consider istreambuf_iteratos for
            character-by-character input.

            Chapter 5: Algorithms

            Item 30:

            Item 31:

            Make sure destination ranges are big enough.

            Know your sorting options.
            Item 32:

            Item 33:

            Item 34:

            Item 35:

            Item 36:

            Item 37:

            Follow removelike algorithms byeraseif you really
            want to remove something.

            Be wary of removelike algorithms on containers of
            pointers.

            Note which algorithms expect sorted ranges.

            Implement simple case-insensitive string comparisons
            via mismatchor lexicographical_compare

            Understand the proper implementation ofcopy_if.

            Use accumulateor for_eachto summarize ranges.

            Chapter 6: Functors, Functor Classes, Functions, etc.

            Item 38:

            Design functor classes for pass-by-value.
            Item 39:

            Item 40:

            Item 41:

            Item 42:

            Make predicates pure functions.

            Make functor classes adaptable.

            Understand the reasons forptr_fun mem_fun and
            mem_fun_ref

            Make sure less<T> means operator<

            Chapter 7: Programming with the STL

            Item 43:

            Item 44:

            Item 45:

            Prefer algorithm calls to hand-written loops.

            Prefer member functions to algorithms with the same
            names.

            Distinguish amongcount, find, binary_search
            lower_bound upper_boung and equal_range
            Item 45:

            Item 46:

            Item 47:

            Item 48:

            Item 49:

            Item 50:

            Distinguish amongcount, find, binary_search
            lower_boung upper_boung and equal_range

            Consider function objects instead of functions as
            algorithm parameters.

            Avoid producing write-only code.

            Always #includethe proper headers.

            Learn to decipher STL-related compiler diagnostics.

            Familiarize yourself with STL-related web sites.
            < Day Day Up > NEXT >


            Appendix B. Item Mappings Between Second
~/Empire/Doks/Comp/lang/clangs/cpp/scottm/effcpp-scottm_more.pdf
~/Empire/Doks/Comp/lang/clangs/cpp/scottm/effcpp-scottm_more.txt
            This page intentionally left blank

            Contents

            Acknowledgments
            xi

            Introduction

            1

            Basics

            9

            Item 1:

            Distinguish between pointers and references.

            Item 2:

            Prefer C++-style casts.

            12

            Item 3:

            Never treat arrays polymorphically.

            16

            Item 4:

            Avoid gratuitous default constructors.

            19

            Operators

            9

            24

            Item 5:

            Be wary of user-defined conversion functions.

            24

            Item 6:

            Distinguish between prefix and postfix forms of
            increment and decrement operators.

            31

            Item 7:

            Never overload &&, ||, or ,.

            35

            Item 8:

            Understand the different meanings of new
            and delete.

            38

            Exceptions

            Item 9:

            Use destructors to prevent resource leaks.

            44
            45

            Item 10: Prevent resource leaks in constructors.

            50

            Item 11: Prevent exceptions from leaving destructors.

            58

            Item 12: Understand how throwing an exception differs from
            passing a parameter or calling a virtual function.

            61

            Item 13: Catch exceptions by reference.

            68

            Item 14: Use exception specifications judiciously.

            72

            Item 15: Understand the costs of exception handling.

            78

            x

            Contents

            Efficiency

            81

            Item 16: Remember the 80-20 rule.

            82

            Item 17: Consider using lazy evaluation.

            85

            Item 18: Amortize the cost of expected computations.

            93

            Item 19: Understand the origin of temporary objects.

            98

            Item 20: Facilitate the return value optimization.

            101

            Item 21: Overload to avoid implicit type conversions.

            105

            Item 22: Consider using op= instead of stand-alone op.

            107

            Item 23: Consider alternative libraries.

            110

            Item 24: Understand the costs of virtual functions, multiple
            inheritance, virtual base classes, and RTTI.

            113

            Techniques

            123

            Item 25: Virtualizing constructors and non-member
            functions.

            123

            Item 26: Limiting the number of objects of a class.

            130

            Item 27: Requiring or prohibiting heap-based objects.

            145

            Item 28: Smart pointers.

            159

            Item 29: Reference counting.

            183

            Item 30: Proxy classes.

            213

            Item 31: Making functions virtual with respect to more
            than one object.

            228

            Miscellany

            252

            Item 32: Program in the future tense.

            252

            Item 33: Make non-leaf classes abstract.

            258

            Item 34: Understand how to combine C++ and C in the
            same program.

            270

            Item 35: Familiarize yourself with the language standard.

            277

            Recommended Reading

            285

            An auto_ptr Implementation

            291

            General Index

            295

            Index of Example Classes, Functions, and Templates 313
~/Empire/Doks/Comp/lang/clangs/cpp/scottm/effmodcpp.pdf
~/Empire/Doks/Comp/lang/clangs/cpp/scottm/effmodcpp.txt
            Table of Contents

            From the Publisher. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xi

            Acknowledgments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii

            Introduction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
            1. Deducing Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
            Item 1:

            Item 2:

            Item 3:

            Item 4:

            Understand template type deduction.

            Understand auto type deduction.

            Understand decltype.

            Know how to view deduced types.

            9
            18
            23
            30

            2. auto. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
            Item 5: Prefer auto to explicit type declarations.

            Item 6: Use the explicitly typed initializer idiom when auto deduces
            undesired types.

            37
            43

            3. Moving to Modern C++. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
            Item 7: Distinguish between () and {} when creating objects.

            Item 8: Prefer nullptr to 0 and NULL.

            Item 9: Prefer alias declarations to typedefs.

            Item 10: Prefer scoped enums to unscoped enums.

            Item 11: Prefer deleted functions to private undefined ones.

            Item 12: Declare overriding functions override.

            Item 13: Prefer const_iterators to iterators.

            Item 14: Declare functions noexcept if they won't emit exceptions.

            Item 15: Use constexpr whenever possible.

            49
            58
            63
            67
            74
            79
            86
            90
            97
            vii

            Item 16: Make const member functions thread safe.

            Item 17: Understand special member function generation.

            103
            109

            4. Smart Pointers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
            Item 18: Use std::unique_ptr for exclusive-ownership resource
            management.

            Item 19: Use std::shared_ptr for shared-ownership resource
            management.

            Item 20: Use std::weak_ptr for std::shared_ptr-like pointers that can
            dangle.

            Item 21: Prefer std::make_unique and std::make_shared to direct use of
            new.

            Item 22: When using the Pimpl Idiom, define special member functions in
            the implementation file.

            118
            125
            134
            139
            147

            5. Rvalue References, Move Semantics, and Perfect Forwarding. . . . . . . . . . . . . . . . . . . . 157
            Item 23: Understand std::move and std::forward.

            Item 24: Distinguish universal references from rvalue references.

            Item 25: Use std::move on rvalue references, std::forward on universal
            references.

            Item 26: Avoid overloading on universal references.

            Item 27: Familiarize yourself with alternatives to overloading on universal
            references.

            Item 28: Understand reference collapsing.

            Item 29: Assume that move operations are not present, not cheap, and not
            used.

            Item 30: Familiarize yourself with perfect forwarding failure cases.

            158
            164
            168
            177
            184
            197
            203
            207

            6. Lambda Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
            Item 31:

            Item 32:

            Item 33:

            Item 34:

            Avoid default capture modes.

            Use init capture to move objects into closures.

            Use decltype on auto&& parameters to std::forward them.

            Prefer lambdas to std::bind.

            216
            224
            229
            232

            7. The Concurrency API. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
            Item 35:

            Item 36:

            Item 37:

            Item 38:

            Item 39:

            viii

            |

            Prefer task-based programming to thread-based.

            Specify std::launch::async if asynchronicity is essential.

            Make std::threads unjoinable on all paths.

            Be aware of varying thread handle destructor behavior.

            Consider void futures for one-shot event communication.

            Table of Contents

            241
            245
            250
            258
            262

            Item 40: Use std::atomic for concurrency, volatile for special memory.

            271

            8. Tweaks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
            Item 41: Consider pass by value for copyable parameters that are cheap to
            move and always copied.

            Item 42: Consider emplacement instead of insertion.

            281
            292

            Index. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
~/Empire/Doks/Comp/lang/clangs/cpp/cpp20-stl.pdf
            Table of Contents
            Preface
            1
            New C++20 Features
            Technical requirements
            Format text with the new
            format library2Easily find feature test macros
            with the <version> header16
            2How to do it…
            How it works…
            There's more…3
            4
            6How to do it…
            How it works…16
            17
            Create safer templates with
            concepts and constraints17
            Use compile-time vectors and
            strings with constexpr7How to do it…
            How it works…8
            8How to do it…
            How it works…
            There's more…18
            20
            21
            Avoid re-compiling template
            libraries with modules23
            How to do it…
            How it works…23
            25
            Create views into containers
            with ranges28
            How to do it…
            How it works…
            There's more…29
            31
            33
            Safely compare integers of
            different types9
            How to do it…
            How it works…10
            10
            Use the "spaceship" operator
            <=> for three-way comparisons 11
            How to do it…
            How it works…
            There's more…
            12
            14
            14vi Table of Contents
            2
            General STL Features
            Technical requirements
            35
            Use the new span class to make
            your C-arrays safer
            36
            How to do it…
            How it works…
            36
            37
            Use structured binding to
            return multiple values38
            How to do it…
            How it works…
            39
            41
            Initialize variables within if and
            switch statements43
            How to do it…43
            How it works…
            There's more…
            44
            45
            Use template argument
            deduction for simplicity and
            clarity46
            How to do it…
            How it works…
            There's more…46
            48
            50
            Use if constexpr to simplify
            compile-time decisions51
            How to do it…
            How it works…51
            52
            How it works…63
            3
            STL Containers
            A quick overview of the STL
            container types53
            Sequential containers
            Associative containers
            Container adapters53
            54
            55
            Technical requirements
            56
            Use uniform erasure functions
            to delete items from a container 56
            How to do it…
            How it works…
            57
            59
            Delete items from an unsorted
            vector in constant time61
            How to do it…61
            Access vector elements directly
            and safely
            64
            How to do it…
            How it works…
            There's more…64
            66
            66
            Keep vector elements sorted67
            How to do it…
            How it works…
            There's more…67
            69
            69
            Efficiently insert elements into
            a map70
            How to do it…
            How it works…71
            73Table of Contents vii
            Efficiently modify the keys of
            map items75
            How to do it…
            How it works…
            There's more…75
            78
            78
            Use unordered_map with
            custom keys79
            How to do it…
            How it works…79
            81
            Use set to sort and filter
            user input82
            How to do it…
            How it works…82
            83
            A simple RPN calculator
            with deque84
            How to do it…
            How it works…
            There's more…86
            90
            91
            A word frequency counter with
            map92
            How to do it…
            How it works…92
            96
            Find long sentences with a
            vector of vectors97
            How to do it…
            How it works…97
            100
            A ToDo list using multimap101
            How to do it…
            How it works…101
            103
            How to do it…
            How it works…118
            121
            4
            Compatible Iterators
            Iterators are fundamental105
            Iterator categories
            Iterator concepts108
            108
            Technical requirements
            Create an iterable range111
            112
            How to do it…
            How it works…
            There's more…112
            114
            115
            Create a generator as iterators 122
            How to do it…
            How it works…
            There's more…123
            125
            126
            Use reverse iterator adapters
            to iterate backward127
            Make your iterators compatible
            with STL iterator traits
            115How to do it…
            How it works…127
            129
            How to do it…
            How it works…
            There's more…Iterate objects of unknown
            length with a sentinel130
            How to do it…
            How it works…131
            133
            Build a zip iterator adapter133
            116
            117
            117
            Use iterator adapters to fill STL
            containers118viii Table of Contents
            How to do it…
            How it works…
            There's more…
            134
            138
            140Create a random-access iterator140
            147Concatenate lambdas with
            recursion162
            How to do it…
            How it works…
            141
            146
            5
            Lambda Expressions
            Lambda expressions
            Closures148
            Technical requirements
            Use lambdas for scoped
            reusable code149How to do it…
            How it works…
            150How to do it…
            How it works…150
            153Combine predicates with logical
            conjunction164
            Use lambdas as predicates with
            the algorithm library
            155
            How to do it…
            How it works…155
            157
            Use std::function as a
            polymorphic wrapper158
            How to do it…
            How it works…
            There's more…158
            160
            161
            How to do it…
            How it works…
            162
            163
            164
            165
            Call multiple lambdas with the
            same input
            166
            How to do it…
            How it works…166
            167
            Use mapped lambdas for a
            jump table168
            How to do it…
            How it works…168
            169
            How it works…
            There's more…179
            180
            Sort containers with std::sort180
            How to do it…
            How it works…181
            184
            6
            STL Algorithms
            Technical requirements
            172
            Copy from one iterator to
            another172
            How to do it…
            How it works…
            173
            175
            Join container elements into a
            string176
            How to do it…
            177
            Modify containers with
            std::transform185
            How to do it…
            185Table of Contents ix
            How it works…187
            Find items in a container188
            How to do it…
            How it works…
            There's more…188
            190
            191
            Limit the values of a container
            to a range with std::clamp
            191
            How to do it…
            How it works…
            191
            193
            Sample data sets with
            std::sample194
            How to do it…
            How it works…194
            197
            Generate permutations of data
            sequences
            197
            How to do it…
            How it works…198
            199
            Merge sorted containers200
            How to do it…
            How it works…200
            202
            7
            Strings, Streams, and Formatting
            String formatting
            204
            Technical requirements
            205
            Use string_view as a lightweight
            string object
            205
            How to do it…
            How it works…205
            207
            Concatenate strings209
            How to do it…
            209
            How it works…
            211
            There's more…
            211
            Why would I choose one over another? 215
            Transform strings215
            How to do it…
            How it works…216
            218
            Format text with C++20's
            format library218
            How to do it…
            How it works…219
            223
            There's more…224
            Trim whitespace from strings225
            How to do it…
            How it works…225
            226
            Read strings from user input227
            How to do it…
            How it works…228
            231
            Count words in a file231
            How to do it…
            How it works…231
            232
            Initialize complex structures
            from file input232
            How to do it…
            How it works…
            There's more…233
            235
            235
            Customize a string class with
            char_traits237
            How to do it…
            237x Table of Contents
            How it works…
            There's more…
            240
            240
            Parse strings with Regular
            Expressions241
            How to do it…
            How it works…
            242
            243
            8
            Utility Classes
            Technical requirements
            246
            Manage optional values with
            std::optional246
            How to do it…
            How it works…
            There's more…247
            249
            249
            Use std::any for type safety250
            How to do it…
            How it works…251
            252
            Store different types with
            std::variant253
            Differences from the primitive union
            structure253
            How to do it…
            254
            How it works…
            258
            Time events with std::chrono259
            How to do it…
            How it works…259
            264
            Use fold expressions for
            variadic tuples265
            Fold expressions
            How to do it…
            How it works…
            There's more…265
            267
            268
            269
            Manage allocated memory with
            std::unique_ptr270
            How to do it…
            How it works…
            271
            274
            Share objects with std::shared_
            ptr275
            How to do it…
            How it works…
            276
            279
            Use weak pointers with shared
            objects280
            How to do it…
            How it works…
            There's more…
            280
            282
            283
            Share members of a managed
            object284
            How to do it…
            How it works…
            284
            286
            Compare random number
            engines287
            How to do it…
            How it works…
            There's more…287
            291
            291
            Compare random number
            distribution generators292
            How to do it…
            How it works…292
            295Table of Contents xi
            9
            Concurrency and Parallelism
            Technical requirements
            Sleep for a specific amount of
            time298
            How to do it…
            How it works…
            There's more…298
            299
            300
            298
            Use std::thread for concurrency300
            How to do it…
            How it works…
            There's more…
            300
            304
            305
            Use std::async for concurrency 306
            How it works…
            There's more…
            323
            323
            Share flags and values with
            std::atomic324
            How to do it…
            How it works…
            There's more…
            324
            326
            330
            Initialize threads with std::call_
            once331
            How to do it…
            How it works…
            331
            332
            How to do it…
            How it works…306
            310Run STL algorithms in parallel
            with execution policiesUse std::condition_variable to
            resolve the producer-consumer
            problem333
            312How to do it…
            How it works…312
            314How to do it…
            How it works…
            Share data safely with mutex
            and locks315How to do it…315
            333
            335
            Implement multiple producers
            and consumers
            337
            How to do it…
            How it works…337
            340
            How to do it…
            How it works…347
            350
            List files in a directory351
            How to do it…
            How it works…
            There's more…351
            360
            360
            10
            Using the File System
            Technical requirements
            344
            Specialize std::formatter for the
            path class
            344
            How to do it…
            How it works…344
            346
            Use manipulation functions
            with path347xii Table of Contents
            Search directories and files with
            a grep utility
            361
            How to do it…
            How it works…
            See also…
            362
            368
            368
            Rename files with regex and
            directory_iterator368
            How to do it…
            How it works…
            See also…368
            372
            373
            Create a disk usage counter373
            How to do it…
            How it works…373
            378
            Leverage existing algorithms:
            gather395
            How to do it…
            How it works…396
            399
            Remove consecutive
            whitespace399
            How to do it…
            How it works…399
            400
            Convert numbers to words401
            How to do it…
            How it works…
            There's more…402
            410
            410
            11
            A Few More Ideas
            Technical requirement
            379
            Create a trie class for search
            suggestions380
            How to do it…
            How it works…
            380
            387
            Calculate the error sum of two
            vectors388
            How to do it…
            How it works…
            There's more…
            388
            390
            390
            Build your own algorithm: split 391
            How to do it…
            How it works…
            392
            395
            Index
            Other Books You May Enjoy
  ~/Empire/Doks/Comp/lang/clangs/cpp/cpp-21days.de.pdf
  ~/Empire/Doks/Comp/lang/clangs/cpp/cpp-21days.de.txt
~/Empire/Doks/Comp/lang/clangs/cpp/cppdir2.txt
~/Empire/Doks/Comp/lang/clangs/cpp/cppdir2def.txt
            Innehåll

            Förord 1

            1 Att komma igång 5

            1.1 Vad är C++? 5
            1.2 Igompilering, länkning och exekvering 6
            1.3 Ovningsuppgifter 16

            2 Grunderna 17

            2.1 Variabler och läsning/skrivning 17
            2.2 Aritmetiska uttryck 25

            2.3 if-satsen 29
            2.4 Jämförelseoperatorer och logiska operatorer 32

            2.5 while-satsen 35
            2.6 for-satsen 43
            2.7 Fält 45

            2.9 Den förenklade for-satsen 58

            2.10 Fel i program 60
            2.11 Övningsuppgifter 62

            3 Tecken och texter 67
            3.1 Teckenkoder och teckenliteraler 67

            3.2 Enstaka tecken, läsning och skrivning 71
            3.3 Standardklassen string 75

            3.4 Teckenfält 89
            3.5 Kodning av texter 98

            3.6 Övningsuppgifter 101

            4 Funktioner 103

            4.1 Funktioner som returnerar ett värde 103

            4.2 Funktioner som inte returnerar något värde 114
            44.3 Deklarationsområde och synlighet 117

            4.4 Funktionsdeklarationer 120

            4.5 Uppdelning av program 122

             

             

              
             

            Innehåll

            4.6 Referensparametrar 126

            4.7 Parametrar med detaultvärden 134
            4.8 Rekursiva funktioner 135

            4.9 Alternativ syntax för funktioner 138
            4.10 Övningsuppgifter 139

            5 Typer 143

            6

            . ii

            5.1 Heltalstyper 144

            5.1.1 Lagring av heltal i en dator 144

            5.1.2 De fördefinierade heltalstypema 146
            5.2 Flyttalstyper 150

            5.2.1 Lagring av reella tal i en dator 150

            5.2.2 De fördefinierade flyttalstypema 151

            5.3 sizeof - operatorn 152
            5.4 Pekare 153

            5.4.1 Primärminnesadresser 153
            5.4.2 Pekarvariabler 154
            5.4.3 Pekare och fält 157
            5.4.4 Pekare och textsträngar 162
            5.4.5 Minnesallokering 166
            5.4.6 Vanliga misstag 170
            5.4.7 Pekare till funktioner 171
            5.5 Referenser 174
            5.5.1 Referenser till variabler 175
            5.5.2 Referenser till temporära uttryck 176

            5.6 Komplicerade deklarationer - typedef 177
            5.7 Typen void 179
            5.8 Typomvandlingar 180
            5.8.1 Automatiska typomvandlingar 180
            5.8.2 Explicita typomvandlingar 181
            5.9 Uppräkningstyper 183
            5.10 Tabeller 188
            5.101 Flerdimensi - onella fält 188
            5.102 Tabeller med hjälp av vektorer 191
            5.11 Par och tupler 193

            5.12 Övningsuppgifter 196 .

             

            Objektorienterad programutve ;

            6.1 Grundläggande begrepp 201 " '
            6.2 Objektorienterad analys 204

            6 3 Objektorienterad design 209

            6.4 Objektorienterad programmering 210

            6.5 Algoritmer 212 ,

            ':. i * " lvg-*** . 'i' ?p'? .. '.' .;

            år." ». _;E

            4. '.
            _q, .

            - 0
            Ö. 11'3 '. I . .
            . " an..-'t"? "'; ':' " W i;! _ 4
            "Hå-_ m.;ilhniåq gi
            ' 'L ' 4' T' '! '.. _. .

             

            _ I
            ! _q._,

             

            Innehc

            6.6 Övningsuppgifter 216

            7 Klasser 217
            7.1 Klassdefinitioner 217

            i 7.2 Placering av klasser 224
            , 7.3 Konstruktorer 229

            |

            |

            7.3.1 Deklarationer av konstruktorer 230
            7.3.2 Definitioner av konstruktorer 231
            7.3.3 Anrop av konstruktorer 233

            1
            7.3.4 Kopieringskonstruktorer 235
            ! 7.3.5 Move-konstruktorer 241
            7.3.6 Konstruktorer med initieringslista som parameter 244
            7.3.7 Typomvandlingskonstruktorer 245
            7.4 Destruktorer 247
            7.5 Ett objektorienterat exempel 249
            7.6 Övningsuppgifter 257

            8 Mer om klasser 261

            8.1 Konstanta obj ekt 261
            8.2 Pekaren this 263
            " 8.3 Vänner 265
            8.4 Operatorer 268
            8.4.1 Binära operatorer 269
            8.4.2 Fördefmierade jämförelseoperatorer 275

            8.4.3 Unära operatorer 276

            8.4.4 Tilldelningsoperatorn 278
            8.4.5 Tilldelningsoperatom, move-version 280

            1

            8.4.6 Indexeringsoperatom 281

            8.4.7 Funktionsanropsoperatorn 282
            8.4.8 Vänfunktioner som operatorer 284
            8.4.9 Operatorer med tillfälliga uttryck som parametrar 286
            8.4. 10 Typomvandlingsoperatorer 288

            8.5 Automatiskt genererade specialfunktioner 289
            i

            8.6 Statiska medlemmar 291
            8.7 Pekare till medlemmar 295

            8.8 Övningsuppgifter 298

            9 Arv 301
            9.1 Härledda klasser 301

             

               

            Innehåll

            9.5 Återanvändning. ett exempel 318
            9.6 Polymortism och dynamisk bindning 333
            9.7 Förbättrad kontroll vid dynamisk bindning 341

            i 9.8 Operatorema typeid och dynamic__cast 343

            w- _! _a r.!" uv"
            _ _ '.

            9.9 Virtuella destruktorer 346
            9.10 Abstrakta klasser 348

            9.11 Virtuella operatorer 352
            9.12 Multipelt arv 355

            9.13 Övningsuppgifter 359

            10 Exceptionella händelser 361

            10.1 Att generera exceptionella händelser 362

            10.2 Att fånga exceptionella händelser 365

            10.3 Definition av egna exception-klasser, ett exempel 375
            10.4 Specifikation av exceptionella händelser 379

            10.5 Övningsuppgifter 381

            11 Strömmar och filer 383

            11.1 Klassen ios 384

            11.2 Läsning av strömmar 389
            11.2.1 Formaterad inmatning 389
            11.2.2 Oformaterad inmatning 392
            11.3 Utskrift till strömmar 393
            12 11.3.1 Forrnaterad utmatning 394
            " 11.3.2 Oformaterad utmatning 397
            11.4 KOppling av filer till strömmar 398

            11.5 Kodning av textfiler 407
            11.6 Filnamn som argument till main 410

            11.7 Direktaccess 414
            118 Lagring av heterogena objekt i filer 421

            11.9 Koppling av string-objekt till strömmar 429
            1110 Övningsuppgifter 432

            12 Containerklasser och algoritmbibliotek 437

            12.1 Iteratorer 438 :
            12.1.1 Att löpa igenom datasamlingar med ite-_ 439
            12.1 .2 Operationer med iteratorer som . .- =; etrar 444 '
            12.1 .3 Iteratorer och strömmar 446
            12.2 Algoritmer ---- allmänna egenskaper 447 _ * ' - :

             

            12.3 Funktionsobjekt 450 +» .. . . .
            12.3.1 Användning av pekare till funktioner 451 _ - ,.
            12.3.2 Användning av riktiga funktionsobjekt 454 ' ' - 7 " lå .;
            W 0 Swdentl

             

             

            _ * 1
            ' . , .

             

            Innehåll

            12.3.3 Användning av fördefinierade funktionsobjekt 458
            12.3.4 Lambda - uttryck 462

            12.4 Standardklassen list 465
            12.5 Avbildningar och mängder 468

            12.5. 1 Standardklassema map och multimap 470
            12.5.2 Standardklasserna set och multiset 478

            12.5.3 Standardklasser för oordnade associativa containers 484
            12.6 Köer och stackar 488

            12.7 Övningsuppgifter 493

            13 Dynamiska datastrukturer 495

            13.1 Länkade listor -- grunderna 495
            13.1.1 Enkellänkade listor 495
            13.1 .2 Dubbellänkade listor 502
            13.2 Länkade listor -- tillämpningar 506
            13.2.1 Stackar 506
            13.2.2 Köer 509
            13.2.3 Mängder 512
            13.3 Iteratorer - implementering 518

            13.4 Träd 523
            13.4.1 Binära träd 524

            13.4.2 Binära sökträd 529
            13.4.3 En trädklass 531

            13.5 Övningsuppgifter 536

            14 Mallar 539

            14.1 Klassmallar 540
            14.1.1 Mallar och instanser 540

            14.1.2 Statiska medlemmar 545
            14.1.3 Vänner och hj älpklasser 547
            14.1.4 Mallparametrar 548

            14.1.5 Egenskapsklasser 550
            14.1.6 Generiska standardklasser 555

            14.2 Funktionsmallar 562
            14.2.1 Dehnitioner och instanser 562

            14.2.2 Generiska standardfunktioner -- Algoritmbiblioteket 566
            14.3 Heterogena objektsamlingar 571

            14.3.1 Den klassiska tekniken 572

            14.. 3. 2 Kombmatlon av arv och mallar 574

             

            Imwhä/l

            15 De sista pusselbitarna 587
            15.1 Namnrymder 587
            15.1 .1 Definition av namnrymder 588

            15.1 .2 Användning av namnrymder 590
            15.1.3 Namnrymder och standardbibliotek 593
            15.2 Bit-operatorer 594
            15.3 struct 595
            15.4 union 597
            15.5 Bit-fält 601
            15.6 do-satsen 603
            15.7 switch - satsen 604
            15.8 Villkorsopemtom 606
            15.9 Konstanta umyck -- conatoxpr 607
            15. 10 Övningsuppgifter 609

            Appendix A Reserverade ord och operatorer 611

            Appendix B LATIN__1 koder 613

            Appendix C Standardalgoritmer 615
            C.] Söka 616
            C.2 Jämföra, löpa igenom, räkna 621
            C.3 Kopiera och flytta element 622
            C.4 Ändra och ta bort element 626
            C.5 Genemm nya data 630
            C.6 Sur-tm 632
            C. 7 Operationerpå ::..! ; t-- - .te-:,:: _ -- ; .
            C. 8 metioner på mangder 638
            C. 9 Numeriska algoritmer 639
            C.10 Heap - algoritmer 641

             

            Sakregister 645
~/Empire/Doks/Comp/lang/clangs/cpp/cpp-in-21-days_tutorial.pdf
            Introduction
            Week 1 at a Glance
            Day 1 Getting Started
            Day 2 The Parts of a C++ Program
            Day 3 Variables and Constants
            Day 4 Expressions and Statements
            Day 5 Functions
            Day 6 Basic Classes
            Day 7 More Program Flow
            Week 1 in Review
            Week 2 at a Glance
            Day 8 Pointers
            Day 9 References
            Day 10 Advanced Functions
            http://hellnet.perverz.hu/ebookz/C++%20in%2021%20days/ (1 of 3)02.03.2005 08:59:13C++ Tutorial
            Day 11 Arrays
            Day 12 Inheritance
            Day 13 Polymorphism
            Day 14 Special Classes and Functions
            Week 2 in Review
            Week 3 at a Glance
            Day 15 Advanced Inheritance
            Day 16 Streams
            Day 17 The Preprocessor
            Day 18 Object-Oriented Analysis and Design
            Day 19 Templates
            Day 20 Exceptions and Error Handling
            Day 21 Whats Next
            Week 3 in Review
            Appendixes
            A Operator Precedence
            B C++ Keywords
            C Binary and Hexadecimal
            http://hellnet.perverz.hu/ebookz/C++%20in%2021%20days/ (2 of 3)02.03.2005 08:59:13C++ Tutorial
            D Answers
            Index
~/Empire/Doks/Comp/lang/clangs/cpp/cppmod-alexandr_2001.pdf
~/Empire/Doks/Comp/lang/clangs/cpp/cpp-moddespatts_2019.pdf  ___hm_eng
            Table of Contents
            Preface1
            Chapter 1: An Introduction to Inheritance and Polymorphism
            Classes and objects
            Inheritance and class hierarchies
            Polymorphism and virtual functions
            Multiple inheritance
            Summary
            Questions
            Further reading
            Chapter 2: Class and Function Templates
            Templates in C++7
            7
            10
            14
            19
            20
            21
            21
            Function templates
            Class templates
            Variable template
            Non-type template parameters
            Template instantiations
            Function templates
            Class templates
            Template specializations
            Explicit specialization
            Partial specialization
            Template function overloading
            Variadic templates
            Lambda expressions
            Summary
            Questions
            Further reading
            Chapter 3: Memory Ownership
            Technical requirements
            What is memory ownership?
            Well-designed memory ownership
            Poorly designed memory ownership
            Expressing memory ownership in C++
            Expressing non-ownership
            Expressing exclusive ownership
            Expressing transfer of exclusive ownership
            Expressing shared ownership
            22
            23
            23
            24
            24
            25
            26
            26
            30
            32
            32
            34
            37
            40
            44
            48
            49
            49
            50
            50
            51
            51
            52
            54
            54
            55
            57
            58Table of Contents
            Summary
            Questions
            Further reading
            Chapter 4: Swap - From Simple to Subtle
            Technical requirements
            Swap and the standard template library
            Swap and STL containers
            Non-member swap
            Swapping like the standard
            When and why to use swap
            Swap and exception safety
            Other common swap idioms
            How to implement and use swap correctly
            Implementing swap
            Using swap correctly
            Summary
            Questions
            Chapter 5: A Comprehensive Look at RAII
            Technical requirements
            Resource management in C++
            Installing the microbenchmark library
            Installing Google Test
            Counting resources
            Dangers of manual resource management
            Manual resource management is error-prone
            Resource management and exception safety
            The RAII idiom
            RAII in a nutshell
            RAII for other resources
            Releasing early
            Careful implementation of Resource Acquisition is Initialization objects
            Downsides of RAII
            Summary
            Questions
            Further reading
            Chapter 6: Understanding Type Erasure
            Technical requirements
            What is type erasure?
            Type erasure by example
            How is type erasure implemented in C++?
            Very old type erasure
            Object-oriented type erasure
            [ ii ]
            60
            60
            61
            62
            62
            63
            63
            66
            67
            67
            67
            69
            71
            71
            75
            76
            77
            78
            79
            79
            80
            80
            81
            82
            82
            85
            87
            87
            91
            93
            96
            99
            101
            101
            101
            102
            102
            102
            103
            107
            107
            108Table of Contents
            The opposite of the type erasure
            Type erasure in C++
            When to use type erasure, and when to avoid it
            Type erasure and software design
            Installing the micro-benchmark library
            The overhead of type erasure
            Summary
            Questions
            Chapter 7: SFINAE and Overload Resolution Management
            Technical requirements
            Overload resolution and overload sets
            C++ function overloading
            Template functions
            Type substitution in template functions
            Type deduction and substitution
            Substitution failure
            Substitution Failure Is Not An Error
            Taking control of overload resolution
            Basic SFINAE
            Advanced SFINAE
            Advanced SFINAE revisited
            The ultimate SFINAE
            Summary
            Questions
            Further reading
            Chapter 8: The Curiously Recurring Template Pattern
            Technical requirements
            Wrapping your head around CRTP
            What is wrong with a virtual function?
            Introducing CRTP
            CRTP and static polymorphism
            Compile-time polymorphism
            The compile-time pure virtual function
            Destructors and polymorphic deletion
            CRTP and access control
            CRTP as a delegation pattern
            Expanding the interface
            Summary
            Questions
            Chapter 9: Named Arguments and Method Chaining
            Technical requirements
            The problem with arguments
            [ iii ]
            111
            112
            114
            115
            116
            117
            119
            120
            121
            121
            122
            122
            126
            129
            129
            131
            133
            135
            136
            139
            149
            154
            160
            161
            161
            162
            163
            163
            163
            166
            170
            170
            171
            173
            175
            177
            177
            183
            183
            184
            184
            185Table of Contents
            What's wrong with many arguments
            Aggregate parameters
            Named arguments in C++
            Method chaining
            Method chaining and named arguments
            Performance of the named arguments idiom
            General method chaining
            Method chaining versus method cascading
            General method chaining
            Method chaining in class hierarchies
            Summary
            Questions
            Chapter 10: Local Buffer Optimization
            Technical requirements
            The overhead of small memory allocations
            The cost of memory allocations
            Introducing local buffer optimization
            The main idea
            Effect of local buffer optimization
            Additional optimizations
            Local buffer optimization beyond strings
            Small vector
            Type-erased and callable objects
            Local buffer optimization in the C++ library
            Downsides of local buffer optimization
            Summary
            Questions
            Further reading
            Chapter 11: ScopeGuard
            Technical requirements
            Error handling and Resource Acquisition Is Initialization
            Error safety and exception safety
            Resource Acquisition Is Initialization
            The ScopeGuard pattern
            ScopeGuard basics
            Generic ScopeGuard
            ScopeGuard and exceptions
            What must not throw an exception
            Exception-driven ScopeGuard
            Type-erased ScopeGuard
            Summary
            Questions
            [ iv ]
            185
            189
            191
            191
            192
            195
            198
            198
            200
            200
            204
            204
            205
            205
            206
            206
            209
            210
            212
            215
            215
            216
            218
            222
            222
            223
            224
            224
            225
            225
            226
            226
            230
            233
            233
            239
            245
            245
            247
            252
            255
            256Table of Contents
            Chapter 12: Friend Factory
            Technical requirements
            Friends in C++
            How to grant friendship in C++
            Friends versus member functions
            Friends and templates
            Friends of template classes
            The template friend factory
            Generating friends on demand
            The friend factory and the Curiously Recurring Template Pattern
            Summary
            Questions
            Chapter 13: Virtual Constructors and Factories
            Technical requirements
            Why constructors cannot be virtual
            When does an object get its type?
            The Factory pattern
            The basics of the Factory method
            Arguments for factory methods
            Dynamic type registry
            Polymorphic factory
            Factory-like patterns in C++
            Polymorphic copy
            CRTP Factory and return types
            CRTP Factory with less copy-paste
            Summary
            Questions
            Chapter 14: The Template Method Pattern and the Non-Virtual Idiom
            Technical requirements
            The Template Method pattern
            The Template Method in C++
            Applications of the Template Method
            Pre-and post-conditions and actions
            The Non-Virtual Interface
            Virtual functions and access
            The NVI idiom in C++
            A note about destructors
            Drawbacks of the Non-Virtual Interface
            Composability
            The Fragile Base Class problem
            Summary
            Questions
            Further reading
            [v]
            257
            257
            257
            258
            258
            263
            263
            266
            266
            268
            271
            271
            272
            272
            273
            273
            276
            276
            278
            279
            282
            284
            284
            285
            287
            289
            289
            290
            290
            291
            291
            292
            295
            296
            296
            297
            299
            301
            301
            302
            304
            304
            304Table of Contents
            Chapter 15: Singleton - A Classic OOP Pattern
            Technical requirements
            The singleton pattern – what is it and what is it for?
            What is a singleton?
            When to use the singleton
            Types of singletons
            Static singleton
            Meyers' Singleton
            Leaky singletons
            Summary
            Questions
            Chapter 16: Policy-Based Design
            Technical requirements
            Strategy pattern and policy-based design
            Foundations of policy-based design
            Implementation of policies
            Use of policy objects
            Advanced policy-based design
            Policies for constructors
            Policies for test
            Policy adapters and aliases
            Using policies to control the public interface
            Rebinding policies
            Recommendations and guidelines
            Strengths of the policy-based design
            Disadvantages of policy-based design
            Guidelines for policy-based designs
            Almost policy-based approach
            Summary
            Questions
            Chapter 17: Adapters and Decorators
            Technical requirements
            The decorator pattern
            Basic decorator pattern
            Decorators the C++ way
            Polymorphic decorators and their limitations
            Composable decorators
            The Adapter pattern
            Basic Adapter pattern
            Function adapters
            Compile-time adapters
            Adapter versus policy
            Summary
            [ vi ]
            305
            305
            306
            306
            308
            310
            312
            315
            322
            325
            326
            327
            327
            328
            328
            335
            339
            346
            346
            355
            356
            359
            365
            367
            368
            369
            370
            373
            380
            381
            382
            382
            383
            383
            387
            392
            394
            396
            397
            400
            403
            407
            411Table of Contents
            Questions
            Chapter 18: The Visitor Pattern and Multiple Dispatch
            Technical requirements
            The Visitor pattern
            What is the Visitor pattern?
            Basic Visitor in C++
            Visitor generalizations and limitations
            Visiting complex objects
            Visiting composite objects
            Serialization and deserialization with Visitor
            Acyclic Visitor
            Visitors in modern C++
            Generic Visitor
            Lambda Visitor
            Generic Acyclic Visitor
            Compile-time Visitor
            Summary
            Questions
            Assessments
            412
            413
            413
            414
            414
            417
            421
            425
            425
            427
            434
            437
            437
            440
            443
            447
            454
            455
            456
            Other Books You May Enjoy479
            Index482
~/Empire/Doks/Comp/lang/clangs/cpp/cpp-prim_5e.pdf
~/Empire/Doks/Comp/lang/clangs/cpp/cpp-prim_5e.txt
            Contents
            Preface
            Chapter 1 Getting Started
            1.1 Writing a Simple C++ Program
            1.1.1 Compiling and Executing Our Program
            1.2 A First Look at Input/Output
            1.3 A Word about Comments
            1.4 Flow of Control
            1.4.1 The while Statement
            1.4.2 The for Statement
            1.4.3 Reading an Unknown Number of Inputs
            1.4.4 The if Statement
            1.5 Introducing Classes
            1.5.1 The Sales_item Class
            1.5.2 A First Look at Member Functions
            1.6 The Bookstore Program
            Chapter Summary
            Defined Terms
            Part I The Basics
            Chapter 2 Variables and Basic Types
            2.1 Primitive Built-in Types
            2.1.1 Arithmetic Types
            2.1.2 Type Conversions
            2.1.3 Literals
            2.2 Variables

            C++ Primer, Fifth Edition

            2.2.1 Variable Definitions
            2.2.2 Variable Declarations and Definitions
            2.2.3 Identifiers
            2.2.4 Scope of a Name
            2.3 Compound Types
            2.3.1 References
            2.3.2 Pointers
            2.3.3 Understanding Compound Type Declarations
            2.4 const Qualifier
            2.4.1 References to const
            2.4.2 Pointers and const
            2.4.3 Top-Level const
            2.4.4 constexpr and Constant Expressions
            2.5 Dealing with Types
            2.5.1 Type Aliases
            2.5.2 The auto Type Specifier
            2.5.3 The decltype Type Specifier
            2.6 Defining Our Own Data Structures
            2.6.1 Defining the Sales_data Type
            2.6.2 Using the Sales_data Class
            2.6.3 Writing Our Own Header Files
            Chapter Summary
            Defined Terms
            Chapter 3 Strings, Vectors, and Arrays
            3.1 Namespace using Declarations
            3.2 Library string Type
            3.2.1 Defining and Initializing strings
            3.2.2 Operations on strings
            3.2.3 Dealing with the Characters in a string
            3.3 Library vector Type
            3.3.1 Defining and Initializing vectors
            3.3.2 Adding Elements to a vector

            C++ Primer, Fifth Edition

            3.3.3 Other vector Operations
            3.4 Introducing Iterators
            3.4.1 Using Iterators
            3.4.2 Iterator Arithmetic
            3.5 Arrays
            3.5.1 Defining and Initializing Built-in Arrays
            3.5.2 Accessing the Elements of an Array
            3.5.3 Pointers and Arrays
            3.5.4 C-Style Character Strings
            3.5.5 Interfacing to Older Code
            3.6 Multidimensional Arrays
            Chapter Summary
            Defined Terms
            Chapter 4 Expressions
            4.1 Fundamentals
            4.1.1 Basic Concepts
            4.1.2 Precedence and Associativity
            4.1.3 Order of Evaluation
            4.2 Arithmetic Operators
            4.3 Logical and Relational Operators
            4.4 Assignment Operators
            4.5 Increment and Decrement Operators
            4.6 The Member Access Operators
            4.7 The Conditional Operator
            4.8 The Bitwise Operators
            4.9 The sizeof Operator
            4.10 Comma Operator
            4.11 Type Conversions
            4.11.1 The Arithmetic Conversions
            4.11.2 Other Implicit Conversions
            4.11.3 Explicit Conversions
            4.12 Operator Precedence Table

            C++ Primer, Fifth Edition

            Chapter Summary
            Defined Terms
            Chapter 5 Statements
            5.1 Simple Statements
            5.2 Statement Scope
            5.3 Conditional Statements
            5.3.1 The if Statement
            5.3.2 The switch Statement
            5.4 Iterative Statements
            5.4.1 The while Statement
            5.4.2 Traditional for Statement
            5.4.3 Range for Statement
            5.4.4 The do while Statement
            5.5 Jump Statements
            5.5.1 The break Statement
            5.5.2 The continue Statement
            5.5.3 The goto Statement
            5.6 try Blocks and Exception Handling
            5.6.1 A throw Expression
            5.6.2 The try Block
            5.6.3 Standard Exceptions
            Chapter Summary
            Defined Terms
            Chapter 6 Functions
            6.1 Function Basics
            6.1.1 Local Objects
            6.1.2 Function Declarations
            6.1.3 Separate Compilation
            6.2 Argument Passing
            6.2.1 Passing Arguments by Value
            6.2.2 Passing Arguments by Reference

            C++ Primer, Fifth Edition

            6.2.3 const Parameters and Arguments
            6.2.4 Array Parameters
            6.2.5 main: Handling Command-Line Options
            6.2.6 Functions with Varying Parameters
            6.3 Return Types and the return Statement
            6.3.1 Functions with No Return Value
            6.3.2 Functions That Return a Value
            6.3.3 Returning a Pointer to an Array
            6.4 Overloaded Functions
            6.4.1 Overloading and Scope
            6.5 Features for Specialized Uses
            6.5.1 Default Arguments
            6.5.2 Inline and constexpr Functions
            6.5.3 Aids for Debugging
            6.6 Function Matching
            6.6.1 Argument Type Conversions
            6.7 Pointers to Functions
            Chapter Summary
            Defined Terms
            Chapter 7 Classes
            7.1 Defining Abstract Data Types
            7.1.1 Designing the Sales_data Class
            7.1.2 Defining the Revised Sales_data Class
            7.1.3 Defining Nonmember Class-Related Functions
            7.1.4 Constructors
            7.1.5 Copy, Assignment, and Destruction
            7.2 Access Control and Encapsulation
            7.2.1 Friends
            7.3 Additional Class Features
            7.3.1 Class Members Revisited
            7.3.2 Functions That Return *this
            7.3.3 Class Types

            C++ Primer, Fifth Edition

            7.3.4 Friendship Revisited
            7.4 Class Scope
            7.4.1 Name Lookup and Class Scope
            7.5 Constructors Revisited
            7.5.1 Constructor Initializer List
            7.5.2 Delegating Constructors
            7.5.3 The Role of the Default Constructor
            7.5.4 Implicit Class-Type Conversions
            7.5.5 Aggregate Classes
            7.5.6 Literal Classes
            7.6 static Class Members
            Chapter Summary
            Defined Terms
            Part II The C++ Library
            Chapter 8 The IO Library
            8.1 The IO Classes
            8.1.1 No Copy or Assign for IO Objects
            8.1.2 Condition States
            8.1.3 Managing the Output Buffer
            8.2 File Input and Output
            8.2.1 Using File Stream Objects
            8.2.2 File Modes
            8.3 string Streams
            8.3.1 Using an istringstream
            8.3.2 Using ostringstreams
            Chapter Summary
            Defined Terms
            Chapter 9 Sequential Containers
            9.1 Overview of the Sequential Containers
            9.2 Container Library Overview
            9.2.1 Iterators

            C++ Primer, Fifth Edition

            9.2.2 Container Type Members
            9.2.3 begin and end Members
            9.2.4 Defining and Initializing a Container
            9.2.5 Assignment and swap
            9.2.6 Container Size Operations
            9.2.7 Relational Operators
            9.3 Sequential Container Operations
            9.3.1 Adding Elements to a Sequential Container
            9.3.2 Accessing Elements
            9.3.3 Erasing Elements
            9.3.4 Specialized forward_list Operations
            9.3.5 Resizing a Container
            9.3.6 Container Operations May Invalidate Iterators
            9.4 How a vector Grows
            9.5 Additional string Operations
            9.5.1 Other Ways to Construct strings
            9.5.2 Other Ways to Change a string
            9.5.3 string Search Operations
            9.5.4 The compare Functions
            9.5.5 Numeric Conversions
            9.6 Container Adaptors
            Chapter Summary
            Defined Terms
            Chapter 10 Generic Algorithms
            10.1 Overview
            10.2 A First Look at the Algorithms
            10.2.1 Read-Only Algorithms
            10.2.2 Algorithms That Write Container Elements
            10.2.3 Algorithms That Reorder Container Elements
            10.3 Customizing Operations
            10.3.1 Passing a Function to an Algorithm
            10.3.2 Lambda Expressions

            C++ Primer, Fifth Edition

            10.3.3 Lambda Captures and Returns
            10.3.4 Binding Arguments
            10.4 Revisiting Iterators
            10.4.1 Insert Iterators
            10.4.2 iostream Iterators
            10.4.3 Reverse Iterators
            10.5 Structure of Generic Algorithms
            10.5.1 The Five Iterator Categories
            10.5.2 Algorithm Parameter Patterns
            10.5.3 Algorithm Naming Conventions
            10.6 Container-Specific Algorithms
            Chapter Summary
            Defined Terms
            Chapter 11 Associative Containers
            11.1 Using an Associative Container
            11.2 Overview of the Associative Containers
            11.2.1 Defining an Associative Container
            11.2.2 Requirements on Key Type
            11.2.3 The pair Type
            11.3 Operations on Associative Containers
            11.3.1 Associative Container Iterators
            11.3.2 Adding Elements
            11.3.3 Erasing Elements
            11.3.4 Subscripting a map
            11.3.5 Accessing Elements
            11.3.6 A Word Transformation Map
            11.4 The Unordered Containers
            Chapter Summary
            Defined Terms
            Chapter 12 Dynamic Memory
            12.1 Dynamic Memory and Smart Pointers

            C++ Primer, Fifth Edition

            12.1.1 The shared_ptr Class
            12.1.2 Managing Memory Directly
            12.1.3 Using shared_ptrs with new
            12.1.4 Smart Pointers and Exceptions
            12.1.5 unique_ptr
            12.1.6 weak_ptr
            12.2 Dynamic Arrays
            12.2.1 new and Arrays
            12.2.2 The allocator Class
            12.3 Using the Library: A Text-Query Program
            12.3.1 Design of the Query Program
            12.3.2 Defining the Query Program Classes
            Chapter Summary
            Defined Terms
            Part III Tools for Class Authors
            Chapter 13 Copy Control
            13.1 Copy, Assign, and Destroy
            13.1.1 The Copy Constructor
            13.1.2 The Copy-Assignment Operator
            13.1.3 The Destructor
            13.1.4 The Rule of Three/Five
            13.1.5 Using = default
            13.1.6 Preventing Copies
            13.2 Copy Control and Resource Management
            13.2.1 Classes That Act Like Values
            13.2.2 Defining Classes That Act Like Pointers
            13.3 Swap
            13.4 A Copy-Control Example
            13.5 Classes That Manage Dynamic Memory
            13.6 Moving Objects
            13.6.1 Rvalue References
            13.6.2 Move Constructor and Move Assignment

            C++ Primer, Fifth Edition

            13.6.3 Rvalue References and Member Functions
            Chapter Summary
            Defined Terms
            Chapter 14 Overloaded Operations and Conversions
            14.1 Basic Concepts
            14.2 Input and Output Operators
            14.2.1 Overloading the Output Operator <<
            14.2.2 Overloading the Input Operator >>
            14.3 Arithmetic and Relational Operators
            14.3.1 Equality Operators
            14.3.2 Relational Operators
            14.4 Assignment Operators
            14.5 Subscript Operator
            14.6 Increment and Decrement Operators
            14.7 Member Access Operators
            14.8 Function-Call Operator
            14.8.1 Lambdas Are Function Objects
            14.8.2 Library-Defined Function Objects
            14.8.3 Callable Objects and function
            14.9 Overloading, Conversions, and Operators
            14.9.1 Conversion Operators
            14.9.2 Avoiding Ambiguous Conversions
            14.9.3 Function Matching and Overloaded Operators
            Chapter Summary
            Defined Terms
            Chapter 15 Object-Oriented Programming
            15.1 OOP: An Overview
            15.2 Defining Base and Derived Classes
            15.2.1 Defining a Base Class
            15.2.2 Defining a Derived Class
            15.2.3 Conversions and Inheritance

            C++ Primer, Fifth Edition

            15.3 Virtual Functions
            15.4 Abstract Base Classes
            15.5 Access Control and Inheritance
            15.6 Class Scope under Inheritance
            15.7 Constructors and Copy Control
            15.7.1 Virtual Destructors
            15.7.2 Synthesized Copy Control and Inheritance
            15.7.3 Derived-Class Copy-Control Members
            15.7.4 Inherited Constructors
            15.8 Containers and Inheritance
            15.8.1 Writing a Basket Class
            15.9 Text Queries Revisited
            15.9.1 An Object-Oriented Solution
            15.9.2 The Query_base and Query Classes
            15.9.3 The Derived Classes
            15.9.4 The eval Functions
            Chapter Summary
            Defined Terms
            Chapter 16 Templates and Generic Programming
            16.1 Defining a Template
            16.1.1 Function Templates
            16.1.2 Class Templates
            16.1.3 Template Parameters
            16.1.4 Member Templates
            16.1.5 Controlling Instantiations
            16.1.6 Efficiency and Flexibility
            16.2 Template Argument Deduction
            16.2.1 Conversions and Template Type Parameters
            16.2.2 Function-Template Explicit Arguments
            16.2.3 Trailing Return Types and Type Transformation
            16.2.4 Function Pointers and Argument Deduction
            16.2.5 Template Argument Deduction and References

            C++ Primer, Fifth Edition

            16.2.6 Understanding std::move
            16.2.7 Forwarding
            16.3 Overloading and Templates
            16.4 Variadic Templates
            16.4.1 Writing a Variadic Function Template
            16.4.2 Pack Expansion
            16.4.3 Forwarding Parameter Packs
            16.5 Template Specializations
            Chapter Summary
            Defined Terms
            Part IV Advanced Topics
            Chapter 17 Specialized Library Facilities
            17.1 The tuple Type
            17.1.1 Defining and Initializing tuples
            17.1.2 Using a tuple to Return Multiple Values
            17.2 The bitset Type
            17.2.1 Defining and Initializing bitsets
            17.2.2 Operations on bitsets
            17.3 Regular Expressions
            17.3.1 Using the Regular Expression Library
            17.3.2 The Match and Regex Iterator Types
            17.3.3 Using Subexpressions
            17.3.4 Using regex_replace
            17.4 Random Numbers
            17.4.1 Random-Number Engines and Distribution
            17.4.2 Other Kinds of Distributions
            17.5 The IO Library Revisited
            17.5.1 Formatted Input and Output
            17.5.2 Unformatted Input/Output Operations
            17.5.3 Random Access to a Stream
            Chapter Summary

            C++ Primer, Fifth Edition

            Defined Terms
            Chapter 18 Tools for Large Programs
            18.1 Exception Handling
            18.1.1 Throwing an Exception
            18.1.2 Catching an Exception
            18.1.3 Function try Blocks and Constructors
            18.1.4 The noexcept Exception Specification
            18.1.5 Exception Class Hierarchies
            18.2 Namespaces
            18.2.1 Namespace Definitions
            18.2.2 Using Namespace Members
            18.2.3 Classes, Namespaces, and Scope
            18.2.4 Overloading and Namespaces
            18.3 Multiple and Virtual Inheritance
            18.3.1 Multiple Inheritance
            18.3.2 Conversions and Multiple Base Classes
            18.3.3 Class Scope under Multiple Inheritance
            18.3.4 Virtual Inheritance
            18.3.5 Constructors and Virtual Inheritance
            Chapter Summary
            Defined Terms
            Chapter 19 Specialized Tools and Techniques
            19.1 Controlling Memory Allocation
            19.1.1 Overloading new and delete
            19.1.2 Placement new Expressions
            19.2 Run-Time Type Identification
            19.2.1 The dynamic_cast Operator
            19.2.2 The typeid Operator
            19.2.3 Using RTTI
            19.2.4 The type_info Class
            19.3 Enumerations
            19.4 Pointer to Class Member

            C++ Primer, Fifth Edition

            19.4.1 Pointers to Data Members
            19.4.2 Pointers to Member Functions
            19.4.3 Using Member Functions as Callable Objects
            19.5 Nested Classes
            19.6 union: A Space-Saving Class
            19.7 Local Classes
            19.8 Inherently Nonportable Features
            19.8.1 Bit-fields
            19.8.2 volatile Qualifier
            19.8.3 Linkage Directives: extern "C"
            Chapter Summary
            Defined Terms
            Appendix A The Library
            A.1 Library Names and Headers
            A.2 A Brief Tour of the Algorithms
            A.2.1 Algorithms to Find an Object
            A.2.2 Other Read-Only Algorithms
            A.2.3 Binary Search Algorithms
            A.2.4 Algorithms That Write Container Elements
            A.2.5 Partitioning and Sorting Algorithms
            A.2.6 General Reordering Operations
            A.2.7 Permutation Algorithms
            A.2.8 Set Algorithms for Sorted Sequences
            A.2.9 Minimum and Maximum Values
            A.2.10 Numeric Algorithms
            A.3 Random Numbers
            A.3.1 Random Number Distributions
            A.3.2 Random Number Engines
            Index

            New Features in C++11

            C++ Primer, Fifth Edition

            2.1.1 long long Type
            2.2.1 List Initialization
            2.3.2 nullptr Literal
            2.4.4 constexpr Variables
            2.5.1 Type Alias Declarations
            2.5.2 The auto Type Specifier
            2.5.3 The decltype Type Specifier
            2.6.1 In-Class Initializers
            3.2.2 Using auto or decltype for Type Abbreviation
            3.2.3 Range for Statement
            3.3 Defining a vector of vectors
            3.3.1 List Initialization for vectors
            3.4.1 Container cbegin and cend Functions
            3.5.3 Library begin and end Functions
            3.6 Using auto or decltype to Simplify Declarations
            4.2 Rounding Rules for Division
            4.4 Assignment from a Braced List of Values
            4.9 sizeof Applied to a Class Member
            5.4.3 Range for Statement
            6.2.6 Library initializer_list Class
            6.3.2 List Initializing a Return Value
            6.3.3 Declaring a Trailing Return Type
            6.3.3 Using decltype to Simplify Return Type Declarations
            6.5.2 constexpr Functions
            7.1.4 Using = default to Generate a Default Constructor
            7.3.1 In-class Initializers for Members of Class Type
            7.5.2 Delegating Constructors
            7.5.6 constexpr Constructors
            8.2.1 Using strings for File Names

            C++ Primer, Fifth Edition

            9.1 The array and forward_list Containers
            9.2.3 Container cbegin and cend Functions
            9.2.4 List Initialization for Containers
            9.2.5 Container Nonmember swap Functions
            9.3.1 Return Type for Container insert Members
            9.3.1 Container emplace Members
            9.4 shrink_to_fit
            9.5.5 Numeric Conversion Functions for strings
            10.3.2 Lambda Expressions
            10.3.3 Trailing Return Type in Lambda Expressions
            10.3.4 The Library bind Function
            11.2.1 List Initialization of an Associative Container
            11.2.3 List Initializing pair Return Type
            11.3.2 List Initialization of a pair
            11.4 The Unordered Containers
            12.1 Smart Pointers
            12.1.1 The shared_ptr Class
            12.1.2 List Initialization of Dynamically Allocated Objects
            12.1.2 auto and Dynamic Allocation
            12.1.5 The unique_ptr Class
            12.1.6 The weak_ptr Class
            12.2.1 Range for Doesn't Apply to Dynamically Allocated Arrays .
            12.2.1 List Initialization of Dynamically Allocated Arrays
            12.2.1 auto Can't Be Used to Allocate an Array
            12.2.2 allocator::construct Can Use any Constructor
            13.1.5 Using = default for Copy-Control Members
            13.1.6 Using = delete to Prevent Copying Class Objects
            13.5 Moving Instead of Copying Class Objects
            13.6.1 Rvalue References
            13.6.1 The Library move Function

            C++ Primer, Fifth Edition

            13.6.2 Move Constructor and Move Assignment
            13.6.2 Move Constructors Usually Should Be noexcept
            13.6.2 Move Iterators
            13.6.3 Reference Qualified Member Functions
            14.8.3 The function Class Template
            14.9.1 explicit Conversion Operators
            15.2.2 override Specifier for Virtual Functions
            15.2.2 Preventing Inheritance by Defining a Class as final
            15.3 override and final Specifiers for Virtual Functions
            15.7.2 Deleted Copy Control and Inheritance
            15.7.4 Inherited Constructors
            16.1.2 Declaring a Template Type Parameter as a Friend
            16.1.2 Template Type Aliases
            16.1.3 Default Template Arguments for Template Functions
            16.1.5 Explicit Control of Instantiation
            16.2.3 Template Functions and Trailing Return Types
            16.2.5 Reference Collapsing Rules
            16.2.6 static_cast from an Lvalue to an Rvalue
            16.2.7 The Library forward Function
            16.4 Variadic Templates
            16.4 The sizeof... Operator
            16.4.3 Variadic Templates and Forwarding
            17.1 The Library Tuple Class Template
            17.2.2 New bitset Operations
            17.3 The Regular Expression Library
            17.4 The Random Number Library
            17.5.1 Floating-Point Format Control
            18.1.4 The noexcept Exception Specifier
            18.1.4 The noexcept Operator
            18.2.1 Inline Namespaces

            18.3.1 Inherited Constructors and Multiple Inheritance
            19.3 Scoped enums
            19.3 Specifying the Type Used to Hold an enum
            19.3 Forward Declarations for enums
            19.4.3 The Library mem_fn Class Template
            19.6 Union Members of Class Types
~/Empire/Doks/Comp/lang/clangs/cpp/cpp-recip.pdf
~/Empire/Doks/Comp/lang/clangs/cpp/cpp-recip.txt
            Contents at a Glance


            About the Author ..........0csessee eossecssecovesees scenneceossesenensceoscoooscnsovosssococooccsecoosssooseeees xix
            About the Technical Reviewers .............00+ ecccccescessecescocsscescocsccosecccsccsscoescocsccoscesesees xxi
            AckNOWledgMERNS ..........scccccsssssresssesssersccssersesssseceesesserses Sccainianananaanasetnaanaaaeetaepaas xxiii
            INTFODUCTION ........0sssrerersersseerseeserssssssssrscsssesssesscers eocvccesscccsooeseosce ecccosccccsvcnscccecoccses XXV
            mChapter 1: Beginning C++ ...........ccsccsessseeees eanictannenceanat scussnssesusbansssesnsonsssensesnsen Ul
            MChapter 2: Modern C++ .........ccccccccccccsscssscssscssseseesssscsssseseceessecssssssees Seaanapenannae 17
            MChapter 3: Working With Text ..........sscccccsccsssssrcssscesssssersesscsssesseesesesseeenes iicalneiennin 59
            mChapter 4: Working with Numbe®s ............00000 soeunaneseosassasensosesbocnannensssossenssocsoents 81
            MChapter 5: Classes..........eccssrcsreessesssssseeens siRNA SRRROpONRE 103
            mChapter 6: Inheritance............. secsusees sceusceceesnenanccnnccenseassees = Ee
            mChapter 7: The STL Containers .............000000 eee anaes i ehaeneeeaeaaeeetes 151
            WChapter 8B: The STL Algorithms. ............ccecssrrsessssrerssssssessssesssssssessesessess th 177
            Bi Gheanter Gz Temmhetes cccscseccsseseccscevcsceserecccnsccssscanecssssscocnscnssvessccnsessscensseesceansossees 195
            MiGhanter 10: MOmROTY cccccccscccccsssccecccoccccenccrececcnsesnecesccssscessvenecoossoosocensesnnsesvennneesens 213
            MChapter 11: CONCUTENCY..........csrerssecsrerssrrsrsssesssessssssrscssesssrssssesseessscsssessseessees 259
            MChapter 12: Networking ..........ssccssecssscsssesssssscssssssscssssssecssssssssssesssesssesssssssessnes 309
            MChapter 13: Scripting ...........cccerscsersssresssesserssersssseseseees snconnceesee snccssseennceseees oo. 301
            mChapter 14: 3D Graphics ProgrammMing.............00000seereererees Se
            NIROX .ecccccsccscccsccssccrocevccsscesccsscosscecsoossoceccscccesscsscccscessooecconscossecee ecccccesccsececsconscocccocss 451

             

            Digitized by the Internet Archive
            in 2022 with funding from
            Kahle/Austin Foundation

            https://archive.org/details/crecipesproblemsO000suth

            Contents


            About the Author .......cccccccccssssssssscsssscssccsscssscssccssccsscsssessecsssocssescnsosscess —aaenansene xix
            About the Technical Reviewers ............cccccccrcrsscssseesreessseensresssssssennessssessessnsesssscnss xxi
            Acknowledgments..........0++ sounnemneuunnceuosenseesseansseoeoanccnssnsssssesseenocnnsstenscnsveenssspqneense xxiii
            Introduction ........0008 con cnscsceonersncccessooscoseesecconosceccnnnscnsccenevssssosorsscosesoococccoseos ssseeeneeXXV
            WChapter 1: Beginning C++ ........ceseessreessessssees SisbssinnseesenSiensaenenasenesnineeene eae
            Recipe 1-1. Finding a Text EGItOL.............sssssesesesesenenenenenenesenenenenenssesensssanenenenenenenennssssenens 2
            PORNO ET ancecsccecece cose secevevocceseesevenesesensesscassssscesenssscvenrocns sees t cece seenee eeve ecacasasasnsaresasnensnecssrecesseseersrenserecnseres 2
            RNAI cca ea conc hianinlpsircsiceiiomeseecmaiaenenetennsliaadioneseanananenoeetae 2
            Recipe 1-2. Installing Clang OM UDUMRU..........cssesesesesesesesensnensnssssssessesesesnsesesesenenenenentes 3
            PLODNOIMN ..<.cccsosececccesarerecevesereveceveseesescecsosscsnscsssnenscensneeavavenereses sevevesavereroveceseserecerasesnenseenenssanesenererecararetere 3

            SOM HON. << cccose ve ceccvevecseresescecsescecsososecssecasarecnsesarereverorereroeososeson ce censnsneeacecenasssnsesesessvarereverererevereveresencsceseesee 3

            Hoy FR WOT ICR. nc ncccccoceseoccovesesecececesese race sera revecesererevoveresesecarevesocesasosasscososeepassororeverssseresecaes;etecacsssssessasseniacne 3
            Recipe 1-3. Installing Clang OM WiINdOWS.............:sssssssssessesnsncesenensncenentenenentanensnsensnsenenes 5
            PrODIOM ...-.-c<ccccereccesvecsesescsrsrcesescseseresesesesesesssesssnsssessesenssnsesesesssrscsacacssananssavaranavarstarersvsossasasevosnsesesescsnss 5
            i ee ne ae eee eee cece neentteteneninier ane (eaeSSeNeTe 5

            Howe IR WOPKS. .ccccccscsosesesesesesesesesesercrereverararerererererevsnasavavavavararararesarerererereverevevevasesassssusensnsnsesnensvavarararararare 5
            Recipe 1-4. Installing Clang OM OS X........csscssssseseressesnessessessssssnsaneaneaneenennsnnsanennasnassaas 6
            PLODIOM ......ererercesescerecsesesesvsvsrsrseserenesseecesesessscsasasaenensnnnnsnsenserenenesesesesnsnsnsusussunsnsnananavararansnananaacasaeasananacas 6
            CAR an nna cccarneesnssemeenameeeeran einen Seer 6

            Sicatar DE NAG aaa teense cnenmnchcanmeceocoeseneasnenennnnnencunnenenneeneenanenSOSTEND 6
            Recipe 1-5. Building Your First C++ Programm ...........ssessessssssessnssnessessussssnnennnanennersnssnssens 7
            POD IOI ._.....~..-<-..-sc.---ccsece snsscevsasosansrererosseorovcsssorannensornseseencoroensnresanesetoronosesconssntsse SnOrersnOTevSneneHSeSeeseHP® 7
            Coleatiings ________ - neseonsenveessanasusnsneunnsvassensnensnunsnensasineensionsensstep sauasosaen toeunnsssnsnsnnannsnensetaistssneeestaasenans 7

             

            CONTENTS

            Recipe 1-6. Debugging C++ programs using GDB in Cygwin OF LINUX ..........cceeeerseeees 9
            HOW Bt WOKS... ccceserereevnees chile thneunenssiteinnchiviesactinsiaialilcnnmmnbipeesarataniceine

            Recipe 1-7. Debugging Your C++ Programs ON OS X..........ccccccscessesseeseerseneessenseensensnes 13

            Bn nusseceseienpsepsiuininsnpiinannnneniegscranens eensiiinienssaieeale iain eee eae
            Himtar I I siccsecinscscninrctiversnnirinditpnamatenciiaailtte aiiagenisasiaiadiciainaiaieainaist ia Sige me ei ae
            Racine 2-3. Using TYPO DOGUCTION... .2..0xreccccsccccccccscesces cesses nce ves ssocseessnsccseseesceecca see sue svesneeee 22

            vi

             
             

            CONTENTS

            mChapter 4: Working with Numbers SHSSSOSSSSSESSS ESS ESSEHSE SST ESOS HSS HOSE SSS ESCESOSS SOS EEEEHES SOTO FOES 81

            Recipe 4-1. Using the Integer Types i C4... ccc ccceccecceesecsesseessessenssnseneeereeeeneeeees 81
            PI atic a acta eedcascels in RSaesta llela patella aa hdameanintnos 5 a ee

            Vili

             
             

            CONTENTS

            FbCIG.5-B, Cleaning Usd CRABB OS caissssccssceccececccecsedivshosadilinnsieilldidties vecudbdsteesiedioteelbey une 115
            III sececctenercrntitensernserniiecsttlidinnnsenitcRiiitainatieiiaibnatateiimmnneliiitesanncittisitipeniiiaanien 1 Oe
            |

            Recipe 5-7. Copying ( CRG vasctesctieestbababiectcseniectden late RieaaE AE: BIS ctiitinetltode 118
            Ne weet itecaresntascaeecencciensndslcancoencrencceis eiarecseinaetecinmseecearaDeceaeieleiataeiiv ceateiecicbictiaielehotes cael 6
            I ceteris time aiiacandresdeemectinniaelinaneikeieteanc 1 Oe

            Recipe 5-8. Optindzing Code with Move SEMantiCs ..........cccccccescesseerseeseeceeeeeeeeeeeeees 127
            I ecisensdinininchednnmsbhestovstiresennenpebeimanansnennsinanentnensiansanecnesecsiatinintlmonsiatamiansti vlminateneditaiiaidies TET
            FE Fe I a enclnsenscsiesnniliariiinsnnennsninnennateeiemmetenennanneninnsinnaitinammmanninisinaannaanaal: Uae

            MChapter 6: Inheritance. ...........ccsccccsccsessessscccesscescvorssscesscesosscesscessccssssossscscsossesess WSS
            FROCHIS BT TROT TEI) THOTT B CEROG nccscccccscsvecscsnccccastbbsnsolecseesesiccseedunssuiiebiscsesmeastbiaens 133
            IPIITTII ccocesiersheterschen disoriented emonrneneneeneeneeeen aeenaenteneeneienieveineeaianagaarenndinnepenenaniananeninsiapesmemenasaaseaenaneene?

            Recipe 6-2. conarciting Access to Member Variables and
            Methods in Derived Classes .............ccccccceccecseecssessssssesseeeecesceseeessessenssseeseeseeeeeeeeeeneenes 135

            PanIIT | scr hiaiantasideniesineds desis taemiianietniaeempeeiemetseencienegiabnetemdemcinmnintenenamantuntindiamaimenaaenalaar Gane
            I sting tainchaatecencank pclae cise eckal il ninclan entail iene en
            How It Works... — ai ennianiinaaihitli nintainina paint daaissattnisiiiaitiiatie adn at Ta
            Recipe 6-3. Hiding Methods in Derived Classes...................cccccccccesceseecsesessseseneeneeeeeneees 139
            I entities ceteris ee eet ae Dae
            I i inn dennis snmmremecintiritamememicisnienessaimnmmn a aan aiattei aed ail te
            How It Works... Shiianeais sali tathaaealitiatintctt haere ita
            Recipe 6-4. Using 13 Pelmmorphic B Base ClaSS@S .0.00.......cccssessesseeceecescesseesecesssneesnersnnrenenss 141

             
             

            CONTENTS

            NN sc eek ckcibheich cebenndsbnedeccoinsodesedeclaninitnnUbniesssmnesistaheilldiliteantianiiasiiclcinbuiicl aaa. Se
            I iis iscsi semis Spsdina t sacarleinaitanicea nema. Te
            Recipe 8-5. Finding Values in & SQQUeNCE ..............ccssessseeecescersesesssssesssssessessersesenrees 191
            SE ee ee
            Hows It Works... amcdlin scaecsisunenaainiiaasanimsceiaipessmpiicle ait 1G
            Recipe 8-6. Sorting E Elements ina teeta in haibaddasedadtuiieaae Dl Ceae Ae ite cist ree 192
            tc ge a ee acre eee res eee ee 192
            Co) ee ee ee ae |
~/Empire/Doks/Comp/lang/clangs/cpp/cpp-stdlib_qref.pdf
~/Empire/Doks/Comp/lang/clangs/cpp/cpp-stdlib_qref.txt
            Contents at a Glance

            About the Authors............................................................................ xv

            About the Technical Reviewer ....................................................... xvii

            Introduction .................................................................................... xix
            ■Chapter 1: Numerics and Math ....................................................... 1
            ■Chapter 2: General Utilities ........................................................... 23
            ■Chapter 3: Containers ................................................................... 51
            ■Chapter 4: Algorithms .................................................................. 81
            ■Chapter 5: Stream I/O ................................................................. 101
            ■Chapter 6: Characters and Strings ............................................. 125
            ■Chapter 7: Concurrency .............................................................. 161
            ■Chapter 8: Diagnostics ............................................................... 183
            ■Appendix A: Standard Library Headers ...................................... 195
            Index .............................................................................................. 201

            v

            Contents

            About the Authors............................................................................ xv

            About the Technical Reviewer ....................................................... xvii

            Introduction .................................................................................... xix
            ■Chapter 1: Numerics and Math ....................................................... 1
            Common Mathematical Functions.............................................. <cmath> 1
            Basic Functions ........................................................................................................ 1
            Exponential and Logarithmic Functions ................................................................... 2
            Power Functions ....................................................................................................... 2
            Trigonometric and Hyperbolic Functions .................................................................. 2
            Error and Gamma Functions ..................................................................................... 3
            Integral Rounding of Floating-Point Numbers .......................................................... 3
            Floating-Point Manipulation Functions ..................................................................... 3
            Classification and Comparison Functions................................................................. 4
            Error Handling........................................................................................................... 5

            Fixed-Width Integer Types .......................................................<cstdint> 5
            Arithmetic Type Properties ...................................................... <limits> 5
            Complex Numbers ..................................................................<complex> 8
            Compile-Time Rational Numbers .............................................. <ratio> 9
            Random Numbers................................................................... <random> 10
            Random Number Generators .................................................................................. 10
            Random Number Distributions ............................................................................... 13

            vii

            ■ CONTENTS

            Numeric Arrays.................................................................... <valarray> 17
            std::slice ........................................................................................................... 19
            std::gslice......................................................................................................... 20
            std::mask_array ................................................................................................ 21
            std::indirect_array ........................................................................................ 21

            ■Chapter 2: General Utilities ........................................................... 23
            Moving, Forwarding, Swapping .............................................<utility> 23
            Moving .................................................................................................................... 23
            Forwarding ............................................................................................................. 25
            Swapping ................................................................................................................ 26

            Pairs and Tuples .................................................................................... 26
            Pairs.................................................................................................... <utility> 26
            Tuples ..................................................................................................... <tuple> 27

            Relational Operators ..............................................................<utility> 28
            Smart Pointers ....................................................................... <memory> 28
            Exclusive-Ownership Pointers ................................................................................ 29
            Shared-Ownership Pointers.................................................................................... 31

            Function Objects ............................................................. <functional> 33
            Reference Wrappers ............................................................................................... 34
            Predefined Functors ............................................................................................... 34
            Generic Function Wrappers .................................................................................... 35
            Binding Function Arguments .................................................................................. 36
            Functors for Class Members................................................................................... 37

            Initializer Lists ....................................................... <initializer_list> 39
            Date and Time Utilities ........................................................... <chrono> 39
            Durations ................................................................................................................ 40
            Time Points ............................................................................................................. 41
            Clocks ..................................................................................................................... 41
            C-style Date and Time Utilities ............................................................... <ctime> 42
            viii

            ■ CONTENTS

            C-Style File Utilities ................................................................ <cstdio> 45
            Type Utilities .......................................................................................... 45
            Runtime Type Identification ..................................... <typeinfo>, <typeindex> 45
            Type Traits ...................................................................................<type_traits> 46

            ■Chapter 3: Containers ................................................................... 51
            Iterators ............................................................................... <iterator> 51
            Iterator Tags ............................................................................................................ 52
            Non-Member Functions to Get Iterators ................................................................. 53
            Non-Member Operations on Iterators ..................................................................... 54

            Sequential Containers ........................................................................... 54
            std::vector....................................................................................... <vector> 54
            std::deque ........................................................................................... <deque> 60
            std::array ........................................................................................... <array> 60
            std::list and std::forward_list ......................<list>, <forward_list> 61
            Sequential Containers Reference ........................................................................... 63
            std::bitset....................................................................................... <bitset> 66

            Container Adaptors ................................................................................ 67
            std::queue ........................................................................................... <queue> 68
            std::priority_queue ........................................................................ <queue> 68
            std::stack ........................................................................................... <stack> 69
            Example .................................................................................................................. 69
            Reference ............................................................................................................... 70

            Ordered Associative Containers ............................................................ 71
            std::map and std::multimap .................................................................<map> 71
            std::set and std::multiset .................................................................<set> 72
            Searching ............................................................................................................... 72
            Order of Elements ................................................................................................... 73
            Complexity .............................................................................................................. 73
            Reference ............................................................................................................... 73
            ix

            ■ CONTENTS

            Unordered Associative Containers .... <unordered_map>, <unordered_set> 75
            Hash Map................................................................................................................ 76
            Template Type Parameters ..................................................................................... 76
            Hash Functions ....................................................................................................... 76
            Complexity .............................................................................................................. 77
            Reference ............................................................................................................... 77

            Allocators .............................................................................................. 79
            ■Chapter 4: Algorithms .................................................................. 81
            Input and Output Iterators ..................................................................... 81
            Algorithms ......................................................................... <algorithm> 82
            Terminology ............................................................................................................ 82
            General Guidelines.................................................................................................. 82
            Applying a Function on a Range ............................................................................. 83
            Checking for the Presence of Elements.................................................................. 84
            Finding Elements .................................................................................................... 84
            Binary Search ......................................................................................................... 85
            Subsequence Search .............................................................................................. 86
            Min/Max.................................................................................................................. 87
            Sequence Comparison ............................................................................................ 88
            Copy, Move, Swap ................................................................................................... 88
            Generating Sequences............................................................................................ 89
            Removing and Replacing ........................................................................................ 90
            Reversing and Rotating .......................................................................................... 91
            Partitioning ............................................................................................................. 92
            Sorting .................................................................................................................... 93
            Shuffling ................................................................................................................. 94
            Operations on Sorted Ranges ................................................................................. 95

            x

            ■ CONTENTS

            Permutation ............................................................................................................ 96
            Heaps...................................................................................................................... 97
            Numeric Algorithms ............................................................................ <numeric> 98

            Iterator Adaptors ................................................................. <iterator> 99
            ■Chapter 5: Stream I/O ................................................................. 101
            Input and Output with Streams ........................................................... 101
            Helper Types ..............................................................................................<ios> 102
            std::ios_base .......................................................................................<ios> 103
            I/O Manipulators ..................................................................<ios>, <iomanip> 105
            Example ................................................................................................................ 106
            std::ios ..................................................................................................<ios> 106
            std::ostream................................................................................. <ostream> 108
            std::istream................................................................................. <istream> 110
            std::iostream .............................................................................. <istream> 112

            String Streams ....................................................................<sstream> 112
            Example ................................................................................................................ 113

            File Streams ........................................................................<fstream> 113
            Example ................................................................................................................ 114

            operator<< and >> for Custom Types ............................................... 115
            Stream Iterators ............................................................... <iterator> 115
            std::ostream_iterator .................................................................................. 115
            std::istream_iterator .................................................................................. 116

            Stream Buffers ............................................................... <streambuf> 117
            C-Style Output and Input ...................................................... <cstdio> 117
            std::printf() Family ....................................................................................... 118
            std::scanf() Family ......................................................................................... 122

            xi

            ■ CONTENTS

            ■Chapter 6: Characters and Strings ............................................. 125
            Strings .................................................................................. <string> 125
            Searching in Strings ............................................................................................. 126
            Modifying Strings ................................................................................................. 127
            Constructing Strings ............................................................................................. 128
            String Length ........................................................................................................ 128
            Copying (Sub)Strings ............................................................................................ 128
            Comparing Strings ................................................................................................ 129
            String Conversions ............................................................................................... 129

            Character Classification ...................................... <cctype>, <cwctype> 130
            Character-Encoding Conversion .......................... <locale>, <codecvt> 131
            Localization .......................................................................... <locale> 134
            Locale Names ....................................................................................................... 134
            The Global Locale ................................................................................................. 135
            Basic std::locale Members ............................................................................. 136
            Locale Facets........................................................................................................ 136
            Combining and Customizing Locales .................................................................... 145
            C Locales .......................................................................................... <clocale> 147

            Regular Expressions ............................................................... <regex> 148
            The ECMAScript Regular Expression Grammar .................................................... 149
            Regular Expression Objects .................................................................................. 153
            Matching and Searching Patterns ........................................................................ 155
            Match Iterators ..................................................................................................... 158
            Replacing Patterns ............................................................................................... 159

            xii

            ■ CONTENTS

            ■Chapter 7: Concurrency .............................................................. 161
            Threads ................................................................................ <thread> 161
            Launching a New Thread ...................................................................................... 161
            A Thread's Lifetime ............................................................................................... 162
            Thread Identifiers ................................................................................................. 162
            Utility Functions .................................................................................................... 163
            Exceptions ............................................................................................................ 163

            Futures ................................................................................. <future> 164
            Return Objects ...................................................................................................... 164
            Providers............................................................................................................... 165
            Exceptions ............................................................................................................ 167

            Mutual Exclusion .................................................................... <mutex> 168
            Mutexes and Locks ............................................................................................... 168
            Mutex Types .......................................................................................................... 170
            Lock Types ............................................................................................................ 171
            Locking Multiple Mutexes..................................................................................... 172
            Exceptions ............................................................................................................ 173
            Calling a Function Once ........................................................................ <mutex> 173

            Condition Variables ...........................................<condition_variable> 174
            Waiting for a Condition ......................................................................................... 174
            Notification ........................................................................................................... 175
            Exceptions ............................................................................................................ 176

            Synchronization................................................................................... 176
            Atomic Operations ................................................................ <atomic> 178
            Atomic Variables ................................................................................................... 178
            Atomic Flags ......................................................................................................... 181
            Nonmember Functions ......................................................................................... 181
            Fences .................................................................................................................. 182

            xiii

            ■ CONTENTS

            ■Chapter 8: Diagnostics ............................................................... 183
            Assertions ...........................................................................<cassert> 183
            Exceptions ...................................................<exception>, <stdexcept> 184
            Exception Pointers........................................................... <exception> 184
            Nested Exceptions ........................................................... <exception> 186
            System Errors ............................................................. <system_error> 187
            std::error_category ...................................................................................... 188
            std::error_code .............................................................................................. 188
            std::error_condition .................................................................................... 189

            C Error Numbers ................................................................... <cerrno> 190
            Failure Handling .............................................................. <exception> 190
            std::uncaught_exception() ......................................................................... 190
            std::terminate() ............................................................................................ 191
            std::unexpected() .......................................................................................... 191

            ■Appendix A: Standard Library Headers ...................................... 195
            Numerics and Math (Chapter 1) .......................................................... 195
            General Utilities (Chapter 2) ................................................................ 196
            Containers (Chapter 3) ........................................................................ 197
            Algorithms (Chapter 4) ........................................................................ 197
            Stream I/O (Chapter 5)......................................................................... 198
            Characters and Strings (Chapter 6) ..................................................... 199
            Concurrency (Chapter 7)...................................................................... 199
            Diagnostics (Chapter 8) ....................................................................... 200
            The C Standard Library........................................................................ 200
            Index .............................................................................................. 201

~/Empire/Doks/Comp/lang/clangs/cpp/notes4pros-cpp.pdf
            Contents
            About ................................................................................................................................................................................... 1
            Chapter 1: Getting started with C++ .................................................................................................................... 2
            Section 1.1: Hello World ................................................................................................................................................. 2
            Section 1.2: Comments .................................................................................................................................................. 3
            Section 1.3: The standard C++ compilation process .................................................................................................. 5
            Section 1.4: Function ...................................................................................................................................................... 5
            Section 1.5: Visibility of function prototypes and declarations ................................................................................. 8
            Section 1.6: Preprocessor .............................................................................................................................................. 9
            Chapter 2: Templates ............................................................................................................................................... 10
            Section 2.1: Basic Class Template .............................................................................................................................. 10
            Section 2.2: Function Templates ................................................................................................................................ 11
            Section 2.3: Variadic template data structures ........................................................................................................ 12
            Section 2.4: Argument forwarding ............................................................................................................................ 15
            Section 2.5: Partial template specialization .............................................................................................................. 15
            Section 2.6: Template Specialization ......................................................................................................................... 17
            Section 2.7: Alias template ......................................................................................................................................... 17
            Section 2.8: Explicit instantiation ................................................................................................................................ 17
            Section 2.9: Non-type template parameter ............................................................................................................. 18
            Section 2.10: Declaring non-type template arguments with auto ......................................................................... 19
            Section 2.11: Template template parameters ........................................................................................................... 20
            Section 2.12: Default template parameter value ..................................................................................................... 20
            Chapter 3: Metaprogramming ............................................................................................................................. 21
            Section 3.1: Calculating Factorials ............................................................................................................................. 21
            Section 3.2: Iterating over a parameter pack .......................................................................................................... 23
            Section 3.3: Iterating with std::integer_sequence .................................................................................................... 24
            Section 3.4: Tag Dispatching ...................................................................................................................................... 25
            Section 3.5: Detect Whether Expression is Valid ...................................................................................................... 26
            Section 3.6: If-then-else .............................................................................................................................................. 27
            Section 3.7: Manual distinction of types when given any type T ........................................................................... 27
            Section 3.8: Calculating power with C++11 (and higher) .......................................................................................... 28
            Section 3.9: Generic Min/Max with variable argument count ................................................................................. 29
            Chapter 4: Iterators .................................................................................................................................................. 29
            Section 4.1: Overview ................................................................................................................................................... 29
            Section 4.2: Vector Iterator ........................................................................................................................................ 32
            Section 4.3: Map Iterator ............................................................................................................................................ 32
            Section 4.4: Reverse Iterators .................................................................................................................................... 33
            Section 4.5: Stream Iterators ...................................................................................................................................... 34
            Section 4.6: C Iterators (Pointers) .............................................................................................................................. 34
            Section 4.7: Write your own generator-backed iterator ......................................................................................... 35
            Chapter 5: Returning several values from a function ............................................................................. 36
            Section 5.1: Using std::tuple ......................................................................................................................................... 36
            Section 5.2: Structured Bindings ................................................................................................................................ 37
            Section 5.3: Using struct ............................................................................................................................................. 39
            Section 5.4: Using Output Parameters ...................................................................................................................... 40
            Section 5.5: Using a Function Object Consumer ...................................................................................................... 40
            Section 5.6: Using std::pair .......................................................................................................................................... 41
            Section 5.7: Using std::array ....................................................................................................................................... 41
            Section 5.8: Using Output Iterator ............................................................................................................................. 41Section 5.9: Using std::vector ..................................................................................................................................... 42
            Chapter 6: std::string ................................................................................................................................................ 42
            Section 6.1: Tokenize ................................................................................................................................................... 43
            Section 6.2: Conversion to (const) char* ................................................................................................................... 44
            Section 6.3: Using the std::string_view class ............................................................................................................ 45
            Section 6.4: Conversion to std::wstring ...................................................................................................................... 45
            Section 6.5: Lexicographical comparison ................................................................................................................. 46
            Section 6.6: Trimming characters at start/end ........................................................................................................ 48
            Section 6.7: String replacement ................................................................................................................................. 49
            Section 6.8: Converting to std::string ......................................................................................................................... 50
            Section 6.9: Splitting .................................................................................................................................................... 50
            Section 6.10: Accessing a character .......................................................................................................................... 51
            Section 6.11: Checking if a string is a preﬁx of another ........................................................................................... 51
            Section 6.12: Looping through each character ......................................................................................................... 52
            Section 6.13: Conversion to integers/ﬂoating point types ...................................................................................... 52
            Section 6.14: Concatenation ....................................................................................................................................... 53
            Section 6.15: Converting between character encodings ......................................................................................... 53
            Section 6.16: Finding character(s) in a string ............................................................................................................ 54
            Chapter 7: Namespaces .......................................................................................................................................... 55
            Section 7.1: What are namespaces? .......................................................................................................................... 55
            Section 7.2: Argument Dependent Lookup ............................................................................................................... 56
            Section 7.3: Extending namespaces .......................................................................................................................... 57
            Section 7.4: Using directive ......................................................................................................................................... 57
            Section 7.5: Making namespaces .............................................................................................................................. 58
            Section 7.6: Unnamed/anonymous namespaces ................................................................................................... 59
            Section 7.7: Compact nested namespaces ............................................................................................................... 59
            Section 7.8: Namespace alias .................................................................................................................................... 60
            Section 7.9: Inline namespace .................................................................................................................................... 60
            Section 7.10: Aliasing a long namespace .................................................................................................................. 62
            Section 7.11: Alias Declaration scope ......................................................................................................................... 62
            Chapter 8: File I/O ...................................................................................................................................................... 63
            Section 8.1: Writing to a ﬁle ........................................................................................................................................ 63
            Section 8.2: Opening a ﬁle .......................................................................................................................................... 64
            Section 8.3: Reading from a ﬁle ................................................................................................................................. 65
            Section 8.4: Opening modes ...................................................................................................................................... 66
            Section 8.5: Reading an ASCII ﬁle into a std::string .................................................................................................. 67
            Section 8.6: Writing ﬁles with non-standard locale settings ................................................................................... 68
            Section 8.7: Checking end of ﬁle inside a loop condition, bad practice? ............................................................... 69
            Section 8.8: Flushing a stream ................................................................................................................................... 69
            Section 8.9: Reading a ﬁle into a container .............................................................................................................. 70
            Section 8.10: Copying a ﬁle ......................................................................................................................................... 71
            Section 8.11: Closing a ﬁle ........................................................................................................................................... 71
            Section 8.12: Reading a `struct` from a formatted text ﬁle. ..................................................................................... 72
            Chapter 9: Classes/Structures ............................................................................................................................. 73
            Section 9.1: Class basics .............................................................................................................................................. 73
            Section 9.2: Final classes and structs ........................................................................................................................ 74
            Section 9.3: Access speciﬁers ..................................................................................................................................... 74
            Section 9.4: Inheritance ............................................................................................................................................... 75
            Section 9.5: Friendship ................................................................................................................................................ 77
            Section 9.6: Virtual Inheritance .................................................................................................................................. 78Section 9.7: Private inheritance: restricting base class interface ........................................................................... 79
            Section 9.8: Accessing class members ..................................................................................................................... 79
            Section 9.9: Member Types and Aliases ................................................................................................................... 81
            Section 9.10: Nested Classes/Structures ................................................................................................................... 84
            Section 9.11: Unnamed struct/class ........................................................................................................................... 88
            Section 9.12: Static class members ............................................................................................................................ 89
            Section 9.13: Multiple Inheritance ............................................................................................................................... 94
            Section 9.14: Non-static member functions .............................................................................................................. 95
            Chapter 10: Smart Pointers ................................................................................................................................... 96
            Section 10.1: Unique ownership (std::unique_ptr) ..................................................................................................... 96
            Section 10.2: Sharing ownership (std::shared_ptr) .................................................................................................. 98
            Section 10.3: Sharing with temporary ownership (std::weak_ptr) ........................................................................ 100
            Section 10.4: Using custom deleters to create a wrapper to a C interface ......................................................... 101
            Section 10.5: Unique ownership without move semantics (auto_ptr) ................................................................. 102
            Section 10.6: Casting std::shared_ptr pointers ....................................................................................................... 104
            Section 10.7: Writing a smart pointer: value_ptr .................................................................................................... 104
            Section 10.8: Getting a shared_ptr referring to this .............................................................................................. 106
            Chapter 11: Function Overloading .................................................................................................................... 107
            Section 11.1: What is Function Overloading? ........................................................................................................... 107
            Section 11.2: Return Type in Function Overloading ................................................................................................ 108
            Section 11.3: Member Function cv-qualiﬁer Overloading ...................................................................................... 109
            Chapter 12: std::vector ........................................................................................................................................... 110
            Section 12.1: Accessing Elements ............................................................................................................................. 110
            Section 12.2: Initializing a std::vector ....................................................................................................................... 113
            Section 12.3: Deleting Elements ............................................................................................................................... 114
            Section 12.4: Iterating Over std::vector .................................................................................................................... 116
            Section 12.5: vector<bool>: The Exception To So Many, So Many Rules ............................................................. 118
            Section 12.6: Inserting Elements ............................................................................................................................... 119
            Section 12.7: Using std::vector as a C array ............................................................................................................ 120
            Section 12.8: Finding an Element in std::vector ...................................................................................................... 120
            Section 12.9: Concatenating Vectors ....................................................................................................................... 121
            Section 12.10: Matrices Using Vectors ..................................................................................................................... 122
            Section 12.11: Using a Sorted Vector for Fast Element Lookup ............................................................................. 123
            Section 12.12: Reducing the Capacity of a Vector .................................................................................................. 123
            Section 12.13: Vector size and capacity ................................................................................................................... 124
            Section 12.14: Iterator/Pointer Invalidation ............................................................................................................. 125
            Section 12.15: Find max and min Element and Respective Index in a Vector ..................................................... 126
            Section 12.16: Converting an array to std::vector ................................................................................................... 127
            Section 12.17: Functions Returning Large Vectors ................................................................................................. 127
            Chapter 13: Operator Overloading .................................................................................................................. 128
            Section 13.1: Arithmetic operators ............................................................................................................................ 129
            Section 13.2: Array subscript operator .................................................................................................................... 130
            Section 13.3: Conversion operators ......................................................................................................................... 131
            Section 13.4: Complex Numbers Revisited .............................................................................................................. 131
            Section 13.5: Named operators ................................................................................................................................ 135
            Section 13.6: Unary operators .................................................................................................................................. 137
            Section 13.7: Comparison operators ........................................................................................................................ 138
            Section 13.8: Assignment operator .......................................................................................................................... 139
            Section 13.9: Function call operator ......................................................................................................................... 140
            Section 13.10: Bitwise NOT operator ........................................................................................................................ 140Section 13.11: Bit shift operators for I/O .................................................................................................................. 141
            Chapter 14: Lambdas ............................................................................................................................................. 141
            Section 14.1: What is a lambda expression? ........................................................................................................... 142
            Section 14.2: Specifying the return type .................................................................................................................. 144
            Section 14.3: Capture by value ................................................................................................................................. 145
            Section 14.4: Recursive lambdas .............................................................................................................................. 146
            Section 14.5: Default capture ................................................................................................................................... 147
            Section 14.6: Class lambdas and capture of this .................................................................................................... 148
            Section 14.7: Capture by reference .......................................................................................................................... 149
            Section 14.8: Generic lambdas ................................................................................................................................. 150
            Section 14.9: Using lambdas for inline parameter pack unpacking .................................................................... 151
            Section 14.10: Generalized capture .......................................................................................................................... 152
            Section 14.11: Conversion to function pointer .......................................................................................................... 153
            Section 14.12: Porting lambda functions to C++03 using functors ....................................................................... 154
            Chapter 15: Loops ..................................................................................................................................................... 155
            Section 15.1: Range-Based For ................................................................................................................................. 155
            Section 15.2: For loop ................................................................................................................................................ 158
            Section 15.3: While loop ............................................................................................................................................ 159
            Section 15.4: Do-while loop ....................................................................................................................................... 160
            Section 15.5: Loop Control statements : Break and Continue ............................................................................... 161
            Section 15.6: Declaration of variables in conditions .............................................................................................. 162
            Section 15.7: Range-for over a sub-range .............................................................................................................. 162
            Chapter 16: std::map ............................................................................................................................................... 163
            Section 16.1: Accessing elements ............................................................................................................................. 163
            Section 16.2: Inserting elements ............................................................................................................................... 164
            Section 16.3: Searching in std::map or in std::multimap ......................................................................................... 166
            Section 16.4: Initializing a std::map or std::multimap .............................................................................................. 167
            Section 16.5: Checking number of elements ........................................................................................................... 167
            Section 16.6: Types of Maps ..................................................................................................................................... 168
            Section 16.7: Deleting elements ................................................................................................................................ 168
            Section 16.8: Iterating over std::map or std::multimap ........................................................................................... 169
            Section 16.9: Creating std::map with user-deﬁned types as key .......................................................................... 170
            Chapter 17: Threading ............................................................................................................................................ 170
            Section 17.1: Creating a std::thread .......................................................................................................................... 171
            Section 17.2: Passing a reference to a thread ........................................................................................................ 172
            Section 17.3: Using std::async instead of std::thread .............................................................................................. 173
            Section 17.4: Basic Synchronization ......................................................................................................................... 174
            Section 17.5: Create a simple thread pool .............................................................................................................. 174
            Section 17.6: Ensuring a thread is always joined .................................................................................................... 176
            Section 17.7: Operations on the current thread ...................................................................................................... 177
            Section 17.8: Using Condition Variables .................................................................................................................. 178
            Section 17.9: Thread operations ............................................................................................................................... 179
            Section 17.10: Thread-local storage ......................................................................................................................... 180
            Section 17.11: Reassigning thread objects ............................................................................................................... 180
            Chapter 18: Value Categories ............................................................................................................................. 181
            Section 18.1: Value Category Meanings .................................................................................................................. 181
            Section 18.2: rvalue .................................................................................................................................................... 181
            Section 18.3: xvalue ................................................................................................................................................... 182
            Section 18.4: prvalue ................................................................................................................................................. 182
            Section 18.5: lvalue .................................................................................................................................................... 183Section 18.6: glvalue .................................................................................................................................................. 183
            Chapter 19: Preprocessor ..................................................................................................................................... 183
            Section 19.1: Include Guards ..................................................................................................................................... 184
            Section 19.2: Conditional logic and cross-platform handling ............................................................................... 184
            Section 19.3: X-macros .............................................................................................................................................. 186
            Section 19.4: Macros .................................................................................................................................................. 187
            Section 19.5: Predeﬁned macros .............................................................................................................................. 190
            Section 19.6: Preprocessor Operators ..................................................................................................................... 192
            Section 19.7: #pragma once ..................................................................................................................................... 193
            Section 19.8: Preprocessor error messages ........................................................................................................... 193
            Chapter 20: SFINAE (Substitution Failure Is Not An Error) .................................................................. 193
            Section 20.1: What is SFINAE .................................................................................................................................... 193
            Section 20.2: void_t .................................................................................................................................................. 194
            Section 20.3: enable_if ............................................................................................................................................. 195
            Section 20.4: is_detected ......................................................................................................................................... 197
            Section 20.5: Overload resolution with a large number of options ..................................................................... 198
            Section 20.6: trailing decltype in function templates ............................................................................................ 199
            Section 20.7: enable_if_all / enable_if_any ......................................................................................................... 200
            Chapter 21: The Rule of Three, Five, And Zero .......................................................................................... 202
            Section 21.1: Rule of Zero .......................................................................................................................................... 202
            Section 21.2: Rule of Five .......................................................................................................................................... 203
            Section 21.3: Rule of Three ....................................................................................................................................... 204
            Section 21.4: Self-assignment Protection ................................................................................................................ 205
            Chapter 22: RAII: Resource Acquisition Is Initialization ......................................................................... 206
            Section 22.1: Locking ................................................................................................................................................. 206
            Section 22.2: ScopeSuccess (c++17) ........................................................................................................................ 207
            Section 22.3: ScopeFail (c++17) ................................................................................................................................ 208
            Section 22.4: Finally/ScopeExit ................................................................................................................................ 209
            Chapter 23: Exceptions .......................................................................................................................................... 210
            Section 23.1: Catching exceptions ............................................................................................................................ 210
            Section 23.2: Rethrow (propagate) exception ....................................................................................................... 211
            Section 23.3: Best practice: throw by value, catch by const reference ............................................................... 212
            Section 23.4: Custom exception ............................................................................................................................... 213
            Section 23.5: std::uncaught_exceptions .................................................................................................................. 215
            Section 23.6: Function Try Block for regular function ........................................................................................... 216
            Section 23.7: Nested exception ................................................................................................................................ 216
            Section 23.8: Function Try Blocks In constructor ................................................................................................... 218
            Section 23.9: Function Try Blocks In destructor ..................................................................................................... 218
            Chapter 24: Implementation-deﬁned behavior ....................................................................................... 219
            Section 24.1: Size of integral types .......................................................................................................................... 219
            Section 24.2: Char might be unsigned or signed ................................................................................................... 221
            Section 24.3: Ranges of numeric types .................................................................................................................. 221
            Section 24.4: Value representation of ﬂoating point types .................................................................................. 222
            Section 24.5: Overﬂow when converting from integer to signed integer ........................................................... 222
            Section 24.6: Underlying type (and hence size) of an enum ................................................................................ 223
            Section 24.7: Numeric value of a pointer ................................................................................................................ 223
            Section 24.8: Number of bits in a byte .................................................................................................................... 224
            Chapter 25: Special Member Functions ......................................................................................................... 224
            Section 25.1: Default Constructor ............................................................................................................................ 224Section 25.2: Destructor ........................................................................................................................................... 226
            Section 25.3: Copy and swap ................................................................................................................................... 228
            Section 25.4: Implicit Move and Copy ..................................................................................................................... 229
            Chapter 26: Random number generation .................................................................................................... 229
            Section 26.1: True random value generator ........................................................................................................... 229
            Section 26.2: Generating a pseudo-random number ........................................................................................... 230
            Section 26.3: Using the generator for multiple distributions ................................................................................ 230
            Chapter 27: References ......................................................................................................................................... 231
            Section 27.1: Deﬁning a reference ........................................................................................................................... 231
            Chapter 28: Sorting ................................................................................................................................................. 231
            Section 28.1: Sorting and sequence containers ...................................................................................................... 232
            Section 28.2: sorting with std::map (ascending and descending) ....................................................................... 232
            Section 28.3: Sorting sequence containers by overloaded less operator ........................................................... 234
            Section 28.4: Sorting sequence containers using compare function .................................................................. 235
            Section 28.5: Sorting sequence containers using lambda expressions (C++11) .................................................. 235
            Section 28.6: Sorting built-in arrays ........................................................................................................................ 236
            Section 28.7: Sorting sequence containers with specifed ordering ..................................................................... 237
            Chapter 29: Regular expressions ...................................................................................................................... 237
            Section 29.1: Basic regex_match and regex_search Examples ........................................................................... 238
            Section 29.2: regex_iterator Example ..................................................................................................................... 238
            Section 29.3: Anchors ................................................................................................................................................ 239
            Section 29.4: regex_replace Example .................................................................................................................... 240
            Section 29.5: regex_token_iterator Example ........................................................................................................ 240
            Section 29.6: Quantiﬁers ........................................................................................................................................... 240
            Section 29.7: Splitting a string .................................................................................................................................. 241
            Chapter 30: Polymorphism .................................................................................................................................. 242
            Section 30.1: Deﬁne polymorphic classes ............................................................................................................... 242
            Section 30.2: Safe downcasting ............................................................................................................................... 243
            Section 30.3: Polymorphism & Destructors ............................................................................................................ 244
            Chapter 31: Perfect Forwarding ........................................................................................................................ 245
            Section 31.1: Factory functions ................................................................................................................................. 245
            Chapter 32: Virtual Member Functions .......................................................................................................... 245
            Section 32.1: Final virtual functions .......................................................................................................................... 246
            Section 32.2: Using override with virtual in C++11 and later .................................................................................. 246
            Section 32.3: Virtual vs non-virtual member functions ......................................................................................... 247
            Section 32.4: Behaviour of virtual functions in constructors and destructors .................................................... 248
            Section 32.5: Pure virtual functions ......................................................................................................................... 249
            Chapter 33: Undeﬁned Behavior ....................................................................................................................... 251
            Section 33.1: Reading or writing through a null pointer ......................................................................................... 251
            Section 33.2: Using an uninitialized local variable ................................................................................................. 251
            Section 33.3: Accessing an out-of-bounds index ................................................................................................... 252
            Section 33.4: Deleting a derived object via a pointer to a base class that doesn't have a virtual destructor.
            ............................................................................................................................................................................. 252
            Section 33.5: Extending the `std` or `posix` Namespace ........................................................................................ 252
            Section 33.6: Invalid pointer arithmetic ................................................................................................................... 253
            Section 33.7: No return statement for a function with a non-void return type .................................................. 254
            Section 33.8: Accessing a dangling reference ....................................................................................................... 254
            Section 33.9: Integer division by zero ...................................................................................................................... 254
            Section 33.10: Shifting by an invalid number of positions ..................................................................................... 255Section 33.11: Incorrect pairing of memory allocation and deallocation ............................................................. 255
            Section 33.12: Signed Integer Overﬂow ................................................................................................................... 255
            Section 33.13: Multiple non-identical deﬁnitions (the One Deﬁnition Rule) .......................................................... 256
            Section 33.14: Modifying a const object .................................................................................................................. 257
            Section 33.15: Returning from a [[noreturn]] function .......................................................................................... 258
            Section 33.16: Inﬁnite template recursion ................................................................................................................ 258
            Section 33.17: Overﬂow during conversion to or from ﬂoating point type ......................................................... 258
            Section 33.18: Modifying a string literal ................................................................................................................... 258
            Section 33.19: Accessing an object as the wrong type .......................................................................................... 259
            Section 33.20: Invalid derived-to-base conversion for pointers to members .................................................... 259
            Section 33.21: Destroying an object that has already been destroyed ............................................................... 259
            Section 33.22: Access to nonexistent member through pointer to member ...................................................... 260
            Section 33.23: Invalid base-to-derived static cast ................................................................................................. 260
            Section 33.24: Floating point overﬂow .................................................................................................................... 260
            Section 33.25: Calling (Pure) Virtual Members From Constructor Or Destructor .............................................. 260
            Section 33.26: Function call through mismatched function pointer type ............................................................ 261
            Chapter 34: Value and Reference Semantics ........................................................................................... 261
            Section 34.1: Deﬁnitions ............................................................................................................................................ 261
            Section 34.2: Deep copying and move support ..................................................................................................... 262
            Chapter 35: Overload resolution ...................................................................................................................... 264
            Section 35.1: Categorization of argument to parameter cost .............................................................................. 264
            Section 35.2: Arithmetic promotions and conversions .......................................................................................... 265
            Section 35.3: Overloading on Forwarding Reference ........................................................................................... 266
            Section 35.4: Exact match ........................................................................................................................................ 266
            Section 35.5: Overloading on constness and volatility .......................................................................................... 267
            Section 35.6: Name lookup and access checking .................................................................................................. 268
            Section 35.7: Overloading within a class hierarchy ............................................................................................... 268
            Section 35.8: Steps of Overload Resolution ........................................................................................................... 269
            Chapter 36: Move Semantics .............................................................................................................................. 271
            Section 36.1: Move semantics ................................................................................................................................... 271
            Section 36.2: Using std::move to reduce complexity from O(n²) to O(n) ............................................................ 271
            Section 36.3: Move constructor ................................................................................................................................ 274
            Section 36.4: Re-use a moved object ...................................................................................................................... 276
            Section 36.5: Move assignment ............................................................................................................................... 276
            Section 36.6: Using move semantics on containers .............................................................................................. 277
            Chapter 37: Pointers to members .................................................................................................................... 278
            Section 37.1: Pointers to static member functions ................................................................................................. 278
            Section 37.2: Pointers to member functions ........................................................................................................... 278
            Section 37.3: Pointers to member variables ........................................................................................................... 279
            Section 37.4: Pointers to static member variables ................................................................................................ 280
            Chapter 38: Pimpl Idiom ........................................................................................................................................ 280
            Section 38.1: Basic Pimpl idiom ................................................................................................................................ 280
            Chapter 39: std::function: To wrap any element that is callable .................................................... 281
            Section 39.1: Simple usage ....................................................................................................................................... 281
            Section 39.2: std::function used with std::bind ........................................................................................................ 282
            Section 39.3: Binding std::function to a dierent callable types .......................................................................... 282
            Section 39.4: Storing function arguments in std::tuple .......................................................................................... 284
            Section 39.5: std::function with lambda and std::bind ............................................................................................ 285
            Section 39.6: `function` overhead ............................................................................................................................. 286Chapter 40: const keyword ................................................................................................................................ 287
            Section 40.1: Avoiding duplication of code in const and non-const getter methods. ........................................ 287
            Section 40.2: Const member functions ................................................................................................................... 289
            Section 40.3: Const local variables .......................................................................................................................... 289
            Section 40.4: Const pointers ..................................................................................................................................... 290
            Chapter 41: auto ....................................................................................................................................................... 290
            Section 41.1: Basic auto sample ............................................................................................................................... 290
            Section 41.2: Generic lambda (C++14) ..................................................................................................................... 291
            Section 41.3: auto and proxy objects ....................................................................................................................... 291
            Section 41.4: auto and Expression Templates ........................................................................................................ 292
            Section 41.5: auto, const, and references ................................................................................................................ 292
            Section 41.6: Trailing return type ............................................................................................................................. 293
            Chapter 42: std::optional ..................................................................................................................................... 293
            Section 42.1: Using optionals to represent the absence of a value ..................................................................... 293
            Section 42.2: optional as return value .................................................................................................................... 294
            Section 42.3: value_or .............................................................................................................................................. 294
            Section 42.4: Introduction ......................................................................................................................................... 295
            Section 42.5: Using optionals to represent the failure of a function ................................................................... 295
            Chapter 43: Copy Elision ....................................................................................................................................... 296
            Section 43.1: Purpose of copy elision ...................................................................................................................... 296
            Section 43.2: Guaranteed copy elision .................................................................................................................... 297
            Section 43.3: Parameter elision ................................................................................................................................ 299
            Section 43.4: Return value elision ............................................................................................................................ 299
            Section 43.5: Named return value elision ............................................................................................................... 299
            Section 43.6: Copy initialization elision .................................................................................................................... 300
            Chapter 44: Bit Operators .................................................................................................................................. 300
            Section 44.1: | - bitwise OR ........................................................................................................................................ 300
            Section 44.2: ^ - bitwise XOR (exclusive OR) .......................................................................................................... 301
            Section 44.3: & - bitwise AND ................................................................................................................................... 302
            Section 44.4: << - left shift ........................................................................................................................................ 302
            Section 44.5: >> - right shift ...................................................................................................................................... 303
            Chapter 45: Fold Expressions ............................................................................................................................. 304
            Section 45.1: Unary Folds .......................................................................................................................................... 304
            Section 45.2: Binary Folds ........................................................................................................................................ 304
            Section 45.3: Folding over a comma ....................................................................................................................... 305
            Chapter 46: Unions .................................................................................................................................................. 305
            Section 46.1: Undeﬁned Behavior ............................................................................................................................ 305
            Section 46.2: Basic Union Features ......................................................................................................................... 305
            Section 46.3: Typical Use .......................................................................................................................................... 306
            Chapter 47: Unnamed types .............................................................................................................................. 306
            Section 47.1: Unnamed classes ................................................................................................................................ 306
            Section 47.2: As a type alias .................................................................................................................................... 307
            Section 47.3: Anonymous members ........................................................................................................................ 307
            Section 47.4: Anonymous Union .............................................................................................................................. 307
            Chapter 48: mutable keyword .......................................................................................................................... 308
            Section 48.1: mutable lambdas ................................................................................................................................ 308
            Section 48.2: non-static class member modiﬁer ................................................................................................... 308
            Chapter 49: Bit ﬁelds .............................................................................................................................................. 309
            Section 49.1: Declaration and Usage ....................................................................................................................... 309Chapter 50: std::array ........................................................................................................................................... 310
            Section 50.1: Initializing an std::array ....................................................................................................................... 310
            Section 50.2: Element access ................................................................................................................................... 310
            Section 50.3: Iterating through the Array ............................................................................................................... 313
            Section 50.4: Checking size of the Array ................................................................................................................ 313
            Section 50.5: Changing all array elements at once .............................................................................................. 313
            Chapter 51: Singleton Design Pattern ............................................................................................................ 313
            Section 51.1: Lazy Initialization .................................................................................................................................. 313
            Section 51.2: Static deinitialization-safe singleton. ................................................................................................. 314
            Section 51.3: Thread-safe Singeton ......................................................................................................................... 315
            Section 51.4: Subclasses ............................................................................................................................................ 315
            Chapter 52: The ISO C++ Standard ................................................................................................................. 316
            Section 52.1: Current Working Drafts ...................................................................................................................... 316
            Section 52.2: C++17 .................................................................................................................................................... 316
            Section 52.3: C++11 ..................................................................................................................................................... 317
            Section 52.4: C++14 .................................................................................................................................................... 319
            Section 52.5: C++98 ................................................................................................................................................... 319
            Section 52.6: C++03 ................................................................................................................................................... 320
            Section 52.7: C++20 ................................................................................................................................................... 320
            Chapter 53: User-Deﬁned Literals ................................................................................................................... 320
            Section 53.1: Self-made user-deﬁned literal for binary ......................................................................................... 320
            Section 53.2: Standard user-deﬁned literals for duration ..................................................................................... 321
            Section 53.3: User-deﬁned literals with long double values ................................................................................. 321
            Section 53.4: Standard user-deﬁned literals for strings ........................................................................................ 322
            Section 53.5: Standard user-deﬁned literals for complex ..................................................................................... 322
            Chapter 54: Enumeration ..................................................................................................................................... 323
            Section 54.1: Iteration over an enum ....................................................................................................................... 323
            Section 54.2: Scoped enums .................................................................................................................................... 324
            Section 54.3: Enum forward declaration in C++11 .................................................................................................. 325
            Section 54.4: Basic Enumeration Declaration ........................................................................................................ 325
            Section 54.5: Enumeration in switch statements ................................................................................................... 326
            Chapter 55: Type Erasure .................................................................................................................................... 326
            Section 55.1: A move-only `std::function` ................................................................................................................. 326
            Section 55.2: Erasing down to a Regular type with manual vtable ..................................................................... 328
            Section 55.3: Basic mechanism ................................................................................................................................ 331
            Section 55.4: Erasing down to a contiguous buer of T ....................................................................................... 332
            Section 55.5: Type erasing type erasure with std::any .......................................................................................... 334
            Chapter 56: Memory management ................................................................................................................. 338
            Section 56.1: Free Storage (Heap, Dynamic Allocation ...) ..................................................................................... 338
            Section 56.2: Placement new ................................................................................................................................... 339
            Section 56.3: Stack .................................................................................................................................................... 340
            Chapter 57: Bit Manipulation .............................................................................................................................. 341
            Section 57.1: Remove rightmost set bit ................................................................................................................... 341
            Section 57.2: Set all bits ............................................................................................................................................ 341
            Section 57.3: Toggling a bit ...................................................................................................................................... 341
            Section 57.4: Checking a bit ..................................................................................................................................... 341
            Section 57.5: Counting bits set ................................................................................................................................. 342
            Section 57.6: Check if an integer is a power of 2 ................................................................................................... 342
            Section 57.7: Setting a bit ......................................................................................................................................... 343Section 57.8: Clearing a bit ....................................................................................................................................... 343
            Section 57.9: Changing the nth bit to x ................................................................................................................... 343
            Section 57.10: Bit Manipulation Application: Small to Capital Letter .................................................................... 343
            Chapter 58: Arrays ................................................................................................................................................... 344
            Section 58.1: Array initialization ............................................................................................................................... 344
            Section 58.2: A ﬁxed size raw array matrix (that is, a 2D raw array). ................................................................. 345
            Section 58.3: Dynamically sized raw array ............................................................................................................ 346
            Section 58.4: Array size: type safe at compile time. .............................................................................................. 346
            Section 58.5: Expanding dynamic size array by using std::vector. ...................................................................... 347
            Section 58.6: A dynamic size matrix using std::vector for storage. ...................................................................... 348
            Chapter 59: Pointers ............................................................................................................................................... 350
            Section 59.1: Pointer Operations .............................................................................................................................. 350
            Section 59.2: Pointer basics ...................................................................................................................................... 351
            Section 59.3: Pointer Arithmetic ............................................................................................................................... 353
            Chapter 60: Explicit type conversions ............................................................................................................ 354
            Section 60.1: C-style casting ..................................................................................................................................... 354
            Section 60.2: Casting away constness .................................................................................................................... 355
            Section 60.3: Base to derived conversion ............................................................................................................... 355
            Section 60.4: Conversion between pointer and integer ........................................................................................ 356
            Section 60.5: Conversion by explicit constructor or explicit conversion function .............................................. 356
            Section 60.6: Implicit conversion ............................................................................................................................. 356
            Section 60.7: Enum conversions .............................................................................................................................. 357
            Section 60.8: Derived to base conversion for pointers to members ................................................................... 358
            Section 60.9: void* to T* ............................................................................................................................................ 358
            Section 60.10: Type punning conversion ................................................................................................................ 359
            Chapter 61: RTTI: Run-Time Type Information ......................................................................................... 359
            Section 61.1: dynamic_cast ....................................................................................................................................... 359
            Section 61.2: The typeid keyword ............................................................................................................................ 360
            Section 61.3: Name of a type ................................................................................................................................... 360
            Section 61.4: When to use which cast in c++ ........................................................................................................... 361
            Chapter 62: Standard Library Algorithms ................................................................................................... 361
            Section 62.1: std::next_permutation ......................................................................................................................... 361
            Section 62.2: std::for_each ....................................................................................................................................... 362
            Section 62.3: std::accumulate ................................................................................................................................... 362
            Section 62.4: std::ﬁnd ................................................................................................................................................ 363
            Section 62.5: std::min_element ................................................................................................................................ 365
            Section 62.6: std::ﬁnd_if ............................................................................................................................................ 366
            Section 62.7: Using std::nth_element To Find The Median (Or Other Quantiles) ............................................... 367
            Section 62.8: std::count ............................................................................................................................................. 368
            Section 62.9: std::count_if ......................................................................................................................................... 369
            Chapter 63: Friend keyword ................................................................................................................................ 370
            Section 63.1: Friend function ..................................................................................................................................... 370
            Section 63.2: Friend method .................................................................................................................................... 371
            Section 63.3: Friend class ......................................................................................................................................... 372
            Chapter 64: Expression templates .................................................................................................................. 373
            Section 64.1: A basic example illustrating expression templates ......................................................................... 373
            Chapter 65: Scopes .................................................................................................................................................. 376
            Section 65.1: Global variables ................................................................................................................................... 376
            Section 65.2: Simple block scope ............................................................................................................................ 377Chapter 66: Atomic Types .................................................................................................................................... 377
            Section 66.1: Multi-threaded Access ........................................................................................................................ 377
            Chapter 67: static_assert .................................................................................................................................... 379
            Section 67.1: static_assert ........................................................................................................................................ 379
            Chapter 68: operator precedence ................................................................................................................... 379
            Section 68.1: Logical && and || operators: short-circuit ......................................................................................... 379
            Section 68.2: Unary Operators ................................................................................................................................ 380
            Section 68.3: Arithmetic operators .......................................................................................................................... 381
            Section 68.4: Logical AND and OR operators ........................................................................................................ 381
            Chapter 69: constexpr ............................................................................................................................................ 382
            Section 69.1: constexpr variables ............................................................................................................................. 382
            Section 69.2: Static if statement .............................................................................................................................. 383
            Section 69.3: constexpr functions ............................................................................................................................ 384
            Chapter 70: Date and time using <chrono> header ............................................................................... 385
            Section 70.1: Measuring time using <chrono> ........................................................................................................ 385
            Section 70.2: Find number of days between two dates ........................................................................................ 386
            Chapter 71: Trailing return type ....................................................................................................................... 387
            Section 71.1: Avoid qualifying a nested type name ................................................................................................ 387
            Section 71.2: Lambda expressions ........................................................................................................................... 387
            Chapter 72: Function Template Overloading ............................................................................................ 387
            Section 72.1: What is a valid function template overloading? .............................................................................. 387
            Chapter 73: Common compile/linker errors (GCC) ................................................................................. 388
            Section 73.1: undeﬁned reference to `***' ................................................................................................................. 388
            Section 73.2: error: '***' was not declared in this scope ......................................................................................... 388
            Section 73.3: fatal error: ***: No such ﬁle or directory ............................................................................................ 390
            Chapter 74: Design pattern implementation in C++ .............................................................................. 390
            Section 74.1: Adapter Pattern ................................................................................................................................... 390
            Section 74.2: Observer pattern ................................................................................................................................ 392
            Section 74.3: Factory Pattern ................................................................................................................................... 395
            Section 74.4: Builder Pattern with Fluent API .......................................................................................................... 396
            Chapter 75: Optimization in C++ ....................................................................................................................... 399
            Section 75.1: Introduction to performance ............................................................................................................. 399
            Section 75.2: Empty Base Class Optimization ........................................................................................................ 399
            Section 75.3: Optimizing by executing less code ................................................................................................... 400
            Section 75.4: Using ecient containers .................................................................................................................. 401
            Section 75.5: Small Object Optimization ................................................................................................................. 401
            Chapter 76: Compiling and Building ................................................................................................................ 403
            Section 76.1: Compiling with GCC ............................................................................................................................. 403
            Section 76.2: Compiling with Visual Studio (Graphical Interface) - Hello World ................................................ 405
            Section 76.3: Online Compilers ................................................................................................................................. 409
            Section 76.4: Compiling with Visual C++ (Command Line) ................................................................................... 411
            Section 76.5: Compiling with Clang ......................................................................................................................... 414
            Section 76.6: The C++ compilation process ............................................................................................................ 414
            Section 76.7: Compiling with Code::Blocks (Graphical interface) ......................................................................... 416
            Chapter 77: Type Traits ........................................................................................................................................ 418
            Section 77.1: Type Properties ................................................................................................................................... 418
            Section 77.2: Standard type traits ........................................................................................................................... 419
            Section 77.3: Type relations with std::is_same<T, T> ............................................................................................. 420Section 77.4: Fundamental type traits .................................................................................................................... 421
            Chapter 78: std::pair ............................................................................................................................................... 422
            Section 78.1: Compare operators ............................................................................................................................ 422
            Section 78.2: Creating a Pair and accessing the elements ................................................................................... 423
            Chapter 79: Keywords ............................................................................................................................................ 424
            Section 79.1: asm ....................................................................................................................................................... 424
            Section 79.2: Dierent keywords ............................................................................................................................. 424
            Section 79.3: typename ............................................................................................................................................ 428
            Section 79.4: explicit .................................................................................................................................................. 429
            Section 79.5: sizeof .................................................................................................................................................... 430
            Section 79.6: noexcept .............................................................................................................................................. 430
            Chapter 80: One Deﬁnition Rule (ODR) ......................................................................................................... 431
            Section 80.1: ODR violation via overload resolution .............................................................................................. 431
            Section 80.2: Multiply deﬁned function ................................................................................................................... 432
            Section 80.3: Inline functions .................................................................................................................................... 432
            Chapter 81: Unspeciﬁed behavior .................................................................................................................... 433
            Section 81.1: Value of an out-of-range enum ......................................................................................................... 433
            Section 81.2: Evaluation order of function arguments .......................................................................................... 434
            Section 81.3: Result of some reinterpret_cast conversions .................................................................................. 435
            Section 81.4: Space occupied by a reference ......................................................................................................... 435
            Section 81.5: Moved-from state of most standard library classes ...................................................................... 436
            Section 81.6: Result of some pointer comparisons ................................................................................................ 436
            Section 81.7: Static cast from bogus void* value .................................................................................................... 436
            Section 81.8: Order of initialization of globals across TU ...................................................................................... 437
            Chapter 82: Floating Point Arithmetic ........................................................................................................... 437
            Section 82.1: Floating Point Numbers are Weird .................................................................................................... 437
            Chapter 83: Argument Dependent Name Lookup ................................................................................... 438
            Section 83.1: What functions are found .................................................................................................................. 438
            Chapter 84: std::variant ....................................................................................................................................... 439
            Section 84.1: Create pseudo-method pointers ....................................................................................................... 439
            Section 84.2: Basic std::variant use ......................................................................................................................... 440
            Section 84.3: Constructing a `std::variant` ............................................................................................................... 441
            Chapter 85: Attributes ........................................................................................................................................... 441
            Section 85.1: [[fallthrough]] ..................................................................................................................................... 441
            Section 85.2: [[nodiscard]] ...................................................................................................................................... 442
            Section 85.3: [[deprecated]] and [[deprecated("reason")]] ............................................................................... 442
            Section 85.4: [[maybe_unused]] ............................................................................................................................ 443
            Section 85.5: [[noreturn]] ......................................................................................................................................... 444
            Chapter 86: Proﬁling ............................................................................................................................................... 445
            Section 86.1: Proﬁling with gcc and gprof ............................................................................................................... 445
            Section 86.2: Generating callgraph diagrams with gperf2dot ............................................................................. 446
            Section 86.3: Proﬁling CPU Usage with gcc and Google Perf Tools .................................................................... 446
            Chapter 87: Return Type Covariance ............................................................................................................ 448
            Section 87.1: 2. Covariant result version of the base example, static type checking. ........................................ 448
            Section 87.2: 3. Covariant smart pointer result (automated cleanup). ................................................................ 448
            Chapter 88: Non-Static Member Functions ................................................................................................. 449
            Section 88.1: Non-static Member Functions ........................................................................................................... 450
            Section 88.2: Encapsulation ..................................................................................................................................... 451
            Section 88.3: Name Hiding & Importing .................................................................................................................. 451Section 88.4: Virtual Member Functions ................................................................................................................. 453
            Section 88.5: Const Correctness .............................................................................................................................. 455
            Chapter 89: Recursion in C++ ............................................................................................................................. 456
            Section 89.1: Using tail recursion and Fibonnaci-style recursion to solve the Fibonnaci sequence ................. 456
            Section 89.2: Recursion with memoization ............................................................................................................. 457
            Chapter 90: Callable Objects .............................................................................................................................. 458
            Section 90.1: Function Pointers ................................................................................................................................ 458
            Section 90.2: Classes with operator() (Functors) .................................................................................................. 458
            Chapter 91: std::iomanip ....................................................................................................................................... 459
            Section 91.1: std::setprecision .................................................................................................................................... 459
            Section 91.2: std::setﬁll ............................................................................................................................................... 459
            Section 91.3: std::setiosﬂags ..................................................................................................................................... 460
            Section 91.4: std::setw ................................................................................................................................................ 461
            Chapter 92: Constant class member functions ......................................................................................... 462
            Section 92.1: constant member function ................................................................................................................ 462
            Chapter 93: Side by Side Comparisons of classic C++ examples solved via C++ vs C++11
            vs C++14 vs C++17 ..................................................................................................................................................... 462
            Section 93.1: Looping through a container ............................................................................................................. 462
            Chapter 94: The This Pointer .............................................................................................................................. 463
            Section 94.1: this Pointer ........................................................................................................................................... 463
            Section 94.2: Using the this Pointer to Access Member Data ............................................................................... 465
            Section 94.3: Using the this Pointer to Dierentiate Between Member Data and Parameters ........................ 466
            Section 94.4: this Pointer CV-Qualiﬁers ................................................................................................................... 467
            Section 94.5: this Pointer Ref-Qualiﬁers .................................................................................................................. 469
            Chapter 95: Inline functions ................................................................................................................................ 470
            Section 95.1: Non-member inline function deﬁnition ............................................................................................. 470
            Section 95.2: Member inline functions .................................................................................................................... 470
            Section 95.3: What is function inlining? ................................................................................................................... 471
            Section 95.4: Non-member inline function declaration ......................................................................................... 471
            Chapter 96: Copying vs Assignment ............................................................................................................... 471
            Section 96.1: Assignment Operator ......................................................................................................................... 472
            Section 96.2: Copy Constructor ............................................................................................................................... 472
            Section 96.3: Copy Constructor Vs Assignment Constructor ............................................................................... 473
            Chapter 97: Client server examples ................................................................................................................ 474
            Section 97.1: Hello TCP Client ................................................................................................................................... 474
            Section 97.2: Hello TCP Server ................................................................................................................................. 475
            Chapter 98: Header Files ...................................................................................................................................... 478
            Section 98.1: Basic Example ..................................................................................................................................... 478
            Section 98.2: Templates in Header Files ................................................................................................................. 480
            Chapter 99: Const Correctness .......................................................................................................................... 480
            Section 99.1: The Basics ............................................................................................................................................ 480
            Section 99.2: Const Correct Class Design ............................................................................................................... 481
            Section 99.3: Const Correct Function Parameters ................................................................................................. 483
            Section 99.4: Const Correctness as Documentation ............................................................................................. 484
            Chapter 100: std::atomics ..................................................................................................................................... 488
            Section 100.1: atomic types ...................................................................................................................................... 488
            Chapter 101: Data Structures in C++ ............................................................................................................... 489
            Section 101.1: Linked List implementation in C++ .................................................................................................... 489Chapter 102: Refactoring Techniques ............................................................................................................ 491
            Section 102.1: Goto Cleanup ..................................................................................................................................... 491
            Chapter 103: C++ Streams .................................................................................................................................... 492
            Section 103.1: String streams .................................................................................................................................... 492
            Section 103.2: Printing collections with iostream ................................................................................................... 493
            Chapter 104: Parameter packs ......................................................................................................................... 494
            Section 104.1: A template with a parameter pack .................................................................................................. 494
            Section 104.2: Expansion of a parameter pack ...................................................................................................... 494
            Chapter 105: Literals ............................................................................................................................................... 495
            Section 105.1: this ....................................................................................................................................................... 495
            Section 105.2: Integer literal ..................................................................................................................................... 496
            Section 105.3: true ..................................................................................................................................................... 497
            Section 105.4: false .................................................................................................................................................... 497
            Section 105.5: nullptr ................................................................................................................................................. 497
            Chapter 106: Flow Control .................................................................................................................................... 497
            Section 106.1: case ..................................................................................................................................................... 497
            Section 106.2: switch .................................................................................................................................................. 498
            Section 106.3: catch ................................................................................................................................................... 498
            Section 106.4: throw .................................................................................................................................................. 499
            Section 106.5: default ................................................................................................................................................ 499
            Section 106.6: try ........................................................................................................................................................ 500
            Section 106.7: if .......................................................................................................................................................... 500
            Section 106.8: else ..................................................................................................................................................... 500
            Section 106.9: Conditional Structures: if, if..else ...................................................................................................... 500
            Section 106.10: goto ................................................................................................................................................... 501
            Section 106.11: Jump statements : break, continue, goto, exit. .............................................................................. 502
            Section 106.12: return ................................................................................................................................................ 505
            Chapter 107: Type Keywords .............................................................................................................................. 505
            Section 107.1: class ..................................................................................................................................................... 505
            Section 107.2: enum ................................................................................................................................................... 506
            Section 107.3: struct ................................................................................................................................................... 508
            Section 107.4: union ................................................................................................................................................... 508
            Chapter 108: Basic Type Keywords ................................................................................................................. 508
            Section 108.1: char ..................................................................................................................................................... 508
            Section 108.2: char16_t ............................................................................................................................................. 508
            Section 108.3: char32_t ............................................................................................................................................. 509
            Section 108.4: int ........................................................................................................................................................ 509
            Section 108.5: void ..................................................................................................................................................... 509
            Section 108.6: wchar_t .............................................................................................................................................. 509
            Section 108.7: ﬂoat .................................................................................................................................................... 510
            Section 108.8: double ................................................................................................................................................ 510
            Section 108.9: long ..................................................................................................................................................... 510
            Section 108.10: short .................................................................................................................................................. 510
            Section 108.11: bool .................................................................................................................................................... 510
            Chapter 109: Variable Declaration Keywords ............................................................................................ 511
            Section 109.1: decltype .............................................................................................................................................. 511
            Section 109.2: const ................................................................................................................................................... 511
            Section 109.3: volatile ................................................................................................................................................ 512
            Section 109.4: signed ................................................................................................................................................. 512Section 109.5: unsigned ............................................................................................................................................. 512
            Chapter 110: Iteration ............................................................................................................................................. 513
            Section 110.1: break .................................................................................................................................................... 513
            Section 110.2: continue .............................................................................................................................................. 513
            Section 110.3: do ......................................................................................................................................................... 513
            Section 110.4: while .................................................................................................................................................... 513
            Section 110.5: range-based for loop ........................................................................................................................ 513
            Section 110.6: for ........................................................................................................................................................ 514
            Chapter 111: type deduction ................................................................................................................................. 514
            Section 111.1: Template parameter deduction for constructors ............................................................................ 514
            Section 111.2: Auto Type Deduction .......................................................................................................................... 514
            Section 111.3: Template Type Deduction ................................................................................................................. 515
            Chapter 112: std::any ............................................................................................................................................... 516
            Section 112.1: Basic usage ......................................................................................................................................... 516
            Chapter 113: C++11 Memory Model .................................................................................................................... 516
            Section 113.1: Need for Memory Model .................................................................................................................... 516
            Section 113.2: Fence example ................................................................................................................................... 518
            Chapter 114: Build Systems ................................................................................................................................. 519
            Section 114.1: Generating Build Environment with CMake ..................................................................................... 519
            Section 114.2: Compiling with GNU make ................................................................................................................ 519
            Section 114.3: Building with SCons ............................................................................................................................ 522
            Section 114.4: Autotools (GNU) ................................................................................................................................. 522
            Section 114.5: Ninja .................................................................................................................................................... 522
            Section 114.6: NMAKE (Microsoft Program Maintenance Utility) .......................................................................... 523
            Chapter 115: Concurrency With OpenMP ....................................................................................................... 523
            Section 115.1: OpenMP: Parallel Sections ................................................................................................................. 523
            Section 115.2: OpenMP: Parallel Sections ................................................................................................................ 524
            Section 115.3: OpenMP: Parallel For Loop ............................................................................................................... 524
            Section 115.4: OpenMP: Parallel Gathering / Reduction ........................................................................................ 525
            Chapter 116: Type Inference ................................................................................................................................ 526
            Section 116.1: Data Type: Auto .................................................................................................................................. 526
            Section 116.2: Lambda auto ...................................................................................................................................... 526
            Section 116.3: Loops and auto .................................................................................................................................. 526
            Chapter 117: std::integer_sequence ................................................................................................................ 527
            Section 117.1: Turn a std::tuple<T...> into function parameters .............................................................................. 527
            Section 117.2: Create a parameter pack consisting of integers ........................................................................... 528
            Section 117.3: Turn a sequence of indices into copies of an element .................................................................. 528
            Chapter 118: Resource Management .............................................................................................................. 529
            Section 118.1: Resource Acquisition Is Initialization ................................................................................................. 529
            Section 118.2: Mutexes & Thread Safety .................................................................................................................. 530
            Chapter 119: std::set and std::multiset ........................................................................................................... 531
            Section 119.1: Changing the default sort of a set .................................................................................................... 531
            Section 119.2: Deleting values from a set ................................................................................................................ 533
            Section 119.3: Inserting values in a set ..................................................................................................................... 534
            Section 119.4: Inserting values in a multiset ............................................................................................................ 536
            Section 119.5: Searching values in set and multiset ............................................................................................... 536
            Chapter 120: Storage class speciﬁers ............................................................................................................ 537
            Section 120.1: extern .................................................................................................................................................. 537
            Section 120.2: register ............................................................................................................................................... 538Section 120.3: static ................................................................................................................................................... 538
            Section 120.4: auto .................................................................................................................................................... 539
            Section 120.5: mutable .............................................................................................................................................. 539
            Chapter 121: Alignment .......................................................................................................................................... 539
            Section 121.1: Controlling alignment ......................................................................................................................... 540
            Section 121.2: Querying the alignment of a type ................................................................................................... 540
            Chapter 122: Inline variables ............................................................................................................................... 541
            Section 122.1: Deﬁning a static data member in the class deﬁnition ................................................................... 541
            Chapter 123: Linkage speciﬁcations ................................................................................................................ 541
            Section 123.1: Signal handler for Unix-like operating system ............................................................................... 541
            Section 123.2: Making a C library header compatible with C++ ........................................................................... 542
            Chapter 124: Curiously Recurring Template Pattern (CRTP) ............................................................. 542
            Section 124.1: The Curiously Recurring Template Pattern (CRTP) ....................................................................... 542
            Section 124.2: CRTP to avoid code duplication ...................................................................................................... 544
            Chapter 125: Using declaration ......................................................................................................................... 545
            Section 125.1: Importing names individually from a namespace ......................................................................... 545
            Section 125.2: Redeclaring members from a base class to avoid name hiding ................................................. 545
            Section 125.3: Inheriting constructors ...................................................................................................................... 546
            Chapter 126: Typedef and type aliases ......................................................................................................... 546
            Section 126.1: Basic typedef syntax ......................................................................................................................... 546
            Section 126.2: More complex uses of typedef ........................................................................................................ 547
            Section 126.3: Declaring multiple types with typedef ............................................................................................ 547
            Section 126.4: Alias declaration with "using" .......................................................................................................... 547
            Chapter 127: Layout of object types .............................................................................................................. 548
            Section 127.1: Class types .......................................................................................................................................... 548
            Section 127.2: Arithmetic types ................................................................................................................................ 550
            Section 127.3: Arrays ................................................................................................................................................. 551
            Chapter 128: C incompatibilities ........................................................................................................................ 551
            Section 128.1: Reserved Keywords ........................................................................................................................... 551
            Section 128.2: Weakly typed pointers ..................................................................................................................... 551
            Section 128.3: goto or switch .................................................................................................................................... 551
            Chapter 129: std::forward_list ........................................................................................................................... 551
            Section 129.1: Example .............................................................................................................................................. 552
            Section 129.2: Methods ............................................................................................................................................. 552
            Chapter 130: Optimization .................................................................................................................................... 553
            Section 130.1: Inline Expansion/Inlining ................................................................................................................... 553
            Section 130.2: Empty base optimization ................................................................................................................. 554
            Chapter 131: Semaphore ....................................................................................................................................... 554
            Section 131.1: Semaphore C++ 11 ............................................................................................................................... 554
            Section 131.2: Semaphore class in action ................................................................................................................ 555
            Chapter 132: Thread synchronization structures ..................................................................................... 556
            Section 132.1: std::condition_variable_any, std::cv_status .................................................................................... 556
            Section 132.2: std::shared_lock ................................................................................................................................ 556
            Section 132.3: std::call_once, std::once_ﬂag ........................................................................................................... 556
            Section 132.4: Object locking for ecient access. ................................................................................................. 557
            Chapter 133: C++ Debugging and Debug-prevention Tools & Techniques ................................. 558
            Section 133.1: Static analysis ..................................................................................................................................... 558
            Section 133.2: Segfault analysis with GDB .............................................................................................................. 559Section 133.3: Clean code ......................................................................................................................................... 560
            Chapter 134: Futures and Promises ................................................................................................................ 562
            Section 134.1: Async operation classes .................................................................................................................... 562
            Section 134.2: std::future and std::promise .............................................................................................................. 562
            Section 134.3: Deferred async example .................................................................................................................. 562
            Section 134.4: std::packaged_task and std::future ................................................................................................. 563
            Section 134.5: std::future_error and std::future_errc ............................................................................................. 563
            Section 134.6: std::future and std::async .................................................................................................................. 564
            Chapter 135: More undeﬁned behaviors in C++ ......................................................................................... 566
            Section 135.1: Referring to non-static members in initializer lists ......................................................................... 566
            Chapter 136: Mutexes .............................................................................................................................................. 566
            Section 136.1: Mutex Types ....................................................................................................................................... 566
            Section 136.2: std::lock ............................................................................................................................................... 566
            Section 136.3: std::unique_lock, std::shared_lock, std::lock_guard ...................................................................... 566
            Section 136.4: Strategies for lock classes: std::try_to_lock, std::adopt_lock, std::defer_lock ........................... 567
            Section 136.5: std::mutex ........................................................................................................................................... 568
            Section 136.6: std::scoped_lock (C++ 17) ................................................................................................................. 569
            Chapter 137: Unit Testing in C++ ....................................................................................................................... 569
            Section 137.1: Google Test ......................................................................................................................................... 569
            Section 137.2: Catch ................................................................................................................................................... 570
            Chapter 138: Recursive Mutex ............................................................................................................................ 571
            Section 138.1: std::recursive_mutex .......................................................................................................................... 571
            Chapter 139: decltype ............................................................................................................................................. 571
            Section 139.1: Basic Example .................................................................................................................................... 571
            Section 139.2: Another example ............................................................................................................................... 572
            Chapter 140: Using std::unordered_map .................................................................................................... 572
            Section 140.1: Declaration and Usage ..................................................................................................................... 572
            Section 140.2: Some Basic Functions ...................................................................................................................... 572
            Chapter 141: Digit separators ............................................................................................................................ 573
            Section 141.1: Digit Separator .................................................................................................................................... 573
            Chapter 142: C++ function "call by value" vs. "call by reference" .................................................. 573
            Section 142.1: Call by value ....................................................................................................................................... 573
            Chapter 143: Basic input/output in c++ ........................................................................................................ 574
            Section 143.1: user input and standard output ....................................................................................................... 574
            Chapter 144: Stream manipulators ................................................................................................................ 575
            Section 144.1: Stream manipulators ......................................................................................................................... 575
            Section 144.2: Output stream manipulators ........................................................................................................... 580
            Section 144.3: Input stream manipulators .............................................................................................................. 581
            Chapter 145: C++ Containers .............................................................................................................................. 583
            Section 145.1: C++ Containers Flowchart ................................................................................................................. 583
            Chapter 146: Arithmitic Metaprogramming ................................................................................................ 583
            Section 146.1: Calculating power in O(log n) ........................................................................................................... 583
~/Empire/Doks/Comp/lang/clangs/cpp/O'Reilly - Practical C++ Programming.pdf


--
cpp gamedev(??(|!!))
Table of Contents
~/Empire/Doks/Comp/Gamedev/cppgamedevcb.txt (??)
            C++ Game Development Cookbook
            1 - Game Development Basics ----
            Installing an IDE on Windows
            eT tty Masel
            kek ok: (Omir
            aan Led, oe
            Choosing the right source control tool
            petty Meet
            Using call stacks for memory storage
            etl meceleyy
            momo Lee
            OT AME bY
            Cen Le) doe
            teem tle) ce
            Using pointers to store memory addresses
            eT meceleyy
            CeCe) eee
            Bate tle) coe
            Casting between different datatypes
            eT Meee
            etl aace ley
            ole (on Lee
            Ble el ce
            Understanding the error messages
            Using bitwise operations for advanced checks and optimization
            eT tlay-meateh
            Using classes for data encapsulation and abstraction
            eT lace ley
            amok? (on oe
            Using polymorphism to reuse code
            eT iilay-maerlohy
            Using copy constructors
            eT litre)
            i [od A Soe [o See
            Lo) Le) doe
            Use operator overloading to reuse operators
            eT Lt Merle
            bao (Lee
            Use function overloading to reuse functions
            petty Masel
            Using files for input and output
            eT Meee
            Creating your first simple game
            eT mceleyy
            Templates - when to use them
            Colma Le) oem
            3 - Data Structures in Game Development ----
            Using more advanced data structures
            eT tty Masel
            memo Loe
            lol Ce) eee
            Using linked lists to store data
            petty Meet
            OTF aie Ce Cm OC KomeE LE]
            eT meceleyy
            aoa oke (On Loe
            Coa Le) doe
            Using queues to store data
            petty Mace Le
            Using trees to store data
            | mk La 0) dP
            OT el ie ce lke 1 Ee]
            eT mcceley
            Using STL lists to store data
            pert Meee
            Using STL maps to store data
            eT lime leyy
            pa CoN cee [o RL ee
            Using STL hash tables to store data
            petty Marte
            ba Ceo Loe See
            4 - Algorithms for Game Development ----
            OE Tty Mela de create [ese ed Me ty fom SL
            Using searching techniques to look for an item
            eT ilay-macrlehy
            momen Loe
            Finding the complexity of an algorithm
            eT litre)
            La CoCo fo Lee
            Finding the endian-ness of a device
            eT Lt Merle
            Coan C0) doe
            Using dynamic programming to break down a complex problem
            petty Masel
            fa kekWa ok: (om Loe
            Using greedy algorithms to solve problems
            eT Meee
            Using divide and conquer algorithms to solve problems
            etl mace ley
            alm cok (on Lee
            eek aCe) ee
            5 - Event-Driven Programming - Making Your First 2D Game ----
            Starting to make a Windows game
            petty Marte
            ba Ceo Loe See
            Using Windows classes and handles
            eT tLe McsrLeh
            aCe) an C0) doe
            Creating your first window
            eT Ly Meee
            Adding keyboard and mouse controls with text output
            etl meceleyy
            amok (on Lee
            OE TTiF AAT ire Cekn mel KA er OL
            Cen Le) doe
            Using dialogs and controls
            eT tlat-meceteh
            | key La Le) de
            Using sprites
            eT maceleyy
            aoe? (on Loe
            Using animated sprites
            eT tlat-mesetehy
            meme (on Lee
            6 - Design Patterns for Game Development ----
            Using the singleton design pattern
            petty McseLe
            Con Le) doe
            Using the factory method
            eT tlay-mccrtehy
            meme (on Looe
            mk ia Le) doe
            Using the abstract factory method
            amok (on oe
            Using the observer pattern
            Tai tlat-Mesteh
            momen Loe
            Nn AU eR avera sta
            eT litre)
            La CoCo fo Lee
            OES t Malema) Lota
            eT Lt Merle
            Coan C0) doe
            Using the command design pattern
            petty Masel
            fa kekWa ok: (om Loe
            Creating an advanced game using design patterns
            eT Meee
            7 - Organizing and Backing Up ----
            Versions of source control
            eT lime leyy
            pa Ceo CoM Lee
            Installing a versioning client
            petty Marte
            Selecting a host to save your data
            eT tLe McsrLeh
            kek Cok: (on oe
            Co) an C0) doe
            eT Ly Meee
            Resolving conflicts
            etl meceleyy
            momo Lee
            eee Meta
            8 - AI in Game Development ----
            Adding artificial intelligence to a game
            petty Masel
            mem oke (on Loe
            Using heuristics in a game
            eT Meee
            Using a Binary Space Partition Tree
            eT mceleyy
            amok (on Lee
            Creating a decision making Al
            Can Ce) doe
            Adding behavioral movements
            eT tlay-meceteh
            lomo (on Lee
            mk La Le) de
            Using neural network
            atmo (on oe
            PORT ik ae fatto Feed a
            Tai tlat-Mcartoh
            momen Loe
            Step 2 (Fitness function)
            Soe eee als
            Step 4 Mutate
            eT Lt Merle
            ba eNO Lom Lee
            Coan C0) doe
            9 - Physics in Game Development ----
            Using physics rules in your game
            eT maceleyy
            aoe? (on Loe
            Making things collide
            eT tlat-mesetehy
            elem cok (on Loe
            Installing and integrating Box2D
            eT lima leyy
            pa Cele (oRL
            Making a basic 2D game
            eT Lt Mert
            Coma Ce) doe
            Making a 3D game
            eT Lt Masel
            Cela C0) doe
            pete AE Late oa)
            petty MeL
            momo (on Looe
            etl meceleyy
            amok (on Lee
            10 - Multithreading in Game Development ----
            eects Mie ne Rte tl
            eT Lt Merle
            Coan C0) doe
            Joining and detaching a thread
            petty Masel
            fa kekWa ok: (om Loe
            Passing arguments to a thread
            eT Meee
            Avoiding deadlocks
            eT mceleyy
            amok (on Lee
            DEVE Meese Mase
            Can Ce) doe
            Writing a thread-safe class
            eT tlay-meceteh
            lomo (on Lee
            mk La Le) de
            11 - Networking in Game Development ----
            Understanding the different layers
            petty Meet
            eT meceleyy
            aoa eke (On Lee
            Serializing the packets
            Using socket programming in games
            eT tlat-meartehy
            Sending the data
            eT mceley
            Xero LF aa ome ee]
            Tai tlat-masetehy
            elem cok (on Loe
            exe Ars
            eT lima leyy
            pa Cele (oRL
            Using synchronized simulation
            eT Lt Mert
            Using area of interest filtering
            eT Lt Masel
            Cela C0) doe
            Using local perception filter
            petty MeL
            momo (on Looe
            12 - Audio in Game Development ----
            Installing FMOD
            eT litre)
            La CoCo fo Lee
            Adding background music
            eT Lt Merle
            ba eNO Lom Lee
            Coan C0) doe
            Adding sound effects
            petty Masel
            mem oke (on Loe
            Creating a sound effect manager
            eT Meee
            Dealing with multiple sound file names
            eT mceleyy
            amok (on Lee
            13 - Tips and Tricks ----
            Effectively commenting your code
            eT tty Mert
            ba Ceo LoL
            Cen C0) doe
            Using bit fields in a struct
            eT tty Masel
            memo Loe
            aan Led, oe
            Writing a sound technical design document
            petty Meet
            eT meceleyy
            aoa oke (On Loe
            Using bit shift operators in an enum
            petty Mace Le
            Using the new lambda function of C++ 11
            Index

