set foldmethod=indent foldlevel=2
vim: fdm=indent:fdl=2:

  ## ~/Dropbox/rsc/data/lists/ref/comp/lang/java/kotlin.txt
## ~/Dropbox/rsc/data/lists/ref/comp/lang/webdev/mob.kotlandr-jetpack.functionslist-bytutlevel.txt

~/Empire/Doks/Comp/lang/java/android/kotlin/cheatsh-qref/kotlin.cheatsh.pdf
            Learn Kotlin with us: www.kt.academy

            Basics:
            "Hello, World" program

            fun main(args: Array<String>) {
              println("Hello, World")
            }

            Declaring function:
            fun sum(a: Int, b: Int): Int {
              return a + b
            }

            Single-expression function:
            fun sum(a: Int, b: Int) = a + b

            Declaring variables:
            val name = "Marcin" // Can't be changed
            var age = 5         // Can be changed
            age++

            Variables with nullable types:
            var name: String? = null
            val length: Int
            length = name?.length ?: 0
            // length, or 0 if name is null
            length = name?.length ?: return
            // length, or return when name is null
            length = name?.length ?: throw Error()
            // length, or throw error when name is null

            Control Structures
            If as an expression
            fun bigger(a: Int, b: Int) = if (a > b) a else b

            For loop
            val list = listOf("A", "B", "C")
            for (element in list) {
              println(element)
            }

            When expression
            fun numberTypeName(x: Number) = when(x) {
              0 -> "Zero"                // Equality check
              in 1..4 -> "Four or less"  // Range check
              5, 6, 7 -> "Five to seven" // Multiple values
              is Byte -> "Byte"          // Type check
              else -> "Some number"
            }

            When expression with predicates
            fun signAsString(x: Int)= when {
              x < 0 -> "Negative"
              x == 0 -> "Zero"
              else -> "Positive"
            }

            CLASSES:
            Primary constructor

            val declares a read-only property, var a mutable one
            class Person(val name: String, var age: Int)
            // name is read-only, age is mutable

            Inheritance:
            open class Person(val name: String) {
              open fun hello() = "Hello, I am $name"
              // Final by default so we need open
            }
            class PolishPerson(name: String) : Person(name) {
              override fun hello() = "Dzień dobry, jestem $name"
            }

            Properties with assessors:
            class Person(var name: String, var surname: String) {
              var fullName: String
                get() = "$name $surname"
                set(value) {
                  val (first, rest) = value.split(" ", limit = 2)
                  name = first
                  surname = rest
                }
            }

            Data classes:
            data class Person(val name: String, var age: Int)
            val mike = Person("Mike", 23)

            Modifier data adds:
            1. toString that displays all primary constructor properties
            print(mike.toString()) // Person(name=Mike, age=23)

            2. equals that compares all primary constructor properties
            print(mike == Person("Mike", 23)) // True
            print(mike == Person("Mike", 21)) // False

            3. hashCode that is based on all primary
            constructor properties
            val hash = mike.hashCode()
            print(hash == Person("Mike", 23).hashCode()) // True
            print(hash == Person("Mike", 21).hashCode()) // False

            4. component1, component2 etc. that allows deconstruction
            val (name, age) = mike
            print("$name $age") // Mike 23

            5. copy that returns copy of object with concrete properties changed
            val jake = mike.copy(name = "Jake")

            Collection Literals:
            listOf(1,2,3,4) // List<Int>
            mutableListOf(1,2,3,4) // MutableList<Int>

            setOf("A", "B", "C") // Set<String>
            mutableSetOf("A", "B", "C") // MutableSet<String>

            arrayOf('a', 'b', 'c') // Array<Char>

            mapOf(1 to "A", 2 to "B") // Map<Int, String>
            mutableMapOf(1 to "A", 2 to "B")
            // MutableMap<Int, String>

            sequenceOf(4,3,2,1) // Sequence<Int>

            1 to "A" // Pair<Int, String>

            List(4) { it * 2 } // List<Int>
            generateSequence(4) { it + 2 } // Sequence<Int>

            Collection Processing:
            students
              .filter { it.passing && it.averageGrade > 4.0 }
              // Only passing students
              .sortedByDescending { it.averageGrade }
              // Starting from ones with biggest grades
              .take(10) // Take first 10
              .sortedWith(compareBy({ it.surname }, { it.name }))
              // Sort by surname and then name

            generateSequence(0) { it + 1 }
            // Infinitive sequence of next numbers starting on 0
              .filter { it % 2 == 0 } // Keep only even
              .map { it * 3 } // Triple every one
              .take(100) // Take first 100
              .average() // Count average

            Most important functions for collection processing
            val l = listOf(1,2,3,4)
            filter - returns only elements matched by predicate
            l.filter { it % 2 == 0 } // [2, 4]
            map - returns elements after transformation
            l.map { it * 2 } // [2, 4, 6, 8]
            flatMap - returns elements yielded from results of trans.
            l.flatMap { listOf(it, it + 10) } // [1, 11, 2, 12, 3, 13, 4, 14]
            fold/reduce - accumulates elements
            l.fold(0.0) { acc, i -> acc + i } // 10.0
            l.reduce { acc, i -> acc * i } // 24
            forEach/onEach - perfoUPs an action on every element
            l.forEach { print(it) } // Prints 1234, returns Unit
            l.onEach { print(it) } // Prints 1234, returns [1, 2, 3, 4]
            partition - splits into pair of lists
            val (even, odd) = l.partition { it % 2 == 0 }
            print(even) // [2, 4]
            print(odd) // [1, 3]
            min/max/minBy/maxBy
            l.min() // 1, possible because we can compare Int
            l.minBy { -it } // 4
            l.max() // 4, possible because we can compare Int
            l.maxBy { -it } // 1
            first/firstBy
            l.first() // 1
            l.first { it % 2 == 0 } // 2 (first even number)
            count - count elements matched by predicate
            l.count { it % 2 == 0 } // 2
            sorted/sortedBy - returns sorted collection
            listOf(2,3,1,4).sorted() // [1, 2, 3, 4]
            l.sortedBy { it % 2 } // [2, 4, 1, 3]
            groupBy - group elements on collection by key
            l.groupBy { it % 2 } // Map: {1=[1, 3], 0=[2, 4]}
            distinct/distinctBy - returns only unique elements
            listOf(1,1,2,2).distinct() // [1, 2]

            Mutable vs immutable collection processing functions
            val list = mutableListOf(3,4,2,1)
            val sortedResult = list.sorted() // Returns sorted
            println(sortedResult) // [1, 2, 3, 4]
            println(list) // [3, 4, 2, 1]
            val sortResult = list.sort() // Sorts mutable collection
            println(sortResult) // kotlin.Unit
            println(list) // [1, 2, 3, 4]


            EXTENSION FUNCTIONS TO ANY OBJECT
            Returns

            Receiver

            Results of lambda

            Reference to receiver

            it

            also

            let


            this

            apply

            run/with

            val dialog = Dialog().apply {
              title = "Dialog title"
              onClick { print("Clicked") }
            }


            FUNCTIONS

            Function types:
            ()->Unit - takes no arguments and returns nothing (Unit).
            (Int, Int)->Int - takes two arguments of type Int and returns Int.
            (()->Unit)->Int - takes another function and returns Int.
            (Int)->()->Unit - takes argument of type Int and returns function.

            Function literals:
            val add: (Int, Int) -> Int = { i, j -> i + j }
            // Simple lambda expression

            val printAndDouble: (Int) -> Int = {
              println(it)
              // When single parameter, we can reference it using `it`
              it * 2 // In lambda, last expression is returned
            }

            // Anonymous function alternative
            val printAndDoubleFun: (Int) -> Int = fun(i: Int): Int {
              println(i)   // Single argument can't be referenced by 'it'
              return i * 2 // Needs return like any function
            }

            val i = printAndDouble(10) // 10
            print(i) // 20

            Extension functions:
            fun Int.isEven() = this % 2 == 0
            print(2.isEven()) // true

            fun List<Int>.average() = 1.0 * sum() / size
            print(listOf(1, 2, 3, 4).average()) // 2.5

            DELEGATES
            Lazy - calculates value before first usage
            val i by lazy { print("init "); 10 }
            print(i) // Prints: init 10
            print(i) // Prints: 10

            notNull - returns last setted value, or throws error if no value has been set

            observable/vetoable - calls function every time
            value changes. In vetoable function also decides
            if new value should be set.
            var name by observable("Unset") { p, old, new ->
              println("${p.name} changed $old -> $new")
            }
            name = "Marcin"
            // Prints: name changed Unset -> Marcin

            Map/MutableMap - finds value on map by property name
            val map = mapOf("a" to 10)
            val a by map
            print(a) // Prints: 10

            VISIBILITY MODIFIERS:
            Modifier

            Class members

            Top-level

            Public (default)

            Visible everywhere

            Visible everywhere

            Private

            Visible only in the same class

            Visible in the same file

            Protected

            Visible only in the same class and subclasses

            Not allowed

            Internal

            Visible in the same module if class is accessible

            Visible in the same module


            VARIANCE MODIFIERS

            Number

            Int


            Invariance
            class Box <T>

            Box<Number>

            Box<Int>


            Covariance

            class Box <out T>

            Box<Number>

            Box<Int>


            Contravariance

            class Box <in T>

            Box<Number>

            Box<Int>

            Learn Kotlin with us: www.kt.academy
~/Empire/Doks/Comp/lang/java/android/kotlin/cheatsh-qref/kotlin.cheatsh-qref.pdf
            Declaring Variables
            var mutable: Int = 1
            mutable = 2 // OK: You can reassign a var.
            val immutable: Double = 2.0
            // immutable = 3.0 // Error: You can't reassign a val!
            var greeting = "Hello, world!" // Inferred as String
            var catchphrase: String? = null // Nullable type
            catchphrase = "Hey, what's up, everybody?"

            Nullable Types
            var name: String? = null // Can hold a String or null
            // Safe cast operator ?.
            // length1 contains name's length if name isn't null; null otherwise
            val length1: Int? = name?.length
            // Elvis operator ?:
            // length1 contains name's length if name isn't null: 0 otherwise
            val length2: Int = name?.length ?: 0
            // The Elvis operator can also execute statements in the case of null values.
            val length3 = name?.length ?: return
            // Non-null assertion operator !!
            name = "Francis"
            val length4: Int = name!!.length // Works if name isn't null; crashes otherwise
            // Smart casts and checking for null
            var nonNullableAuthor: String
            var nullableAuthor: String?
            if (name != null) { // Checking for null
              nonNullableAuthor = name // Smart cast to String
            } else {
              nullableAuthor = name // Smart cast to String?
            }

            Control Flow: if expression
            // Using if to choose different paths
            var condition = true
            if (condition) {
              // If condition is true, this gets executed
            } else {
              // If condition is false, this gets executed
            }
            // Using if to set a value
            val x = 100
            valy = 1
            val more = if (x > y) x else y // more == 100
            val less = if (x < y) {
              println("x is smaller.")
              x // The last expression is the block's value
            } else {
              println("y is smaller.")
              y
            }

            Control Flow: when expression
            // Using when to choose different paths
            val year = 2010
            when (year) {
              2010 -> print("Froyo")
              2011 -> print("Ice Cream Sandwich")
              2008, 2009 -> print("The early days")
              in 2012..2015 -> {
                println("Jellybean through Marshmallow,")
                println("when things got interesting.")
              }
              else -> println("Some other era")
            }
            // Using when to set a value
            val androidEra = when (year) {
              2010 -> "Froyo"
              2011 -> "Ice Cream Sandwich"
              2008, 2009 -> "The early days"
              in 2012..2015 -> {
                print("Jellybean through Marshmallow")
                // The last expression is the block's value
                "When things got interesting"
              }
              else -> "Some other era"
            }
            // Using when with conditionals to set a value
            val catsOwned = 2
            val dogsOwned = 1
            val judgement = when {
              catsOwned == 0 -> "No cats"
              catsOwned < 0 -> {
                print("Call the cat police!")
                // The last expression is the block's value
                "Owes someone some cats"
              }
              catsOwned == 1 && dogsOwned == 1 ->
                "Seeking balance"
              catsOwned > 0 && catsOwned < 3 -> "Yay cats!"
              else -> "Cat Nirvana"
            }

            Collections: List
            val immutableList = listOf("Alice", "Bob")
            val valMutableList = mutableListOf("Carol", "Dave")
            var varMutableList = mutableListOf("Eve", "Frank")
            // One way to test membership
            val isBobThere1 = "Bob" in immutableList
            // Another way to test membership
            val isBobThere2 = immutableList.contains("Bob")
            val name: String = immutableList[0] // Access by index
            valMutableList[1] = "Bart" // Update item in list
            // immutableList[1] = "Bart" // Error: Can't change
            valMutableList.add(2, "Ellen") // Add item at index
            // Delete by index
            val removedPerson = valMutableList.removeAt(1)
            // Delete by value
            val wasRemoved = valMutableList.remove("Bart")
            // You can change the contents of a val mutable collect but you CAN'T reassign it:
            // You can change the contents of a var mutable collection, and you CAN reassign it:
            varMutableList[0] = "Ellen"
            varMutableList = mutableListOf("Gemma", "Harry")
            Collections: Map
            val immutableMap = mapOf("name" to "Kirk", "rank" to "captain")
            val mutableMap = mutableMapOfC("name" to "Picard", "rank" to "captain")
            // Is this key in the map?
            val hasRankKey = immutableMap.containsKey("rank")
            // Is this value in the map?
            val hasKirkValue = immutableMap.containsValue("Kirk")
            // Access by key, returns nullable
            val name: String? = immutableMap["name"]
            // Update value for key
            mutableMap["name"] = "Janeway"
            // Add new key and value
            mutableMap["ship"] = "Voyager"
            mutableMap.remove("rank") // Delete by key
            // Delete by key and value
            mutableMap.remove("ship", "Voyager")
            // Won't work, value doesn't match
            mutableMap.remove("name", "Spock")
            Collections: Set
            // Sets ignore duplicate items, so immutableSet has 2 items: "chocolate" and "vanilla"
            val immutableSet = setOf<String>C"chocolate", "vanilla", "chocolate")
            val mutableSet = mutableSetOf("butterscotch", "strawberry")
            // One way to test membership
            val hasChocolate1 = "chocolate" in immutableSet
            // Another way to test membership
            val hasChocolate2 = imnutableSet.contains("chocolate")
            mutableSet.add("green tea") // Add item
            // Delete by value
            val flavorWasRemoved = mutableSet.remove("strawberry")
            Control Flow: loops
            // Iterate over list or set
            for (item in listOrSet) {
              println(item)
            }
            // Iterate over map
            for (key, value) in myMap) {
              println("$key -> $value")
            }
            // Iterating over ranges
            for (i in 0..10) {} // 0 to 10
            for (i in 0 until 10) {}  // 0 to 9
            for (i in 1..10 step 2)  {} // 1, 3, 5, 7, 9
            for (i in 10 downTo 1) {} // 10 to 1
            // while and do while
            var x = 0
            while (x < 10) {
              x++
              println(x)
            }
            do {
              x--
              println(x)
            } while (x > 0)

            Functions
            fun sayHi() { // A Unit function
              println("Hello")
            }
            // Function with parameters
            fun sayHello(name: String) {
              println("Hello, $name!")
            }
            // Function with default arguments
            fun sayFriendlyHello(name: String = "Friend") {
              print("Hello, $name!")
            }
            // Function with mix of regular and default arguments
            fun createCat(name: String = "Kitty", age: Int, isSpayed: Boolean = false) {
              print("$name / $age / $isSpayed")
            }
            createCat(age = 1) // Using just the non-default argument
            createCat("Fluffy", 2, true) // One way to call a function
            // Calling a function with named arguments
            createCat(age = 2, isSpayed = true, name = "Fluffy")
            // Function with parameters and return value
            fun total(x: Int, y: Int): Int {
              return x + y
            }
            // A function as a single expression
            fun product(x: Int, y: Int) = x * y
            // A function that accepts another function
            fun doMathCmathOperation: (Int, Int) -> Int, a: Int, b: Int):
            Int {
              return mathOperation(a, b)
            }
            // Calling a function that accepts another function
            val add = doMath(::total, 2, 3)
            val multiply = doMath(::product, 2, 3)
            Lambdas
            // Lambda
            val adder: (Int, Int) -> Int = { x, y -> x + y}
            // Lambda with single parameter: it keyword
            val square: (Int) -> Int = { it * it }
            // Passing a lambda to a function
            val addWithLambda = doMath(adder, 2, 3)

            Extensions
            // Add the "fizzbuzz()" function to the Int class
            fun Int.fizzBuzz(): String {
              return when {
                this % 3 == 0 -> "fizz"
                this % 5 == 0 -> "buzz"
                this % 15 == 0 -> "fizzbuzz"
                else -> this.toString()
              }
            }
            println(6.fizzBuzz()) // Prints "fizz"
            println(8.fizzBuzz()) // Prints "8"
            // Add the "absValue" property to the Int class
            val Int.absValue: Int
              get() = abs(this)
            println(-3).absValue) // Prints "3"

            Objects
            // Only a single instance exists
            // Takes the place of static utility classes
            object Constants {
              const val baseUrl = "http://api.raywenderlich.com"
            }

            Classes
            class Spaceship(var name: String, val size: Int) {
              var speed: Int = 0
              fun fly() {
                speed = 100
              }
              fun isFlying(): Boolean {
                return speed > 0
              }
              // Companion object replaces static members
              companion object {
                fun newSpaceship(): Spaceship {
                  return Spaceship("Falcon", 25)
                }
              }
            }
            val myShip = Spaceship("Enterprise", 150)
            myShip.fly()
            val flying = myShip.isFlying()
            class Sailor(var rank: String, var lastName: String) {
              // Class properties with accessors
              var fullName: String
                get() = "$rank $lastName"
                set(value) {
                  val (firstWord, remainder) = value.split(" ", limit = 2)
                  rank = firstWord
                  lastName = remainder
                }
            }
            // Subclassing: only open classes can be subclassed
            open class Crewmember(val name: String) {
              // Only open methods can be overridden
              open fun sayHello() = "Hello, I'm crewmember $name."
            }
            // Subclassing
            class Captain(name: String): CrewmemberCname) {
              override fun sayHello() = "Greetings! I am Captain $name."
            }

            Data Classes
            // A data class is a structured data container
            // with pre-defined toString() and other overrides
            data class Student(val name: String, var year: Int)
            // name is a read-only property, year is mutable
            val newStudent = Student("Siddartha", 1)
            // Data class with properties outside the constructor
            data class Professor(val name: String) {
              var isTenured: Boolean = false
            }
            val newProfessor = Professor(" Snape")
            newProfessor.isTenured = true

            Enum Classes
            enum class Taste {
              SWEET, SOUR, SALTY, BITTER, UMAMI
            }
            val vinagerTaste: Taste = Taste.UMAMI
            // Iterating through an enum class
            for (flavor in Taste.values()) {
              print("Taste: ${flavor.ordinal}: ${flavor.name}")
            }

            Sealed Classes
            // Like enum classes, but can make multiple instances
            sealed class Shape {
              class Circle(val radius: Int): Shaped)
              class Square(val sideLength: Int): Shaped)
            }
            val circle1 = Shape.Circle(3)
            val circle2 = Shape.Circle(42)
            val square = Shape.Square(5)
https://developer.android.com/studio/intro/keyboard-shortcuts [!!]
  ~/Empire/Doks/Comp/lang/java/android/kotlin/kotlin-riptut.pdf

~/Empire/Doks/Comp/lang/java/android/kotlin/funct/functkotl_2018.txt !!
~/Empire/Doks/Comp/lang/java/android/kotlin/funct/kotlfunct_2021.txt !!

~/Empire/Doks/Comp/lang/java/android/kotlin/kotlincb_2020.txt  !!!!
--
~/Dropbox/rsc/data/lists/ref/comp/lang/java/kotlincb.txt
~/Empire/Doks/Comp/lang/java/android/kotlin/kotlincb_2018.txt
            1 - Installation and Working with Environment ----
                Creating Kotlin Android project
                How to use Gradle to run Kotlin code
                How to run a Kotlin compiled class
                How to build a self-executable JAR with Gradle and Kotlin
                Reading console input in Kotlin
                Converting Java code to Kotlin and vice versa
                How to write an idiomatic logger in Kotlin
                Escaping for Java identifiers that are keywords in Kotlin
                Disambiguating using the "as" keyword to locally rename the clashing entity
                Doing bit manipulations in Kotlin
                    Or
                    and
                    xor
                    inv
                    shl
                    shr
                    ushr
                Parsing String to Long, Double, or Int
                    Converting String to Long
                    Converting string to Long using string.toLongOrNull()
                        Converting with special radix
                    Parsing string to Long with special radix
                Using String templates in Kotlin
            2 - Control Flow ----
                Assigning result to an expression using the if keyword
                Using range with the when expression
                Using when with custom objects
                Using try-catch as an expression
                How to write a swap function in Kotlin using the also function
                How to throw a custom exception in Kotlin
                How to make a multiconditional loop in Kotlin
            3 - Classes and Objects ----
                Initializing body of constructor
                Converting one data type into another
                How to type check an object
                How to work with an abstract class in Kotlin
                How to iterate over a class's properties in Kotlin
                How to work with inline properties
                How to work with nested class
                Getting class in Kotlin
                Working with delegated properties
                Working with enums
            4 - Functions ----
                Specifying default values in functions
                Using named arguments in functions
                Creating the RecyclerView Adapter in Kotlin
                Creating getter setters in Kotlin
                Passing variable arguments to a function
                Passing a function as a parameter to another
                Declaring a static function
                Using the use keyword in Kotlin
                Working with closures
                Function literals with receivers
                Working with anonymous functions
            5 - Object-Oriented Programming ----
                Working with interfaces in Kotlin
                How to implement complicated interfaces with multiple overridden methods in Kotlin
                How to extend a class in Kotlin (Inheritance and Extension functions)
                    Extension functions
                How to work with Generics in Kotlin
                How to implement polymorphism in Kotlin
                Restricting class hierarchies
            6 - Collections Framework ----
                How to merge two collections
                Splitting original collection into pair of collections
                Sorting a list by specified comparator
                Sorting in descending order
                Parsing a JSON response using Gson
                How to filter and map using lambda expressions
                How to sort a list of objects and keep null objects at the end
                How to implement a lazy list in Kotlin
                How to pad a string in Kotlin
                How to flatten an array or map
                How to sort collection by multiple fields in Kotlin
                How to use limit in Kotlin list
                How to create a 2D array in Kotlin
                How to skip the first "n" entries in Kotlin
            7 - Handling File Operations in Kotlin ----
                Reading from files using InputReader
                Reading all lines in a file using InputReader
                Reading line by line using InputReader
                Reading from files using BufferedReader
                Reading all lines in a file using BufferedReader
                Reading string and JSON over network
            8 - Anko Commons and Extension Function ----
                Setting up Anko with Gradle
                Extending Android framework using extension function
                Using extensions as properties
                Using intents with Anko
                Making a call intent using Anko
                Sending a text intent using Anko
                Browsing the web browser using Anko
                Sharing some text using intents in Anko
                Sending an email using Anko
                Creating Android dialogs with Anko
                Showing an alert dialog with a list of text items
                Using Anko in Views
                Logging using Anko
                Handling dimensions with Anko
                Version checking on Android
            9 - anko Layouts ----
                Setting up Anko library for Anko layouts in Gradle
                Creating user-interface programmatically
                Working with the old code of XML layouts
                Using the provided AnkoComponent interface
                Setting theme for Android views in Anko
                Setting layout parameters for Anko views
                Adding listeners to Anko views
                Inserting XML layouts into DSL
                Converting XML files into DSL
                Showing Snackbar
                Showing Toasts
                Accessing views using synthetic properties
                Accessing views of view groups using extension functions
            10 - Databases and Dependency Injection ----
                Using SQLite database in Kotlin
                Creating database tables
                Injecting dependencies in Kotlin
                Reading data from database
                Converting database cursor into list of objects
                Using parseOpt for nullable object
                Inserting data into database
                Creating singletons in Kotlin
                Using Dagger 2 with Kotlin
                Using Butterknife with Kotlin
            11 - Networking and Concurrency ----
                How to fetch data over network
                How to create data class in Kotlin
                How to copy data class with modifications
                How to parse JSON data from network to data class
                How to download a file in Kotlin
                How to use RxJava and Retrofit with Kotlin
                How to make an endless list using RecyclerView
                How to use Anko to run background tasks with Kotlin in Android
                How to use coroutines to achieve multithreading
            12 - Lambdas and Delegates ----
                Click listeners using lambdas
                Using lazy delegate in Kotlin
                Using the observable delegate
                Using vetoable delegate
                Writing your own delegates
                Using the lateinit modifier
                Working with SharedPreferences
                Creating a chain of multiple lets in Kotlin
                Creating global variables
            13 - Testing ----
                Unit testing Kotlin code
                Unit testing with Mockito
                    Spy object
                    Mockito limitations
                Running instrumentation tests
                Writing JUnit rules in Kotlin (@Rule)
                Acceptance tests using Espresso Kotlin
                Writing assertEquals in Kotlin
            14 - web Services with Kotlin ----
                How to run the application on Tomcat
                Setting up dependencies for building RESTful services
                How to create a REST controller
                Creating the Application class for Spring Boot
            ----
            Reactive Programming in Kotlin
            Rivu Chakraborty
            ISBN: 978-1-78847-302-6
            - Learn about reactive programming paradigms and how reactive
            programming can improve your existing projects
            - Gain in-depth knowledge in RxKotlin 2.0 and the ReactiveX
            Framework
                evince -p 1348 ~/Empire/Doks/Comp/lang/java/android/kotlin/kotlincb.pdf &
            - Use RxKotlin with Android
            - Create your own custom operators in RxKotlin
            - Use Spring Framework 5.0 with Kotlin
            - Use the reactor-Kotlin extension
            - Build Rest APIs with Spring,Hibernate, and RxKotlin
            - Use testSubscriber to test RxKotlin applications
            - Use backpressure management and Flowables
            - Use new features to write structured and readable object-oriented
            code
            - Find out how to use lambdas and higher-order functions to write
            clean, reusable, and simple code
            - Write unit tests and integrate Kotlin tests with Java code in a
            transitioning code base
                evince -p 1351 ~/Empire/Doks/Comp/lang/java/android/kotlin/kotlincb.pdf &
            clean, reusable, and simple code
            Write unit tests and integrate Kotlin tests with Java code ina
            transitioning code base
            Write real-world production code in Kotlin in the style of
            microservices
            Leverage Kotlin's extensions to the Java collections library
            Use destructuring expressions and find out how to write your own
            Write code that avoids null pointer errors and see how Java-nullable
            code can integrate with features in a Kotlin code base
            Discover how to write functions in Kotlin, see the new features
            available, and extend existing libraries
            Learn to write an algebraic data types and figure out when they
            should be used
        ~/Empire/Doks/Comp/lang/java/android/kotlin/kotlin-androidappintro_2017.txt
   ~/Empire/Doks/Comp/lang/java/android/kotlin/kotlbybuildingandroidapps.txt  2018
            Get in touch
            Reviews
            Setting Up for Android Development
            Why&#xAo;develop Android with Kotlin?
            Solas
            Java interoperability
            Setting up your environment
            Java
            aks Tamia PDC
            Android Studio
            Installing&#xAo;Android Studio
            Getting Android Studio ready
            Choosing an SDK
            Building your project
            Gradle
            Parts of an Android project
            Running your app
            The Android emulator
            Creating an Android emulator
            Running from an emulator
            Running on an actual device
            Summary
            Configuring Your Environment for Kotlin
            Installing the Kotlin plugin
            Kotlin alongside Java?
            Kotlin to Java?
            Summary
            The user interface
            ,
            aa
            Building our game Ul
            Basic types
            Variables and constants
            Properties
            Summary
            Classes and Objects
            Structure of a class
            Constructors
            Data classes
            foley (Laie
            Summary
            Type Checks and Null Safety
            Null safety
            Nullable and non-nullable types
            Safe call operator
            The Elvis operator
            The !! operator
            Tyne checke
            Cast operator
            Summary
            Functions and Lambdas
            Functions
            ele tan cles)
            Higher&#x2013;0rder functions and lambdas
            Lambda expressions
            Implementing a game status check
            Summary
            Developing Your Location-Based Alarm
            Creating a project
            Generation of a Google Maps API key
            ror aT aN ay eat ae-12)
            Understanding the code
            Customizing the code
            Finding the Lat and Lng of a place
            The XML layout
            Neveloning a <creen for eer Innit
            The AndroidManifest file
            Build.gradle
            Summary
            Working with Google&#x27;s Location Services
            Integrating shared preferences
            Adding permissions
            Integration of the location API
            ER eer late m ela voles
            The Google API client
            Matching the location
            Sielaalaartay
            Connecting the Outside World &#x2013; Networking
            Network connectivity
            Manifest permissions
            Mel TSValieLe-loy
            Sync adapter
            Third-party libraries
            Dicacco
            User interface &#x2013; XML
            build.gradle
            Kotlin code
            Manifest permissions
            Glide
            build. gradle&#xAo;
            Kotlin code
            Summary
            Developing a Simple To-Do List App
            Creating the project
            Building your Ul
            Using the Android Studio layout editor
            Adding functionality to the user interface&#xAo;
            Adding a new task
            Displaying data in the ListView
            Updating/deleting a Todo item
            Adding a menu
            Summary
            Persisting with Databases
            Introduction to databases
            Relational databases
            OE TeF ee N ESS
            Inserting data into the database
            Retrieving data from the database
            Updating a task
            Pratl ae m4
            ORM libraries
            Retrieving data from the database
            Inserting data into the database
            Updating a task
            DYatdlay ae
            Non-relational databases
            Summary
            Setting Reminders for Tasks
            AlarmManager
            Creating the alarm
            Starting the reminder dialog
            BroadcastReceiver
            Sending broadcasts
            Creating a broadcast receiver
            Creating the AlarmService
            Creating an IntentService
            Firebase Cloud Messaging
            Integrating FCM
            STelaalane lay
            Testing and Continuous Integration
            Testing
            Importance of testing
            Model-View-Presenter architecture
            Test-Driven Development
            Functional versus non-functional testing
            Notes app
            Test dependencies
            Nom Ke
            Crashlytics
            Connect
            Stages of testing
            Alpha testing
            Beta testing
            Setting up for beta testing
            Creating the beta test track
            The opt-in URL
            Continuous integration
            Definition
            Tools
            Installing fastlane
            Summary
            Making Your App Available to the World
            Key store generation
            Key store generation through Android Studio
            Auto signing the APK through Android Studio
            Build types and flavors
            Key store generation through the command line
            Publishing the app in Google Play Store
            App release section
            Store listing section
            Ve es
            —
            sr ie
            Content rating section
            Pricing and distribution section
            Publishing the app in Amazon Appstore
            General information
            Availability &amp; Pricing section
            Description section
            Images &amp; Multimedia section
            Content Rating section
            Binary File(s) section
            Summary.
            Building an App Using the Google Faces API
            Introduction to Mobile Vision
            Faces API concepts
            Getting started &#x2013; detecting faces
            RSL Asal Oday dem Keyra
            Loading the image
            Creating a Paint instance
            Creatino a canvac
            Na SS a)
            21.
            Creating the face detector
            DY day mda
            Drawing rectangles on the faces
            Results
            Summary
            Other Books You May Enjoy
            Leave a review - let other readers know what you think
   ~/Empire/Doks/Comp/lang/java/android/kotlin/kotlandrprogr.mini.txt
            Agenda
            ➔
            ➔
            ➔
            ➔
            ➔
            ➔
            ➔
            ➔
            ➔
            ➔
            Background
            What is Kotlin?
            Perfect for Android
            Performance and cost
            Case study
            Migration guide
            Community adoption
            Current issues
            Future releases
            Summary
            Background
            Background
            ● Apple got a nice(r) new language
            ● Android stuck with Java
            ● Not fair!
            Problems with Java
            ● Missing modern features
            ○ Lambdas, properties, higher-order functions
            ● Null safety
            ○ NullPointerException
            ● Boilerplate code
            ● Features specific to JDK (and Android API)
            What is Kotlin?
            What is Kotlin?
            ● Named after island in St. Petersburg
            ● Programming language
            ○ Based on the JVM
            ○ Compact and modern ("better Java")
            ○ Open source
            ● Created by JetBrains
            ○ Built into Android Studio and IntelliJ IDEA
            ○ Used by JetBrains internally
            History
            ● Project Kotlin unveiled in July 2011
            ● Kotlin 1.0 released in February 2016
            ● "Language of the Month" - Dr. Dobb's Journal (01/2012)
            Syntax
            ●
            ●
            ●
            ●
            Types follow variable/function names
            Functions start with fun keyword
            Default constructor in class signature
            Semicolons not required
            class Foo(name: String) : Bar(name) {
            override fun makeStuff(): Stuff {
            return Stuff()
            }
            }
            Null safety
            KOTLIN
            JAVA
            var str1: String? = null
            str1?.trim() // doesn't run
            String str1 = null;
            str1.trim(); // runs and crashes
            str1 = "Not null anymore"
            str1?.trim() // does runs
            str1 = "Not null anymore";
            str1.trim(); // runs
            str1!!.trim() // runs anyway
            val str2: String = "I am not null"
            str2.trim() // no need for "?."
            String str2 = "I am not null";
            str2.trim(); // runs
            Lambdas
            KOTLIN
            fun evens(nums: List<Int>) = nums.filter { it % 2 == 0 }
            JAVA
            public List<Integer> evens(List<Integer> nums) {
            List<Integer> numsCopy = new ArrayList<>(nums);
            Iterator<Integer> numsItr = numsCopy.listIterator();
            while (numsItr.hasNext()) {
            Integer num = numsItr.next();
            if (num % 2 != 0) numsItr.remove();
            }
            return numsCopy;
            }
            Data classes
            KOTLIN
            data class Island(var name: String)
            JAVA
            public static class Island {
            private String mName;
            public Island(String name) { mName = name; }
            public String getName() { return mName; }
            public void setName(String name) { mName = name; }
            @Override public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Island island = (Island) o;
            return mName != null ? mName.equals(island.mName) : island.mName == null;
            }
            @Override public int hashCode() { return mName != null ? mName.hashCode() : 0; }
            }
            Properties in Java code
            // Java code
            public class Circle {
            private float mRadius;
            public float getRadius() { return mRadius; }
            public void setRadius(float radius) { mRadius = radius; }
            }
            // Kotlin code
            val circle = Circle()
            circle.radius = 1.5f // => circle.setRadius(1.5f)
            println(circle.radius) // => circle.getRadius()
            Sealed classes (algebraic data types)
            // Arithmetic expression
            sealed class Expr {
            class Const(val number: Double) : Expr()
            class Sum(val e1: Expr, val e2: Expr) : Expr()
            object NotANumber : Expr()
            }
            fun eval(expr: Expr): Double = when (expr) {
            is Expr.Const -> expr.number
            is Expr.Sum -> eval(expr.e1) + eval(expr.e2)
            Expr.NotANumber -> Double.NaN
            }
            Named/optional arguments
            // Argument "stroke" is optional
            fun circle(x: Int, y: Int, rad: Int, stroke: Int = 1) {
            ...
            }
            // Argument "rad" is named and "stroke" defaults to 1
            circle(0, 0, rad = 5)
            Extension functions
            // Extension to String
            fun String.encodeSpaces(): String {
            return this.replace(" ", "_")
            }
            println("one two three".encodeSpaces()) // output: one_two_three
            Perfect for Android
            Perfect for Android
            ●
            ●
            ●
            ●
            Android stuck with Java 6 or 7 (depending on API)
            Complete interop with Java
            Compact runtime
            Do more with less code
            Why not others?
            ● Scala
            ○ Huge runtime
            ○ Lots of garbage collection
            ● Groovy
            ○ Large runtime
            ○ Average tooling support
            ● Ceylon
            ○ Not much support for Android
            Android extensions
            ● View binding (like Butter Knife)
            ● No instance variables required
            ● How?
            ○ Import synthetic layout
            ■
            import kotlinx.android.synthetic.main.<layout>.*
            ○ Use view by ID
            ■
            E.g. txt_status.text = "OK"
            ○ Under the hood: synthetic calls replaced by functions
            Android extensions
            import kotlinx.android.synthetic.main.activity_main.*
            override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContentView(R.layout.activity_main)
            btn_go.setText(R.string.go)
            btn_go.setOnClickListener { v ->
            txt_status.text = "Done"
            }
            }
            Nullability
            ● Remember nullable types, e.g. String vs String?
            ● Compatible with @NonNull and @Nullable annotations
            ○ @NonNull → String
            ○ @Nullable → String?
            ● Works with @Inject annotation
            ○ @Inject lateinit val foo: Foo
            ○ Non-nullable, even though not instantiated
            Annotation processing
            ● Supported via kapt
            ● The only change in build.gradle:
            ○ apt "com.google.dagger:dagger-compiler:2.7"
            ○ kapt "com.google.dagger:dagger-compiler:2.7"
            Performance and cost
            Performance
            ● Compiled to bytecode (like Java)
            ● No impact on performance
            ● Some Kotlin code faster
            ○ Lambdas that can be inlined
            ○ Built-in operations faster than DIY implementations
            Build time
            ● Used to be a problem (in early releases)
            ● Much improved with incremental builds
            ● Keepsafe benchmarked compilation speed Kotlin vs Java
            ○ Link - goo.gl/WPs1Gx
            ● Configurations (Gradle daemon running):
            ○ Clean builds
            ○ Incremental build - isolated file change
            ○ Incremental build - core file change
            Build time: clean
            Courtesy of Keepsafe Engineering blog - goo.gl/WPs1Gx
            Build time: incremental - isolated file change
            Courtesy of Keepsafe Engineering blog - goo.gl/WPs1Gx
            Build time: incremental - core file change
            Courtesy of Keepsafe Engineering blog - goo.gl/WPs1Gx
            Cost
            ● Kotlin Standard Library (1.0.4)
            ○ 5,723 methods
            ○ JAR size: 757 KB
            ○ DEX size: 1,012 KB
            ● For comparison:
            ○ Fresco (0.14.0) - 11,122 methods
            ○ Guava (19.0) - 15,076 methods
            ○ Google Play Service (5.0.77) - 20,298 methods
            Case study
            Case study
            ● Production app
            ○ Safedome
            ● Converted approx. 95% of the code to Kotlin
            ○ Kotlin 1.0.2 (early 2016)
            ● Enabled ProGuard
            ● Used Kotlin features (instead of straight conversion)
            Method count
            All methods →
            Method count
            Kotlin methods →
            Lines of code
            APK size
            Migration guide
            Migration guide
            ● Simple process
            ○ Add Gradle dependencies (plugin, runtime, etc.)
            ○ Start writing .kt files instead of .java ones
            ●
            No need to migrate everything at once
            ○ Kotlin classes can co-exist with Java ones
            ● IntelliJ has a Java-to-Kotlin converter
            ○ Not perfect but good start
            ○ Works with pasted code
            Migration fears
            ● Difficulty training developers
            ● Unsupported libraries
            Were they founded?
            Migration fears
            ● Difficulty training developers
            ● Unsupported libraries
            Were they founded? No
            Migration fears
            ● Difficulty training developers
            ○ Plenty of documentation
            ○ Desire to ditch Java motivates
            ● Unsupported libraries
            ○ Java libraries work just fine
            ○ Most current libraries have Kotlin support threads
            Community adoption
            Community adoption
            ● Popular in the Android community
            ● Some companies using Kotlin in production:
            ○
            ○
            ○
            ○
            Basecamp
            NBC News Digital
            Hootsuite
            Prezi
            Contributions
            ● Libraries
            ○ Spek, Wasabi, RxKotlin and many more
            ● Documentation
            ○ Books, articles, tutorials
            ● Other IDE support
            ○ Eclipse
            ○ NetBeans
            Gradle support
            ● Write scripts/plugins in Kotlin (since Gradle 3.0)
            ○ Note: Groovy not deprecated or removed… for now
            ● Works with Android plugin (since 2.2)
            ● Better IDE support and performance
            Not just Android
            ● Kotlin is not limited to Android
            ● Just happens to be a good match
            ● Other applications
            ○ Back end: Spring, Vert.x, etc.
            ○ Front end: JavaScript
            ○ Any other Java applications
            Current issues
            Current issues
            ● Issue #1: Reflection
            ○ Requires kotlin-reflect import
            ○ Works fine if you need it
            ○ ...but it adds 8k methods!
            ● Solution:
            ○ Write files requiring reflection in Java
            ○ Example: Realm models
            Current issues
            ● Issue #2: IntelliJ plugin stability
            ○ Plugin crashes sometimes
            ○ Doesn't crash the whole IDE
            ● Solution:
            ○ Not a major annoyance
            ○ Only happens when doing something dodgy
            Future releases
            Future releases
            ● 1.0.x track
            ○ Bug fixes
            ○ Stability improvements
            ○ IDE support
            ● 1.1.x track
            ○ New features
            ○ Breaking changes (potentially)
            Kotlin EAP 1.1
            ●
            ●
            ●
            ●
            ●
            ●
            ●
            ●
            Coroutines
            Type aliases
            Bound callable references
            Local delegation properties & inline properties
            Relaxed rules for sealed classes and data classes
            Scripting
            Java 7/8 support
            JavaScript
            Kotlin EAP 1.1 (relevant to Android)
            ●
            ●
            ●
            ●
            ●
            ●
            ●
            ●
            Coroutines
            Type aliases
            Bound callable references
            Local delegation properties & inline properties
            Relaxed rules for sealed classes and data classes
            Scripting
            Java 7/8 support
            JavaScript
            Summary
            Summary
            ●
            ●
            ●
            ●
            ●
            ●
            ●
            Kotlin is a light, modern, compact language
            Compatible with Android
            No significant performance overhead
            Allows for gradual migration
            Becoming widely adopted
            In active development
            Ready for production
            Thank you!
            ● Resources - gouline.net/talks
            ● Documentation - kotlinlang.org/docs/reference
            ● Kotlin Weekly - kotlinweekly.net
            More Kotlin talks at YOW! Connected 2016:
            ● "Anko - The Ultimate Ninja of Kotlin Libraries?"
            ○ Speaker: Kai Koenig
            gouline.net • @mgouline • +MikeGouline

https://kotlinlang.org/docs/multiplatform-full-stack-app.html (+=Ktor)

  ~/Empire/Doks/Comp/lang/java/android/kotlin/andrrealworld_2021.txt
            This book is split into five main sections:
            Section I: Developing Real-World AppsIn this section, you'll learn how to design and implement PetSave as an
            example of a professional real-world app. You'll learn how to choose the
            right architectural pattern and how to structure the code to make the
            app more testable and maintainable.
            Section II: Modularizing Your App
            As you add new features to your app, the code becomes more complex
            and difficult to maintain. In this section, you'll learn how to split your
            app into different modules. In particular, you'll learn how to use the
            dynamic feature option, which optimizes the size of the code your users
            have to download to use your app.
            Section III: Enhancing Your UI
            Here, you'll learn how to enhance the user interface of your app with
            animation that you can create and customize. You'll use the new
            Animation Editor, found in recent versions of Android Studio.
            Section IV: Securing Your App
            In this section, you'll learn how to handle security from different points
            of view. You'll learn how to protect user data and how to securely
            connect to a server. Finally, you'll learn how to make hackers' lives more
            difficult, by using different methods to protect your code and your data.
            Section V: Maintaining Your App
            Publishing a real-world app is not the end of your work. In this section,
            you'll learn everything you need to know about maintaining and
            controlling your app after it's published and available to users. After
            reading this section, you'll be ready to use all the available tools for
            improving your app's quality.
  ~/Empire/Doks/Comp/lang/java/android/kotlin/kotlfunct_2021.txt
            Part 1. Introduction to functional programming
            - 1. What is functional programming?
            1.1 The benefits of FP: A simple example
            A program with side effects
            A functional solution: Removing the side effects
            1.2 Exactly what is a (pure) function?
            1.3 RT, purity, and the substitution model
            1.4 What lies ahead
            2 Getting started with functional programming in Kotlin
            2.1 Higher-order functions: Passing functions to functions
            A short detour: Writing loops functionally
            Writing our first higher-order function
            2.2 Polymorphic functions: Abstracting over types
            An example of a polymorphic function
            Calling HOFs with anonymous functions
            2.3 Following types to implementations
            ea late eta
            3.1 Defining functional data structures
            3.2 Working with functional data structures
            The when construct as an alternative to if-else logic
            Pattern matching and how it differs from Kotlin matching
            3.3 Data sharing in functional data structures
            The efficiency of data sharing
            3.4 Recursion over lists and generalizing to HOFs
            More functions for working with lists
            Lists in the Kotlin standard library
            Inefficiency of assembling list functions from simpler components
            3.5 Trees
            4 Handling errors without exceptions
            4.1 The problems with throwing exceptions
            4.2 Problematic alternatives to exceptions
            SYelalalaka Ve TOK
            Supplied default value
            4.3 Encoding success conditions with Option
            Usage patterns for Option
            For-comprehensions with Option
            4.4 Encoding success and failure conditions with Either
            For-comprehensions with Either
            CMe dase em rae
            5.1 Strict and non-strict functions
            5.2 An extended example: Lazy lists
            Memoizing streams and avoiding recomputation
            Helper functions for inspecting streams
            5.3 Separating program description from evaluation
            5.4 Producing infinite data streams through corecursive functions
            5.5 Conclusion
            G6 Purely functional state
            6.1 Generating random numbers using side effects
            6.2 Purely functional random number generation
            6.3, Making stateful APIs pure
            More power by combining state actions
            Recursive retries through nested state actions
            6.7 Conclusion
            Part 2. Functional design and combinator libraries
            7 Purely functional parallelism
            7.1 Choosing data types and functions
            7.2 Picking a representation
            7.3 Refining the API with the end user in mind
            7.4 Reasoning about the API in terms of algebraic equations
            The law of mapping
            The law of forking
            Using actors for a non-blocking implementation
            7-5 Refining combinators to their most general form
            8 Property-based testing
            8.1 A brief tour of property-based testing
            8.2 Choosing data types and functions
            Exploring the meaning and API of properties
            Discovering the meaning and API of generators
            Generators that depend on generated values
            8.3 Test case minimization
            8.4 Using the library and improving the user experience
            Some simple examples
            Writing _a test suite for parallel computations
            8.5 Generating higher-order functions and other possibilities
            8.6 The laws of generators
            8.7 Conclusion
            Cs od LAY ODO) dda ay
            9.1
            a
            om
            Designing an algebra
            A parser to recognize single characters
            A parser to recognize entire strings
            A parser to recognize repetition
            Counting character repetition
            Slicing and nonempty repetition
            Handling context sensitivity
            Writing a JSON parser
            Defining expectations of a JSON parser
            Reviewing the JSON format
            A JSON parser
            9.5 Surfacing errors through reporting
            First attempt at representing errors
            Accumulating errors through error nesting
            Controlling branching and backtracking
            9.6 Implementing the algebra
            Building up the algebra implementation gradually
            Sequencing parsers after each other
            Capturing error messages through labeling parsers
            Recovering from error conditions and backtracking over them
            Propagating state through context-sensitive parsers
            9.7 Conclusion
            Part 3. Common structures in functional design
            10 Monoids
            10.1 What is a monoid?
            10.2 Folding lists with monoids
            10.3 Associativity and parallelism
            10.4 Example: Parallel parsing
            10.5 Foldable data structures
            10.6 Composing monoids
            Assembling more complex monoids
            Using composed monoids to fuse traversals
            aed alee kell ae)
            11.1 Functors
            Defining the functor by generalizing the map function
            The importance of laws and their relation to the functor
            11.2 Monads: Generalizing the flatMap and unit functions
            Introducing the Monad interface
            11.3, Monadic combinators
            11.4 Monad laws
            The associative law
            Proving the associative law for a specific monad
            The left and right identity laws
            11.5 Just what is a monad?
            The identity monad
            The State monad and partial type application
            12 Applicative and traversable functors
            12.1 Generalizing monads for reusability
            12.2 Applicatives as an alternative abstraction to the monad
            12.3 The difference between monads and applicative functors
            The Parser applicative vs. the Parser monad
            12.4 The advantages of applicative functors
            Not all applicative functors are monads
            12.5 Reasoning about programs through the applicative laws
            Laws of left and right identity
            Law of associativity
            EWR) maFVePleeliiay
            12.6 Abstracting traverse and sequence using traversable functors
            12.7 Using Traversable to iteratively transform higher kinds
            From monoids to applicative functors
            Traversing collections while propagating state actions
            Combining traversable structures
            Traversal fusion for single pass efficiency
            Simultaneous traversal of nested traversable structures
            Pitfalls and workarounds for monad composition
            Part 4. Effects and 1/O
            CE Me 24440 Le
            13.1 Factoring effects out of an effectful program
            13.2 Introducing the I|O type to separate effectful code
            Handling input effects
            Benefits and drawbacks of the simple IO type
            13.3 Avoiding stack overflow errors by reification and trampolining
            Reifying control flow as data constructors
            Trampolining: A general solution to stack overflow
            13.4 Amore nuanced IO type
            Reasonably priced monads
            A monad that supports only console |/O
            Testing console |/O by using pure interpreters
            13.5 Non-blocking and asynchronous |/O
            14 Local effects and mutable state
            14.1 State mutation is legal in pure functional code
            14.2 A data type to enforce scoping of side effects
            A domain-specific language for scoped mutation
            An algebra of mutable references
            Running mutable state actions
            14.3 Purity is contextual
            Definition by example
            Ase) alee i lolMtnicleleg
            15 Stream processing and incremental I|/O
            15.1 Problems with imperative |/O: An example
            15.2 Transforming streams with simple transducers
            Combinators for building stream transducers
            15.3 An extensible process type for protocol parameterization
            Sources for stream emission
            Ensuring resource safety in stream transducers
            Applying transducers to a single-input stream
            Multiple input streams
            Sinks for output processing
            Hiding effects in effectful channels
            Dynamic resource allocation
            15.4 Application of stream transducers in the real world
            Tahar
            Taha
            rT Taha oe
            Appendix D.
            Exercise hints and tips
            Exercise solutions
            Higher-kinded types
            Type classes
            index
            Besa

  --
  ~/Empire/Doks/Comp/lang/java/android/kotlin/kotlin-progrbegin_2019.txt
            Table of Contents
            Preface
            Chapter 1: Getting Started with Android and Kotlin
            Why use Kotlin and Android?
            The beginner's first stumbling block
            How Kotlin and Android work together
            The Android API
            Kotlin is object-oriented
            Run that by me again – what, exactly, is Android?
            Android Studio
            Setting up Android Studio
            Final step – for now
            What makes an Android app?
            Android resources
            The structure of Android's code
            Packages
            Classes
            Functions
            Our first Android app
            Possible extra step 1
            Possible extra step 2
            Deploying the app so far
            Running and debugging the app on an Android emulator
            Running the app on a real device
            Frequently asked question
            Chapter 2: Kotlin, XML, and the UI Designer
            Examining the log output
            Filtering the logcat output
            Exploring the project's Kotlin code and the main layout's XML code
            Examining the MainActivity.kt file
            Code folding (hiding) in Android Studio
            The package declaration
            Importing classes
            The class declaration
            Functions inside the class
            A summary of the Kotlin code so far
            Examining the main layout file
            UI layout elements
            UI text elements
            Adding buttons to the main layout file
            Adding a button via the visual designer
            Examining the XML code for the new button
            Adding a button by editing the XML code
            Giving the buttons unique id attributes
            Positioning the two buttons in the layout
            Making the buttons call different functions
            Leaving comments in our Kotlin code
            Coding messages to the user and the developer
            Writing our first Kotlin code
            Adding message code to the onCreate function
            Editing the button's attributes
            Examining the output
            Writing our own Kotlin functions
            Examining the output
            Frequently asked questions
            Summary
            Chapter 3: Exploring Android Studio and the Project Structure
            A quick guided tour of Android Studio
            Project Explorer and project anatomy
            The Empty Activity project
            Exploring the Empty Activity project
            The manifests folder
            The java folder
            The res folder
            The res/drawable folder
            The res/layout folder
            The res/mipmap folder
            The res/values folder
            [ ii ]
            Table of Contents
            The Basic Activity project
            Exploring the Basic Activity project
            Exploring the Android emulator
            The emulator control panel
            Using the emulator as a real device
            The MainActivity.kt file
            The activity_main.xml file
            The extra functions in MainActivity.kt
            The content_main.xml file
            Accessing the app drawer
            Viewing active apps and switching between apps
            Summary
            Chapter 4: Getting Started with Layouts and Material Design
            Material design
            Exploring Android UI design
            Layouts
            Creating the Exploring Layouts project
            Building a menu with LinearLayout
            Adding a LinearLayout to the project
            Preparing your workspace
            Examining the generated XML
            Adding a TextView to the UI
            Adding a multi-line TextView to the UI
            Wiring up the UI with the Kotlin code (part 1)
            Adding layouts within layouts
            Making the layout look pretty
            Wiring up the UI with the Kotlin code (part 2)
            Building a precise UI with ConstraintLayout
            Adding a CalenderView
            Resizing a view in a ConstraintLayout
            Using the Component Tree window
            Adding constraints manually
            Adding and constraining more UI elements
            Making the text clickable
            Laying out data with TableLayout
            Adding a TableRow to TableLayout
            Using the Component Tree when the visual designer won't do
            Organizing the table columns
            Linking back to the main menu
            Summary
            [ iii ]
            Table of Contents
            Chapter 5: Beautiful Layouts with CardView and ScrollView
            Chapter 6: The Android Lifecycle
            Chapter 7: Kotlin Variables, Operators, and Expressions
            Attributes – a quick summary
            Sizing using dp
            Sizing fonts using sp
            Determining size with wrap or match
            Using padding and margin
            Using the layout_weight property
            Using gravity
            Building a UI with CardView and ScrollView
            Setting the view with Kotlin code
            Adding image resources
            Creating the content for the cards
            Defining dimensions for CardView
            Adding CardView to our layout
            Including layout files inside another layout
            Themes and material design
            Using the Android Studio theme designer
            Creating a tablet emulator
            Frequently asked question
            Summary
            The life and times of an Android app
            How Android interacts with our apps
            A simplified explanation of the Android lifecycle
            The lifecycle phases demystified
            How we handle the lifecycle phases
            The lifecycle demo app
            Coding the lifecycle demo app
            Running the lifecycle demo app
            Examining the lifecycle demo app output
            Some other overridden functions
            The structure of Kotlin code – revisited
            Summary
            Learning the jargon
            More on code comments
            Variables
            Types of variables
            Declaring and initializing variables
            Saving keystrokes with type inference
            [ iv ]
            Table of Contents
            Operators and expressions
            The assignment operator
            The addition operator
            The subtraction operator
            The division operator
            The multiplication operator
            The increment operator
            The decrement operator
            The express yourself demo app
            Summary
            Chapter 8: Kotlin Decisions and Loops
            Making decisions in Kotlin
            Indenting code for clarity
            More Kotlin operators
            The comparison operator
            The logical NOT operator
            The NOT equal operator
            The greater-than operator
            The less-than operator
            The greater-than-or-equal-to operator
            The less-than-or-equal-to operator
            The logical AND operator
            The logical OR operator
            How to use all these operators to test variables
            Using the if expression
            If they come over the bridge, shoot them!
            Using when to make decisions
            The When Demo app
            Repeating code with loops
            while loops
            do-while loops
            Ranges
            For loops
            Controlling loops with break and continue
            Sample code
            Summary
            Chapter 9: Kotlin Functions
            Function basics and recap
            The basic function declaration
            Function parameter lists
            The return type and the return keyword
            Function bodies and single-expression functions
            [v]
            Table of Contents
            Making functions flexible
            Default and named arguments
            Even more on functions
            Summary
            Chapter 10: Object-Oriented Programming
            Introducing OOP
            What is OOP exactly?
            Encapsulation
            Polymorphism
            Inheritance
            Why do it like this?
            Class recap
            Basic classes
            Declaring a class
            Instantiating a class
            Classes have functions and variables (kind of)
            Visibility modifiers
            Public
            Private
            Protected
            Internal
            Visibility modifiers summary
            Constructors
            Primary constructors
            Secondary constructors
            Init blocks
            Basic classes app and using the init block
            Introduction to references
            Summary
            Using the variables of a class
            Using the functions and variables of a class
            Class variables are properties
            Examples using properties with their getters, setters, and fields
            When to use overridden getters and setters
            We need to talk about this
            Using the Meeting class
            Chapter 11: Inheritance in Kotlin
            OOP and inheritance
            Using inheritance with open classes
            Basic inheritance examples
            Overriding functions
            Summary so far
            [ vi ]
            Table of Contents
            More polymorphism
            Abstract classes and functions
            Classes using the Inheritance example app
            Summary
            Chapter 12: Connecting Our Kotlin to the UI and Nullability
            All the Android UI elements are classes too
            A quick break to throw out the trash
            Seven useful facts about the Stack and the Heap
            So, how does this Heap thing help me?
            Kotlin interfaces
            Using buttons and TextView widgets from our layout with
            a little help from interfaces
            Nullability – val and var revisited
            Null objects
            Safe call operator
            Non null assertion
            Nullability in review
            Summary
            Chapter 13: Bringing Android Widgets to Life
            Declaring and initializing the objects from the layout
            Creating UI widgets from pure Kotlin without XML
            Exploring the palette – part 1
            The EditText widget
            The ImageView widget
            RadioButtons and RadioGroups
            Lambdas
            Writing the code for the overridden function
            Exploring the palette – part 2, and more lambdas
            The Switch widget
            The CheckBox widget
            The TextClock widget
            The widget exploration app
            Setting up the widget exploration project and UI
            Coding the widget exploration app
            Coding the CheckBox widget
            Changing transparency
            Changing color
            Changing size
            Coding the RadioButton widgets
            Using a lambda for handling clicks on a regular Button widget
            Coding the Switch widget
            [ vii ]
            Table of Contents
            Running the Widget Exploration app
            Converting layouts to ConstraintLayout
            Summary
            Chapter 14: Android Dialog Windows
            Dialog windows
            Creating the dialog demo project
            Coding a DialogFragment class
            Using chaining to configure the DialogFragment class
            Using the DialogFragment class
            The Note to self app
            Using String resources
            How to get the code files for the Note to self app
            The completed app
            Building the project
            Preparing the String resources
            Coding the Note class
            Implementing the dialog designs
            Coding the dialog boxes
            Coding the DialogNewNote class
            Coding the DialogShowNote class
            Showing and using our new dialogs
            Coding the floating action button
            Summary
            Chapter 15: Handling Data and Generating Random Numbers
            Chapter 16: Adapters and Recyclers
            A random diversion
            Handling large amounts of data with arrays
            Arrays are objects
            A simple mini-app array example
            Getting dynamic with arrays
            A dynamic array example
            ArrayLists
            Arrays and ArrayLists are polymorphic
            Hashmaps
            The Note to self app
            Frequently asked questions
            Summary
            Inner classes
            RecyclerView and RecyclerAdapter
            The problem with displaying lots of widgets
            [ viii ]
            Table of Contents
            The solution to the problem with displaying lots of widgets
            How to use RecyclerView and RecyclerAdapter
            What we will do to set up RecyclerView with RecyclerAdapter
            and an ArrayList of notes
            Adding RecyclerView, RecyclerAdapter, and ArrayList to the
            Note to Self project
            Removing the temporary "Show Note" button and adding
            RecyclerView
            Creating a list item for RecyclerView
            Coding the RecyclerAdapter class
            Coding the onCreateViewHolder function
            Coding the onBindViewHolder function
            Coding getItemCount
            Coding the ListItemHolder inner class
            Coding MainActivity to use the RecyclerView and
            RecyclerAdapter classes
            Adding code to onCreate
            Modifying the createNewNote function
            Coding the showNote function
            Running the app
            Frequently asked questions
            Summary
            Chapter 17: Data Persistence and Sharing
            The Android Intent class
            Switching Activity
            Passing data between Activities
            Adding a settings page to Note to self
            Creating the SettingsActivity
            Designing the settings screen layout
            Enabling the user to switch to the "Settings" screen
            Persisting data with SharedPreferences
            Reloading data with SharedPreferences
            Making the Note to self settings persist
            Coding the SettingsActivity class
            Coding the MainActivity class
            More advanced persistence
            What is JSON?
            Exceptions – try, catch, and finally
            Backing up user data in Note to self
            Frequently asked questions
            Summary
            [ ix ]
            Table of Contents
            Chapter 18: Localization
            Chapter 19: Animations and Interpolations
            Making the Note to self app Spanish, English, and German
            Adding Spanish support
            Adding German support
            Adding the String resources
            Running Note to self in German or Spanish
            Making the translations work in Kotlin code
            Summary
            Animations in Android
            Designing cool animations in XML
            Fading in and out
            Move it, move it
            Scaling or stretching
            Controlling the duration
            Rotate animations
            Repeating animations
            Combining an animation's properties with sets
            Instantiating animations and controlling them with Kotlin code
            More animation features
            Listeners
            Animation interpolators
            Animations demo app – introducing SeekBar
            Laying out the animation demo
            Coding the XML animations
            Wiring up the Animation demo app in Kotlin
            Frequently asked questions
            Summary
            Chapter 20: Drawing Graphics
            Understanding the Canvas class
            Getting started drawing with Bitmap, Canvas, and ImageView
            Canvas and Bitmap
            Paint
            ImageView and Activity
            Canvas, Bitmap, Paint, and ImageView – a quick summary
            Using the Canvas class
            Preparing the instances of the required classes
            Initializing the objects
            Setting the Activity content
            The Canvas Demo app
            Creating a new project
            Coding the Canvas demo app
            Drawing on the screen
            [x]
            Table of Contents
            The Android coordinate system
            Plotting and drawing
            Creating bitmap graphics with the Bitmap class
            Manipulating bitmaps
            What is a bitmap?
            The Matrix class
            The Bitmap manipulation demo app
            Adding the Bob graphic to the project
            Frequently asked question
            Summary
            Inverting a bitmap to face the opposite direction
            Rotating the bitmap to face up and down
            Chapter 21: Threads and Starting the Live Drawing App
            Creating the Live Drawing project
            Looking ahead at the Live Drawing app
            Coding the MainActivity class
            Coding the LiveDrawingView class
            Adding the properties
            Coding the draw function
            Adding the printDebuggingText function
            Understanding the draw function and the SurfaceView class
            The game loop
            Threads
            Problems with threads
            Implementing the game loop with a thread
            Implementing Runnable and providing the run function
            Coding the thread
            Starting and stopping the thread
            Using the Activity lifecycle to start and stop the thread
            Coding the run function
            Running the app
            Summary
            Chapter 22: Particle Systems and Handling Screen Touches
            Adding custom buttons to the screen
            Implementing a particle system effect
            Coding the Particle class
            Coding the ParticleSystem class
            Spawning particle systems in the LiveDrawingView class
            Handling touches
            Coding the onTouchEvent function
            Finishing the HUD
            [ xi ]
            Table of Contents
            Running the app
            Summary
            Chapter 23: Android Sound Effects and the Spinner Widget
            The SoundPool class
            Initializing SoundPool
            Loading sound files into memory
            Playing a sound
            Stopping a sound
            Sound demo app introducing the Spinner widget
            Making sound effects
            Laying out the sound demo UI
            Coding the Sound demo
            Summary
            Chapter 24: Design Patterns, Multiple Layouts, and Fragments
            Introducing the model-view-controller pattern
            Model
            View
            Controller
            Android design guidelines
            Real-world apps
            Device detection mini app
            Coding the MainActivity class
            Unlocking the screen orientation
            Running the app
            Configuration qualifiers
            The limitation of configuration qualifiers
            Fragments
            Fragments have a life cycle too
            Managing fragments with FragmentManager
            Our first fragment app
            Fragment reality check
            Frequently asked question
            Summary
            The onCreate function
            The onCreateView function
            The onAttach and onDetach functions
            The onStart, onPause, and onStop functions
            Chapter 25: Advanced UI with Paging and Swiping
            The Angry Birds classic swipe menu
            Building an image gallery/slider app
            Implementing the layout
            [ xii ]
            Table of Contents
            Coding the PagerAdapter class
            Coding the MainActivity class
            Running the gallery app
            Kotlin companion objects
            Building a Fragment Pager/slider app
            Coding the SimpleFragment class
            The fragment_layout
            Coding the MainActivity class
            The activity_main layout
            Running the fragment slider app
            Summary
            Chapter 26: Advanced UI with Navigation Drawer
            and Fragment
            Chapter 27: Android Databases
            Introducing the NavigationView
            Examining the Age Database app
            Insert
            Delete
            Search
            Results
            Starting the Age Database project
            Exploring the auto-generated code and assets
            Coding the Fragment classes and their layouts
            Creating the empty files for the classes and layouts
            Coding the classes
            Designing the layouts
            Designing content_insert.xml
            Designing content_delete.xml
            Designing content_search.xml
            Designing content_results.xml
            Using the Fragment classes and their layouts
            Editing the navigation drawer menu
            Adding a holder to the main layout
            Coding the MainActivity.kt file
            Summary
            Database 101
            What is a database?
            What is SQL?
            What is SQLite?
            The SQL syntax primer
            [ xiii ]
            Table of Contents
            SQLite example code
            Creating a table
            Inserting data into the database
            Retrieving data from the database
            Updating the database structure
            The Android SQLite API
            SQLiteOpenHelper and SQLiteDatabase
            Building and executing queries
            Database cursors
            Coding the database class
            Coding the Fragment classes to use the DataManager class
            Running the Age Database app
            Summary
            Chapter 28: A Quick Chat Before You Go
            Other Book You May Enjoy
            Index
            Publishing
            Making an app!
            Carrying on learning
            Carrying on reading
            GitHub
            StackOverflow
            Android user forums
            Higher-level study
            My other channels
            Goodbye and thank you
            [ xiv ]
  ~/Empire/Doks/Comp/lang/java/android/kotlin/andrstudio-kotlin_2019.qref.txt
            Introduction  xvii
            Chapter 1: Setup   1
            Setting Up Android Studio   2
            Configuring Android Studio   4
            Hardware Acceleration   8
            Chapter Summary   9
            Chapter 2: Quick How-Tos   11
            Creating a Project   11
            Creating an Activity   17
            Creating a Class   20
            Creating an Interface   21
            Override Methods   21
            Running a Project   24
            Chapter Summary   24
            www.allitebooks.com
            Chapter 3: The IDE   25
            The IDE   26
            Main Editor   28
            Editing Layout Files   29
            Inserting TODO Items   31
            How to Get More Screen Space for Code   31
            Project Tool Window   34
            Preferences/Settings   35
            The SDK Manager   36
            Code Styles   38
            Chapter Summary   38
            Chapter 4: Debugging   41
            Types of Errors   41
            Syntax Errors   41
            Runtime Errors   42
            Logic Errors   44
            Debugger   46
            Single Stepping   48
            Chapter 5: Unit Testing   51
            JVM Test vs. Instrumented Test   52
            A Simple Demo   53
            Implementing a Test   57
            Running a Unit Test   59
            Test First   61
            Chapter 6: Instrumented Testing   63
            About Espresso   63
            Setting Up a Simple Test   64
            Recording Espresso Tests   67
            More on Espresso Matchers   70
            Espresso Actions   71
            Chapter 7: Android Studio Profiler   73
            The Profiler   73
            CPU   75
            Memory   78
            Network   80
            Energy   81
            Chapter Summary   82
            Chapter 8: Gradle   83
            The Build Process   83
            The Build Files   84
            Module-Level Gradle File   85
            Dependencies   88
            Android Support Library   91
            Chapter Summary   93
            Chapter 9: Git   95
            Getting Git   95
            Using Android Studio with GitHub   97
            Sharing a Project on GitHub   99
            Opening a Project from GitHub   103
            Updating Git Projects   105
            Using Other Git Repos   107
            Chapter Summary   115
            Chapter 10: Navigation   117
            Navigation Before Architecture Components   117
            Navigation Components   120
            Working with Jetpack Navigation   122
            Chapter Summary   132
            Chapter 11: Lifecycle, ViewModel, LiveData, and Room   135
            Lifecycle-Aware Components   135
            ViewModel   139
            LiveData   143
            Room   147
            Chapter Summary   153
            Chapter 12: Release Builds   155
            Preparing the App for Release   155
            Preparing the Material and Assets for Release   156
            Configuring the App for Release   156
            Building a Release-Ready Application   157
            Releasing the App   161
            Chapter Summary   165
            Chapter 13: Short Takes   167
            Productivity Features   167
            Importing Samples   168
            Refactoring   169
            Generate   171
            Coding Styles   173
            Live Templates   175
            Important Keyboard Shortcuts   176
  ~/Empire/Doks/Comp/lang/java/android/kotlin/effectivekotlin_2019.txt
            Contents
            Introduction: Be pragmatic
            Part 1: Good code
            Chapter 1: Safety
            Item 1: Limit mutability
            Item 2: Minimize the scope of variables
            Item 3: Eliminate platform types as soon as possible
            Item 4: Do not expose inferred types
            Item 5: Specify your expectations on arguments
            and state
            Item 6: Prefer standard errors to custom ones
            Item 7: Prefer null or Failure result when the
            lack of result is possible
            Item 8: Handle nulls properly
            Item 9: Close resources with use
            Item 10: Write unit tests
            Chapter 2: Readability
            Item 11: Design for readability
            Item 12: Operator meaning should be consistent
            with its function name
            Item 13: Avoid returning or operating on Unit?
            Item 14: Specify the variable type when it is not clear 113
            CONTENTS
            Item 15: Consider referencing receivers explicitly
            Item 16: Properties should represent state, not behavior
            Item 17: Consider naming arguments
            Item 18: Respect coding conventions
            Part 2: Code design
            Chapter 3: Reusability
            Item 19: Do not repeat knowledge
            Item 20: Do not repeat common algorithms
            Item 21: Use property delegation to extract common property patterns
            Item 22: Use generics when implementing common algorithms
            Item 23: Avoid shadowing type parameters
            Item 24: Consider variance for generic types
            Item 25: Reuse between different platforms by
            extracting common modules
            Chapter 4: Abstraction design
            Item 26: Each function should be written in terms
            of a single level of abstraction
            Item 27: Use abstraction to protect code against
            changes
            Item 28: Specify API stability
            Item 29: Consider wrapping external API
            Item 30: Minimize elements visibility
            Item 31: Define contract with documentation
            Item 32: Respect abstraction contracts
            Chapter 5: Object creation
            Item 33: Consider factory functions instead of
            constructors
            CONTENTS
            Item 34: Consider a primary constructor with named
            optional arguments
            Item 35: Consider defining a DSL for complex
            object creation
            Chapter 6: Class design
            Item 36: Prefer composition over inheritance
            Item 37: Use the data modifier to represent a
            bundle of data
            Item 38: Use function types instead of interfaces to
            pass operations and actions
            Item 39: Prefer class hierarchies to tagged classes
            Item 40: Respect the contract of equals
            Item 41: Respect the contract of hashCode
            Item 42: Respect the contract of compareTo
            Item 43: Consider extracting non-essential parts of
            your API into extensions
            Item 44: Avoid member extensions
            Part 3: Efficiency
            Chapter 7: Make it cheap
            Item 45: Avoid unnecessary object creation
            Item 46: Use inline modifier for functions with
            parameters of functional types
            Item 47: Consider using inline classes
            Item 48: Eliminate obsolete object references
            Chapter 8: Efficient collection processing
            Item 49: Prefer Sequence for big collections with
            more than one processing step
            Item 50: Limit the number of operations
            Item 51: Consider Arrays with primitives for performancecritical processing
            CONTENTS
            Item 52: Consider using mutable collections
            Dictionary
    ~/Empire/Doks/Comp/lang/java/android/kotlin/kotlin-androidstudioapp_2018.txt
            About the Author   xiii
            About the Technical Reviewers  xv
            Acknowledgments  xvii
            Introduction  xix
            Part I: The Kotlin Language   1
            Chapter 1: Getting into Kotlin   3
            About Kotlin   4
            Installing the Java SDK   6
            Installing on macOS   7
            Installing on Windows 10   8
            Installing on Linux   9
            Installing Kotlin   10
            Installing the Command Line Tools   10
            Coding With the Command Line Tools   15
            Installing IntelliJ   17
            Creating a Project   19
            The IntelliJ IDE   29
            Chapter Summary   31
            Chapter 2: Kotlin Basics   33
            Program Elements   33
            Literals   34
            Variables   34
            Expressions and Statements   36
            Keywords   37
            v
            Table of Contents
            Whitespace   38
            Operators   39
            Blocks   41
            Comments   42
            Basic Types   44
            Numbers and Literal Constants   44
            Characters   46
            Booleans   47
            Arrays   47
            Strings and String Templates   49
            Controlling Program Flow   51
            Using ifs   51
            The when Statement   53
            The while Statement   55
            for loops   55
            Exception Handling   57
            Handling Nulls   58
            Chapter Summary   60
            Chapter 3: Functions   63
            Declaring Functions   63
            Single Expression Functions   67
            Default Arguments   68
            Named Parameters   69
            Variable Number of Arguments   70
            Extension Functions   71
            Infix Functions   73
            Operator Overloading   75
            Chapter Summary   78
            vi
            Table of Contents
            Chapter 4: Working with Types   79
            Interfaces   79
            Diamond Problem   81
            Invoking Super Behavior   82
            Classes   84
            Constructors   85
            Inheritance   88
            Properties   92
            Data Classes   96
            Visibility Modifiers   100
            Access Modifiers   102
            Object Declarations   102
            Chapter Summary   103
            Chapter 5: Lambdas and Higher Order Functions   105
            Higher Order Functions   105
            Lambda and Anonymous Functions   109
            Parameters in Lambda Expressions   110
            Closures   113
            with and apply   114
            Chapter Summary   116
            Chapter 6: Collections and Arrays   117
            Arrays   117
            Collections   121
            Lists   123
            Sets   124
            Maps   125
            Collections Traversal   127
            Filter and Map   128
            Chapter Summary   130
            vii
            Table of Contents
            Chapter 7: Generics   133
            Why Generics   133
            Terminologies   135
            Using Generics in Functions   136
            Using Generics in Classes   138
            Variance   140
            Subclass vs Subtype   144
            Reified Generics   149
            Chapter Summary   153
            Part II: Android Programming with Kotlin   155
            Chapter 8: Android Studio Introduction and Setup   157
            History   157
            Architecture   158
            Android Studio IDE   160
            Setup   161
            Android Studio Configuration   163
            Hardware Acceleration   169
            Chapter Summary   170
            Chapter 9: Getting Started   173
            What's in an App   173
            Component Activation   176
            Creating a Project   177
            The IDE   190
            Main Menu   192
            Keyboard Shortcuts   193
            Customizing Code Style   195
            Chapter Summary   196
            viii
            Table of Contents
            Chapter 10: Activities and Layouts   197
            Application Entry Point   197
            Activity Class   198
            Layout File   200
            View and ViewGroup Objects   201
            Containers   203
            Hello World   204
            Modifying Hello World   208
            Chapter Summary   218
            Chapter 11: Event Handling   221
            Introduction to Event Handling   221
            Chapter Summary   237
            Chapter 12: Intents   239
            What Intents Are   239
            Loose Coupling   242
            Two Kinds of Intent   243
            Intents Can Carry Data   243
            Getting Back Results from Another Activity   246
            Implicit Intents   249
            Demo 1: Launch an Activity   251
            Demo 2: Send Data to an Activity   259
            Demo 3: Send and Get Data Back to and from an Activity   265
            Demo 4: Implicit Intents   278
            Chapter Summary   282
            Chapter 13: Themes and Menus   283
            Styles and Themes   283
            Customizing the Theme   286
            Menus   288
            Chapter Summary   303
            ix
            Table of Contents
            Chapter 14: Fragments   305
            Introduction to Fragments   305
            Book Title and Description, a Fragments Demo   311
            Fragments Demo, Dynamic   337
            Chapter Summary   341
            Chapter 15: Running in the Background   343
            Basic Concepts   344
            The UI Thread   344
            Threads and Runnables   349
            Using the Handler Class   354
            AsyncTask   357
            Anko's doAsync   360
            A Real-World Example   363
            Chapter Summary   371
            Chapter 16: Debugging   373
            Syntax Errors   373
            Runtime Errors   377
            Logic Errors   382
            Walking Through Code   385
            Other Notes   387
            Chapter Summary   388
            Chapter 17: SharedPreferences   389
            Sharing Data Between Activities   398
            Chapter Summary   406
            Chapter 18: Internal Storage   407
            Overview of File Storage   407
            Internal and External Storage   408
            Cache Directory   409
            x
            Table of Contents
            How to Work with Internal Storage   409
            Chapter Summary   424
            Chapter 19: BroadcastReceivers   425
            Introduction to BroadcastReceivers   425
            System Broadcast vs. Custom Broadcast   426
            Manifest Registration vs. Context Registration   427
            Basics of BroadcastReceivers   430
            Implicit vs. Explicit Broadcast Actions   432
            Demo App: Custom Broadcast   433
            Demo App: System Broadcast   440
            Other Notes   443
            Chapter Summary   444
            Chapter 20: App Distribution   445
            Preparing the App for Release   446
            Prepare Materials and Assets for Release   446
            Configure the App for Release   447
            Build a Release-Ready Application   448
            Releasing the App   452
            Chapter Summary   456
            Index   459
  ~/Empire/Doks/Comp/lang/java/android/kotlin/functkotl_2018.txt
            Appendix, Kotlin's Quick Start will give you a quick start with the language).
            What this book covers
            chapter 1, Kotlin - Data Types, Objects, and Classes, introduces you to object-oriented
            programming in Kotlin. Kotlin is primary object-oriented programming, and we'll use these
            features to introduce a functional programming style.
            Chapter 2, Getting Started with Functional Programming, covers the basic principles of functional
            programming using Kotlin's object-oriented programming features.
            chapter 3, Immutability - It's Important, emphasizes on immutability as one of the most important
            concepts in functional programming. This chapter will give you an in-depth understanding of
            immutability.
            Chapter 4, Functions, Function Types, and Side Effects, introduces you to the basic functional
            programming concepts around functions, pure functions, and various function types and side
            effects.
            chapter 5, More on Functions, talks about Kotlin's features for functional programming such as
            extension functions. operator overloading. DSLs. and corecursion.
            wremeape wwe ' a Senta a tg See meet cet rreet cere enttmntteneet Mee eng MRAM ren ts enn QM Vermeer ment ence were RMU net Qeeenren mre) cr eS orn? gegen cere cise re one esestrteneRc nts neces ne! WEP em
            programming concepts around functions, pure functions, and various function types and side
            effects.
            Chapter 5, More on Functions, talks about Kotlin's features for functional programming such as
            extension functions, operator overloading, DSLs, and corecursion.
            chapter 6, Delegates in Kotlin, covers how Kotlin has language-level support for delegates. Though
            delegates are a object-oriented programming concept, they can be helpful in making your code
            more modular.
            Chapter 7, ASynchronous Programming with Coroutines, gives you an introduction to asynchronous
            programming in Kotlin, comparing different styles against coroutines.
            Chapter 8, Collections and Data Operations in Kotlin, covers the enhanced collections API by
            Kotlin and the functional interfaces that Kotlin's collections framework has to offer.
            Chapter 9, Functional Programming and Reactive Programming, shows how functional
            programming can be combined with other programming paradigms to get the best out of them. This
            chapter discusses how you can combine functional programming with object-oriented programming
            and reactive programming.
            Phantnr san Giumotare Annlincativoc and hAnnade citrac wnii an intradiuctian tan ttmad finctinnogl
            programming in Kotlin, comparing different styles against coroutines.
            Chapter 8, Collections and Data Operations in Kotlin, covers the enhanced collections API by
            Kotlin and the functional interfaces that Kotlin's collections framework has to offer.
            chapter 9, Functional Programming and Reactive Programming, shows how functional
            programming can be combined with other programming paradigms to get the best out of them. This
            chapter discusses how you can combine functional programming with object-oriented programming
            and reactive programming.
            Chapter 10, Functors, Applicatives and Monads, gives you an introduction to typed functional
            programming and its basic concepts. It also talks about how to implement it in Kotlin.
            Chapter 11, Working with Streams in Kotlin, gets you introduced to the Streams API in Kotlin.
            Chapter 12, Getting Started with Arrow, covers how to use Arrow and its extensions for functional
            programming, function composition, currying, partial application, memoization, and optics.
            Chapter 13, Arrow Types, helps you understand Arrow data types such as Option, Either, Try, and
            Chapter 12, Getting Started with Arrow, covers how to use Arrow and its extensions for functional
            programming, function composition, currying, partial application, memoization, and optics.
            Chapter 13, Arrow Types, helps you understand Arrow data types such as Option, Either, Try, and
            State and its type classes, functors, and monads.
            Appendix, Kotlin's Quick Start, it provides everything that you need to start writing a Kotlin code,
            such as tools, basic syntax constructs and other resources to help you progress in your Kotlin
            journey.
  --
    ~/Empire/Doks/Comp/lang/java/android/kotlin/kotl-hiperf.pdf
            Table of Contents
            Preface1
            Chapter 1: Identifying Performance Bottlenecks
            Reasons for performance issues6
            Memory management
            Garbage collection
            Working principles of the garbage collector
            Impacts of garbage collection
            Heap fragmentation
            Finalization
            Resource leaks
            Memory leaks
            String pool
            Memory model
            The problem of concurrency and parallelism
            Java Memory Model (JMM)
            Synchronization
            Slow rendering
            Device refresh rate
            Frame rate
            Summary
            Chapter 2: Identifying Indicators of Performance Issues
            Benchmarking
            Microbenchmarks
            Java Microbenchmark Harness (JMH)
            Benchmark modes
            Benchmark time units
            Benchmark state
            State scope
            Fixture methods
            Levels of fixture methods
            Writing good benchmarks
            The pitfalls of loops
            Dead Code Elimination
            Using black holes
            Constant folding
            Kotlin benchmarks
            IDEA JMH plugin
            General performance metrics
            Types of performance testing
            Performance testing process
            55Table of Contents
            Overview of performance testing tools
            JMeter
            Fabric
            Summary
            Chapter 3: Learning How to Use Profiling Tools
            Memory profiling
            Memory Viewer
            HProf
            Eclipse Memory Analyzer Tool
            Histogram
            Shallow and Retained Heap
            Dominator Tree
            Top Consumers
            Analyzing class loaders
            Android Studio Memory Profiler
            Memory categories
            Recording memory allocation
            Threads profiling
            Threads viewer
            Frames pane
            The Threads pane
            Thread profiling in the MAT
            Threads Overview
            Thread Details
            CPU Profiler in Android Studio
            Call Chart and Flame Chart tabs
            Top Down and Bottom Up tabs
            Summary
            Chapter 4: Functional Approach
            Functional programming
            Declarative versus imperative
            Pure functions
            First-class functions
            Higher-order functions
            Function composition
            Lambdas
            Closures
            Typeclasses
            Arrow library
            Functor
            Monad
            Immutability
            Inspecting functional features
            Inline versus non-inline
            Capturing and non-capturing lambdas
            [ ii ]
            121Table of Contents
            Summary
            Chapter 5: Enhancing the Performance of Collections
            Data structures
            Arrays
            Linked lists
            Stacks
            Queues
            Sets
            Maps
            Hash tables
            Binary search trees
            Tries
            Binary heaps
            Graphs
            Time complexity
            Calculating time complexity
            Time complexity of lists
            Time complexity of sets
            Time complexity of queues
            Time complexity of maps
            Collections in Kotlin
            Sequences in Kotlin
            Summary
            Chapter 6: Optimizing Access to Properties
            Fields and properties
            Backing fields
            Backing properties
            @JvmField annotation
            Compile-time constants
            Inner classes
            lateinit
            Companion objects
            Summary
            Chapter 7: Preventing Unnecessary Overhead Using Delegates
            Types of delegation
            Explicit delegation
            Implicit delegation
            Class delegation
            Delegated properties
            Lazy
            Creating a delegated property
            Inspecting the lazy function
            Observable delegates
            [ iii ]
            205Table of Contents
            Summary
            Chapter 8: Ranges and Identifying Performance Issues
            Ranges in Kotlin
            Utility functions
            Range benchmarking
            Summary
            Chapter 9: Multithreading and Reactive Programming
            Concurrency and parallelism
            Reactive programming
            Coroutines
            Setting up a project
            The launch function
            The async function
            The buildSequence function
            The suspendingSequence function
            The produce function
            Coroutines with reactive programming
            Summary
            Chapter 10: Best Practices
            The disposable pattern
            Immutability
            Data classes
            The String pool
            StringBuilder
            Functional programming
            Declarative versus imperative
            Pure functions
            First-class functions
            Higher-order functions
            Inline functions
            Function composition
            Capturing lambdas
            Collections
            Properties
            Backing properties
            @JvmField annotation
            Top-level members
            Compile-time constants
            The lateinit modifier
            Delegation
            Singleton delegate object
            The lazy funcation with unsafe thread mode
            [ iv ]
            282Table of Contents
            Delegate object with generic
            Ranges
            Concurrency and parallelism
            Summary
            Other Books You May Enjoy
            Index
    # ~/Empire/Doks/Comp/lang/java/android/kotlin/kotlin-multiplatform.intro.pdf
~/Empire/Doks/Comp/lang/java/android/kotlin/KotlinNotesForProfessionals.pdf
            Contents
            About  1
            Chapter 1: Getting started with Kotlin  2
            Section 1.1: Hello World  2
            Section 1.2: Hello World using a Companion Object  2
            Section 1.3: Hello World using an Object Declaration  3
            Section 1.4: Main methods using varargs  4
            Section 1.5: Compile and Run Kotlin Code in Command Line  4
            Section 1.6: Reading input from Command Line  4
            Chapter 2: Basics of Kotlin  6
            Section 2.1: Basic examples  6
            Chapter 3: Strings  7
            Section 3.1: String Equality  7
            Section 3.2: String Literals  7
            Section 3.3: Elements of String  8
            Section 3.4: String Templates  8
            Chapter 4: Arrays  9
            Section 4.1: Generic Arrays  9
            Section 4.2: Arrays of Primitives  9
            Section 4.3: Create an array  9
            Section 4.4: Create an array using a closure  9
            Section 4.5: Create an uninitialized array  9
            Section 4.6: Extensions  10
            Section 4.7: Iterate Array  10
            Chapter 5: Collections  11
            Section 5.1: Using list  11
            Section 5.2: Using map  11
            Section 5.3: Using set  11
            Chapter 6: Enum  12
            Section 6.1: Initialization  12
            Section 6.2: Functions and Properties in enums  12
            Section 6.3: Simple enum  12
            Section 6.4: Mutability  12
            Chapter 7: Functions  14
            Section 7.1: Function References  14
            Section 7.2: Basic Functions  15
            Section 7.3: Inline Functions  16
            Section 7.4: Lambda Functions  16
            Section 7.5: Operator functions  16
            Section 7.6: Functions Taking Other Functions  17
            Section 7.7: Shorthand Functions  17
            Chapter 8: Vararg Parameters in Functions  18
            Section 8.1: Basics: Using the vararg keyword  18
            Section 8.2: Spread Operator: Passing arrays into vararg functions  18
            Chapter 9: Conditional Statements  19
            Section 9.1: When-statement argument matching  19
            Section 9.2: When-statement as expression  19Section 9.3: Standard if-statement  19
            Section 9.4: If-statement as an expression  19
            Section 9.5: When-statement instead of if-else-if chains  20
            Section 9.6: When-statement with enums  20
            Chapter 10: Loops in Kotlin  22
            Section 10.1: Looping over iterables  22
            Section 10.2: Repeat an action x times  22
            Section 10.3: Break and continue  22
            Section 10.4: Iterating over a Map in kotlin  23
            Section 10.5: Recursion  23
            Section 10.6: While Loops  23
            Section 10.7: Functional constructs for iteration  23
            Chapter 11: Ranges  25
            Section 11.1: Integral Type Ranges  25
            Section 11.2: downTo() function  25
            Section 11.3: step() function  25
            Section 11.4: until function  25
            Chapter 12: Regex  26
            Section 12.1: Idioms for Regex Matching in When Expression  26
            Section 12.2: Introduction to regular expressions in Kotlin  27
            Chapter 13: Basic Lambdas  30
            Section 13.1: Lambda as parameter to filter function  30
            Section 13.2: Lambda for benchmarking a function call  30
            Section 13.3: Lambda passed as a variable  30
            Chapter 14: Null Safety  31
            Section 14.1: Smart casts  31
            Section 14.2: Assertion  31
            Section 14.3: Eliminate nulls from an Iterable and array  31
            Section 14.4: Null Coalescing / Elvis Operator  31
            Section 14.5: Nullable and Non-Nullable types  32
            Section 14.6: Elvis Operator (?:)  32
            Section 14.7: Safe call operator  32
            Chapter 15: Class Delegation  34
            Section 15.1: Delegate a method to another class  34
            Chapter 16: Class Inheritance  35
            Section 16.1: Basics: the 'open' keyword  35
            Section 16.2: Inheriting fields from a class  35
            Section 16.3: Inheriting methods from a class  36
            Section 16.4: Overriding properties and methods  36
            Chapter 17: Visibility Modifiers  38
            Section 17.1: Code Sample  38
            Chapter 18: Generics  39
            Section 18.1: Declaration-site variance  39
            Section 18.2: Use-site variance  39
            Chapter 19: Interfaces  41
            Section 19.1: Interface with default implementations  41
            Section 19.2: Properties in Interfaces  42
            Section 19.3: super keyword  42
            Section 19.4: Basic Interface  42Section 19.5: Conﬂicts when Implementing Multiple Interfaces with Default Implementations  43
            Chapter 20: Singleton objects  44
            Section 20.1: Use as replacement of static methods/fields of java  44
            Section 20.2: Use as a singleton  44
            Chapter 21: coroutines  45
            Section 21.1: Simple coroutine which delay's 1 second but not blocks  45
            Chapter 22: Annotations  46
            Section 22.1: Meta-annotations  46
            Section 22.2: Declaring an annotation  46
            Chapter 23: Type aliases  47
            Section 23.1: Function type  47
            Section 23.2: Generic type  47
            Chapter 24: Type-Safe Builders  48
            Section 24.1: Type-safe tree structure builder  48
            Chapter 25: Delegated properties  49
            Section 25.1: Observable properties  49
            Section 25.2: Custom delegation  49
            Section 25.3: Lazy initialization  49
            Section 25.4: Map-backed properties  49
            Section 25.5: Delegate Can be used as a layer to reduce boilerplate  49
            Chapter 26: Reﬂection  51
            Section 26.1: Referencing a class  51
            Section 26.2: Inter-operating with Java reﬂection  51
            Section 26.3: Referencing a function  51
            Section 26.4: Getting values of all properties of a class  51
            Section 26.5: Setting values of all properties of a class  52
            Chapter 27: Extension Methods  54
            Section 27.1: Potential Pitfall: Extensions are Resolved Statically  54
            Section 27.2: Top-Level Extensions  54
            Section 27.3: Lazy extension property workaround  54
            Section 27.4: Sample extending Java 7+ Path class  55
            Section 27.5: Sample extending long to render a human readable string  55
            Section 27.6: Sample extending Java 8 Temporal classes to render an ISO formatted string  55
            Section 27.7: Using extension functions to improve readability  55
            Section 27.8: Extension functions to Companion Objects (appearance of Static functions)  56
            Section 27.9: Extensions for easier reference View from code  57
            Chapter 28: DSL Building  58
            Section 28.1: Infix approach to build DSL  58
            Section 28.2: Using operators with lambdas  58
            Section 28.3: Overriding invoke method to build DSL  58
            Section 28.4: Using extensions with lambdas  58
            Chapter 29: Idioms  60
            Section 29.1: Serializable and serialVersionUid in Kotlin  60
            Section 29.2: Delegate to a class without providing it in the public constructor  60
            Section 29.3: Use let or also to simplify working with nullable objects  61
            Section 29.4: Use apply to initialize objects or to achieve method chaining  61
            Section 29.5: Fluent methods in Kotlin  61
            Section 29.6: Filtering a list  62
            Section 29.7: Creating DTOs (POJOs/POCOs)  62Chapter 30: RecyclerView in Kotlin  63
            Section 30.1: Main class and Adapter  63
            Chapter 31: logging in kotlin  65
            Section 31.1: kotlin.logging  65
            Chapter 32: Exceptions  66
            Section 32.1: Catching exception with try-catch-finally  66
            Chapter 33: JUnit  67
            Section 33.1: Rules  67
            Chapter 34: Kotlin Android Extensions  68
            Section 34.1: Using Views  68
            Section 34.2: Configuration  68
            Section 34.3: Painful listener for getting notice, when the view is completely drawn now is so simple and
            awesome with Kotlin's extension  69
            Section 34.4: Product ﬂavors  69
            Chapter 35: Kotlin for Java Developers  71
            Section 35.1: Declaring Variables  71
            Section 35.2: Quick Facts  71
            Section 35.3: Equality & Identity  71
            Section 35.4: IF, TRY and others are expressions, not statements  72
            Chapter 36: Java 8 Stream Equivalents  73
            Section 36.1: Accumulate names in a List  73
            Section 36.2: Collect example #5 - find people of legal age, output formatted string  73
            Section 36.3: Collect example #6 - group people by age, print age and names together  73
            Section 36.4: Dierent Kinds of Streams #7 - lazily iterate Doubles, map to Int, map to String, print each
            Section 36.5: Counting items in a list after filter is applied  75
            Section 36.6: Convert elements to strings and concatenate them, separated by commas  75
            Section 36.7: Compute sum of salaries of employee  75
            Section 36.8: Group employees by department  75
            Section 36.9: Compute sum of salaries by department  75
            Section 36.10: Partition students into passing and failing  75
            Section 36.11: Names of male members  76
            Section 36.12: Group names of members in roster by gender  76
            Section 36.13: Filter a list to another list  76
            Section 36.14: Finding shortest string a list  76
            Section 36.15: Dierent Kinds of Streams #2 - lazily using first item if exists  76
            Section 36.16: Dierent Kinds of Streams #3 - iterate a range of Integers  77
            Section 36.17: Dierent Kinds of Streams #4 - iterate an array, map the values, calculate the average
            Section 36.18: Dierent Kinds of Streams #5 - lazily iterate a list of strings, map the values, convert to Int,
            find max  77
            Section 36.19: Dierent Kinds of Streams #6 - lazily iterate a stream of Ints, map the values, print results
            Section 36.20: How streams work - filter, upper case, then sort a list  78
            Section 36.21: Dierent Kinds of Streams #1 - eager using first item if it exists  78
            Section 36.22: Collect example #7a - Map names, join together with delimiter  78
            Section 36.23: Collect example #7b - Collect with SummarizingInt  79
            Chapter 37: Kotlin Caveats  81
            Section 37.1: Calling a toString() on a nullable type  81Appendix A: Configuring Kotlin build  82
            Section A.1: Gradle configuration  82
            Section A.2: Using Android Studio  83
            Section A.3: Migrating from Gradle using Groovy script to Kotlin script  84
            Credits  86
            You may also like  88
  ~/Empire/Doks/Comp/lang/java/android/kotlin/kotlprogrbyex_2018.txt
            Contents
            Introduction: Be pragmatic
            Part 1: Good code
            Chapter 1: Safety
            Item 1: Limit mutability
            Item 2: Minimize the scope of variables
            Item 3: Eliminate platform types as soon as possible
            Item 4: Do not expose inferred types
            Item 5: Specify your expectations on arguments and state
            Item 6: Prefer standard errors to custom ones
            Item 7: Prefer null or Failure result when the lack of result is possible
            Item 8: Handle nulls properly
            Item 9: Close resources with use
            Item 10: Write unit tests
            Chapter 2: Readability
            Item 11: Design for readability
            Item 12: Operator meaning should be consistent with its function name
            Item 13: Avoid returning or operating on Unit?
            Item 14: Specify the variable type when it is not clear 113
            Item 15: Consider referencing receivers explicitly
            Item 16: Properties should represent state, not behavior
            Item 17: Consider naming arguments
            Item 18: Respect coding conventions
            Part 2: Code design
            Chapter 3: Reusability
            Item 19: Do not repeat knowledge
            Item 20: Do not repeat common algorithms
            Item 21: Use property delegation to extract common property patterns
            Item 22: Use generics when implementing common algorithms
            Item 23: Avoid shadowing type parameters
            Item 24: Consider variance for generic types
            Item 25: Reuse between different platforms by extracting common modules
            Chapter 4: Abstraction design
            Item 26: Each function should be written in terms of a single level of abstraction
            Item 27: Use abstraction to protect code against changes
            Item 28: Specify API stability
            Item 29: Consider wrapping external API
            Item 30: Minimize elements visibility
            Item 31: Define contract with documentation
            Item 32: Respect abstraction contracts
            Chapter 5: Object creation
            Item 33: Consider factory functions instead of constructors
            Item 34: Consider a primary constructor with named optional arguments
            Item 35: Consider defining a DSL for complex object creation
            Chapter 6: Class design
            Item 36: Prefer composition over inheritance
            Item 37: Use the data modifier to represent a bundle of data
            Item 38: Use function types instead of interfaces to pass operations and actions
            Item 39: Prefer class hierarchies to tagged classes
            Item 40: Respect the contract of equals
            Item 41: Respect the contract of hashCode
            Item 42: Respect the contract of compareTo
            Item 43: Consider extracting non-essential parts of your API into extensions
            Item 44: Avoid member extensions
            Part 3: Efficiency
            Chapter 7: Make it cheap
            Item 45: Avoid unnecessary object creation
            Item 46: Use inline modifier for functions with parameters of functional types
            Item 47: Consider using inline classes
            Item 48: Eliminate obsolete object references
            Chapter 8: Efficient collection processing
            Item 49: Prefer Sequence for big collections with more than one processing step
            Item 50: Limit the number of operations
            Item 51: Consider Arrays with primitives for performancecritical processing
            Item 52: Consider using mutable collections
            Dictionary
~/Empire/Doks/Comp/lang/java/android/kotlin/kotlin-androidstudioapp_2018.txt
            Part I: The Kotlin Language   1
            Chapter 1: Getting into Kotlin   3
            About Kotlin   4
            Installing the Java SDK   6
            Installing on macOS   7
            Installing on Windows 10   8
            Installing on Linux   9
            Installing Kotlin   10
            Installing the Command Line Tools   10
            Coding With the Command Line Tools   15
            Installing IntelliJ   17
            Creating a Project   19
            The IntelliJ IDE   29
            Chapter Summary   31
            Chapter 2: Kotlin Basics   33
            Program Elements   33
            Literals   34
            Variables   34
            Expressions and Statements   36
            Keywords   37
            v
            Table of Contents
            Whitespace   38
            Operators   39
            Blocks   41
            Comments   42
            Basic Types   44
            Numbers and Literal Constants   44
            Characters   46
            Booleans   47
            Arrays   47
            Strings and String Templates   49
            Controlling Program Flow   51
            Using ifs   51
            The when Statement   53
            The while Statement   55
            for loops   55
            Exception Handling   57
            Handling Nulls   58
            Chapter Summary   60
            Chapter 3: Functions   63
            Declaring Functions   63
            Single Expression Functions   67
            Default Arguments   68
            Named Parameters   69
            Variable Number of Arguments   70
            Extension Functions   71
            Infix Functions   73
            Operator Overloading   75
            Chapter Summary   78
            vi
            Table of Contents
            Chapter 4: Working with Types   79
            Interfaces   79
            Diamond Problem   81
            Invoking Super Behavior   82
            Classes   84
            Constructors   85
            Inheritance   88
            Properties   92
            Data Classes   96
            Visibility Modifiers   100
            Access Modifiers   102
            Object Declarations   102
            Chapter Summary   103
            Chapter 5: Lambdas and Higher Order Functions   105
            Higher Order Functions   105
            Lambda and Anonymous Functions   109
            Parameters in Lambda Expressions   110
            Closures   113
            with and apply   114
            Chapter Summary   116
            Chapter 6: Collections and Arrays   117
            Arrays   117
            Collections   121
            Lists   123
            Sets   124
            Maps   125
            Collections Traversal   127
            Filter and Map   128
            Chapter Summary   130
            vii
            Table of Contents
            Chapter 7: Generics   133
            Why Generics   133
            Terminologies   135
            Using Generics in Functions   136
            Using Generics in Classes   138
            Variance   140
            Subclass vs Subtype   144
            Reified Generics   149
            Chapter Summary   153
            Part II: Android Programming with Kotlin   155
            Chapter 8: Android Studio Introduction and Setup   157
            History   157
            Architecture   158
            Android Studio IDE   160
            Setup   161
            Android Studio Configuration   163
            Hardware Acceleration   169
            Chapter Summary   170
            Chapter 9: Getting Started   173
            What's in an App   173
            Component Activation   176
            Creating a Project   177
            The IDE   190
            Main Menu   192
            Keyboard Shortcuts   193
            Customizing Code Style   195
            Chapter Summary   196
            viii
            Table of Contents
            Chapter 10: Activities and Layouts   197
            Application Entry Point   197
            Activity Class   198
            Layout File   200
            View and ViewGroup Objects   201
            Containers   203
            Hello World   204
            Modifying Hello World   208
            Chapter Summary   218
            Chapter 11: Event Handling   221
            Introduction to Event Handling   221
            Chapter Summary   237
            Chapter 12: Intents   239
            What Intents Are   239
            Loose Coupling   242
            Two Kinds of Intent   243
            Intents Can Carry Data   243
            Getting Back Results from Another Activity   246
            Implicit Intents   249
            Demo 1: Launch an Activity   251
            Demo 2: Send Data to an Activity   259
            Demo 3: Send and Get Data Back to and from an Activity   265
            Demo 4: Implicit Intents   278
            Chapter Summary   282
            Chapter 13: Themes and Menus   283
            Styles and Themes   283
            Customizing the Theme   286
            Menus   288
            Chapter Summary   303
            ix
            Table of Contents
            Chapter 14: Fragments   305
            Introduction to Fragments   305
            Book Title and Description, a Fragments Demo   311
            Fragments Demo, Dynamic   337
            Chapter Summary   341
            Chapter 15: Running in the Background   343
            Basic Concepts   344
            The UI Thread   344
            Threads and Runnables   349
            Using the Handler Class   354
            AsyncTask   357
            Anko's doAsync   360
            A Real-World Example   363
            Chapter Summary   371
            Chapter 16: Debugging   373
            Syntax Errors   373
            Runtime Errors   377
            Logic Errors   382
            Walking Through Code   385
            Other Notes   387
            Chapter Summary   388
            Chapter 17: SharedPreferences   389
            Sharing Data Between Activities   398
            Chapter Summary   406
            Chapter 18: Internal Storage   407
            Overview of File Storage   407
            Internal and External Storage   408
            Cache Directory   409
            x
            Table of Contents
            How to Work with Internal Storage   409
            Chapter Summary   424
            Chapter 19: BroadcastReceivers   425
            Introduction to BroadcastReceivers   425
            System Broadcast vs. Custom Broadcast   426
            Manifest Registration vs. Context Registration   427
            Basics of BroadcastReceivers   430
            Implicit vs. Explicit Broadcast Actions   432
            Demo App: Custom Broadcast   433
            Demo App: System Broadcast   440
            Other Notes   443
            Chapter Summary   444
            Chapter 20: App Distribution   445
            Preparing the App for Release   446
            Prepare Materials and Assets for Release   446
            Configure the App for Release   447
            Build a Release-Ready Application   448
            Releasing the App   452
            Chapter Summary   456
            Index   459
  ~/Empire/Doks/Comp/lang/java/android/kotlin/kotlmaster5guides.txt
            Introduction  
            1 Anko layouts on Android  
            Anko layouts DSL  
            Should I start using Anko layouts to build my projects?
            How to start using Anko  
            Kotlin and Anko Layouts, an exciting combination
            2 Kotlin DSL to write Gradle scripts on Android
            Using Kotlin DSL on your Gradle files. Is it worth it?
            How to convert your files  
            It's not easy, but it's cool!  
            3 A first walk into Kotlin coroutines on Android
            Understanding how coroutines work  
            Using Anko for coroutines  
            Using coroutines in our example  
            4 Kotlin Android Extensions  
            How to use Kotlin Android Extensions
            Kotlin Android Extensions in 1.1.4
            Conclusion  
            5 Java interoperability
            Package-level functions
            Extension functions
            Function overloads
            Instance and static fields
            Data classes  
            Sealed classes  
            Inline functions and reified types  
            Conclusion  
  ~/Empire/Doks/Comp/lang/java/android/kotlin/andravancapparchit.txt
            Advanced Android App Architectures
            Table of Contents: Overview
            What You Need  13
            Book License  14
            Book Source Code & Forums  15
            About the Cover  16
            Section I: Building a Foundation  17
            Chapter 1: Introduction  18
            Chapter 2: Model View Controller  26
            Chapter 3: Testing MVC  33
            Chapter 4: Android Architecture Components . 40
            Chapter 5: Dependency Injection  48
            Chapter 6: RxJava 55
            Section II: Fundamental UI Architectures  66
            Chapter 7: Model View Presenter Theory  67
            Chapter 8: Model View Presenter Sample  74
            Chapter 9: Testing MVP  94
            Chapter 10: Model-View-ViewModel Theory . 108
            Chapter 11: MVVM Sample with data
            binding  117
            Chapter 12: MVVM Sample with Android
            Architecture Components 132
            raywenderlich.com
            Advanced Android App Architectures
            Chapter 13: MVVM Testing  149
            Section III: VIPER and MVI  160
            Chapter 14: VIPER Theory  161
            Chapter 15: VIPER Sample 169
            Chapter 16: Testing VIPER  190
            Chapter 17: MVI Theory  203
            Chapter 18: MVI Sample  214
            Chapter 19: MVI Debugging 236
            Conclusion  249
            raywenderlich.com
            Advanced Android App Architectures
            Table of Contents: Extended
            What You Need   13
            Book License   14
            Book Source Code & Forums   15
            About the Cover   16
            Section I: Building a Foundation  17
            Chapter 1: Introduction   18
            What is this book?   18
            Why is app architecture important?   19
            Introducing the sample project   20
            WeWatch sample app walkthrough  20
            Where to go from here?   25
            Chapter 2: Model View Controller   26
            The Model-View-Controller pattern   26
            Applying MVC to Android  28
            WeWatch MVC code   29
            Key points   31
            Chapter 3: Testing MVC   33
            Android Testing   33
            Focusing on unit tests   35
            Unit testing the Movie class  36
            Unit testing an Android Activity   37
            Why MVC makes unit testing hard   38
            Key points   38
            Where to go from here?   39
            Chapter 4: Android Architecture Components   40
            Using the Android Architecture Components   42
            raywenderlich.com
            Advanced Android App Architectures
            Key points   47
            Where to go from here?   47
            Chapter 5: Dependency Injection   48
            What is a dependency?   48
            Why dependencies can be problematic   49
            Injecting dependencies   50
            Dependency injection frameworks   51
            Key points   53
            Where to go from here?   54
            Chapter 6: RxJava   55
            What is the Observer pattern?   55
            Getting to know RxJava   57
            Observing events   57
            Frequently Not Asked RxJava Questions   64
            Key points   64
            Where to go from here?   65
            Section II: Fundamental UI Architectures   66
            Chapter 7: Model View Presenter Theory   67
            The Model-View-Presenter pattern   67
            MVP advantages and concerns   72
            Key points   72
            Where to go from here?   73
            Chapter 8: Model View Presenter Sample   74
            Getting started   74
            Applying MVP to the Movies app   75
            The Main screen   75
            The Add Movie screen   85
            The Search Movie screen   89
            Key points   92
            Where to go from here?   93
            raywenderlich.com
            Advanced Android App Architectures
            Chapter 9: Testing MVP   94
            Getting started   94
            Getting to know Mockito   94
            Testing the MainPresenter   97
            Testing the AddMoviePresenter   102
            Testing the SearchPresenter   104
            Key points   106
            Where to go from here?   107
            Chapter 10: Model-View-ViewModel Theory   108
            The Model-View-ViewModel pattern   109
            MVVM by example   113
            MVVM advantages and concerns   114
            Key points   115
            Where to go from here?   116
            Chapter 11: MVVM Sample with data binding . . . . 117
            What is data binding?   117
            Getting Started   118
            Implementing data binding   119
            Challenge   130
            Key points   130
            Where to go from here?   131
            Chapter 12: MVVM Sample with Android
            Architecture Components   132
            Getting started   133
            Current architecture layers   134
            Creating a movie repository   135
            Creating ViewModels   137
            Using LiveData with ViewModels   140
            MVVM architecture   147
            Key points   148
            Where to go from here?   148
            raywenderlich.com
            Advanced Android App Architectures
            Chapter 13: MVVM Testing  149
            Getting started   149
            Creating unit tests   150
            Section III: VIPER and MVI   160
            Chapter 14: VIPER Theory   161
            What is VIPER?   161
            VIPER Advantages and Concerns   166
            Questions you didn't think to ask   167
            Key points   168
            Where to go from here?   168
            Chapter 15: VIPER Sample   169
            Getting started   170
            Implementing the Main Module   173
            Implementing the AddMovie module   180
            Implementing SearchMovie   183
            Key points   188
            Where to go from here?   189
            Chapter 16: Testing VIPER   190
            Getting started   190
            Testing your Main presenter   193
            Testing the AddMovie presenter   197
            Testing SearchMovie Presenter   200
            Chapter 17: MVI Theory   203
            What is MVI?   203
            MVI Advantages and Concerns  211
            Frequently Not Asked MVI Questions   212
            Key points   212
            Where to go from here?   213
            Chapter 18: MVI Sample  214
            Getting started   215
            raywenderlich.com
            Advanced Android App Architectures
            Going Reactive   216
            Creating Interactors and State   219
            Creating the Presenters   221
            Creating the Views   225
            Final thoughts   233
            Key points   234
            Where to go from here?   234
            Chapter 19: MVI Debugging   236
            Getting started   236
            Introducing Timber   239
            Testing the MVI architecture   240
            Key points   248
            Where to go from here?   248
            Conclusion   249
  ~/Empire/Doks/Comp/lang/java/android/kotlin/kotlbluepr.txt   #web/mobile, +spring boot/node.js
            Table of Contents
            Preface
            What this book covers
            What you need for this book
            Who this book is for
            Conventions
            Reader feedback
            Customer support
            Downloading the example code
            Downloading the color images of this book
            Errata
            Piracy
            Questions
            1.
            The Power of Kotlin
            Kotlin – a better Java
            Why not other languages?
            Why Kotlin?
            Concise yet expressive code
            Enhanced robustness
            Excellent IDE support from day one
            Beyond being a better Java
            Kotlin is in the winning camp
            Go native strategy
            Kotlin's winning strategy
            Summary
            2.
            Geospatial Messenger – Spring Boot
            Why Spring Boot?
            Leveraging Kotlin in Spring Boot applications
            Extension functions
            Constructor injection
            Leveraging Null safety
            Functional bean declaration DSL
            Let's build our geospatial messenger
            Preview
            Features
            Architecture
            Setting up the IDE
            Creating a project
            Project structure
            Setting up the build script
            Adding Kotlin dependency
            Adding Spring Boot dependencies
            Exposed library
            Gradle dependency
            Defining the table
            Connecting to the database
            CRUD operations
            Explaining PostGIS
            Installation
            Gradle dependency
            Object mapping
            Gradle dependency
            Completing the Gradle script
            Coding the application
            Frontend
            HTML
            CSS
            JavaScript
            Rendering the map
            Plotting messages on the map
            Listening to message saved events
            Complete JavaScript
            Application class
            Backend
            Application configuration
            Data classes
            Exposed integration
            Exposed objects
            Extras for geospatial support
            Service/Controller
            Repository
            CrudRepository
            Event broadcaster
            Extension functions
            Testing
            Gradle dependency
            Test cases
            Pro-tips
            All-open compiler plugin
            Spring starter
            Playing with the Java to Kotlin converter
            Migrating to Kotlin
            Should I rewrite the existing Java code in Kotlin?
            What if I want to rewrite Java to Kotlin?
            Summary
            3.
            Social Media Aggregator Android App
            Setting up Kotlin
            Setting up the Kotlin plugin for Android Studio
            Getting started
            Converting Java code to Kotlin code
            Creating a social media aggregator
            Using datatypes and conversion
            String interpolation
            String utility methods
            Classes
            Constructors
            Data classes
            Inheritance
            Singletons
            lateinit versus lazy initialization
            lateinit
            The lazy property
            Control flow
            The when() expression
            Getters and setters
            Declaring a property
            Interfaces
            Kotlin Android extension
            Ditching the findViewById() method
            View extensions
            Fragment LayoutInflater extension
            The Standard.kt function
            The with() function
            The apply() function
            The let() function
            Functions in Kotlin
            Single-expression function
            Inline function
            Default and named parameters
            Default parameter
            Named parameter
            Destructing declaration
            Android context
            Null-Safety
            Why Kotlin is called null-safe
            Safe call operator (?.)
            Elvis operator (?:)
            Force unwrap (!!)
            Smart casts
            The is and !is operators
            The as operator
            Companion object
            Fragment instantiation using companion objects
            Dealing with constants
            Object expressions and declarations
            Delegated properties
            Dealing with Shared Preferences
            Setting up an item click on RecyclerView
            Anko - Kotlin's buddy for Android
            Setting up Anko
            Displaying toast()
            Starting an activity made easy
            Anko layout
            Summary
            4.
            Weather App Using Kotlin for JavaScript
            Creating your first Kotlin and JavaScript project
            Choosing an IDE
            Creating a project
            Creating an HTML page
            Creating a Main.kt file
            Running the project
            Developing a weather forecast web app
            Creating a UI with dummy data
            Simple HTML approach
            Creating UI using Kotlin
            What is DSL?
            Using Kotlinx.html
            Refactoring the HTML code using DSL
            Calling a weather API
            Reading data from input elements
            Data classes
            Showing data to the user
            Showing weather details
            Named parameters
            Extension functions
            Giving final touches
            Adding CSS
            Interoperability with JavaScript
            Summary
            5.
            Chat Application with Server-Side JavaScript Generation
            Creating our first Node.js app using Kotlin
            Choosing an IDE
            Installing Node.js
            Installing the Node.js plugin
            Creating a project
            Creating a chat application
            Setting up the Node.js server
            Specifying the output files
            Examining the compilation output
            Specifying the router
            Starting the node server
            Creating a login page
            Creating an index.ejs file
            Using DSL
            Using kotlinx.html
            Lambda functions
            Reading the nickname
            Passing nickname to the server
            Smart cast
            Registering a callback
            Establishing a socket connection
            Setting up Socket.IO
            Listening to events
            Emitting the event
            Incrementing and decrementing operator overloading
            Showing a list of online users
            Using the data class
            Using the Pair class
            Iterating list
            Sending and receiving a message
            Null safety
            Force unwraps
            Using the let function
            Named parameter
            Disconnecting a socket
            Styling the page using CSS
            Summary
            6.
            News Feed – REST API
            What is REST?
            What is Ktor?
            Why Ktor?
            Understanding unopinionated applications
            Asynchronous nature
            Highly testable
            Deploying the Ktor app
            Let's build our news application
            News provider
            Fetching news sources
            Fetching news articles
            Preview
            Features
            Architecture
            Setting up the IDE
            Prerequisites
            Creating the project
            Project structure
            Deploying
            Deploying in IntelliJ IDEA
            Setting up the build script
            Adding Kotlin dependency
            Adding Ktor dependencies
            Configuring logging
            Adding Fuel
            What is Fuel?
            Adding Gradle dependency
            Quick sample
            Asynchronous mode
            Blocking mode
            Completing Gradle script
            Let's code!
            Application configuration
            Deployment block
            Application block
            Application main
            Installing routing
            Simple routing
            Modular routing
            Understanding route paths
            Path parameters
            Testing
            Adding Gradle dependency
            Testing the application
            Testing the index URL
            Testing JSON using Postman
            Testing news sources using Postman
            Testing news sources using Postman
            Summary
            7.
            CSV Reader in Kotlin Native
            What is Kotlin Native?
            Target platforms
            Multiplatform Kotlin
            Installing Kotlin Native
            Installing from the source
            Installing from binaries
            Testing the installation
            Memory management
            Building our app
            Writing the main function
            Reading command-line arguments
            Opening the file
            Reading the file contents
            Counting unique entries
            Converting to Kotlin string
            Splitting strings
            Printing the result
            Complete code
            Running the program
            Understanding the dataset
            Compiling the program
            Executing the program
            Multiplatform Kotlin
            Project structure
            Common module
            Platform module
            Regular module
            Overview of the dependency structure
            Setting up a multiplatform project
            Creating a multiplatform project with an IDE
            Creating a multiplatform project without an IDE
            Summary
            8.
            Dictionary Desktop Application - TornadoFX
            Introducing TornadoFX
            Java-based desktop frameworks
            TornadoFX special additions
            Creating a type-safe UI versus FXML
            Type-safe styling
            Other improvements
            Let's build our dictionary application
            What we will build
            Words API
            Definition API
            Features of our application
            Setting up the IDE
            Prerequisites
            Installing the TornadoFX plugin
            Creating the project
            Project structure
            Let's code!
            Application class
            Type-safe CSS
            Dependency injection
            Property delegate
            Consuming the REST API
            Defining the Model
            Implementing the JSONModel interface
            REST client
            Configuring the client
            Controllers
            Views
            Layouts
            VBox layout
            HBox layout
            Other layouts
            Forms
            Background operations
            Printing the result
            Complete View
            Launching the application
            Summary
  ~/Empire/Doks/Comp/lang/java/android/kotlin/andrdatastructalgoskotl.txt
            Data Structures & Algorithms in Kotlin
            Table of Contents: Overview
            Book License  14
            Who This Book Is For  15
            What You Need  16
            Book Source Code & Forums  17
            About the Cover  19
            Section I: Introduction to Data Structures &
            Algorithms 20
            Chapter 1: Kotlin & Kotlin Standard Library  21
            Chapter 2: Complexity  39
            Section II: Elementary Data Structures  52
            Chapter 3: Linked List 53
            Chapter 4: Stack Data Structures  85
            Chapter 5: Queues  94
            Section III: Trees  125
            Chapter 6: Trees  127
            Chapter 7: Binary Trees  140
            Chapter 8: Binary Search Trees  152
            Chapter 9: AVL Trees  173
            Chapter 10: Tries  191
            Chapter 11: Binary Search  204
            Chapter 12: The Heap Data Structure  213
            Data Structures & Algorithms in Kotlin
            Chapter 13: Priority Queues  238
            Section IV: Sorting Algorithms  251
            Chapter 14: O(n²) SorZng Algorithms  253
            Chapter 15: Merge Sort 268
            Chapter 16: Radix Sort  279
            Chapter 17: Heap Sort  289
            Chapter 18: Quicksort  298
            Section V: Graphs  316
            Chapter 19: Graphs  318
            Chapter 20: Breadth-First Search  344
            Chapter 21: Depth-First Search  355
            Chapter 22: Dijkstra's Algorithm  368
            Chapter 23: Prim's Algorithm  387
            Conclusion  403
            Data Structures & Algorithms in Kotlin
            Table of Contents: Extended
            Book License   14
            Who This Book Is For   15
            What You Need   16
            Book Source Code & Forums   17
            About the Cover   19
            Section I: Introduction to Data Structures &
            Algorithms   20
            Chapter 1: Kotlin & Kotlin Standard Library   21
            Introduction to Kotlin   22
            The Kotlin Standard Library   30
            Key points   38
            Chapter 2: Complexity   39
            Time complexity  
            Other time complexiZes  
            Comparing time complexity  
            Space complexity  
            Key points  
            Section II: Elementary Data Structures   52
            Chapter 3: Linked List   53
            Node  
            LinkedList  
            Adding values to the list  
            Removing values from the list  
            Kotlin collection interfaces  
            Becoming a Kotlin mutable collection  
            Data Structures & Algorithms in Kotlin
            Challenges   76
            Key points   84
            Chapter 4: Stack Data Structures   85
            Stack operations  
            Implementation  
            push and pop operations  
            Challenges  
            Key points  
            Chapter 5: Queues   94
            Common operations   95
            Example of a queue   96
            List-based implementation   97
            Doubly linked list implementation   100
            Ring buffer implementation   104
            Double-stack implementation   108
            Challenges   115
            Key points   124
            Section III: Trees   125
            Chapter 6: Trees   127
            Terminology  
            Implementation  
            Traversal algorithms  
            Challenges  
            Key points  
            Chapter 7: Binary Trees   140
            Implementation  
            Traversal algorithms  
            Challenges  
            Key points  
            raywenderlich.com
            Data Structures & Algorithms in Kotlin
            Chapter 8: Binary Search Trees   152
            Case study: array vs. BST  
            Implementation  
            Challenges  
            Key points  
            Chapter 9: AVL Trees   173
            Understanding balance  
            Implementation  
            Challenges  
            Key points  
            Chapter 10: Tries   191
            Example  
            Implementation  
            Challenges  
            Key points  
            Chapter 11: Binary Search   204
            Example  
            Implementation  
            Challenges  
            Key points  
            Chapter 12: The Heap Data Structure   213
            What is a heap?  
            The heap property  
            Heap applications  
            Common heap operations  
            SorZng and comparing  
            How do you represent a heap?  
            InserZng into a heap  
            Removing from a heap  
            Removing from an arbitrary index  
            Data Structures & Algorithms in Kotlin
            Searching for an element in a heap  
            Heapify an array 
            TesZng  
            Challenges  
            Key points  
            Chapter 13: Priority Queues   238
            Applications  
            Common operations  
            Implementation  
            Challenges  
            Key points  
            Section IV: Sorting Algorithms   251
            Chapter 14: O(n²) SorZng Algorithms   253
            Bubble sort  
            Selection sort  
            Insertion sort  
            Generalization  
            Challenges  
            Key points  
            Chapter 15: Merge Sort   268
            Implementation  
            Performance  
            Challenges  
            Key points  
            Chapter 16: Radix Sort   279
            Example  
            Implementation  
            Challenges  
            Key points  
            Data Structures & Algorithms in Kotlin
            Chapter 17: Heap Sort   289
            Gehng started  
            Example  
            Implementation  
            Performance  
            Challenges  
            Key points  
            Chapter 18: Quicksort   298
            Example  
            Partitioning strategies  
            Effects of a bad pivot choice  
            Challenges  
            Key points  
            Section V: Graphs   316
            Chapter 19: Graphs   318
            Weighted graphs  
            Common operations  
            Defining a vertex  
            Defining an edge  
            Adjacency list  
            Implementation  
            Adjacency matrix  
            Implementation  
            Graph analysis  
            Challenges  
            Key points  
            Chapter 20: Breadth-First Search   344
            Example   345
            Implementation   348
            Performance   349
            Data Structures & Algorithms in Kotlin
            Challenges   350
            Key points   354
            Chapter 21: Depth-First Search   355
            DFS example  
            Implementation  
            Performance  
            Challenges  
            Key points  
            Chapter 22: Dijkstra's Algorithm   368
            Example  
            Implementation  
            Trying out your code  
            Performance  
            Challenges  
            Key points  
            Chapter 23: Prim's Algorithm   387
            Example  
            Implementation  
            Testing your code  
            Performance  
            Challenges  
            Key points  
            Conclusion   403
  ~/Empire/Doks/Comp/lang/java/android/kotlin/progrkotl.txt
            Table of Contents
            Preface
            Chapter 1: Getting Started with Kotlin
            Using the command line to compile and run Kotlin code
            Kotlin runtime
            The REPL
            Kotlin for scripting
            Kotlin with Gradle
            Kotlin with Maven
            IntelliJ and Kotlin
            Eclipse and Kotlin
            Mixing Kotlin and Java in a project
            Summary
            Chapter 2: Kotlin Basics
            Vals and vars
            Type inference
            Basic types
            Numbers
            Booleans
            Chars
            Strings
            Arrays
            Comments
            Packages
            Imports
            Wildcard imports
            Import renaming
            String templates
            Ranges
            Loops
            Exception handling
            Instantiating classes
            Referential equality and structural equality
            This expression
            Scope
            Visibility modifiers
            Private
            Protected
            Internal
            Control flow as expressions
            Null syntax
            Smart casts
            Explicit casting
            When expression
            When (value)
            When without argument
            Function Return
            Type hierarchy
            Summary
            Chapter 3: Object-Oriented Programming in Kotlin
            Classes
            Access levels
            Nested classes
            Data classes
            Enum classes
            Static methods and companion objects
            Interfaces
            Inheritance
            Visibility modifiers
            Abstract classes
            Interface or abstract class
            Polymorphism
            Overriding rules
            Inheritance versus composition
            Class delegation
            Sealed classes
            Summary
            Chapter 4: Functions in Kotlin
            Defining functions
            Single expression functions
            Member functions
            Local functions
            Top-level functions
            [ ii ]
            Named parameters
            Default parameters
            Extension functions
            Extension function precedence
            Extension functions on nulls
            Member extension functions
            Overriding member extension functions
            Companion object extensions
            Multiple return values
            Infix functions
            Operators
            Operator overloading
            Basic operators
            In/contains
            Get/set
            Invoke
            Comparison
            Assignment
            Java interop
            Function literals
            Tail recursive functions
            Varargs
            Spread operator
            Standard library functions
            Apply
            Let
            With
            Run
            Lazy
            Use
            Repeat
            Require/assert/check
            Generic functions
            Pure functions
            Java from Kotlin
            Getters and setters
            Single abstract methods
            Escaping Kotlin identifiers
            Java void methods
            [ iii ]
            Kotlin from Java
            Top-level functions
            Default parameters
            Object and static methods
            Erasure naming
            Checked exceptions
            Summary
            Chapter 5: Higher Order Functions and Functional Programming
            Higher order functions
            Returning a function
            Function assignment
            Closures
            Anonymous functions
            Function references
            Top-level function references
            Member and extension function references
            Bound references
            Function-literal receivers
            Functions in the JVM
            Bytecode
            Function composition
            Inline functions
            Noinline
            Currying and partial application
            Currying in action
            Adding currying support
            Memoization
            Implementing memoization
            Type alias
            Either
            Fold
            Projection
            Further projection functions
            Custom DSLs
            Infix functions as keywords
            Using function receivers in a DSL
            Validation and error accumulation
            Summary
            [ iv ]
            Chapter 6: Properties
            Why use properties?
            Syntax and variations
            Visibility
            Late initialization
            Delegated properties
            Lazy initializations
            Lateinit versus lazy
            Observables
            A non-null property delegate
            Properties or methods?
            Summary
            Chapter 7: Null Safety, Reflection, and Annotations
            Nullable types
            Smart cast
            Safe null access
            Force operator
            Elvis operator
            Safe casting
            Optionals
            Creating and returning an Optional
            Using an Optional
            Reflection
            KClass
            Instantiation using reflection
            Constructors
            Instantiation with callBy
            Objects and companions
            Useful KClass properties
            Reflective functions and properties
            Invoking a function reflectively
            Declared and undeclared
            Annotations
            Annotation parameters
            Standard annotations
            @JvmName
            @JvmStatic
            @Throws
            [v]
            @JvmOverloads
            Runtime annotation discovery
            Summary
            Chapter 8: Generics
            Parameterised functions
            Parameterized types
            Bounded polymorphism
            Upper bounds
            Multiple bounds
            Type variance
            Invariance
            Covariance
            Covariant return
            Contravariance
            Variance overview
            Nothing type
            Type projection
            Type erasure
            Type reification
            Recursive type bounds
            Algebraic data types
            Summary
            Chapter 9: Data Classes
            Automatic creation of getters and setters
            The copy method
            toString out of the box
            hashCode and equals methods generated for you
            Destructed declarations
            Destructing types
            Data class definition rules
            Limitations
            Summary
            Chapter 10: Collections
            Class hierarchy
            Arrays
            Lists
            Maps
            Sets
            [ vi ]
            Read-only views
            Indexed access
            Sequences
            Summary
            Chapter 11: Testing in Kotlin
            Getting started
            Choosing a spec
            Matchers
            String matchers
            Collection matchers
            Floating point matchers
            Expecting exceptions
            Combining matchers
            Custom matchers
            Inspectors
            Interceptors
            The test case interceptor
            The spec interceptor
            Project config
            Property testing
            Specifying a generator
            A custom generator
            Table-driven testing
            Testing non-deterministic code
            Tags, conditions, and config
            Config
            Conditions
            Tags
            One instance
            Resources
            Summary
            Chapter 12: Microservices with Kotlin
            Definition
            Drawbacks
            Why microservices?
            Lagom
            Defining services
            Implementing a Lagom service
            Summary
            [ vii ]
            Chapter 13: Concurrency
            Threads
            Blocking
            Creating a thread
            Stopping a thread
            Thread interrupts
            CPU-bound versus I/O-bound
            Deadlocks and livelocks
            Dining philosophers problem
            Executors
            Race conditions
            Monitors
            Locks
            Read-write locks
            Semaphores
            The bounded buffer problem
            Concurrent collections
            ConcurrentHashMap
            A blocking queue
            Atomic variables
            CountDownLatch
            Cyclic Barrier
            Non-blocking I/O and asynchronous programming
            Futures
            Summary
            Index
      ~/Empire/Doks/Comp/lang/java/android/kotlin/kotlatom.txt
            Section I: Programming Basics
            Introduction
            Why Kotlin?
            Hello, World!
            var & val
            Data Types
            Functions
            if Expressions
            String Templates
            Number Types
            Booleans
            Repetition with while
            Looping & Ranges
            The in Keyword
            Expressions & Statements
            Summary 1
            Section II: Introduction to Objects
            Objects Everywhere
            Creating Classes
            Properties
            Constructors
            Constraining Visibility
            Packages
            Testing
            Exceptions
            Lists
            Variable Argument Lists
            Sets
            Maps
            Property Accessors
            Summary 2
            Section III: Usability
            Extension Functions
            Named & Default Arguments
            Overloading
            when Expressions
            Enumerations
            Data Classes
            Destructuring Declarations
            Nullable Types
            Safe Calls & the Elvis Operator
            Non-Null Assertions
            Extensions for Nullable Types
            Introduction to Generics
            Extension Properties
            break & continue
            Section IV: Functional Programming
            Lambdas
            The Importance of Lambdas
            Operations on Collections
            Member References
            Higher-Order Functions
            Manipulating Lists
            Building Maps
            Sequences
            Local Functions
            Folding Lists
            Recursion
            Section V: Object-Oriented Programming
            Interfaces
            Complex Constructors
            Secondary Constructors
            Inheritance
            Base Class Initialization
            Abstract Classes
            Upcasting
            Polymorphism
            Composition
            Inheritance & Extensions
            Class Delegation
            Downcasting
            Sealed Classes
            Type Checking
            Nested Classes
            Objects
            Inner Classes
            Companion Objects
            Section VI: Preventing Failure
            Exception Handling
            Check Instructions
            The Nothing Type
            Resource Cleanup
            Logging
            Unit Testing
            Section VII: Power Tools
            Extension Lambdas
            Scope Functions
            Creating Generics
            Operator Overloading
            Using Operators
            Property Delegation
            Property Delegation Tools
            Lazy Initialization
            Late Initialization
            Appendices
            Appendix A: AtomicTest
            Appendix B: Java Interoperability
            Copyright
            Atomic Kotlin

~/Dropbox/rsc/data/lists/ref/comp/lang/webdev/mob.kotlandr-jetpack.functionslist-bytutlevel.txt
--
JETPACK + JETPACK COMPOSE ****
=from Dok (='Jetpack Compose Essentials')
                evince -p 130 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import android.os.Bundle
            import androidx.activity.ComponentActivity
            import androidx.activity.compose.setContent
            import androidx.compose.material.MaterialTheme
            import androidx.compose.material.Surface
                evince -p 131 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.material.Text
                evince -p 157 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.text.font.FontWeight
            import androidx.compose.ui.unit.sp
                evince -p 163 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.layout.*
            import androidx.compose.material.Slider
            import androidx.compose.ui.unit.dp
                evince -p 167 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.runtime.*
                evince -p 169 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.Alignment
                evince -p 192 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            (import com.example.composedemo.vi.theme.ComposeDemoTheme)
                evince -p 680 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.material.*
            import androidx.compose.runtime.mutableStateOf
            import androidx.compose.runtime.remember
            import androidx.compose.foundation.layout.Column
                evince -p 682 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.runtime.getValue
            import androidx.compose.runtime.setValue
                evince -p 703 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.runtime.saveable.rememberSaveable
                evince -p 717 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.background
            import androidx.compose.foundation.isSystemInDarkTheme
            import androidx.compose.foundation.layout.Column
            import androidx.compose.runtime.CompositionLocalProvider
            import androidx.compose.runtime.staticCompositionLocalOf
            import androidx.compose.ui.graphics.Color
                evince -p 725 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import android.content.res.Configuration.UI.MODE_NIGHT_YES
                evince -p 758 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.runtime.*
            import androidx.compose.material.*
            import androidx.compose.foundation.layout.*
                evince -p 761 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.Alignment
            import androidx.compose.ui.unit.dp
                evince -p 765 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.layout.Row
                evince -p 779 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.Image
            import androidx.compose.ui.res.painterResource
                evince -p 799 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.graphics.Color
                evince -p 800 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.unit.sp
            import androidx.compose.ui.text.font.FontWeight
                evince -p 804 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.border
            import androidx.compose.foundation.layout.padding
            import androidx.compose.ui.unit.dp
                evince -p 809 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.Image
            import androidx.compose.ui.res.painterResource
                evince -p 814 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.Alignment
            import androidx.compose.foundation.layout.*
                evince -p 817 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.shape.RoundedCornerShape
            import androidx.compose.ui.draw.clip
                evince -p 830 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.border
            import androidx.compose.foundation.layout.padding
            import androidx.compose.foundation.layout.*
            import androidx.compose.ui.graphics.Color
            import androidx.compose.ui.text.font.FontWeight
            import androidx.compose.ui.text.style.TextAlign
            import androidx.compose.ui.unit.dp
            import androidx.compose.ui.unit.sp
                evince -p 843 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.Alignment
                evince -p 866 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.layout.LastBaseline
                evince -p 881 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.border
            import androidx.compose.foundation.layout.padding
            import androidx.compose.ui.graphics.Color
            import androidx.compose.ui.text.font.FontWeight
            import androidx.compose.ui.text.style.TextAlign
            import androidx.compose.ui.unit.dp
            import androidx.compose.ui.unit.sp
                evince -p 883 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.layout.Box
            import androidx.compose.foundation.layout.size
                evince -p 889 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.Alignment
                evince -p 895 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.background
            import androidx.compose.ui.draw.clip
            import androidx.compose.foundation.shape.CircleShape
                evince -p 896 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.shape.RoundedCornerShape
                evince -p 898 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.shape.CutCornerShape
                evince -p 911 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.background
            import androidx.compose.foundation.layout.*
            import androidx.compose.ui.graphics.Color
            import androidx.compose.ui.unit.dp
            import androidx.compose.ui.layout.layout
                evince -p 927 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import kotlin.math.roundToInt
                evince -p 929 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.Alignment
                evince -p 951 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.layout.Layout
                evince -p 957 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.background
            import androidx.compose.foundation.layout.Box
            import androidx.compose.foundation.layout.size
            import androidx.compose.ui.graphics.Color
            import androidx.compose.ui.unit.dp
                evince -p 1013 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.material.Button
            import androidx.constraintlayout.compose.ConstraintLayout
                evince -p 1015 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.layout.size
            import androidx.compose.ui.unit.dp
                evince -p 1043 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.constraintlayout.compose.ChainStyle
                evince -p 1050 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.layout.width
            import androidx.constraintlayout.compose.Dimension
                evince -p 1062 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.unit.Dp
            import androidx.constraintlayout.compose.ConstraintSet
                evince -p 1079 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.material.TextField
                evince -p 1080 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.runtime.*
                evince -p 1081 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.background
            import androidx.compose.foundation.layout.*
            import androidx.compose.ui.graphics.Color
            import androidx.compose.ui.unit.dp
                evince -p 1135 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.layout.Column
            import androidx.compose.foundation.layout.padding
            import androidx.compose.ui.unit.dp
                evince -p 1141 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.rememberScrollState
            import androidx.compose.foundation.verticalScroll
                evince -p 1143 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.layout.Row
            import androidx.compose.material.Button
            import androidx.compose.runtime.rememberCoroutineScope
                evince -p 1146 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import kotlinx.coroutines.launch
                evince -p 1151 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.horizontalScroll
                evince -p 1172 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.Image
            import androidx.compose.foundation.layout.*
            import androidx.compose.ui.layout.ContentScale
            import androidx.compose.ui.unit.dp
            import coil.compose.rememberImagePainter
                evince -p 1177 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.shape.RoundedCornerShape
            import androidx.compose.material.Card
            import androidx.compose.ui.Alignment
                evince -p 1181 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.lazy.LazyColumn
            import androidx.compose.foundation.lazy.items
                evince -p 1187 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import android.widget.Toast
            import androidx.compose.ui.platform.LocalContext
                evince -p 1188 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.*
                evince -p 1201 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.graphics.Color
                evince -p 1208 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.lazy.rememberLazyListState
            import androidx.compose.runtime.rememberCoroutineScope
                evince -p 1211 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.material.*
            import kotlinx.coroutines.launch
                evince -p 1214 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.animation.AnimatedVisibility
                evince -p 1226 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.material.*
            import androidx.compose.ui.graphics.Color
                evince -p 1227 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.background
            import androidx.compose.foundation.layout.*
            import androidx.compose.ui.unit.dp
            import androidx.compose.ui.Alignment
            import androidx.compose.runtime.*
                evince -p 1232 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.animation.*
                evince -p 1241 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.animation.core.*
                evince -p 1273 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.Image
            import androidx.compose.foundation.layout.*
            import androidx.compose.material.Button
            import androidx.compose.runtime.*
            import androidx.compose.ui.Alignment
            import androidx.compose.ui.draw.rotate
            import androidx.compose.ui.res.painterResource
            import androidx.compose.ui.unit.dp
                evince -p 1277 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.animation.core.*
                evince -p 1282 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.background
            import androidx.compose.ui.graphics.Color
                evince -p 1286 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.animation.animateColorAsState
                evince -p 1292 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.platform.LocalConfiguration
                evince -p 1293 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.unit.Dp
                evince -p 1298 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.animation.core.Spring.DampingRatioHighBouncy
                evince -p 1299 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.animation.core.Spring.StiffnessVery Low
                evince -p 1311 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.animation.animateColor
                evince -p 1329 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.Canvas
            import androidx.compose.foundation.layout.size
            import androidx.compose.ui.geometry.Offset
            import androidx.compose.ui.geometry.Size
            import androidx.compose.ui.graphics.*
            import androidx.compose.ui.unit.dp
                evince -p 1343 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.graphics.drawscope.inset
                evince -p 1344 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.geometry.CornerRadius
            import androidx.compose.ui.graphics.drawscope.Stroke
                evince -p 1347 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.graphics.drawscope.rotate
                evince -p 1367 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import java.lang.Math.PI
            import java.lang.Math.sin
                evince -p 1373 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.res.imageResource
                evince -p 1413 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.runtime.getValue
            import androidx.compose.runtime.mutableStateOf
            import androidx.compose.runtime.setValue
            import androidx.lifecycle.ViewModel
                evince -p 1414 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import java.lang.Exception
            import kotlin.math.roundToInt
                evince -p 1417 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.lifecycle.viewmodel.compose.viewModel
                evince -p 1425 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.animation.Crossfade
            import androidx.compose.animation.core.tween
            import androidx.compose.foundation.layout.*
            import androidx.compose.foundation.text.KeyboardOptions
            import androidx.compose.material.*
            import androidx.compose.ui.Alignment
            import androidx.compose.ui.res.painterResource
            import androidx.compose.ui.text.TextStyle
            import androidx.compose.ui.text.font.FontWeight
            import androidx.compose.ui.text.input.KeyboardType
            import androidx.compose.ui.unit.dp
                evince -p 1426 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.unit.sp
                evince -p 1433 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.runtime.getValue
            import androidx.compose.runtime.mutableStateOf
            import androidx.compose.runtime.setValue
            import androidx.compose.runtime.remember
                evince -p 1497 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import android.content.Context
            import androidx.room.Database
            import androidx.room.Room
            import androidx.room.RoomDatabase
                evince -p 1523 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.annotation.NonNull
            import androidx.room.ColumnInfo
            import androidx.room.Entity
            import androidx.room.PrimaryKey
                evince -p 1528 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.lifecycle.LiveData
            import androidx.room.Dao
            import androidx.room.Insert
            import androidx.room.Query
                evince -p 1531 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import android.content.Context
            import androidx.room.Database
            import androidx.room.Room
            import androidx.room.RoomDatabase
                evince -p 1535 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.lifecycle.LiveData
            import androidx.lifecycle.MutableLiveData
            import kotlinx.coroutines.*
                evince -p 1542 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import android.app.Application
            import androidx.lifecycle.LiveData
            import androidx.lifecycle.MutableLiveData
                evince -p 1543 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.lifecycle.ViewModel
                evince -p 1547 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.background
            import androidx.compose.foundation.layout.*
            import androidx.compose.foundation.text.KeyboardOptions
            import androidx.compose.material.*
            import androidx.compose.ui.graphics.Color
            import androidx.compose.ui.text.TextStyle
            import androidx.compose.ui.text.font.FontWeight
            import androidx.compose.ui.text.input.KeyboardType
            import androidx.compose.ui.unit.dp
            import androidx.compose.ui.unit.sp
                evince -p 1553 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import android.app.Application
            import androidx.lifecycle.ViewModel
            import androidx.lifecycle.ViewModelProvider
                evince -p 1554 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.platform.LocalContext
            import androidx.lifecycle.viewmodel.compose.LocalViewModelStoreOwner
            import androidx.lifecycle.viewmodel.compose.viewModel
                evince -p 1557 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.runtime.*
            import androidx.compose.runtime.livedata.observeAsState
                evince -p 1560 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.Alignment.Companion.CenterHorizontally
                evince -p 1564 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.lazy.LazyColumn
            import androidx.compose.foundation.lazy.items
                evince -p 1620 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.layout.*
            import androidx.compose.material.*
            import androidx.compose.runtime.*
            import androidx.compose.ui.Alignment
            import androidx.compose.ui.Modifier
            import androidx.compose.ui.text.TextStyle
            import androidx.compose.ui.text.font.FontWeight
            import androidx.compose.ui.unit.dp
            import androidx.compose.ui.unit.sp
            import androidx.navigation.NavHostController
            import com.example.navigationdemo.NavRoutes
                evince -p 1625 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.layout.*
            import androidx.compose.material.*
            import androidx.compose.runtime.*
            import androidx.compose.ui.Alignment
            import androidx.compose.ui.Modifier
            import androidx.compose.ui.unit.dp
            import androidx.navigation.NavHostController
            import com.example.navigationdemo.NavRoutes
                evince -p 1627 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.layout.*
            import androidx.compose.material.*
            import androidx.compose.runtime.*
            import androidx.compose.ui.Alignment
            import androidx.compose.ui.Modifier
                evince -p 1629 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.navigation.compose.NavHost
            import androidx.navigation.compose.composable
            import androidx.navigation.compose.rememberNavController
            import com.example.navigationdemo.screens.Home
            import com.example.navigationdemo.screens.Profile
            import com.example.navigationdemo.screens.Welcome
                evince -p 1653 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.graphics.vector.ImageVector
                evince -p 1655 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.material.icons.*
            import androidx.compose.material.icons.filled.Home
            import androidx.compose.material.icons.filled.Favorite
            import androidx.compose.material.icons.filled.Face
                evince -p 1658 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.layout.Box
            import androidx.compose.foundation.layout.fillMaxSize
            import androidx.compose.foundation.layout.size
            import androidx.compose.material.Icon
            import androidx.compose.material.icons.Icons
            import androidx.compose.material.icons.filled.Home
            import androidx.compose.runtime.Composable
            import androidx.compose.ui.Alignment
            import androidx.compose.ui.Modifier
            import androidx.compose.ui.graphics.Color
            import androidx.compose.ui.tooling.preview.Preview
            import androidx.compose.ui.unit.dp
                evince -p 1660 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.material.icons.filled.Face
                evince -p 1661 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.material.icons.filled.Favorite
                evince -p 1663 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.navigation.compose.NavHost
            import androidx.navigation.compose.composable
            import androidx.navigation.compose.rememberNavController
            import androidx.navigation.NavHostController
            import com.example.bottombardemo.screens.Contacts
            import com.example.bottombardemo.screens.Favorites
            import com.example.bottombardemo.screens.Home
                evince -p 1667 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.material.*
            import androidx.compose.runtime.getValue
            import androidx.navigation.compose.currentBackStackEntryAsState
            import androidx.navigation.NavGraph.Companion.findStartDestination
                evince -p 1685 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.*
            import androidx.compose.foundation.gestures.*
            import androidx.compose.foundation.layout.*
            import androidx.compose.runtime.*
            import androidx.compose.ui.graphics.*
            import androidx.compose.ui.unit.dp
                evince -p 1690 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.Alignment
            import androidx.compose.ui.input.pointer.pointerInput
                evince -p 1695 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.unit.IntOffset
            import kotlin.math.roundTolnt
                evince -p 1711 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.geometry.Offset
            import androidx.compose.ui.res.imageResource
                evince -p 1749 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.material.*
            import androidx.compose.ui.platform.LocalDensity
            import androidx.compose.ui.unit.dp
                evince -p 1753 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.gestures.Orientation
            import androidx.compose.foundation.layout.*
                evince -p 1755 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.background
            import androidx.compose.foundation.shape.CircleShape
            import androidx.compose.ui.Alignment
            import androidx.compose.ui.graphics.Color
                evince -p 1757 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.ui.unit.sp
            import androidx.compose.ui.unit.IntOffset
            import kotlin.math.roundToInt
                evince -p 1793 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.foundation.layout.Arrangement
            import androidx.compose.foundation.layout.Column
                evince -p 1794 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import androidx.compose.material.icons.Icons
            import androidx.compose.material.icons.filled.Favorite
            import androidx.compose.material.icons.filled.Home
            import androidx.compose.material.icons.filled.Settings
            import androidx.compose.material3.*
            import androidx.compose.runtime.*
            import androidx.compose.ui.Alignment
                evince -p 1809 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.pdf &
            import android.os.Build
            import androidx.compose.material3.*
            import androidx.compose.ui.platform.LocalContext
components/methods: sorted by occurence (=in 'Jetpack Compose Essentials')
            ----
            [sorted by: -t, -k2 -n]
            ----
            import android.os.Bundle
            import androidx.activity.ComponentActivity
            import androidx.activity.compose.setContent
            import androidx.compose.material.MaterialTheme
            import androidx.compose.material.Surface
            import androidx.compose.material.Text
            import androidx.compose.ui.text.font.FontWeight
            import androidx.compose.ui.unit.sp
            import androidx.compose.foundation.layout.*
            import androidx.compose.material.Slider
            import androidx.compose.ui.unit.dp
            import androidx.compose.runtime.*
            import androidx.compose.ui.Alignment
            (import com.example.composedemo.vi.theme.ComposeDemoTheme)
            import androidx.compose.material.*
            import androidx.compose.runtime.mutableStateOf
            import androidx.compose.runtime.remember
            import androidx.compose.foundation.layout.Column
            import androidx.compose.runtime.getValue
            import androidx.compose.runtime.setValue
            import androidx.compose.runtime.saveable.rememberSaveable
            import androidx.compose.foundation.background
            import androidx.compose.foundation.isSystemInDarkTheme
            import androidx.compose.runtime.CompositionLocalProvider
            import androidx.compose.runtime.staticCompositionLocalOf
            import androidx.compose.ui.graphics.Color
            import android.content.res.Configuration.UI.MODE_NIGHT_YES
            import androidx.compose.foundation.layout.Row
            import androidx.compose.foundation.Image
            import androidx.compose.ui.res.painterResource
            import androidx.compose.foundation.border
            import androidx.compose.foundation.layout.padding
            import androidx.compose.foundation.shape.RoundedCornerShape
            import androidx.compose.ui.draw.clip
            import androidx.compose.ui.text.style.TextAlign
            import androidx.compose.ui.layout.LastBaseline
            import androidx.compose.foundation.layout.Box
            import androidx.compose.foundation.layout.size
            import androidx.compose.foundation.shape.CircleShape
            import androidx.compose.foundation.shape.CutCornerShape
            import androidx.compose.ui.layout.layout
            import kotlin.math.roundToInt
            import androidx.compose.ui.layout.Layout
            import androidx.compose.material.Button
            import androidx.constraintlayout.compose.ConstraintLayout
            import androidx.constraintlayout.compose.ChainStyle
            import androidx.compose.foundation.layout.width
            import androidx.constraintlayout.compose.Dimension
            import androidx.compose.ui.unit.Dp
            import androidx.constraintlayout.compose.ConstraintSet
            import androidx.compose.material.TextField
            import androidx.compose.foundation.rememberScrollState
            import androidx.compose.foundation.verticalScroll
            import androidx.compose.runtime.rememberCoroutineScope
            import kotlinx.coroutines.launch
            import androidx.compose.foundation.horizontalScroll
            import androidx.compose.ui.layout.ContentScale
            import coil.compose.rememberImagePainter
            import androidx.compose.material.Card
            import androidx.compose.foundation.lazy.LazyColumn
            import androidx.compose.foundation.lazy.items
            import android.widget.Toast
            import androidx.compose.ui.platform.LocalContext
            import androidx.compose.foundation.*
            import androidx.compose.foundation.lazy.rememberLazyListState
            import androidx.compose.animation.AnimatedVisibility
            import androidx.compose.animation.*
            import androidx.compose.animation.core.*
            import androidx.compose.ui.draw.rotate
            import androidx.compose.animation.animateColorAsState
            import androidx.compose.ui.platform.LocalConfiguration
            import androidx.compose.animation.core.Spring.DampingRatioHighBouncy
            import androidx.compose.animation.core.Spring.StiffnessVery Low
            import androidx.compose.animation.animateColor
            import androidx.compose.foundation.Canvas
            import androidx.compose.ui.geometry.Offset
            import androidx.compose.ui.geometry.Size
            import androidx.compose.ui.graphics.*
            import androidx.compose.ui.graphics.drawscope.inset
            import androidx.compose.ui.geometry.CornerRadius
            import androidx.compose.ui.graphics.drawscope.Stroke
            import androidx.compose.ui.graphics.drawscope.rotate
            import java.lang.Math.PI
            import java.lang.Math.sin
            import androidx.compose.ui.res.imageResource
            import androidx.lifecycle.ViewModel
            import java.lang.Exception
            import androidx.lifecycle.viewmodel.compose.viewModel
            import androidx.compose.animation.Crossfade
            import androidx.compose.animation.core.tween
            import androidx.compose.foundation.text.KeyboardOptions
            import androidx.compose.ui.text.TextStyle
            import androidx.compose.ui.text.input.KeyboardType
            import android.content.Context
            import androidx.room.Database
            import androidx.room.Room
            import androidx.room.RoomDatabase
            import androidx.annotation.NonNull
            import androidx.room.ColumnInfo
            import androidx.room.Entity
            import androidx.room.PrimaryKey
            import androidx.lifecycle.LiveData
            import androidx.room.Dao
            import androidx.room.Insert
            import androidx.room.Query
            import androidx.lifecycle.MutableLiveData
            import kotlinx.coroutines.*
            import android.app.Application
            import androidx.lifecycle.ViewModelProvider
            import androidx.lifecycle.viewmodel.compose.LocalViewModelStoreOwner
            import androidx.compose.runtime.livedata.observeAsState
            import androidx.compose.ui.Alignment.Companion.CenterHorizontally
            import androidx.compose.ui.Modifier
            import androidx.navigation.NavHostController
            import com.example.navigationdemo.NavRoutes
            import androidx.navigation.compose.NavHost
            import androidx.navigation.compose.composable
            import androidx.navigation.compose.rememberNavController
            import com.example.navigationdemo.screens.Home
            import com.example.navigationdemo.screens.Profile
            import com.example.navigationdemo.screens.Welcome
            import androidx.compose.ui.graphics.vector.ImageVector
            import androidx.compose.material.icons.*
            import androidx.compose.material.icons.filled.Home
            import androidx.compose.material.icons.filled.Favorite
            import androidx.compose.material.icons.filled.Face
            import androidx.compose.foundation.layout.fillMaxSize
            import androidx.compose.material.Icon
            import androidx.compose.material.icons.Icons
            import androidx.compose.runtime.Composable
            import androidx.compose.ui.tooling.preview.Preview
            import com.example.bottombardemo.screens.Contacts
            import com.example.bottombardemo.screens.Favorites
            import com.example.bottombardemo.screens.Home
            import androidx.navigation.compose.currentBackStackEntryAsState
            import androidx.navigation.NavGraph.Companion.findStartDestination
            import androidx.compose.foundation.gestures.*
            import androidx.compose.ui.input.pointer.pointerInput
            import androidx.compose.ui.unit.IntOffset
            import androidx.compose.ui.platform.LocalDensity
            import androidx.compose.foundation.gestures.Orientation
            import androidx.compose.foundation.layout.Arrangement
            import androidx.compose.material.icons.filled.Settings
            import androidx.compose.material3.*
            import android.os.Build
components/methods: number of occurences (=in 'Jetpack Compose Essentials')
             2 import android.app.Application
             2 import android.content.Context
             1 import android.content.res.Configuration.UI.MODE_NIGHT_YES
             1 import android.os.Build
             1 import android.os.Bundle
             1 import android.widget.Toast
             1 import androidx.activity.ComponentActivity
             1 import androidx.activity.compose.setContent
             1 import androidx.annotation.NonNull
             1 import androidx.compose.animation.*
             1 import androidx.compose.animation.animateColor
             1 import androidx.compose.animation.animateColorAsState
             1 import androidx.compose.animation.AnimatedVisibility
             2 import androidx.compose.animation.core.*
             1 import androidx.compose.animation.core.Spring.DampingRatioHighBouncy
             1 import androidx.compose.animation.core.Spring.StiffnessVery Low
             1 import androidx.compose.animation.core.tween
             1 import androidx.compose.animation.Crossfade
             2 import androidx.compose.foundation.*
             9 import androidx.compose.foundation.background
             3 import androidx.compose.foundation.border
             1 import androidx.compose.foundation.Canvas
             1 import androidx.compose.foundation.gestures.*
             1 import androidx.compose.foundation.gestures.Orientation
             1 import androidx.compose.foundation.horizontalScroll
             4 import androidx.compose.foundation.Image
             1 import androidx.compose.foundation.isSystemInDarkTheme
            16 import androidx.compose.foundation.layout.*
             1 import androidx.compose.foundation.layout.Arrangement
             3 import androidx.compose.foundation.layout.Box
             4 import androidx.compose.foundation.layout.Column
             1 import androidx.compose.foundation.layout.fillMaxSize
             4 import androidx.compose.foundation.layout.padding
             2 import androidx.compose.foundation.layout.Row
             5 import androidx.compose.foundation.layout.size
             1 import androidx.compose.foundation.layout.width
             2 import androidx.compose.foundation.lazy.items
             2 import androidx.compose.foundation.lazy.LazyColumn
             1 import androidx.compose.foundation.lazy.rememberLazyListState
             1 import androidx.compose.foundation.rememberScrollState
             2 import androidx.compose.foundation.shape.CircleShape
             1 import androidx.compose.foundation.shape.CutCornerShape
             3 import androidx.compose.foundation.shape.RoundedCornerShape
             2 import androidx.compose.foundation.text.KeyboardOptions
             1 import androidx.compose.foundation.verticalScroll
            11 import androidx.compose.material.*
             2 import androidx.compose.material3.*
             3 import androidx.compose.material.Button
             1 import androidx.compose.material.Card
             1 import androidx.compose.material.Icon
             1 import androidx.compose.material.icons.*
             2 import androidx.compose.material.icons.filled.Face
             3 import androidx.compose.material.icons.filled.Favorite
             3 import androidx.compose.material.icons.filled.Home
             1 import androidx.compose.material.icons.filled.Settings
             2 import androidx.compose.material.icons.Icons
             1 import androidx.compose.material.MaterialTheme
             1 import androidx.compose.material.Slider
             1 import androidx.compose.material.Surface
             1 import androidx.compose.material.Text
             1 import androidx.compose.material.TextField
            11 import androidx.compose.runtime.*
             1 import androidx.compose.runtime.Composable
             1 import androidx.compose.runtime.CompositionLocalProvider
             4 import androidx.compose.runtime.getValue
             1 import androidx.compose.runtime.livedata.observeAsState
             3 import androidx.compose.runtime.mutableStateOf
             2 import androidx.compose.runtime.remember
             2 import androidx.compose.runtime.rememberCoroutineScope
             1 import androidx.compose.runtime.saveable.rememberSaveable
             3 import androidx.compose.runtime.setValue
             1 import androidx.compose.runtime.staticCompositionLocalOf
            17 import androidx.compose.ui.Alignment
             1 import androidx.compose.ui.Alignment.Companion.CenterHorizontally
             2 import androidx.compose.ui.draw.clip
             1 import androidx.compose.ui.draw.rotate
             1 import androidx.compose.ui.geometry.CornerRadius
             2 import androidx.compose.ui.geometry.Offset
             1 import androidx.compose.ui.geometry.Size
             2 import androidx.compose.ui.graphics.*
            13 import androidx.compose.ui.graphics.Color
             1 import androidx.compose.ui.graphics.drawscope.inset
             1 import androidx.compose.ui.graphics.drawscope.rotate
             1 import androidx.compose.ui.graphics.drawscope.Stroke
             1 import androidx.compose.ui.graphics.vector.ImageVector
             1 import androidx.compose.ui.input.pointer.pointerInput
             1 import androidx.compose.ui.layout.ContentScale
             1 import androidx.compose.ui.layout.LastBaseline
             1 import androidx.compose.ui.layout.layout
             1 import androidx.compose.ui.layout.Layout
             4 import androidx.compose.ui.Modifier
             1 import androidx.compose.ui.platform.LocalConfiguration
             3 import androidx.compose.ui.platform.LocalContext
             1 import androidx.compose.ui.platform.LocalDensity
             2 import androidx.compose.ui.res.imageResource
             4 import androidx.compose.ui.res.painterResource
             7 import androidx.compose.ui.text.font.FontWeight
             2 import androidx.compose.ui.text.input.KeyboardType
             2 import androidx.compose.ui.text.style.TextAlign
             3 import androidx.compose.ui.text.TextStyle
             1 import androidx.compose.ui.tooling.preview.Preview
             6 import androidx.compose.ui.unit.dp
             1 import androidx.compose.ui.unit.Dp
            15 import androidx.compose.ui.unit.dp
             1 import androidx.compose.ui.unit.Dp
             2 import androidx.compose.ui.unit.IntOffset
             8 import androidx.compose.ui.unit.sp
             1 import androidx.constraintlayout.compose.ChainStyle
             1 import androidx.constraintlayout.compose.ConstraintLayout
             1 import androidx.constraintlayout.compose.ConstraintSet
             1 import androidx.constraintlayout.compose.Dimension
             3 import androidx.lifecycle.LiveData
             2 import androidx.lifecycle.MutableLiveData
             3 import androidx.lifecycle.ViewModel
             1 import androidx.lifecycle.viewmodel.compose.LocalViewModelStoreOwner
             2 import androidx.lifecycle.viewmodel.compose.viewModel
             1 import androidx.lifecycle.ViewModelProvider
             2 import androidx.navigation.compose.composable
             1 import androidx.navigation.compose.currentBackStackEntryAsState
             2 import androidx.navigation.compose.NavHost
             2 import androidx.navigation.compose.rememberNavController
             1 import androidx.navigation.NavGraph.Companion.findStartDestination
             3 import androidx.navigation.NavHostController
             1 import androidx.room.ColumnInfo
             1 import androidx.room.Dao
             2 import androidx.room.Database
             1 import androidx.room.Entity
             1 import androidx.room.Insert
             1 import androidx.room.PrimaryKey
             1 import androidx.room.Query
             2 import androidx.room.Room
             2 import androidx.room.RoomDatabase
             1 import coil.compose.rememberImagePainter
             1 import com.example.bottombardemo.screens.Contacts
             1 import com.example.bottombardemo.screens.Favorites
             1 import com.example.bottombardemo.screens.Home
             1 (import com.example.composedemo.vi.theme.ComposeDemoTheme)
             2 import com.example.navigationdemo.NavRoutes
             1 import com.example.navigationdemo.screens.Home
             1 import com.example.navigationdemo.screens.Profile
             1 import com.example.navigationdemo.screens.Welcome
             1 import java.lang.Exception
             1 import java.lang.Math.PI
             1 import java.lang.Math.sin
             3 import kotlin.math.roundToInt
             1 import kotlin.math.roundTolnt
             1 import kotlinx.coroutines.*
             2 import kotlinx.coroutines.launch
[[ .(=auxlist(??)) ]]
            import android.app.Application,212
            import android.app.Application,226
            import android.content.Context,193
            import android.content.Context,205
            import android.content.res.Configuration.UI.MODE_NIGHT_YES,28
            import android.os.Build,330
            import android.os.Bundle,1
            import android.widget.Toast,122
            import androidx.activity.ComponentActivity,2
            import androidx.activity.compose.setContent,3
            import androidx.annotation.NonNull,197
            import androidx.compose.animation.*,138
            import androidx.compose.animation.animateColor,156
            import androidx.compose.animation.animateColorAsState,151
            import androidx.compose.animation.AnimatedVisibility,130
            import androidx.compose.animation.core.*,139
            import androidx.compose.animation.core.*,148
            import androidx.compose.animation.core.Spring.DampingRatioHighBouncy,154
            import androidx.compose.animation.core.Spring.StiffnessVery Low,155
            import androidx.compose.animation.core.tween,178
            import androidx.compose.animation.Crossfade,177
            import androidx.compose.foundation.*,124
            import androidx.compose.foundation.*,297
            import androidx.compose.foundation.background,133
            import androidx.compose.foundation.background,149
            import androidx.compose.foundation.background,216
            import androidx.compose.foundation.background,22
            import androidx.compose.foundation.background,314
            import androidx.compose.foundation.background,69
            import androidx.compose.foundation.background,74
            import androidx.compose.foundation.background,82
            import androidx.compose.foundation.background,98
            import androidx.compose.foundation.border,40
            import androidx.compose.foundation.border,49
            import androidx.compose.foundation.border,59
            import androidx.compose.foundation.Canvas,157
            import androidx.compose.foundation.gestures.*,298
            import androidx.compose.foundation.gestures.Orientation,312
            import androidx.compose.foundation.horizontalScroll,111
            import androidx.compose.foundation.Image,112
            import androidx.compose.foundation.Image,140
            import androidx.compose.foundation.Image,35
            import androidx.compose.foundation.Image,43
            import androidx.compose.foundation.isSystemInDarkTheme,23
            import androidx.compose.foundation.layout.*,113
            import androidx.compose.foundation.layout.*,134
            import androidx.compose.foundation.layout.*,141
            import androidx.compose.foundation.layout.*,179
            import androidx.compose.foundation.layout.*,217
            import androidx.compose.foundation.layout.*,237
            import androidx.compose.foundation.layout.*,248
            import androidx.compose.foundation.layout.*,256
            import androidx.compose.foundation.layout.*,299
            import androidx.compose.foundation.layout.*,31
            import androidx.compose.foundation.layout.*,313
            import androidx.compose.foundation.layout.*,46
            import androidx.compose.foundation.layout.*,51
            import androidx.compose.foundation.layout.*,75
            import androidx.compose.foundation.layout.*,9
            import androidx.compose.foundation.layout.*,99
            import androidx.compose.foundation.layout.Arrangement,321
            import androidx.compose.foundation.layout.Box,272
            import androidx.compose.foundation.layout.Box,66
            import androidx.compose.foundation.layout.Box,83
            import androidx.compose.foundation.layout.Column,102
            import androidx.compose.foundation.layout.Column,18
            import androidx.compose.foundation.layout.Column,24
            import androidx.compose.foundation.layout.Column,322
            import androidx.compose.foundation.layout.fillMaxSize,273
            import androidx.compose.foundation.layout.padding,103
            import androidx.compose.foundation.layout.padding,41
            import androidx.compose.foundation.layout.padding,50
            import androidx.compose.foundation.layout.padding,60
            import androidx.compose.foundation.layout.Row,107
            import androidx.compose.foundation.layout.Row,34
            import androidx.compose.foundation.layout.size,158
            import androidx.compose.foundation.layout.size,274
            import androidx.compose.foundation.layout.size,67
            import androidx.compose.foundation.layout.size,84
            import androidx.compose.foundation.layout.size,89
            import androidx.compose.foundation.layout.width,92
            import androidx.compose.foundation.lazy.items,121
            import androidx.compose.foundation.lazy.items,236
            import androidx.compose.foundation.lazy.LazyColumn,120
            import androidx.compose.foundation.lazy.LazyColumn,235
            import androidx.compose.foundation.lazy.rememberLazyListState,126
            import androidx.compose.foundation.rememberScrollState,105
            import androidx.compose.foundation.shape.CircleShape,315
            import androidx.compose.foundation.shape.CircleShape,71
            import androidx.compose.foundation.shape.CutCornerShape,73
            import androidx.compose.foundation.shape.RoundedCornerShape,117
            import androidx.compose.foundation.shape.RoundedCornerShape,47
            import androidx.compose.foundation.shape.RoundedCornerShape,72
            import androidx.compose.foundation.text.KeyboardOptions,180
            import androidx.compose.foundation.text.KeyboardOptions,218
            import androidx.compose.foundation.verticalScroll,106
            import androidx.compose.material.*,128
            import androidx.compose.material.*,131
            import androidx.compose.material.*,15
            import androidx.compose.material.*,181
            import androidx.compose.material.*,219
            import androidx.compose.material.*,238
            import androidx.compose.material.*,249
            import androidx.compose.material.*,257
            import androidx.compose.material.*,293
            import androidx.compose.material.*,30
            import androidx.compose.material.*,309
            import androidx.compose.material3.*,327
            import androidx.compose.material3.*,331
            import androidx.compose.material.Button,108
            import androidx.compose.material.Button,142
            import androidx.compose.material.Button,87
            import androidx.compose.material.Card,118
            import androidx.compose.material.Icon,275
            import androidx.compose.material.icons.*,268
            import androidx.compose.material.icons.filled.Face,271
            import androidx.compose.material.icons.filled.Face,284
            import androidx.compose.material.icons.filled.Favorite,270
            import androidx.compose.material.icons.filled.Favorite,285
            import androidx.compose.material.icons.filled.Favorite,324
            import androidx.compose.material.icons.filled.Home,269
            import androidx.compose.material.icons.filled.Home,277
            import androidx.compose.material.icons.filled.Home,325
            import androidx.compose.material.icons.filled.Settings,326
            import androidx.compose.material.icons.Icons,276
            import androidx.compose.material.icons.Icons,323
            import androidx.compose.material.MaterialTheme,4
            import androidx.compose.material.Slider,10
            import androidx.compose.material.Surface,5
            import androidx.compose.material.Text,6
            import androidx.compose.material.TextField,96
            import androidx.compose.runtime.*,12
            import androidx.compose.runtime.*,137
            import androidx.compose.runtime.*,143
            import androidx.compose.runtime.*,232
            import androidx.compose.runtime.*,239
            import androidx.compose.runtime.*,250
            import androidx.compose.runtime.*,258
            import androidx.compose.runtime.*,29
            import androidx.compose.runtime.*,300
            import androidx.compose.runtime.*,328
            import androidx.compose.runtime.*,97
            import androidx.compose.runtime.Composable,278
            import androidx.compose.runtime.CompositionLocalProvider,25
            import androidx.compose.runtime.getValue,170
            import androidx.compose.runtime.getValue,189
            import androidx.compose.runtime.getValue,19
            import androidx.compose.runtime.getValue,294
            import androidx.compose.runtime.livedata.observeAsState,233
            import androidx.compose.runtime.mutableStateOf,16
            import androidx.compose.runtime.mutableStateOf,171
            import androidx.compose.runtime.mutableStateOf,190
            import androidx.compose.runtime.remember,17
            import androidx.compose.runtime.remember,192
            import androidx.compose.runtime.rememberCoroutineScope,109
            import androidx.compose.runtime.rememberCoroutineScope,127
            import androidx.compose.runtime.saveable.rememberSaveable,21
            import androidx.compose.runtime.setValue,172
            import androidx.compose.runtime.setValue,191
            import androidx.compose.runtime.setValue,20
            import androidx.compose.runtime.staticCompositionLocalOf,26
            import androidx.compose.ui.Alignment,119
            import androidx.compose.ui.Alignment,13
            import androidx.compose.ui.Alignment,136
            import androidx.compose.ui.Alignment,144
            import androidx.compose.ui.Alignment,182
            import androidx.compose.ui.Alignment,240
            import androidx.compose.ui.Alignment,251
            import androidx.compose.ui.Alignment,259
            import androidx.compose.ui.Alignment,279
            import androidx.compose.ui.Alignment,303
            import androidx.compose.ui.Alignment,316
            import androidx.compose.ui.Alignment,32
            import androidx.compose.ui.Alignment,329
            import androidx.compose.ui.Alignment,45
            import androidx.compose.ui.Alignment,57
            import androidx.compose.ui.Alignment,68
            import androidx.compose.ui.Alignment,80
            import androidx.compose.ui.Alignment.Companion.CenterHorizontally,234
            import androidx.compose.ui.draw.clip,48
            import androidx.compose.ui.draw.clip,70
            import androidx.compose.ui.draw.rotate,145
            import androidx.compose.ui.geometry.CornerRadius,164
            import androidx.compose.ui.geometry.Offset,159
            import androidx.compose.ui.geometry.Offset,307
            import androidx.compose.ui.geometry.Size,160
            import androidx.compose.ui.graphics.*,161
            import androidx.compose.ui.graphics.*,301
            import androidx.compose.ui.graphics.Color,100
            import androidx.compose.ui.graphics.Color,125
            import androidx.compose.ui.graphics.Color,132
            import androidx.compose.ui.graphics.Color,150
            import androidx.compose.ui.graphics.Color,220
            import androidx.compose.ui.graphics.Color,27
            import androidx.compose.ui.graphics.Color,281
            import androidx.compose.ui.graphics.Color,317
            import androidx.compose.ui.graphics.Color,37
            import androidx.compose.ui.graphics.Color,52
            import androidx.compose.ui.graphics.Color,61
            import androidx.compose.ui.graphics.Color,76
            import androidx.compose.ui.graphics.Color,85
            import androidx.compose.ui.graphics.drawscope.inset,163
            import androidx.compose.ui.graphics.drawscope.rotate,166
            import androidx.compose.ui.graphics.drawscope.Stroke,165
            import androidx.compose.ui.graphics.vector.ImageVector,267
            import androidx.compose.ui.input.pointer.pointerInput,304
            import androidx.compose.ui.layout.ContentScale,114
            import androidx.compose.ui.layout.LastBaseline,58
            import androidx.compose.ui.layout.layout,78
            import androidx.compose.ui.layout.Layout,81
            import androidx.compose.ui.Modifier,241
            import androidx.compose.ui.Modifier,252
            import androidx.compose.ui.Modifier,260
            import androidx.compose.ui.Modifier,280
            import androidx.compose.ui.platform.LocalConfiguration,152
            import androidx.compose.ui.platform.LocalContext,123
            import androidx.compose.ui.platform.LocalContext,229
            import androidx.compose.ui.platform.LocalContext,332
            import androidx.compose.ui.platform.LocalDensity,310
            import androidx.compose.ui.res.imageResource,169
            import androidx.compose.ui.res.imageResource,308
            import androidx.compose.ui.res.painterResource,146
            import androidx.compose.ui.res.painterResource,183
            import androidx.compose.ui.res.painterResource,36
            import androidx.compose.ui.res.painterResource,44
            import androidx.compose.ui.text.font.FontWeight,185
            import androidx.compose.ui.text.font.FontWeight,222
            import androidx.compose.ui.text.font.FontWeight,243
            import androidx.compose.ui.text.font.FontWeight,39
            import androidx.compose.ui.text.font.FontWeight,53
            import androidx.compose.ui.text.font.FontWeight,62
            import androidx.compose.ui.text.font.FontWeight,7
            import androidx.compose.ui.text.input.KeyboardType,186
            import androidx.compose.ui.text.input.KeyboardType,223
            import androidx.compose.ui.text.style.TextAlign,54
            import androidx.compose.ui.text.style.TextAlign,63
            import androidx.compose.ui.text.TextStyle,184
            import androidx.compose.ui.text.TextStyle,221
            import androidx.compose.ui.text.TextStyle,242
            import androidx.compose.ui.tooling.preview.Preview,282
            import androidx.compose.ui.unit.dp,101
            import androidx.compose.ui.unit.dp,104
            import androidx.compose.ui.unit.dp,11
            import androidx.compose.ui.unit.dp,115
            import androidx.compose.ui.unit.dp,135
            import androidx.compose.ui.unit.dp,147
            import androidx.compose.ui.unit.Dp,153
            import androidx.compose.ui.unit.dp,162
            import androidx.compose.ui.unit.dp,187
            import androidx.compose.ui.unit.dp,224
            import androidx.compose.ui.unit.dp,244
            import androidx.compose.ui.unit.dp,253
            import androidx.compose.ui.unit.dp,283
            import androidx.compose.ui.unit.dp,302
            import androidx.compose.ui.unit.dp,311
            import androidx.compose.ui.unit.dp,33
            import androidx.compose.ui.unit.dp,42
            import androidx.compose.ui.unit.dp,55
            import androidx.compose.ui.unit.dp,64
            import androidx.compose.ui.unit.dp,77
            import androidx.compose.ui.unit.dp,86
            import androidx.compose.ui.unit.dp,90
            import androidx.compose.ui.unit.Dp,94
            import androidx.compose.ui.unit.IntOffset,305
            import androidx.compose.ui.unit.IntOffset,319
            import androidx.compose.ui.unit.sp,188
            import androidx.compose.ui.unit.sp,225
            import androidx.compose.ui.unit.sp,245
            import androidx.compose.ui.unit.sp,318
            import androidx.compose.ui.unit.sp,38
            import androidx.compose.ui.unit.sp,56
            import androidx.compose.ui.unit.sp,65
            import androidx.compose.ui.unit.sp,8
            import androidx.constraintlayout.compose.ChainStyle,91
            import androidx.constraintlayout.compose.ConstraintLayout,88
            import androidx.constraintlayout.compose.ConstraintSet,95
            import androidx.constraintlayout.compose.Dimension,93
            import androidx.lifecycle.LiveData,201
            import androidx.lifecycle.LiveData,209
            import androidx.lifecycle.LiveData,213
            import androidx.lifecycle.MutableLiveData,210
            import androidx.lifecycle.MutableLiveData,214
            import androidx.lifecycle.ViewModel,173
            import androidx.lifecycle.ViewModel,215
            import androidx.lifecycle.ViewModel,227
            import androidx.lifecycle.viewmodel.compose.LocalViewModelStoreOwner,230
            import androidx.lifecycle.viewmodel.compose.viewModel,176
            import androidx.lifecycle.viewmodel.compose.viewModel,231
            import androidx.lifecycle.ViewModelProvider,228
            import androidx.navigation.compose.composable,262
            import androidx.navigation.compose.composable,287
            import androidx.navigation.compose.currentBackStackEntryAsState,295
            import androidx.navigation.compose.NavHost,261
            import androidx.navigation.compose.NavHost,286
            import androidx.navigation.compose.rememberNavController,263
            import androidx.navigation.compose.rememberNavController,288
            import androidx.navigation.NavGraph.Companion.findStartDestination,296
            import androidx.navigation.NavHostController,246
            import androidx.navigation.NavHostController,254
            import androidx.navigation.NavHostController,289
            import androidx.room.ColumnInfo,198
            import androidx.room.Dao,202
            import androidx.room.Database,194
            import androidx.room.Database,206
            import androidx.room.Entity,199
            import androidx.room.Insert,203
            import androidx.room.PrimaryKey,200
            import androidx.room.Query,204
            import androidx.room.Room,195
            import androidx.room.Room,207
            import androidx.room.RoomDatabase,196
            import androidx.room.RoomDatabase,208
            import coil.compose.rememberImagePainter,116
            import com.example.bottombardemo.screens.Contacts,290
            import com.example.bottombardemo.screens.Favorites,291
            import com.example.bottombardemo.screens.Home,292
            (import com.example.composedemo.vi.theme.ComposeDemoTheme),14
            import com.example.navigationdemo.NavRoutes,247
            import com.example.navigationdemo.NavRoutes,255
            import com.example.navigationdemo.screens.Home,264
            import com.example.navigationdemo.screens.Profile,265
            import com.example.navigationdemo.screens.Welcome,266
            import java.lang.Exception,174
            import java.lang.Math.PI,167
            import java.lang.Math.sin,168
            import kotlin.math.roundToInt,175
            import kotlin.math.roundToInt,320
            import kotlin.math.roundToInt,79
            import kotlin.math.roundTolnt,306
            import kotlinx.coroutines.*,211
            import kotlinx.coroutines.launch,110
            import kotlinx.coroutines.launch,129
----
~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackComposeEss.txt
            1 - Start Here ----
            1.1 For Kotlin programmers
            1.2 For new Kotlin programmers
            1.3 Downloading the code samples
            1.4 Feedback
            1.5 Errata
            2 - Setting up an Android Studio Development Environment ----
            2.1 System requirements
            2.2 Downloading the Android Studio package
            2.3 Installing Android Studio
              2.3.1 Installation on Windows
              2.3.2 Installation on macOS
              2.3.3 Installation on Linux
            2.4 The Android Studio setup wizard
            2.5 Installing additional Android SDK packages
            2.6 Making the Android SDK tools command-line accessible
              2.6.1 Windows 8.1
              2.6.2 Windows 10
              2.6.3 Windows 11
              2.6.4 Linux
            2.6.5 macOS
            2.7 Android Studio memory management
            2.8 Updating Android Studio and the SDK
            3 - A Compose Project Overview ----
            3.1 About the project
            3.2 Creating the project
            3.3 Creating an activity
            3.4 Defining the project and SDK settings
            3.5 Previewing the example project
            3.6 Reviewing the main activity
            3.7 Preview updates
            4 - An Example Compose Project ----
            4.1 Getting started
            4.2 Removing the template Code
            4.3 The Composable hierarchy
            4.4 Adding the DemoText composable
            4.5 Previewing the DemoText composable
            4.6 Adding the DemoSlider composable
            4.8 Previewing the DemoScreen composable
            4.9 Testing in interactive mode
            4.10 Completing the project
            5 - Creating an Android Virtual Device (AVD) in Android Studio ----
            5.1 About Android Virtual Devices
            5.2 Starting the emulator
            5.3 Running the application in the AVD
            5.4 Running on multiple devices
            5.5 Stopping a running application
            5.6 Supporting dark theme
            5.7 Running the emulator in a separate window
            5.8 Enabling the device frame
            5.9 AVD command-line creation
            5.10 Android Virtual Device configuration files
            5.11 Moving and renaming an Android Virtual Device
            6 - Using and Configuring the Android Studio AVD Emulator ----
            6.1 The emulator environment
            6.2 The emulator toolbar options
            6.3 Working in zoom mode
            6.4 Resizing the emulator window
            6.5 Extended control options
              6.5.1 Location
              6.5.2 Displays
              6.5.3 Cellular
              6.5.4 Battery
              6.5.5 Camera
              6.5.6 Phone
              6.5.7 Directional pad
              6.5.8 Microphone
              6.5.9 Fingerprint
              6.5.10 Virtual sensors
              6.5.11 Snapshots
              6.5.12 Record and playback
              6.5.13 Google Play
              6.5.14 Settings
              6.5.15 Help
            6.6 Working with snapshots
            6.7 Configuring fingerprint emulation
            6.8 The emulator in tool window mode
            7 - A Tour of the Android Studio User Interface ----
            7.1 The Welcome screen
            7.2 The main window
            7.3 The tool windows
            7.4 Android Studio keyboard shortcuts
            7.5 Switcher and recent files navigation
            7.6 Changing the Android Studio theme
            8 - Testing Android Studio Apps on a Physical Android Device ----
            8.1 An overview of the Android Debug Bridge (ADB).
            8.2 Enabling USB debugging ADB on Android devices
              8.2.1 macOS ADB configuration
              8.2.2 Windows ADB configuration
              8.2.3 Linux adb configuration
            8.3 Resolving USB connection issues
            8.4 Enabling wireless debugging on Android devices
            8.5 Testing the adb connection
            9 - The Basics of the Android Studio Code Editor ----
            9.1 The Android Studio editor
            9.2 Code mode
            9.3 Splitting the editor window
            9.4 Code completion
            9.5 Statement completion
            9.6 Parameter information
            9.7 Parameter name hints
            9.8 Code generation
            9.9 Code folding
            9.10 Quick documentation lookup
            9.11 Code reformatting
            9.12 Finding sample code
            9.13 Live templates
            10 - An Overview of the Android Architecture ----
            10.1 The Android software stack
            10.2 The Linux kernel
            10.3 Android runtime - ART
            10.4 Android libraries
              10.4.1 C/C++ libraries
            10.5 Application framework
            10.6 Applications
            11 - An Introduction to Kotlin ----
            11.1 What is Kotlin?
            11.2 Kotlin and Java
            11.3 Converting from Java to Kotlin
            11.4 Kotlin and Android Studio
            11.5 Experimenting with Kotlin
            11.6 Semi-colons in Kotlin
            12 - Kotlin Data Types, Variables and Nullability ----
            12.1 Kotlin data types
              12.1.1 Integer data types
              12.1.2 Floating point data types
              12.1.3 Boolean data type
              12.1.4 Character data type
              12.1.5 String data type
              12.1.6 Escape sequences
            12.2 Mutable variables
            12.3 Immutable variables
            12.4 Declaring mutable and immutable variables
            12.5 Data types are objects
            12.6 Type annotations and type inference
            12.7 Nullable type
            12.8 The safe call operator
            12.9 Not-null assertion
            12.10 Nullable types and the let function
            12.11 Late initialization (lateinit)
            12.12 The Elvis operator
            12.13 Type casting and type checking
            13 - Kotlin Operators and Expressions ----
            13.1 Expression syntax in Kotlin
            13.2 The Basic assignment operator
            13.3 Kotlin arithmetic operators
            13.4 Augmented assignment operators
            13.5 Increment and decrement operators
            13.6 Equality operators
            13.7 Boolean logical operators
            13.8 Range operator
            13.9 Bitwise operators
              13.9.1 Bitwise Inversion
              13.9.2 Bitwise AND
              13.9.3 Bitwise OR
              13.9.4 Bitwise XOR
              13.9.5 Bitwise left shift
              13.9.6 Bitwise right shift
            14 - Kotlin Control Flow ----
            14.1 Looping control flow
              14.1.1 The Kotlin for-in Statement
              14.1.2 The while loop
              14.1.3 The do ... while loop
              14.1.4 Breaking from Loops
              14.1.5 The continue statement
              14.1.6 Break and continue labels
            14.2 Conditional control flow
              14.2.1 Using the if expressions
              14.2.2 Using if... else ... expressions
              14.2.3 Using if... else if... Expressions
              14.2.4 Using the when statement
            15 - An Overview of Kotlin Functions and Lambdas ----
            15.1 What is a function?
            15.2 How to declare a Kotlin function
            15.3 Calling a Kotlin function
            15.4 Single expression functions
            15.5 Local functions
            15.6 Handling return values
            15.7 Declaring default function parameters
            15.8 Variable number of function parameters
            15.9 Lambda expressions
            15.10 Higher-order functions
            16 - The Basics of Object-Oriented Programming in Kotlin ----
            16.1 What is an object?
            16.2 What is a class?
            16.3 Declaring a Kotlin class
            16.4 Adding properties to a class
            16.5 Defining methods
            16.6 Declaring and initializing a class instance
            16.7 Primary and secondary constructors
            16.8 Initializer blocks
            16.9 Calling methods and accessing properties
            16.10 Custom accessors
            16.11 Nested and inner classes
            16.12 Companion objects
            17 - An Introduction to Kotlin Inheritance and Subclassing ----
            17.1 Inheritance, classes, and subclasses
            17.2 Subclassing syntax
            17.3 A Kotlin inheritance example
            17.4 Extending the functionality of a subclass
            17.5 Overriding inherited methods
            17.6 Adding a custom secondary constructor
            17.7 Using the SavingsAccount class
            18 - An Overview of Compose ----
            18.1 Development before Compose
            18.2 Compose declarative syntax
            18.3 Compose is data-driven
            19 - Composable Functions Overview ----
            19.1 What is a composable function?
            19.2 Stateful vs. stateless composables
            19.3 Composable function syntax
            19.4 Foundation and Material composables
            20 - An Overview of Compose State and Recomposition ----
            20.1 The basics of state
            20.2 Introducing recomposition
            20.3 Creating the StateExample project
            20.4 Declaring state in a composable
            20.5 Unidirectional data flow
            20.6 State hoisting
            20.7 Saving state through configuration changes
            21 - An Introduction to Composition Local ----
            21.1 Understanding CompositionLocal
            21.2 Using CompositionLocal
            21.3 Creating the CompLocalDemo project
            21.4 Designing the layout
            21.5 Adding the CompositionLocal state
            21.6 Accessing the CompositionLocal state
            21.7 Testing the design
            22 - An Overview of Compose Slot APIs ----
            22.1 Understanding slot APIs
            22.2 Declaring a slot API
            22.3 Calling slot API composables
            23 - A Compose Slot API Tutorial ----
            23.1 About the project
            23.2 Creating the SlotApiDemo project
            23.3 Preparing the MainActivity class file
            23.4 Creating the MainScreen composable
            23.5 Adding the ScreenContent composable
            23.6 Creating the Checkbox composable
            23.7 Implementing the ScreenContent slot API
            23.8 Adding an Image drawable resource
            23.9 Writing the TitleImage composable
            23.10 Completing the MainScreen composable
            23.11 Previewing the project
            24 - Using Modifiers in Compose ----
            24.1 An overview of modifiers
            24.2 Creating the ModifierDemo project
            24.3 Creating a modifier
            24.4 Modifier ordering
            24.5 Adding modifier support to a composable
            24.6 Common built-in modifiers
            24.7 Combining modifiers
            25 - Composing Layouts with Row and Column ----
            25.1 Creating the RowColDemo project
            25.2 Row composable
            25.3.Column composable
            25.4 Combining Row and Column composables
            25.5 Layout Alignment
            25.6 Layout arrangement positioning
            25.7 Layout arrangement spacing
            25.8 Row and Column scope modifiers
            25.9 Scope modifier weights
            26 - Box Layouts in Compose ----
            26.1 An introduction to the Box composable
            26.2 Creating the BoxLayout project
            26.3 Adding the TextCell composable
            26.4 Adding a Box layout
            26.5 Box alignment
            26.6 BoxScope modifiers
            26.7 Using the clip() modifier
            27 - Custom Layout Modifiers ----
            27.1 Compose layout basics
            27.2 Custom layouts
            27.3 Creating the LayoutModifier project
            27.4 Adding the ColorBox composable
            27.5 Creating a custom layout modifier
            27.6 Understanding default position
            27.7 Completing the layout modifier
            27.8 Using a custom modifier
            27.9 Working with alignment lines
            27.10 Working with baselines
            28 - Building Custom Layouts ----
            28.1 An overview of custom layouts
            28.2 Custom layout syntax
            28.3 Using a custom layout
            28.4 Creating the CustomLayout project
            28.5 Creating the CascadeLayout composable
            28.6 Using the CascadeLayout composable
            29 - A Guide to ConstraintLayout in Compose ----
            29.1 An introduction to ConstraintLayout
            29.2 How ConstraintLayout works
              29.2.1 Constraints
              29.2.2 Margins
              29.2.3 Opposing constraints
              29.2.4 Constraint bias
              29.2.5 Chains
              29.2.6 Chain styles
            29.3 Configuring dimensions
            29.4 Guideline helper
            29.5 Barrier helper
            30 - Working with ConstraintLayout in Compose ----
            30.1 Calling ConstraintLayout
            30.2 Generating references
            30.3 Assigning a reference to a composable
            30.4 Adding constraints
            30.5 Creating the ConstraintLayout project
            30.6 Adding the ConstraintLayout library
            30.7 Adding a custom button composable
            30.8 Basic constraints
            30.9 Opposing constraints
            30.10 Constraint bias
            30.11 Constraint margins
            30.12 The importance of opposing constraints and bias
            30.13 Creating chains
            30.14 Working with guidelines
            30.15 Working with barriers
            30.16 Decoupling constraints with constraint sets
            31 - Working with IntrinsicSize in Compose ----
            31.1 Intrinsic measurements
            31.2 Max. vs Min. Intrinsic Size measurements
            31.3 About the example project
            31.4 Creating the IntrinsicSizeDemo project
            31.5 Creating the custom text field
            31.6 Adding the Text and Box components
            31.7 Adding the top-level Column
            31.8 Testing the project
            31.9 Applying IntrinsicSize.Max measurements
            31.10 Applying IntrinsicSize.Min measurements
            32 - An Overview of Lists and Grids in Compose ----
            32.1 Standard vs. lazy lists
            32.2 Working with Column and Row lists
            32.3 Creating lazy lists
            32.4 Enabling scrolling with ScrollState
            32.5 Programmatic scrolling
            32.6 Sticky headers
            32.7 Responding to scroll position
            32.8 Creating a lazy grid
            33 - A Compose Row and Column List Tutorial ----
            33.1 Creating the ListDemo project
            33.2 Creating a Column-based list
            33.3 Enabling list scrolling
            33.4 Manual scrolling
            33.5 A Row list example
            34 - A Compose Lazy List Tutorial ----
            34.1 Creating the LazyListDemo project
            34.2 Adding list data to the project
            34.3 Reading the XML data
            34.4 Handling image loading
            34.5 Designing the list item composable
            34.6 Building the lazy list
            34.7 Testing the project
            34.8 Making list items clickable
            35 - Lazy List Sticky Headers and Scroll Detection ----
            35.1 Grouping the list item data
            35.2 Displaying the headers and items
            35.3 Adding sticky headers
            35.4 Reacting to scroll position
            35.5 Adding the scroll button
            35.6 Testing the finished app
            36 - Compose Visibility Animation ----
            36.1 Creating the AnimateVisibility project
            36.2 Animating visibility
            36.3 Defining enter and exit animations
            36.4 Animation specs and animation easing
            36.5 Repeating an animation
            36.6 Different animations for different children
            36.7 Auto-starting an animation
            36.8 Implementing crossfading
            37 - Compose State-Driven Animation ----
            37.1 Understanding state-driven animation
            37.2 Introducing animate as state functions
            37.3 Creating the AnimateState project
            37.4 Animating rotation with animateFloatAsState
            37.5 Animating color changes with animateColorAsState
            37.6 Animating motion with animateDpAsState
            37.7 Adding spring effects
            37.8 Working with keyframes
            37.9 Combining multiple animations
            37.10 Using the Animation Inspector
            38 - Canvas Graphics Drawing in Compose ----
            38.1 Introducing the Canvas component
            38.2 Creating the CanvasDemo project
            38.3 Drawing a line and getting the canvas size
            38.4 Drawing dashed lines
            38.5 Drawing a rectangle
            38.6 Applying rotation
            38.7 Drawing circles and ovals
            38.8 Drawing gradients
            38.9 Drawing arcs
            38.10 Drawing paths
            38.11 Drawing points
            38.12 Drawing an image
            39 - Working with ViewModels in Compose ----
            39.1 What is Android Jetpack?
            39.2 The "old" architecture
            39.3 Modern Android architecture
            39.4 The ViewModel component
            39.5 ViewModel implementation using state
            39.6 Connecting a ViewModel state to an activity
            39.7 ViewModel implementation using LiveData
            39.8 Observing ViewModel LiveData within an activity
            40 - A Compose ViewModel Tutorial ----
            40.1 About the project
            40.2 Creating the ViewModelDemo project
            40.3 Adding the ViewModel
            40.4 Accessing DemoViewModel from MainActivity
            40.5 Designing the temperature input composable
            40.6 Designing the temperature input composable
            40.7 Completing the user interface design
            40.8 Testing the app
            41 - An Overview of Android SQLite Databases ----
            41.1 Understanding database tables
            41.2 Introducing database schema
            41.3 Columns and data types
            41.4 Database rows
            41.5 Introducing primary keys
            41.6 What is SQLite?
            41.7 Structured Query Language (SQL)
            41.8 Trying SQLite on an Android Virtual Device (AVD)
            41.9 The Android Room persistence library
            42 - Room Databases and Compose ----
            42.1 Revisiting modern app architecture
            42.2 Key elements of Room database persistence
              42.2.1 Repository
              42.2.2 Room database
              42.2.3 Data Access Object (DAO)
              42.2.4 Entities
              42.2.5 SQLite database
            42.3 Understanding entities
            42.4 Data Access Objects
            42.5 The Room database
            42.6 The Repository
            42.7 In-Memory databases
            42.8 Database Inspector
            43 - A Compose Room Database and Repository Tutorial ----
            43.1 About the RoomDemo project
            43.2 Creating the RoamDemo project
            43.3 Modifying the build configuration
            43.4 Building the entity
            43.5 Creating the Data Access Object
            43.6 Adding the Room database
            43.7 Adding the repository
            43.8 Adding the ViewModel
            43.9 Designing the user interface
            43.10 Writing a ViewModelProvider Factory class
            43.11 Completing the MainScreen function
            43.12 Testing the RoomDemo app
            43.13 Using the Database Inspector
            44 - An Overview of Navigation in Compose ----
            44.1 Understanding navigation
            44.2 Declaring a navigation controller
            44.3 Declaring a navigation host
            44.4 Adding destinations to the navigation graph
            44.5 Navigating to destinations
            44.6 Passing arguments to a destination
            44.7 Working with bottom navigation bars
            45 - A Compose Navigation Tutorial ----
            45.1 Creating the NavigationDemo project
            45.2 About the NavigationDemo project
            45.3 Declaring the navigation routes
            45.4 Adding the home screen
            45.5 Adding the welcome screen
            45.6 Adding the profile screen
            45.7 Creating the navigation controller and host
            45.8 Implementing the screen navigation
            45.9 Passing the user name argument
            45.10 Testing the project
            46 - A Compose Bottom Navigation Bar Tutorial ----
            46.1 Creating the BottomBarDemo project
            46.2 Declaring the navigation routes
            46.3 Designing bar items
            46.4 Creating the bar item list
            46.5 Adding the destination screens
            46.6 Creating the navigation controller and host
            46.7 Designing the navigation bar
            46.8 Working with the Scaffold component
            46.9 Testing the project
            47 - Detecting Gestures in Compose ----
            47.1 Compose gesture detection
            47.2 Creating the GestureDemo project
            47.3 Detecting click gestures
            47.4 Detecting taps using PointerInputScope
            47.5 Detecting drag gestures
            47.6 Detecting drag gestures using PointerInputScope
            47.7 Scrolling using the scrollable modifier
            47.8 Scrolling using the scroll modifiers
            47.9 Detecting pinch gestures
            47.10 Detecting rotation gestures
            47.11 Detecting translation gestures
            48 - Detecting Swipe Gestures in Compose ----
            48.1 Swipe gestures and anchors
            48.2 Detecting swipe gestures
            48.3 Declaring the anchors map
            48.4 Declaring thresholds
            48.5 Moving a component in response to a swipe
            48.6 About the SwipeDemo project
            48.7 Creating the SwipeDemo project
            48.8 Setting up the swipeable state and anchors
            48.9 Designing the parent Box
            48.10 Testing the project
            49 - Working with Compose Theming ----
            49.1 Material Design 2 vs Material Design 3
            49.2 Material Design 2 Theming
            49.3 Material Design 3 Theming
            49.4 Building a Custom Theme
            50 - A Material Design 3 Theming Tutorial ----
            50.1 Creating the ThemeDemo project
            50.2 Adding the Material Design 3 library
            50.3 Designing the user interface
            50.4 Building a new theme
            50.5 Adding the theme to the project
            50.6 Enabling dynamic colors
            51 - Creating, Testing, and Uploading an Android App Bundle ----
            51.1 The release preparation process
            51.2 Android app bundles
            51.3 Register for a Google Play Developer Console account
            51.4 Configuring the app in the console
            51.5 Enabling Google Play app signing
            51.6 Creating a keystore file
            51.7 Creating the Android app bundle
            51.8 Generating test APK files
            51.9 Uploading the app bundle to the Google Play Developer Console
            51.10 Exploring the app bundle
            51.11 Managing testers
            51.12 Rolling the app out for testing
            51.13 Uploading new app bundle revisions
            51.14 Analyzing the app bundle file
            52 - An Overview of Gradle in Android Studio ----
            52.1 An Overview of Gradle
            52.2 Gradle and Android Studio
              52.2.1 Sensible Defaults
              52.2.2 Dependencies
              52.2.3 Build Variants
              52.2.4 Manifest Entries
              52.2.5 APK Signing
              52.2.6 ProGuard Support
            52.3 The Property and Settings Gradle Build Files
            52.4 The Top-level Gradle Build File
            52.5 Module Level Gradle Build Files
            52.6 Configuring Signing Settings in the Build File
            52.7 Running Gradle Tasks from the Command-line
~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/JpackElements.txt
            Prerequisites
            Source Code and Its License
            Introducing Android ----
            Focus: Apps, Not Operating Systems
            What You Need
            How This Book Is Organized
            Setting Up the Tools ----
            But First, Some Notes About Android's Emulator
            Step #1: Install Android Studio
            Step #2: Running Android Studio for the First Time
            Getting Your First Project ----
            Step #2: Get Ready for the x86 Emulator
            Step #3: Set Up the AVD
            Step #4: Set Up the Device
            Step #5: Running the Project
            Taking a Tour of Android Studio ----
            The Project Tree
            The Editing Pane
            The Docked Views
            Popular Menu and Toolbar Options
            Android Studio and Release Channels
            Examining Your Code ----
            The Top Level
            The Project Contents
            The App Module Contents
            The Generated Source Sets
            Language Differences
            Introducing the Activity
            Other Things in the Project Tree
            Exploring Your Resources ----
            What You See in res/
            OS Versions and API Levels
            Decoding Resource Directory Names
            Our Initial Resource Types
            About That R Thingy
            The Resource Manager
            Inspecting Your Manifest ----
            The Root Element
            The Application Element
            The Activity Element (And Its Children)
            Reviewing Your Gradle Scripts ----
            Gradle: The Big Questions
            Obtaining Gradle
            Examining the Gradle Files
            Requesting Plugins
            Android Plugin for Gradle Configuration
            Other Stuff in the android Closure
            Libraries and Dependencies
            Inspecting the Compiled App ----
            What We Build
            Where They Go
            Building the APK
            Analyzing the APK
            Touring the Tests ----
            Instrumented Tests
            Unit Tests
            Introducing jetpack ----
            Um, OK, So, What's the Point?
            Key Elements of Jetpack
            What Came Before: the Android Support Library
            Introducing the Sampler Projects ----
            The Projects
            Getting a Sampler Project
            The Modules
            Running the Samples
            Starting Simple: TextView and Button ----
            First, Some Terminology
            Introducing the Graphical Layout Editor
            TextView: Assigning Labels
            Button: Reacting to Input
            The Curious Case of the Missing R
            Debugging Your App ----
            Get Thee To a Stack Trace
            Running Your App in the Debugger
            So, Where Did We Go Wrong?
            Introducing ConstraintLayout ----
            The Role of Containers
            Layouts and Adapter-Based Containers
            ConstraintLayout: One Layout To Rule Them All
            Getting ConstraintLayout
            Using Widgets and Containers from Libraries
            A Quick RTL Refresher
            Simple Rows with ConstraintLayout
            Starting from Scratch
            ConstraintLayout and the Attributes Pane
            EditText: Making Users Type Stuff
            More Complex Forms
            Turning Back to RTL
            More Fun with ConstraintLayout
            Notes on the Classic Containers
            Integrating Common Form Widgets ----
            ImageView and ImageButton
            Compound Buttons
            SeekBar
            ScrollView: Making It All Fit
            Other Notes About the Sample
            Contemplating Contexts ----
            It's Not an OMG Object, But It's Close
            The Major Types of Context
            Key Context Features
            Know Your Context
            Context Anti-Patterns
            Icons ----
            App Icons... And Everything Else
            Creating an App Icon with the Asset Studio
            Creating Other Icons with the Asset Studio
            Adding Libraries ----
            Depending on a Local JAR
            Artifacts and Repositories
            Requesting Dependencies
            Employing RecyclerView ----
            Recap: Layouts vs. Adapter-Based Containers
            The Challenge: Memory
            Enter RecyclerView
            A Trivial List
            Hey, What About ListView?
            Gesture Navigation and Scrolling Widgets
            Coping with Configurations ----
            What's a Configuration? And How Do They Change?
            Configurations and Resource Sets
            Implementing Resource Sets
            Resource Set Rules
            Activity Lifecycles
            When Activities Die
            Context Anti-Pattern: Outliving It
            Integrating ViewModel ----
            Configuration Changes
            What We Want... and What We Do Not Want
            Enter the ViewModel
            Applying ViewModel
            ViewModel and the Lifecycle
            Changing Data in the ViewModel
            ViewModel and AndroidViewModel
            ViewModelFactory
            Understanding Processes ----
            When Processes Are Created
            What Is In Your Process
            BACK, HOME, and Your Process
            Termination
            Foreground Means "I Love You"
            Tasks and Your App
            Instance State
            Pondering Parcelable
            A State-Aware ViewModel
            Binding Your Data ----
            The Basic Steps
            Why Bother?
            The Other Common "Gimme the Views" Options
            Defining and Using Styles ----
            Styles: DIY DRY
            Elements of Style
            Themes: Would a Style By Any Other Name...
            Android 10 Dark Mode
            The DayNight Solution
            The Material Components for Android
            Context Anti-Pattern: Using Application Everywhere
            Configuring the App Bar ----
            So. Many. Bars.
            Vector Drawables
            Menu Resources
            Using Toolbar Directly
            Using Toolbar as the Action Bar
            Having Fun at Bars
            Implementing Multiple Activities ----
            Multiple Activities, and Your App
            Creating Your Second (and Third and...) Activity
            Starting Your Own Activity
            Extra! Extra!
            Seeing This In Action
            Using Implicit Intents
            Activities and Results
            The Inverse: <intent-filter>
            Adding Library Modules ----
            Reasons for Library Modules
            Consuming a Library Module
            Adopting Fragments ----
            The Six Questions
            Where You Get Your Fragments From
            Static vs. Dynamic Fragments
            Fragments, and What You Have Seen Already
            ToDo, or Not ToDo? That Is the Question
            The Fragment Lifecycle Methods
            View Binding and Fragments
            Context Anti-Pattern: Assuming Certain Types
            Navigating Your App ----
            What We Get from the Navigation Component
            Elements of Navigation
            A Navigation-ized To-Do List
            So... Was It Worth It?
            The Next Wave: Kotlin DSL
            Dialogs ----
            A Tale of Four Dialogs
            Using AlertDialog and DialogFragment
            Writing an App Widget ----
            Writing a... What?
            Challenges with App Widgets
            Introducing Broadcasts and Receivers
            Pieces of the App Widget
            Colors in an App Widget
            Actions and App Widgets
            Thinking About Threads and LiveData ----
            The Main Application Thread
            The UI Thread is for UI
            Introducing LiveData
            Colors... Live!
            Sources of Owners
            Where Do Threads Come From? Um, Besides From Me?
            Coroutines and ViewModel
            The End of LiveData?!?
            Adding Some Architecture ----
            Repositories
            Unidirectional Data Flow
            A UDF Implementation
            The Kotlin LiveData Alternative: StateFlow
            States and Events
            Working with Content ----
            The Storage Access Framework
            Android 11+ Restrictions
            Using Preferences ----
            The Preferred Preferences
            Collecting Preferences with PreferenceFragmentCompat
            Types of Preferences
            Working with SharedPreferences
            Requesting Permissions ----
            Frequently-Asked Questions About Permissions
            Dangerous Permissions: Request at Runtime
            Handling Files ----
            The Three Types of File Storage
            What the User Sees
            Storage, Permissions, and Access
            Reading, Writing, and Debugging Storage
            Serving Files with FileProvider
            What You Should Use
            Accessing the Internet ----
            An API Roundup
            Android's Restrictions
            Forecasting the Weather
            Inverting Your Dependencies ----
            The Problem: Test Control
            The Solution: Dependency Inversion
            Dependency Inversion in Android
            Applying Koin
            Storing Data in a Room ----
            Room Requirements
            Room Furnishings
            Other Fun Stuff in the App
            What Else Does Room Offer?
            Examining Your Database
            Testing Your Changes ----
            A Quick Recap
            Which Tests Should I Write?
            Writing Unit Tests
            Employing Mocks
            Writing Instrumented Tests
            Writing Basic Espresso Tests
            Another Option: UI Automator
            Again: What Should I Be Using?
            Working with WorkManager ----
            The Role of WorkManager
            WorkManager Dependencies
            Workers: They Do Work
            Performing Simple Work
            Work Inputs
            Constrained Work
            Tagged Work
            Monitoring Work
            Canceling Work
            Delayed Work
            Parallel Work
            Chained Work
            Periodic Work
            Unique Work
            Testing Work
            Inspecting Work
            WorkManager and Side Effects
            Creating a New Project ----
            Key Decisions That You Need to Make
            The New-Project Wizard
            Copying an Existing Project
            Creating a Library Module
            Signing Your App ----
            Role of Code Signing
            What Happens In Debug Mode
            Production Signing Keys
            Shrinking Your App ----
            Why We Care
            Identify What to Attack
            Shrinking Your Dependencies
            Shrinking Your Code
            Removing Unused Resources
            Optimizing Bitmaps
            Hey, What About App Bundles?
            Using the AVD Manager and the Emulator ----
            Notable AVD Configuration Options
            The Emulator Sidebar
            Emulator Window Operations
            In-IDE Emulator
            Using the SDK Manager ----
            Installing Platform Pieces
            Installing and Upgrading Tools
            Adding Third-Party SDK Suppliers
            Configuring Your Project ----
            Risks and Rewards
            The Project Category
            The SDK Location
            The Variables
            The Modules
            Dependencies
            Build Variants
            Suggestions
            Configuring Android Studio ----
            Searching for Settings
            Themes and Colors
            Fonts. And Other Fonts.
            Code Styles
            Inlay Hints
            Other Settings of Note
            Coping with New Android Versions ----
            The March of the Versions
            The Typical Release Process
            Things to Worry About
            Deciding Where to Go From Here ----
            The Rest of the Books
            Android Developer Support
            Major Conferences
~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/jpackcompose-bytuts_2021.pdf
              Section I: Getting Started with Jetpack Compose  21
              Chapter 1: Developing UI in Android  22
              Chapter 2: Learning Jetpack Compose Fundamentals 52
              Chapter 3: Building Layout Groups in Compose  87
              Chapter 4: Building Lists with Jetpack Compose  109
              Section II: Composing User Interfaces 130
              Chapter 5: Combining Composables  131
              Chapter 6: Using Compose Modifiers 157
              Chapter 7: Managing State in Compose  183
              Chapter 8: Applying Material Design to Compose  209
              Section III: Building Complex Apps with Jetpack
              Compose  255
              Chapter 9: Using ConstraintSets in Composables 256
              Chapter 10: Building Complex UI in Jetpack
              Compose  283
              Chapter 11: Reacting to Compose Lifecycle  305
              Chapter 12: Animating Properties Using Compose 322
              Chapter 13: Adding View Compatibility 344
              Conclusion  361
            ----
            Book License  13
            Before You Begin  14
            What You Need  15
            Book Source Code & Forums  16
            Introduction  17
            How to read this book  18
            ---- Section I: Getting Started with Jetpack Compose ----
            Chapter 1 - Developing UI in Android ----
            Unwrapping the Android UI toolkit  23
            Introduction to Jetpack Compose  39
            Jetpack Compose's tech stack  48
            Key points  50
            Where to go from here? 51
            Chapter 2 - Learning Jetpack Compose Fundamentals ----
            Composable functions  53
            Basic composable functions  55
            Text  57
            Previewing changes  62
            TextField  64
            Buttons  69
            Progress Bars  78
            AlertDialog  81
            Key points  85
            Where to go from here? 86
            Chapter 3 - Building Layout Groups in Compose ----
            Using basic layouts in Jetpack Compose  88
            Linear layouts  89
            Using Boxes  94
            Scaffold  100
            Key points  107
            Where to go from here?  108
            Chapter 4 - Building Lists with Jetpack Compose ----
            Using vertical scrolling modifiers  110
            Using horizontal scrolling modifiers  113
            Lists in Compose  115
            Grids in Compose 122
            Key points  129
            Where to go from here?  129
            ---- Section II: Composing User Interfaces ----
            Chapter 5 - Combining Composables ----
            Application features  132
            Project overview  133
            Thinking in Compose  136
            Bottom-up approach  137
            Creating the Note composable  138
            Building the app drawer composable 142
            Putting all the pieces together  154
            Key points  156
            Where to go from here?  156
            Chapter 6 - Using Compose Modifiers ----
            Modifiers  158
            Chaining modifiers  160
            Rounding out the NoteColor  163
            Adding NoteColor to Note  167
            Adding a background to Note  168
            Centering Text & Checkbox composables  170
            Centering NoteColor  171
            Taking advantage of the modifier parameter  172
            Styling title and content  174
            Adding the Color composable  176
            Key points  182
            Where to go from here?  182
            Chapter 7 - Managing State in Compose ----
            Understanding state 184
            Handling state with Android UI Toolkit  185
            Handling state with unidirectional data flow  186
            Compose & ViewModel  188
            Creating the Notes screen  190
            Creating the app bar 193
            Stateless composables  196
            Extracting a stateless composable  205
            Key points  208
            Chapter 8 - Applying Material Design to Compose ----
            Opening the Notes screen  210
            Resurrecting the app drawer  213
            Adding the FAB  219
            Adding an entry point  221
            Adding the top bar 224
            Opening the Save Note screen in Editing mode  231
            Creating a content composable  233
            Wrapping up the Save Note screen  239
            Using Material Design composables in the Notes screen  248
            Theming in Compose  251
            Key points  254
            Where to go from here?  254
            ---- Section III: Building Complex Apps with Jetpack Compose ----
            Chapter 9 - Using ConstraintSets in Composables ----
            Understanding ConstraintLayout  257
            ConstraintLayout in Jetpack Compose  258
            Implementing the app drawer layout  260
            Creating the app drawer header  263
            Implementing the app drawer's body  271
            Advanced features of ConstraintLayout  275
            Key points  282
            Chapter 10 - Building Complex UI in Jetpack Compose ----
            Building the home screen  284
            Building the Subreddits screen  295
            Key points  304
            Chapter 11 - Reacting to Compose Lifecycle ----
            Events in Compose  306
            Implementing the community chooser  308
            Implementing the back button handler  313
            Effects in Compose  315
            Migrate effects  319
            Key points  321
            Where to go from here?  321
            Chapter 12 - Animating Properties Using Compose ----
            Building JoinButton  323
            Adding JoinButton to Post  326
            Animating the JoinButton background 328
            Using transitions to animate JoinButton  330
            Animating composable content  335
            Adding experimental annotations  341
            Key points  343
            Chapter 13 - Adding View Compatibility ----
            Introducing the Chat screen and the Trending view  345
            Using composables with the View framework  347
            Using View with Jetpack Compose  351
            Key points  360
            Where to go from here?  360
https://developer.android.com/courses/android-basics-compose/course [****]
 ~/Empire/Doks/Comp/lang/java/android/kotlin/jetpack-compose/jetpackcompose-internals.pdf

