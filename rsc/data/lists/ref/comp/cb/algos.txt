set foldmethod=indent foldlevel=2
vim: fdm=indent:fdl=2:

~/Empire/Doks/Comp/PROGR/algos/algorintrod3d.pdf
            Part I - Foundations
                    1 - The Role of Algorithms in Computing  5
                        1.1 Algorithms  5
                        1.2 Algorithms as a technology  11
                        .
                        .
                    2 - Getting Started 16
                        2.1 Insertion sort 16
                        2.2 Analyzing algorithms 23
                        2.3 Designing algorithms 29
                        .
                        .
                    3 - Growth of Functions 43
                        3.1 Asymptotic notation 43
                        3.2 Standard notations and common functions 53
                        .
                        .
                    4 - Divide-and-Conquer 65
                        4.1 The maximum-subarray problem 68
                        4.2 Strassen's algorithm for matrix multiplication 75
                        4.3 The substitution method for solving recurrences 83
                        4.4 The recursion-tree method for solving recurrences 88
                        4.5 The master method for solving recurrences 93
                        4.6 Proof of the master theorem 97
                        .
                        .
                    5 - Probabilistic Analysis and Randomized Algorithms 114
                        5.1 The hiring problem 114
                        5.2 Indicator random variables 118
                        5.3 Randomized algorithms 122
                        5.4 Probabilistic analysis and further uses of indicator random variables 130
                        .
                        .
            Part II - Sorting and Order Statistics
                    6 - Heapsort 151
                        6.1 Heaps 151
                        6.2 Maintaining the heap property 154
                        6.3 Building a heap 156
                        6.4 The heapsort algorithm 159
                        6.5 Priority queues 162
                        .
                        .
                    7 - Quicksort 170
                        7.1 Description of quicksort 170
                        7.2 Performance of quicksort 174
                        7.3 A randomized version of quicksort 179
                        7.4 Analysis of quicksort 180
                        .
                        .
                    8 - Sorting in Linear Time 191
                        8.1 Lower bounds for sorting 191
                        8.2 Counting sort 194
                        8.3 Radix sort 197
                        8.4 Bucket sort 200
                        .
                        .
                    9 - Medians and Order Statistics 213
                        9.1 Minimum and maximum 214
                        9.2 Selection in expected linear time 215
                        9.3 Selection in worst-case linear time 220
                        .
                        .
            Part III - Data Structures
                    10 - Elementary Data Structures 232
                        10.1 Stacks and queues 232
                        10.2 Linked lists 236
                        10.3 Implementing pointers and objects 241
                        10.4 Representing rooted trees 246
                        .
                        .
                    11 - Hash Tables 253
                        11.1 Direct-address tables 254
                        11.2 Hash tables 256
                        11.3 Hash functions 262
                        11.4 Open addressing 269
                        11.5 Perfect hashing 277
                        .
                        .
                    12 - Binary Search Trees 286
                        12.1 What is a binary search tree? 286
                        12.2 Querying a binary search tree 289
                        12.3 Insertion and deletion 294
                        12.4 Randomly built binary search trees 299
                        .
                        .
                    13 - Red-Black Trees 308
                        13.1 Properties of red-black trees 308
                        13.2 Rotations 312
                        13.3 Insertion 315
                        13.4 Deletion 323
                        .
                        .
                    14 - Augmenting Data Structures 339
                        14.1 Dynamic order statistics 339
                        14.2 How to augment a data structure 345
                        14.3 Interval trees 348
                        .
                        .
            Part IV - Advanced Design and Analysis Techniques
                    15 - Dynamic Programming 359
                        15.1 Rod cutting 360
                        15.2 Matrix-chain multiplication 370
                        15.3 Elements of dynamic programming 378
                        15.4 Longest common subsequence 390
                        15.5 Optimal binary search trees 397
                        .
                        .
                    16 - Greedy Algorithms 414
                        16.1 An activity-selection problem 415
                        16.2 Elements of the greedy strategy 423
                        16.3 Huffman codes 428
                        16.4 Matroids and greedy methods 437
                        16.5 A task-scheduling problem as a matroid 443
                        .
                        .
                    17 - Amortized Analysis 451
                        17.1 Aggregate analysis 452
                        17.2 The accounting method 456
                        17.3 The potential method 459
                        17.4 Dynamic tables 463
                        .
                        .
            Part V - Advanced Data Structures
                    18 - B-Trees 484
                        18.1 Definition of B-trees 488
                        18.2 Basic operations on B-trees 491
                        18.3 Deleting a key from a B-tree 499
                        .
                        .
                    19 - Fibonacci Heaps 505
                        19.1 Structure of Fibonacci heaps 507
                        19.2 Mergeable-heap operations 510
                        19.3 Decreasing a key and deleting a node 518
                        19.4 Bounding the maximum degree 523
                        .
                        .
                    20 - van Emde Boas Trees 531
                        20.1 Preliminary approaches 532
                        20.2 A recursive structure 536
                        20.3 The van Emde Boas tree 545
                        .
                        .
                    21 - Data Structures for Disjoint Sets 561
                        21.1 Disjoint-set operations 561
                        21.2 Linked-list representation of disjoint sets 564
                        21.3 Disjoint-set forests 568
                        *21.4 Analysis of union by rank with path compression
                        .
                        .
            Part VI - Graph Algorithms
                    22 - Elementary Graph Algorithms 589
                        22.1 Representations of graphs 589
                        22.2 Breadth-first search 594
                        22.3 Depth-first search 603
                        22.4 Topological sort 612
                        22.5 Strongly connected components 615
                        .
                        .
                    23 - Minimum Spanning Trees 624
                        23.1 Growing a minimum spanning tree 625
                        23.2 The algorithms of Kruskal and Prim 631
                        .
                        .
                    24 - Single-Source Shortest Paths 643
                        24.1 The Bellman-Ford algorithm 651
                        24.2 Single-source shortest paths in directed acyclic graphs
                        24.3 Dijkstra's algorithm 658
                        24.4 Difference constraints and shortest paths 664
                        24.5 Proofs of shortest-paths properties 671
                        .
                        .
                    25 - All-Pairs Shortest Paths 684
                        25.1 Shortest paths and matrix multiplication 686
                        25.2 The Floyd-Warshall algorithm 693
                        25.3 Johnson's algorithm for sparse graphs 700
                        .
                        .
                    26 - Maximum Flow 708
                        26.1 Flow networks 709
                        26.2 The Ford-Fulkerson method 714
                        26.3 Maximum bipartite matching 732
                        *26.4 Push-relabel algorithms 736
                        *26.5 The relabel-to-front algorithm 748
                        .
                        .
            Part VII - Selected Topics
                    27 - Multithreaded Algorithms 772
                        27.1 The basics of dynamic multithreading 774
                        27.2 Multithreaded matrix multiplication 792
                        27.3 Multithreaded merge sort 797
                        .
                        .
                    28 - Matrix Operations 813
                        28.1 Solving systems of linear equations 813
                        28.2 Inverting matrices 827
                        28.3 Symmetric positive-definite matrices and least-squares approximation 832
                        .
                        .
                    29 - Linear Programming 843
                        29.1 Standard and slack forms 850
                        29.2 Formulating problems as linear programs 859
                        29.3 The simplex algorithm 864
                        29.4 Duality 879
                        29.5 The initial basic feasible solution 886
                        .
                        .
                    30 - Polynomials and the FFT 898
                        30.1 Representing polynomials 900
                        30.2 The DFT and FFT 906
                        30.3 Efficient FFT implementations 915
                        .
                        .
                    31 - Number-Theoretic Algorithms 926
                        31.1 Elementary number-theoretic notions 927
                        31.2 Greatest common divisor 933
                        31.3 Modular arithmetic 939
                        31.4 Solving modular linear equations 946
                        31.5 The Chinese remainder theorem 950
                        31.6 Powers of an element 954
                        31.7 The RSA public-key cryptosystem 958
                        *31.8 Primality testing 965
                        *31.9 Integer factorization 975
                        .
                        .
                    32 - String Matching 985
                        32.1 The naive string-matching algorithm 988
                        32.2 The Rabin-Karp algorithm 990
                        32.3 String matching with finite automata 995
                        *32.4 The Knuth-Morris-Pratt algorithm 1002
                        .
                        .
                    33 - Computational Geometry 1014
                        33.1 Line-segment properties 1015
                        33.2 Determining whether any pair of segments intersects 1021
                        33.3 Finding the convex hull 1029
                        33.4 Finding the closest pair of points 1039
                        .
                        .
                    34 - NP-Completeness 1048
                        34.1 Polynomial time 1053
                        34.2 Polynomial-time verification 1061
                        34.3 NP-completeness and reducibility 1067
                        34.4 NP-completeness proofs 1078
                        34.5 NP-complete problems 1086
                        .
                        .
                    35 - Approximation Algorithms 1106
                        35.1 The vertex-cover problem 1108
                        35.2 The traveling-salesman problem 1111
                        35.3 The set-covering problem 1117
                        35.4 Randomization and linear programming 1123
                        35.5 The subset-sum problem 1128
                        .
                        .
            Part VIII - Appendix: Mathematical Background
                    A - Summations 1145
                        A.1 Summation formulas and properties 1145
                        A.2 Bounding summations 1149
                        .
                        .
                    B - Sets, Etc. 1158
                        B.1 Sets 1158
                        B.2 Relations 1163
                        B.3 Functions 1166
                        B.4 Graphs 1168
                        B.5 Trees 1173
                        .
                        .
                    C - Counting and Probability 1183
                        C.1 Counting 1183
                        C.2 Probability 1189
                        C.3 Discrete random variables 1196
                        C.4 The geometric and binomial distributions 1201
                        *C.5 The tails of the binomial distribution 1208
                        .
                        .
                    D - Matrices 1217
                        D.1 Matrices and matrix operations 1217
                        D.2 Basic matrix properties 1222
                        .
                        .
                    Bibliography 1231
                    Index 1251
'40 Algorithms Every Programmer Should Know'
~/Empire/Doks/Comp/PROGR/algos/algos40.pdf
            Section 1: Fundamentals and Core Algorithms --
            Chapter 1: Overview of Algorithms --
            What is an algorithm?
            The phases of an algorithm
            Specifying the logic of an algorithm
            Understanding pseudocode
            A practical example of pseudocode
            Using snippets
            Creating an execution plan
            Introducing Python packages
            Python packages
            The SciPy ecosystem
            Implementing Python via the Jupyter Notebook
            Algorithm design techniques
            The data dimension
            Compute dimension
            A practical example
            Performance analysis
            Space complexity analysis
            Time complexity analysis
            Estimating the performance
            The best case
            The worst case
            The average case
            Selecting an algorithm
            Big O notation
            Constant time (O(1)) complexity
            Linear time (O(n)) complexity
            Quadratic time (O(n2)) complexity
            Logarithmic time (O(logn)) complexity
            Validating an algorithm
            Exact, approximate, and randomized algorithms
            Explainability
            Summary
            Chapter 2: Data Structures Used in Algorithms --
            Exploring data structures in Python
            Using lists
            Lambda functions
            The range function
            The time complexity of lists
            Tuples
            The time complexity of tuples
            Dictionary
            The time complexity of a dictionary
            Sets
            Time complexity analysis for sets
            DataFrames
            Terminologies of DataFrames
            Creating a subset of a DataFrame
            Matrix
            Column selection
            Row selection
            Matrix operations
            Exploring abstract data types
            Vector
            Stacks
            The time complexity of stacks
            Practical example
            Queues
            The basic idea behind the use of stacks and queues
            Tree
            Terminology
            Types of trees
            Practical examples
            Summary
            Chapter 3: Sorting and Searching Algorithms --
            Introducing Sorting Algorithms
            Swapping Variables in Python
            Bubble Sort
            Understanding the Logic Behind Bubble Sort
            A Performance Analysis of Bubble Sort
            Insertion Sort
            Merge Sort
            Shell Sort
            A Performance Analysis of Shell Sort
            Selection Sort
            The performance of the selection sort algorithm
            Choosing a sorting algorithm
            Introduction to Searching Algorithms
            Linear Search
            The Performance of Linear Search
            Binary Search
            The Performance of Binary Search
            Interpolation Search
            The Performance of Interpolation Search
            Practical Applications
            Summary
            Chapter 4: Designing Algorithms --
            Introducing the basic concepts of designing an algorithm
            Concern 1 – Will the designed algorithm produce the result we expect?
            Concern 2 – Is this the optimal way to get these results?
            Characterizing the complexity of the problem
            Concern 3 – How is the algorithm going to perform on larger datasets?
            Understanding algorithmic strategies
            Understanding the divide-and-conquer strategy
            Practical example – divide-and-conquer applied to Apache Spark
            Understanding the dynamic programming strategy
            Understanding greedy algorithms
            Practical application – solving the TSP
            Using a brute-force strategy
            Using a greedy algorithm
            Presenting the PageRank algorithm
            Problem definition
            Implementing the PageRank algorithm
            Understanding linear programming
            Formulating a linear programming problem
            Defining the objective function
            Specifying constraints
            Practical application – capacity planning with linear programming
            Summary
            Chapter 5: Graph Algorithms --
            Representations of graphs
            Types of graphs
            Undirected graphs
            Directed graphs
            Undirected multigraphs
            Directed multigraphs
            Special types of edges
            Ego-centered networks
            Social network analysis
            Introducing network analysis theory
            Understanding the shortest path
            Creating a neighborhood
            Triangles
            Density
            Understanding centrality measures
            Degree
            Betweenness
            Fairness and closeness
            Eigenvector centrality
            Calculating centrality metrics using Python
            Understanding graph traversals
            Breadth-first search
            Initialization
            The main loop
            Depth-first search
            Case study – fraud analytics
            Conducting simple fraud analytics
            Presenting the watchtower fraud analytics methodology
            Scoring negative outcomes
            Degree of suspicion
            Summary
            Section 2: Machine Learning Algorithms --
            Chapter 6: Unsupervised Machine Learning Algorithms --
            Introducing unsupervised learning
            Unsupervised learning in the data-mining life cycle
            Current research trends in unsupervised learning
            Practical examples
            Voice categorization
            Document categorization
            Understanding clustering algorithms
            Quantifying similarities
            Euclidean distance
            Manhattan distance
            Cosine distance
            K-means clustering algorithm
            The logic of k-means clustering
            Initialization
            The steps of the k-means algorithm
            Stop condition
            Coding the k-means algorithm
            Limitation of k-means clustering
            Hierarchical clustering
            Steps of hierarchical clustering
            Coding a hierarchical clustering algorithm
            Evaluating the clusters
            Application of clustering
            Dimensionality reduction
            Principal component analysis
            Limitations of PCA
            Association rules mining
            Examples of use
            Market basket analysis
            Association rules
            Types of rule
            Trivial rules
            Inexplicable rules
            Actionable rules
            Ranking rules
            Support
            Confidence
            Lift
            Algorithms for association analysis
            Apriori Algorithm
            Limitations of the apriori algorithm
            FP-growth algorithm
            Populating the FP-tree
            Mining Frequent Patterns
            Code for using FP-growth
            Practical application– clustering similar tweets together
            Topic modeling
            Clustering
            Anomaly-detection algorithms
            Using clustering
            Using density-based anomaly detection
            Using support vector machines
            Summary
            Chapter 7: Traditional Supervised Learning Algorithms --
            Understanding supervised machine learning
            Formulating supervised machine learning
            Understanding enabling conditions
            Differentiating between classifiers and regressors
            Understanding classification algorithms
            Presenting the classifiers challenge
            The problem statement
            Feature engineering using a data processing pipeline
            Importing data
            Feature selection
            One-hot encoding
            Specifying the features and label
            Dividing the dataset into testing and training portions
            Scaling the features
            Evaluating the classifiers
            Confusion matrix
            Performance metrics
            Understanding overfitting
            Bias
            Variance
            Bias-variance trade-off
            Specifying the phases of classifiers
            Decision tree classification algorithm
            Understanding the decision tree classification algorithm
            Using the decision tree classification algorithm for the classifiers challenge
            The strengths and weaknesses of decision tree classifiers
            Strengths
            Weaknesses
            Use cases
            Classifying records
            Feature selection
            Understanding the ensemble methods
            Implementing gradient boosting with the XGBoost algorithm
            Using the random forest algorithm
            Training a random forest algorithm
            Using random forest for predictions
            Differentiating the random forest algorithm from ensemble boosting
            Using the random forest algorithm for the classifiers challenge
            Logistic regression
            Assumptions
            Establishing the relationship
            The loss and cost functions
            When to use logistic regression
            Using the logistic regression algorithm for the classifiers challenge
            The SVM algorithm
            Using the SVM algorithm for the classifiers challenge
            Understanding the naive Bayes algorithm
            Bayes, theorem
            Calculating probabilities
            Multiplication rules for AND events
            The general multiplication rule
            Addition rules for OR events
            Using the naive Bayes algorithm for the classifiers challenge
            For classification algorithms, the winner is...
            Understanding regression algorithms
            Presenting the regressors challenge
            The problem statement of the regressors challenge
            Exploring the historical dataset
            Feature engineering using a data processing pipeline
            Linear regression
            Simple linear regression
            Evaluating the regressors
            Multiple regression
            Using the linear regression algorithm for the regressors challenge
            When is linear regression used?
            The weaknesses of linear regression
            The regression tree algorithm
            Using the regression tree algorithm for the regressors challenge
            The gradient boost regression algorithm
            Using gradient boost regression algorithm for the regressors challenge
            For regression algorithms, the winner is...
            Practical example – how to predict the weather
            Summary
            Chapter 8: Neural Network Algorithms --
            Table of Contents
            Understanding ANNs
            The Evolution of ANNs
            Training a Neural Network
            Understanding the Anatomy of a Neural Network
            Defining Gradient Descent
            Activation Functions
            Threshold Function
            Sigmoid
            Rectified linear unit (ReLU)
            Leaky ReLU
            Hyperbolic tangent (tanh)
            Softmax
            Tools and Frameworks
            Keras
            Backend Engines of Keras
            Low-level layers of the deep learning stack
            Defining hyperparameters
            Defining a Keras model
            Choosing sequential or functional model
            Understanding TensorFlow
            Presenting TensorFlow's Basic Concepts
            Understanding Tensor Mathematics
            Understanding the Types of Neural Networks
            Convolutional Neural Networks
            Convolution
            Pooling
            Recurrent Neural Networks
            Generative Adversarial Networks
            Transfer Learning
            Case study – using deep learning for fraud detection
            Methodology
            Summary
            Chapter 9: Algorithms for Natural Language Processing --
            Introducing NLP
            Understanding NLP terminology
            Normalization
            Corpus
            Tokenization
            Named entity recognition
            Stopwords
            Sentiment analysis
            Stemming and lemmatization
            NLTK
            BoW-based NLP
            Introduction to word embedding
            The neighborhood of a word
            Properties of word embeddings
            Table of Contents
            Using RNNs for NLP
            Using NLP for sentiment analysis
            Case study: movie review sentiment analysis
            Summary
            Chapter 10: Recommendation Engines --
            Introducing recommendation systems
            Types of recommendation engines
            Content-based recommendation engines
            Finding similarities between unstructured documents
            Using a co-occurrence matrix
            Collaborative filtering recommendation engines
            Hybrid recommendation engines
            Generating a similarity matrix of the items
            Generating reference vectors of the users
            Generating recommendations
            Understanding the limitations of recommender systems
            The cold start problem
            Metadata requirements
            The data sparsity problem
            Bias due to social influence
            Limited data
            Areas of practical applications
            Practical example – creating a recommendation engine
            Summary
            Section 3: Advanced Topics
            Chapter 11: Data Algorithms
            Introduction to data algorithms
            Data classification
            Presenting data storage algorithms
            Understanding data storage strategies
            Presenting the CAP theorem
            CA systems
            AP systems
            CP systems
            Presenting streaming data algorithms
            Applications of streaming
            Presenting data compression algorithms
            Lossless compression algorithms
            Understanding the basic techniques of lossless compression
            Huffman coding
            A practical example – Twitter real-time sentiment analysis
            Summary
            Chapter 12: Cryptography --
            Table of Contents
            Introduction to Cryptography
            Understanding the Importance of the Weakest Link
            The Basic Terminology
            Understanding the Security Requirements
            Identifying the Entities
            Establishing the Security Goals
            Understanding the Sensitivity of the Data
            Understanding the Basic Design of Ciphers
            Presenting Substitution Ciphers
            Understanding Transposition Ciphers
            Understanding the Types of Cryptographic Techniques
            Using the Cryptographic Hash Function
            Implementing cryptographic hash functions
            Understanding MD5-tolerated
            Understanding SHA
            An Application of the Cryptographic Hash Function
            Using Symmetric Encryption
            Coding Symmetric Encryption
            The Advantages of Symmetric Encryption
            The Problems with Symmetric Encryption
            Asymmetric Encryption
            The SSL/TLS Handshaking Algorithm
            Public Key Infrastructure
            Example – Security Concerns When Deploying a Machine Learning
            Model
            MITM attacks
            How to prevent MITM attacks
            Avoiding Masquerading
            Data and Model Encrpytion
            Summary
            Chapter 13: Large-Scale Algorithms --
            Introduction to large-scale algorithms
            Defining a well-designed, large-scale algorithm
            Terminology
            Latency
            Throughput
            Network bisection bandwidth
            Elasticity
            The design of parallel algorithms
            Amdahl's law
            Conducting sequential process analysis
            Conducting parallel execution analysis
            Understanding task granularity
            Load balancing
            Locality issues
            Enabling concurrent processing in Python
            Strategizing multi-resource processing
            Introducing CUDA
            Designing parallel algorithms on CUDA
            Using GPUs for data processing in Python
            Cluster computing
            Implementing data processing in Apache Spark
            The hybrid strategy
            Summary
            Chapter 14: Practical Considerations --
            Introducing practical considerations
            The sad story of an AI Twitter Bot
            The explainability of an algorithm
            Machine learning algorithms and explainability
            Presenting strategies for explainability
            Implementing explainability
            Understanding ethics and algorithms
            Problems with learning algorithms
            Understanding ethical considerations
            Inconclusive evidence
            Traceability
            Misguided evidence
            Unfair outcomes
            Reducing bias in models
            Tackling NP-hard problems
            Simplifying the problem
            Example
            Customizing a well-known solution to a similar problem
            Example
            Using a probabilistic method
            Example
            When to use algorithms
            A practical example – black swan events
            Four criteria to classify an event as a black swan event
            Applying algorithms to black swan events
            Summary
            Other Books You May Enjoy
            Index

~/Empire/Doks/Comp/PROGR/algos/algosnutsh-2e_2016.pdf
~/Empire/Doks/Comp/PROGR/algos/algothink-introd-2021.pdf
~/Empire/Doks/Comp/PROGR/algos/notes4pros-algos.pdf

