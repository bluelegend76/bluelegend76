vim: fdm=indent:fdl=2:
set fdm=indent fdl=2
set fdm=indent fdl=2 syn= guifont=* | colors ron
set fdm=indent fdl=2 syn=cs guifont=* | colors ron
set syn=
set syn=cs
__
____
___zzzz

ref  = skicka inte värdet, utan adressen
out  = tar inget invärde, ger bara ett utvärde
namespace  = i den här _ måste alla klass- och typ-namn vara unika
   [+using  = slippa kvalificera med namnrymd.aaaaa.function()]

DotNet CLI  [moved to Compile/Build]
Azure CLI (??)
                .
                .
  TeamViever (Live Share)  #Vnc
Spectre Console:
    ~/gdrive/SpectreConsole.tags1.txt
Rider (JetBrains) Keymap
~/Empire/Doks/Comp/editor/Rider-shortc.pdf
  Set breakpoint
  Run with Debug  s-f9  # TODO = REWORK FOR VS KEYB.SHORTCUT-SETTINGS[!]
  Run  s-f10
    Step over  f8
  Step into  f7
    Step out of  s-f8
  Stop  c-f2
                Build solution  a_b Ent
                Create And Edit ----
                    Expand/Collapse Code Block  @
                        c-n+ / c-n-
                    Show Context Actions
                        a-Enter
                    
                    Basic Code Completion
                        c-Space
                    Smart Code Completion
                        cs-Space
                    Type Name Completion  ___hm_eng
                        ca-Space
                    Complete Statement
                        cs-Enter
                    Parameter Information
                        c-p
                    Quick Definition
                        cs-i
                    Quick/External Documentation
                        c-q / s-f1
                    Generate...
                        a-Insert
                    Override/Implement Members
                        c-o / c-i
                    Surround With...
                        ca-t
                    Unwrap/Remove...
                        cs-Delete
                    Comment with Line/Block Comment
                        c-/ / cs-/
                    Extend/Shrink Selection
                        c-w / cs-w
                    Context Info
                        a-q
                    Optimize Imports
                        ca-o
                    Auto-Indent Lines
                        ca-i
                    Cut/Copy/Paste
                        c-x / c-c / c-v
                    Copy Document Path
                        cs-c
                    Paste from Clipboard History
                        cs-v
                    Duplicate Current Line or Selection
                        c-d
                    Move Line Up/Down
                        sa-up / sa-down
                    Move Statement Up/Down
                        cs-up / cs-down
                    Move Element Right/Left
                        csa-right / csa-left
                    Delete Line at Caret
                        c-y
                    Join/Split Line
                        cs-j / c-Enter
                    New Line Above/Below
                        ca-Enter / s-Enter
                    Toggle Case
                        cs-u
                    Save All
                        c-s
                Analyze And Explore ----
                    Problems Tool Window
                        a-6
                    Show Error Description  @
                        c-f1
                    Next/Previous Highlighted Error  @
                        f2 / s-f2
                    Next/Previous Error in Solution  @
                        a-f2 / sa-f2
                    Toggle Code Inspection in File
                        csa-8
                    Run Inspection by Name...
                        csa-i
                    Inspect This...  ¤
                        csa-a
                    Type Hierarchy  ¤¤
                        c-h
                    Method Hierarchy  ¤¤
                        cs-h
                    Call Hierarchy  ¤¤
                        ca-h
                Version Control ----
                    VCS Operations  @
                        a-`
                Commit...  @
                    c-k
                    Update Project
                        c-t
                    Recent Changes
                        sa-c
                    Rollback...
                        ca-z
                Push...  @
                    cs-k
                Next/Previous Change  ¤
                    csa-down / csa-up
                Commit/Version Control Tool Window  @
                    a-0
                Master Your IDE ----
                    Find Action...
                        cs-a
                    Open Solution or Project  @
                        cs-o
                    Project/Explorer Tool Window  ¤
                        a-1
                    Add New File  @@
                        ca-Insert (**) __ __
                        a-Insert
                    Reload All from Disk
                        ca-y
                    Quick Switch Scheme...  ?
                        c-`
                    Settings...  @
                        ca-s
                    Jump to Source  ·
                        f4
                    Jump to Last Tool Window  ¤
                        f12
                    Hide Active/All Tool Windows  ·
                        s-Esc / cs-f12
                    Go to Next/Previous Editor Tab  @@
                        a-right / a-left
                    Go to Editor (from a Tool Window)
                        Esc
                    Close Active Editor Tab
                        c-f4
                Find Everything ----
                    Search Everywhere  @@
                        Double Shift
                    Find/Replace in Project  @@
                        cs-f / cs-r
                    Go to Symbol  @@
                        csa-n
                    Go to Class  @@
                        c-n
                    Go to File Member  @(@)
                        c-f12
                    [[Find/Replace in File]]
                        c-f / c-r
                    Go to File
                        cs-n
                    Go to Text
                        csa-e
                Navigate From Symbols ----
                    Go to Declaration or Usages  @(@)
                        c-b
                    Go to Type Declaration  @(@)
                        cs-b
                    Go to Base/Derived Symbols  @
                        c-u / ca-b
                    Find Usages  @@
                        a-f7
                    Show Usages  @
                        ca-f7
                    Highlight Usages in File
                        cs-f7
                    Navigate To...
                        cs-g
                Navigate Context ----
                    Select In...
                        a-f1
                    Switcher  ??
                        c-Tab
                    Recently Viewed/Changed Files  @?
                        c-e
                    [Last Edit Location]
                        cs-Back
                    Navigate Back/Forward  ??(+rebind)
                        ca-left / ca-right
                    Next/Previous method  @(@)
                        a-down / a-up
                    Go to Line:Column...
                        c-g
                    Go to Code Block End/Start  @?
                        c-] / c-[
                    Next/Previous Occurrence
                        f3 / s-f3
                    [[Next/Previous Word at Caret]]
                        c-f3 / cs-f3
                    Toggle Bookmark
                        f11
                    Toggle Bookmark with Mnemonic  @?
                        c-f11
                    Go to Numbered Bookmark
                        c-[0-9]
                    Show Bookmarks...  [@]
                        s-f11
                    Find Tool Window  [@(@]
                        a-3
                    Bookmarks Tool Window  [@]
                        a-2
                Build, Run, And Debug ----
                    Build  @  c-f9
                    Cancel Build
                        c-f9
                    Run Anything  ??
                        Double Ctrl
                    Run context configuration
                        cs-f10
                    Run/Debug Selected Configuration
                        sa-f10 / sa-f9
                Run/Debug Current Configuration  s-f10 / s-f9
                    Step Over  @
                        f8
                    Step Into
                        f7
                    Smart Step Into  [@@!]
                        s-f7
                    Step Out
                        s-f8
                    Run to Cursor  @[@]
                        a-f9
                    Force Run to Cursor
                        ca-f9
                    Show Execution Point  ??
                        a-f10
                    Evaluate Expression...  !!
                        a-f8
                    Stop  [@]
                        c-f2
                    Resume Program  [@]
                        f9
                    Toggle Line Breakpoint  [@@]
                        c-f8
                    Toggle Temporary Line Breakpoint
                        csa-f8
                    Edit breakpoint
                        cs-f8
                    View Breakpoints...  [@]
                        cs-f8
                    Run/Debug Tool Window  @
                        a-4 / a-5
                    Services Tool Window
                        a-8
                Unit Tests ----
                    Unit Testing Quick List...  @
                        sa-u
                    Run/Debug Unit Tests
                        c-; r / c-; d
                    Stop Execution
                        c-; s
                    Repeat Previous Run
                        c-; t
                    Rerun Failed Tests
                        c-; f
                    Run All Tests from Solution
                        c-; l
                    Create New Session
                        c-; n
                    Append Tests to Session
                        c-; a
                    Run Current Session
                        c-; y
                    Rerun Tests
                        sa-r
                    Go to Test
                        cs-t
                    Show Coverage Data...  @@
                        ca-f6
                    Unit Tests Tool Window
                        sa-8
                Refactor And Clean Up ----
                    Refactor This...  @@
                        csa-t
                    Copy...
                        f5
                    Move...
                        f6
                    Safe Delete...  ?(?)
                        a-Delete
                    Rename...  @
                        s-f6
                    Change Signature...  @
                        c-f6
                    Inline...  [@]
                        ca-n
                    Extract Method  @@__
                        ca-m
                    Introduce Variable
                        ca-v
                    Introduce Field
                        ca-f
                    Introduce Constant
                        ca-c
                    Introduce Parameter
                        ca-p
                    Reformat Code  @@[!!]
                        ca-l
https://cheatography.com/franklioty/cheat-sheets/jetbrains-rider-keyboard-shortcuts/#downloads
  TODO: IMPORT DONE LIST RIDER KEYB.SHORTCUTS  __ __
Rider Docs TOC:  https://www.jetbrains.com/help/rider/Introduction.html
  set bracing (BSD vs K&R style)  = settings  (+indent style 2 2)
  braces-style
  new project in solution  right-click solution (+select)
  cursor blinking off  Settings >> editor > general > [ ] caret blinking
  Reformat Code  (vim-mode) = / ca-l  ****
  Toggle Inlay Hints  a-h  #custom
  sticky lines  --> off
  --
                    evince -p 1 ~/Empire/Doks/Comp/editor/Jetbrains/JetbrainsDocs/RiderToc.pdf &
                Get started
                  Installation guide
                    Run JetBrains Rider for the first time
                    Register
                    Update
                    Uninstall
                  User interface
                    New UI
                    User interface themes
                    IDE viewing modes
                    IDE zoom level
                    Menus and toolbars
                    Touch bar support
                    Keyboard shortcuts
                      Customize keyboard shortcuts
                      Keyboard shortcuts in predefined keymaps
                        Keyboard shortcuts: keymaps comparison (Windows)
                        Keyboard shortcuts: keymaps comparison (macOS)
                      Keyboard shortcut not working?
                    Colors schemes: fonts and colors of IDE text
                    Switch between schemes
                    Accessibility features
                    Background image
                    Action indicators and action list
                    Error stripe and status indicator
                    'Pencils' widget
                    Hot spot session
                    Tool windows
                      Arrange tool windows
                      Tool window view modes
                      Speed Search in tool windows
                  First steps with JetBrains Rider
                  Quick-start tips
                  Get started with run/debug configurations
                  Get started with unit testing
                  Get started with version control
                  Work offline
                  Support and assistance
                  Notifications
                Projects and solutions
                  Create projects and solutions
                  Open projects and solutions
                  Trusted and untrusted solutions
                  Install custom project templates
                  Extend and organize your solution
                  Work with solution filters
                  Configure project properties
                  Configure file properties
                  Explorer window
                    File nesting rules
                  Consume NuGet packages
                  NuGet window
                  Build projects
                    Build configurations
                    Build process
                    Build window
                  Project-level refactorings
                    Adjust Namespaces
                    Move Types into Matching Files
                    Remove Unused References
                  Share solution settings
                AI Assistant
                  Chat with AI
                  Use AI prompts to explain and refactor your code
                  Use AI in editor
                  Get AI assistance for VCS commits
                  Generate documentation with AI
                  Use AI to convert files to another language
                  Generate tests with AI
                  Disable AI Assistant
                Create and edit code
                  Editor basics
                    Handle caret and select text
                    Multiple cursors and selection ranges
                    Cut, copy, paste
                    Add, delete, and manipulate lines
                    Toggle case
                    Inlay hints
                    Code Vision
                    Fold and unfold (collapse/expand) code fragments
                    Save and revert changes
                    Editor tabs
                    Macros
                    Change editor font size
                Coding assistance
                  Code completion (IntelliSense)
                    Automatic completion
                    Basic completion
                    Smart completion
                    Second basic completion
                    Generative completion
                  Typing assistance
                  Complete Statement
                  Color assistance
                  Context actions
                    Language-independent context actions
                    Context actions for C#
                    Context actions for Visual Basic
                    Context actions for ASP.NET
                    Context actions for Razor
                    Context actions for XAML
                    Context actions for C++
                  Regular expressions assistance
                  Language injections
                  Language injections in Web languages
                  Parameter Information
                  Quick Documentation
                  Quick Definition
                  Structural navigation with Tab and Shift+Tab
                  Highlighting of matching code elements
                  Rearrange code elements
                  Duplicate line or selection
                  Split and join string literals
                  Add and remove #region blocks
                  Comment and uncomment code
                  CamelHumps
                  Entity Framework support
                Code generation  __
                  Generate code from usage
                  Generate null-checking routines
                  Generate code with code completion
                  Generate GUIDs
                  Generate C# classes from JSON
                  Generate type members
                    Generate Deconstructors
                    Generate Delegating Members
                    Generate Dispose Pattern
                    Generate Equality Comparer
                    Generate Equality Members
                    Generate Formatting Members
                    Generate Partial Methods
                    Generate Properties
                    Generate Relational Comparer
                    Generate Relational Members
                    Generate Type Constructors
                    Generate Missing/Overriding Members
                Localization assistance
                  Localization Manager
                  Localization inspections and quick-fixes
                  Coding assistance for localization
                  Localization refactorings
                  Navigate resources
                    Navigation within Resx files
                    Navigation between code and Resx files
                    Navigation between cultures
                    Find usages of resources
                Code templates
                  Code templates
                    Types of templates
                    Template scopes
                    Template variables
                    Template macros
                    Apply templates
                      Create source code using live templates
                      Surround code fragments with templates
                      Create files from templates
                    Create and edit templates
                      Create a live/surround template
                      Create a file template
                      Declare template variables
                      Edit templates
                    List of predefined templates
                      Predefined live templates
                        ASP.NET
                        C#
                        C++
                        Razor
                        VB.NET
                        Unity
                      Predefined surround templates
                        ASP.NET
                        ASP.NET (C#)
                        ASP.NET (VB.NET)
                        C#
                        C++
                        HTML
                        HTML-Like
                        JavaScript
                        Razor
                        TypeScript
                        VB.NET
                        XML
                        XAML (C#)
                      Predefined file templates
                        ASP.NET (C#)
                        ASP.NET (VB.NET)
                        C#
                        C++
                        Razor (C#)
                        Tests  __
                        TypeScript
                        VB.NET
                        XAML
                        Unity
                        Unreal Engine
                    Postfix templates
                    Source templates
                  Web-specific templates
                    Live templates
                      Create live templates
                      Live template variables
                      Share live templates
                      Emmet
                    File templates
                      File template variables
                      Reusable content in templates
                  Local History
                  Design Windows Forms
                  Compare files and folders
                Run, debug, test, deploy
                  Running
                    Run/debug configurations
                    Run and debug .NET static methods
                    Run and debug .NET projects of executable types
                    Run and debug .NET executables without source code
                    Run native executables
                    Run and debug UWP applications
                    List of run/debug configuration templates
                    Run anything
                    Run/debug multiple targets
                    Run window
                    Services window
                  Debugging
                    Breakpoints
                    Start, pause, resume, and stop
                    Attach to process
                    Examine suspended program
                      Step through code
                      Inspect variable values and objects
                      Watch variables and expressions
                      Track objects (Mark/Unmark Object)
                      Evaluate Expressions
                      Interact with program using Immediate window
                    Predictive debugger
                    Debug exceptions
                    Debug external code
                    View loaded modules (.exe and .dll)
                    Explore .NET memory while debugging
                    Debug multithreaded applications
                    Debug remote applications via SSH
                    Remote debugging with Mono
                    Breakpoints dialog
                    Debug window
                  Edit running code with Hot Reload
                  Unit testing assistance  __ __
                    In current document
                    In project or solution
                    Unit test sessions
                    Test categories
                    Execute tests and analyze results
                    Create unit tests
                    Navigate between tests and tested code
                    Maintain code quality of unit tests
                    Monitor memory with dotMemory Unit
                    Unit Tests window
                    Unit Tests Coverage window
                  Coverage analysis of .NET code
                    Analyze Coverage of Unit Tests
                    Use Continuous Testing
                    Set up coverage filters
                    Work with coverage results
                  Performance profiling of .NET code
                    Profile applications
                    Profile unit tests
                    Attach to and profile .NET processes
                    Analyze profiling results
                    dotTrace Profiler window
                  Memory profiling of .NET code
                    Profile applications
                    Attach to and profile .NET processes
                  Analyze profiling results
                    Analyze Object Sets
                      Group by Types
                      Group by Dominators
                      Group by Instances
                      Group by Generations
                    Analyze Instances
                      Outgoing References
                      Incoming References
                      Shortest Paths to Roots
                    Analyze memory allocation
                    Compare Snapshots
                    Analyze GC Roots
                    Analyze Process Dumps
                  Work with Workspaces
                  dotMemory Profiler window

                  Dynamic Program Analysis (DPA)
                    Basic operations with issues
                    Narrow down DPA scope
                    Fix memory issues
                    Fix database issues
                    Fix ASP Issues
                  Create NuGet packages
                  Publish .NET applications to folder
                  C# Interactive
                Navigate and search
                  Textual search
                    Find and replace text in a file
                    Find and replace text in solution
                    Find and replace text using regular expressions
                    Find word at caret
                    Go to Text
                  Search by name
                    Search Everywhere
                    Go to Class
                    Go to File
                    Go to File Member
                    Go to Symbol
                    Find actions and options
                  Navigate from symbols
                    Go to Declaration
                    Go to Type of Symbol
                    Go to Base Symbols
                    Go to Implementation
                    Go to Derived Symbols
                    Navigate inheritance hierarchy with gutter marks
                    Navigate To
                      Assembly Explorer
                      Control Flow Target
                      Decompiled Sources
                      Exposing APIs
                      Consuming APIs
                      Extension Methods
                      Function Exits
                      Generic Substitutions
                      Implementing Members
                      Member Overloads
                      Metadata View
                      Overriding Members
                      Parameter Declaration
                      Sources from Symbol Files
                      Test Explorer and Tests Sessions
                      TODO Explorer
                    Find Usages  __
                      Find Usages of Symbols
                      Find Usages of Related Entities
                      Go to Usages of Symbol
                      Find code dependent on referenced modules
                      Highlight Usages in File
                    Navigate current context
                    Find referenced code
                    Navigate recent locations and changes
                    Navigate compiled code
                      Presentation options for compiled code
                      Access decompiled files
                      Explore and decompile assemblies
                      Assembly Explorer window
                      Open and close assemblies
                      Find assemblies in folders
                      Open assemblies from NuGet packages
                      Open assemblies from Global Assembly Cache
                      Manage assembly lists
                      Explore assembly and portable PDB Metadata
                    Explore and navigate exception stack traces
                    Analyze search results
                    TODO lists
                    Bookmarks
                  Code analysis
                    Find code issues with code inspection
                      Code inspections
                      Analyze code issues in design time
                      Find code issues in specific scope
                      Solution-wide analysis
                      Solution-wide code inspections
                      Configure code inspection settings
                      Report and update deprecated APIs
                      Spellchecking
                      Value and nullability analysis
                      Analysis of integer values (integral arithmetics)
                      Collection access analysis
                      ConfigureAwait analysis
                      Dispose analysis
                      Code analysis and helpers for string literals
                      Problems tool window
                      Use annotations to refine code inspection  __
                        Annotations in source code
                        External annotations
                        Contract annotations
                        Code annotation attributes
                      Code inspection index
                        Code Inspections in C#
                        Code Inspections in VB.NET
                        Code Inspections in C++
                        Code Inspections in XAML
                        Code Inspections in ASP.NET
                        Code Inspections in Razor
                        Code Inspections in Resource files
                      Code Inspection Index (Web-Related)
                        Code Inspections in Angular
                        Code Inspections in CSS
                        Code Inspections in Docker-compose
                        Code Inspections in Dockerfile
                        Code Inspections in EditorConfig
                        Code Inspections in File Watchers
                        Code Inspections in General
                        Code Inspections in HTML
                        Code Inspections in HTTP Client
                        Code Inspections in Handlebars/Mustache
                        Code Inspections in Ini files
                        Code Inspections in Internationalization
                        Code Inspections in JSON and JSON5
                        Code Inspections in JavaScript and TypeScript
                        Code Inspections in Less
                        Code Inspections in MSBuild
                        Code Inspections in Markdown
                        Code Inspections in MongoJS
                        Code Inspections in MySQL
                        Code Inspections in OpenAPI specifications
                        Code Inspections in Oracle
                        Code Inspections in PostCSS
                        Code Inspections in PostagreSQL
                        Code Inspections in Proofreading
                        Code Inspections in Properties files
                        Code Inspections in Pug/Jade
                        Code Inspections in RELAX NG
                        Code Inspections in RegExp
                        Code Inspections in SOL
                        Code Inspections in SQL server
                        Code Inspections in Sass/SCSS
                        Code Inspections in Security
                        Code Inspections in Shell script
                        Code Inspections in Unreal Engine
                        Code Inspections in Version control
                        Code Inspections in Vue
                        Code Inspections in XML
                        Code Inspections in XPath
                        Code Inspections in Vue
                        Code Inspections in XML
                        Code Inspections in XPath
                        Code Inspections in XSLT
                        Code Inspections in YAML
                    Quick-fixes for code issues
                      Examples of quick-fixes
                      Import missing namespaces
                      Fix in scope
                    Code exploration  __
                      Inspect This
                      Call tracking
                      Value tracking
                      Explore type hierarchy
                      View intermediate language (IL)
                      View high-level and low-level C# code
                    Visual dependency analysis
                      Explore type dependency diagram  __
                      Explore project dependency diagram
                    Ignore parts of the code
                    .NET Compiler Platform (Roslyn) analyzers
                  Refactorings  __
                    Refactor This
                    Main set of refactorings
                      Change Signature
                      Convert Abstract Class to Interface
                      Convert Anonymous to Named Type
                      Convert Extension Method to Plain Static
                      Convert Indexer to Method
                      Convert Interface to Abstract Class
                      Convert Method to Indexer
                      Convert Method to Property
                      Convert Property to Auto-Property
                      Convert Property to Method(s)
                      Convert Static to Extension Method
                      Convert to Global Using
                      Convert to Non-Global Using
                      Copy Type
                      Encapsulate Field
                      Extract Class
                      Extract Interface
                      Extract Method
                      Extract Superclass
                      Inline refactorings
                        Inline Class
                        Inline Field
                        Inline Method
                        Inline Parameter
                        Inline Variable
                      Introduce Field
                      Introduce Parameter
                      Introduce Variable
                      Introduce Variable for Substring
                      Invert Boolean
                      Make Method Non-Static
                      Make Method/Property Static
                      Extract Members to Partial
                      Move refactorings
                        Move Instance Method
                        Move Type to Another File
                        Move Type to Another Namespace
                        Move Type to Outer Scope
                        Move to Another Type
                        Move to Folder
                      Pull Members Up
                      Push Members Down
                      Rename
                      Replace Constructor with Factory Method
                      Safe Delete
                      Transform Parameters
                      Use Base Type Where Possible
                    Inplace refactorings
                    Resolve conflicts in refactorings
                  Code style and cleanup
                    Code cleanup
                    Use EditorConfig  __
                      Index of EditorConfig properties
                      EditorConfig properties by language and category
                        Generalized EditorConfig properties
                        EditorConfig properties for C#: Blank Lines
                        EditorConfig properties for C#: Braces Layout
                        EditorConfig properties for C#: Syntax Style
                        EditorConfig properties for C#: Tabs, Indents, Alignment
                        EditorConfig properties for C#: Line Breaks
                        EditorConfig properties for C#: Other
                        EditorConfig properties for C#: Spaces
                        EditorConfig properties for VB.NET: Blank Lines
                        EditorConfig properties for VB.NET: Line Breaks
                        EditorConfig properties for VB.NET: Other
                        EditorConfig properties for VB.NET: Spaces
                        EditorConfig properties for VB.NET: Syntax Style
                        EditorConfig properties for VB.NET: Tabs and Indents
                        EditorConfig properties for Razor CSharp: Code Style
                        EditorConfig properties for C++: Blank Lines
                        EditorConfig properties for C++: Braces Layout
                        EditorConfig properties for C++: Tabs and Indents
                        EditorConfig properties for C++: Indentation and Alignment
                        EditorConfig properties for C++: Spaces
                        EditorConfig properties for C++: Line breaks and Wrapping
                        EditorConfig properties for ShaderLab: ShaderLab Formatting Style
                    Use StyleCop styles
                    Format code with spaces, tabs, and line breaks
                      Apply formatting rules
                      Configure formatting rules
                      Indentation style
                      Reformat XML Doc comments
                    Syntax styles
                      Bodies of type members
                      Braces for single nested statements
                      Built-in type references
                      File-Scoped Namespaces
                      Implicit/explicit typing ('var' keyword)
                      Modifiers
                      Multiple attributes
                      Named/positional arguments
                      Namespace imports
                      Optional member qualifiers
                      Optional parentheses
                      Trailing commas
                      Object creation
                      Default value expressions
                      Null checking pattern
                    Naming style
                    File header style
                    Rearrange members with file and type layout patterns
                    Remove code redundancies
                    Use auto-properties
                    Make fields readonly
                    Make auto-properties get-only
                  Integrated tools
                    Version control
                      Enable version control
                      Resolve conflicts
                      Manage changelists
                      Shelve and unshelve changes
                      Use patches
                      Review changes
                      Git
                        Set up a Git repository
                        Add files to Git and track changes
                        Sync with a remote Git repository (fetch, pull, update)
                        Commit and push changes to Git repository
                        Sign commits with GPG keys
                        Compare file and folder versions
                        Investigate changes in Git repository
                        Manage Git branches
                        Apply changes from one Git branch to another
                        Resolve Git conflicts
                        Use Git to work on several features simultaneously
                        Undo changes in Git repository
                        Use tags to mark specific Git commits
                        Edit Git project history
                        Git integration with issue trackers
                      GitHub
                        Manage projects hosted on GitHub
                        Fork GitHub projects
                        Work with GitHub pull requests
                        Share code with GitHub gists
                      GitLab
                        Clone GitLab project
                        Work with GitLab merge requests
                        Share code with GitLab snippets
                      Mercurial
                        Set up a local Mercurial
                        Share code with GitLab
                        snippets
                        sami -iceie late)
                        Set up a local Mercurial
                        repository
                        Add files to a local Mercurial
                        repository
                        Manage Mercurial branches
                        and bookmarks
                        Tag changesets and
                        repositories
                        Switch between Mercurial
                        working directories
                        Pull changes from the
                        Mercurial upstream (Pull)
                        Push changes to the Mercurial
                        upstream (Push)
                        v Perforce
                        Configure Perforce integration
                        Handle modified without
                        oj al -101. 400 )@ fi (=1-)
                        Integrate Perforce files
                        Resolve conflicts with Perforce
                        integration
                        Show Revision Graph and
                        Time-Lapse View
                        Use multiple Perforce depots
                        with PACONFIG
                        PALES 16-1810) 8)
                        Show Revision Graph and
                        Time-Lapse View
                        Use multiple Perforce depots
                        with PACONFIG
                        Work with Perforce offline
                        Check Perforce project status
                        Attach and detach Perforce
                        jobs to changelists
                        vy Subversion
                        Browse Subversion repository
                        Check out files from
                        Subversion repository
                        Clean up local working copy
                        Compare with branch in
                        Subversion
                        Configure the format of the
                        local working copy
                        Configure HTTP proxy in
                        Subversion
                        Configure Subversion
                        repository location
                        Configuring Subversion
                        Branches
                        Create Subversion branches
                        and tags
                        Export information from
                        Subversion repositorv
                        1-101) 8) =)
                        Create Subversion branches
                        and tags
                        Export information from
                        Subversion repository
                        Import a local directory to
                        Subversion repository
                        Integrate changes to
                        Subversion branch
                        Integrate SVN projects or
                        directories
                        Integrate changes to/from
                        feature branches in Subversion
                        Lock and unlock files and
                        folders
                        Resolve conflicts in
                        Subversion
                        Share directory
                        View and fast process of
                        changelists
                        Define the set of
                        changelists to display
                        Filter out extraneous
                        changelists
                        Integrate files and
                        changelists from the
                        Version Control tool window
                        View and manage
                        integration status
                        Share directory
                        vy View and fast process of
                        changelists
                        Define the set of
                        changelists to display
                        Filter out extraneous
                        changelists
                        Integrate files and
                        changelists from the
                        Version Control tool window
                        View and manage
                        integration status
                        View merge sources
                        vy Work with Subversion
                        properties for files and
                        directories
                        View differences in
                        properties
                        Resolve property conflicts
                        Diagnose problems with
                        Subversion integration

                  Database Tools and SOL
                    Glossary
                    Connection to a database
                      Data sources
                        Amazon Redshift
                        Apache Cassandra
                          Apache Cassandra with SSL
                        Apache Derby
                        Apache Hive
                        Azure SQL Database
                        BigQuery
                          Connect to BigQuery
                        ClickHouse
                        CockroachDB
                        Couchbase Query
                        DocumentDB
                        DynamoDB
                        Exasol
                        Greenplum
                        H2
                        HSQLDB
                        IBM Db2 LUW
                        MariaDB
                        Microsoft SOL Server
                          Connect to MS SOL server
                        Microsoft SOL Server LocalDB
                        MongoDB
                          How to fetch more fields for MongoDB introspection
                          SQL for MongoDB
                          Editing data in MongoDB
                        MySQL
                          Connect to MySQL with named pipes
                          Connect to MySQL with unix sockets
                          Cannot connect to MySQL 5.1
                        Oracle
                          Connect to Oracle with OCI
                          Connect to Oracle Cloud by using Wallet and OCI
                        PostgreSQL
                          Connect to Heroku Postgres without SSL validation
                        Redis
                        Snowflake
                        SQLite
                        Sybase ASE
                        Vertica
                        DDLdata sources
                          DDL mappings
                        Other
                      Sessions
                      Configure connection
                        SSH and SSL
                        JDBC drivers
                      Data Sources and Drivers dialog
                        Database objects
                          Database tool window
                            Schemas
                            Tables
                            Columns
                            Primary keys
                            Foreign keys
                            Indexes
                            Views
                            Users and roles
                            Virtual objects
                              Virtual foreign keys
                              Virtual views
                              Virtual columns
                            Dialogs reference
                              Create and Modify
                              Confirm Drop
                              Database Color Settings
                            Schema comparison and migration
                            Modify source code
                            Working with DDL definitions
                            Database diagrams
                          Compare and update database schemas
                          Run queries and files
                            Run queries
                              Query results
                              Query execution plan
                            Run SQL files
                            Debug Oracle PL/SQL code
                          Data editor and viewer
                            View data
                            Compare data
                            Sort data
                            Filter data
                            Rows
                            Cells
                            Submit changes to a database
                          Export and import
                            Export
                            Import
                            Data extractors
                          File management
                            Query consoles
                            User files
                              Edit DSV files as tables
                          Full-text search in databases
                          Configure settings
                            Configure the SQL code style
                          Injected SQL statements
                          Troubleshooting
                            Cannot connect to a database
                            Cannot find a database object in Database tool window
                            Cannot connect to a database because of SSLHandshakeException
                            Troubleshooting materials
                      Space
                        Getting started with Space
                        Review code in Space
                      Remote development
                        Overview
                        System requirements
                        JetBrains Gateway installation scenarios
                        Connect to a remote server from JetBrains Rider
                        Connect with JetBrains Gateway
                        Fully offline mode
                        Work inside remote project
                        FAQ
                        Troubleshooting
                        Licensing and useful links
                        Security model
                      Dev Containers
                        Prerequisites and limitations
                        Sharing credentials
                        FAQ about Dev Containers
                      Manage tasks and contexts
                        Configure generic task server
                      Terminal
                      Docker
                        Docker tools for .NET projects
                        Run and debug Docker projects in Fast mode
                        Docker images
                        Docker containers
                        Docker run configurations
                          Docker Image run configuration
                          Dockerfile run configuration
                          Docker compose run configuration
                        Docker Compose
                        Tutorials
                          Run a database in a Docker container
                        Docker troubleshooting
                        Podman
                        Qodana
                        Vagrant: Working with Reproducible Development Environments
                        HTTP Client
                          Exploring the HTTP request syntax
                          OAuth 2.0 authorization
                          HTTP Response handling API reference
                            HTTP Client reference
                            HTTP Client crypto API reference
                            Supported JavaScript API
                            HTTP request and response reference
                            Response handling examples
                          HTTP Client CLI
                        File Watchers
                        Presentation Assistant

                      Languages and frameworks
                      Ors
                      ban alert: 1) Le
                      Code inspection and quick-fixes
                      C#
                      Se alert 1) (es
                      Code inspection and quick-fixes
                      Coding assistance
                      Code style assistance
                      Navigation and search
                      Refactorings
                      Code generation
                      Code templates
                      Sere
                      Code analysis
                      Coding assistance
                      Code style assistance
                      Clang-Tidy integration
                      Using Clang-Format
                      Navigation and search
                      Inlay hints
                      Refactorings
                      Code templates
                      Code generation
                      Disassembly view
                      Unit testing assistance
                      Code generation
                      Disassembly view
                      Unit testing assistance
                      C++/CLI Support

                    F#
                      Code Inspection
                      Coding Assistance
                      Navigation and Search
                      F# Interactive
                    JavaScript
                      Angular
                      Angulars
                      Bower
                      Configure JavaScript libraries
                      JSDoc comments
                      vy Debug JavaScript in Chrome
                      Interactive debugger console
                      Configuring JavaScript
                      debugger
                      Live Edit in HTML, CSS, and
                      JavaScript
                      View actual HTML DOM
                      Find unused code with coverage
                      LIVE CONTI MINIL, Yoo, dia
                      JavaScript
                      View actual HTML DOM
                      Find unused code with coverage
                      Flow
                      Grunt
                      Gulp
                      Handlebars and Mustache
                      JavaScript documentation look-
                      up
                      JavaScript postfix templates
                      vy JavaScript linters
                      So) tale
                      JSLint
                      JSHint
                      JSCS
                      Closure Linter
                      Minifying JavaScript
                      Prettier
                      Saat -t- [018
                      Next.js
                      Refactoring JavaScript
                      vy Testing JavaScript
                      Cucumpberis
                      Nextjs
                      Refactoring JavaScript
                      vy Testing JavaScript
                      Cucumberjs
                      Bi-t-4
                      Karma
                      Mocha
                      Protractor
                      sai
                      Vuejs
                      Mahe
                      Webpack
                      y TypeScript
                      Compiling TypeScript into
                      JavaScript
                      Refactoring TypeScript
                      Running and debugging
                      TypeScript
                      Linting TypeScript
                      vy ASP.NET
                    ASP.NET
                      Run and debug .NET Core and ASP.NET Core apps with launch profiles
                      Run and debug ASP.NET Core apps in IIS Express
                      Publish ASP.NET and ASP.NET Core applications
                    CoffeeScript
                    JSON
                    ie
                    Markdown
                    OpenAPI
                    wv Node.js
                    Supported Node.js versions
                    Configuring remote Node.js
                    interpreters
                    y Running and debugging Node.js
                    Debugging the server- and the
                    client-side code
                    Multiprocess debugging
                    Using interactive Debugger
                    Console
                    Live Edit in Node js
                    applications
                    yw Run/Debug configuration:
                    ws - ae
                    Console
                    Live Edit in NodeJjs
                    applications
                    vy Run/Debug configuration:
                    Node.js
                    Node.js Interpreters Dialog
                    Run/Debug configuration:
                    Attach to Node.js/Chrome
                    Run/Debug configuration:
                    A
                    Testing Nodejs
                    V8 CPU and Memory Profiling
                    Node.js with Docker
                    Node.js with Docker Compose
                    Node.js via SSH
                    Pug (Jade)
                    npm, pnpm, and Yarn
                  React Native
                  Shell scripts
                  Style sheets
                    Minifying CSS
                    Sass, SCSS, and Less
                    Sass and SCSS in Compass
                    applications
                    agai lane
                    Shell scripts
                    bed B 813 a)
                    Minifying CSS
                    Sass, SCSS, and Less
                    Sass and SCSS in Compass
                    applications
                    ag (= ai fane
                    aa LUE)
                    Tailwind CSS
                    HTML
                  XML
                    Validating web content files
                    Generating DTD
                    Generating instance documents from XML schemas
                    Generating XMLschemas from instance documents
                    Referencing XMLschemas and DTD
                  XPath and XSLT
                    XPath expression evaluation
                    XPath search
                    XPath expression generation
                    Plugin settings
                    XSLT support
                      Code completion in XSLT
                      Refactoring XSLT
                      Highlighting errors in XSLT
                        XPath inspections
                      Search and navigation in XSLT
                      Documenting XSLT
                      XSLT run configurations
                      XSLT file associations
                      XSLT specific intention actions
                    XAML  __
                      code inspection and quick-fixes
                      Coding assistance
                      Code style assistance
                      Navigation and search

                    ~ Xamarin
                      tlie ~ Minti
                      Code style assistance
                      Navigation and search
                      ~ Xamarin
                      Run and debug Xamarin.Mac
                      projects
                      Run and debug Xamarin.Android
                      projects
                      Run and debug Xamarin.iOS
                      projects

                  Streamline your work with JetBrains Rider
                    Rider settings
                      Directory-based settings
                      Layer-based settings
                      Share IDE settings
                      Restore default settings
                    Advanced configuration
                      Directories used by the IDE
                      Change boot runtime
                      Increase memory heap
                      IDE performance monitor
                      Trusted root certificates
                    Scopes and file colors
                    Scratch files
                    Install plugins
                    External tools
                    Command-line interface
                      Open files from the command line
                      Compare files from the command line
                      Merge files from the command line
                      Install plugins from the command line
                      ReSharper command line tools  __
                        CleanupCode
                        InspectCode
                    Configure synchronization with a server
                      Create an in-place server configuration
                      Create a local server configuration
                      Create a remote server configuration
                      Customize upload and download
                      Organize servers into groups
                    Create SSH configurations
                    Run SSH terminal
                    Background tasks
                    Configure browsers
                    File type associations
                    Configure file size limits
                    Encoding
                    Invalidate caches
                    Tips and tricks
                Game development with JetBrains Rider
                  Unity
                    Features
                    Refresh Unity Assets
                    Debug Unity Applications
                    Run and Debug Unity Tests
                    Run/Debug Configuration: Standalone Player
                    Analyze Coverage of Unity Tests
                    Profile Unity Applications
                    Unity window
                  Unreal Engine  __
                    Before you start
                    Code analysis
                    Create new Unreal Engine entities
                    Unreal Engine Testing Framework
                    Reflection specifiers
                    Remote Procedure Calls
                    Shader development with HLSL
                    Blueprints Support
                    UnrealLink and RiderLink
                    Unreal Engine Program Arguments and Environment Variables
                    Debug Unreal Engine Project
                    Performance tips
                    Unreal Engine naming convention

                Reference
                  vy Settings
                    v Appearance & Behavior
                    Appearance
                    Menus and Toolbars
                    vw System Settings
                      Passwords
                      HTTP Proxy
                      Data Sharing
                      Date Formats
                      File Colors
                      Scopes
                      Tressel.
                      Date Formats
                      File Colors
                      Scopes
                      Notifications
                      Data Editor and Viewer
                      Quick Lists
                      Path Variables
                      Keymap
                      ~ Editor
                      ~ General
                      Auto Import
                      Appearance
                      Breadcrumbs
                      Code Completion
                      Code Folding
                      Console
                      Editor Tabs
                      Gutter Icons
                      Postfix Completion
                      vy Typing Assistance
                      Typing Assistance
                      settings: HTML/CSS
                      Editor Tabs
                      Gutter Icons
                      Postfix Completion
                      vy Typing Assistance
                      Typing Assistance
                      settings: HTML/CSS
                      Typing Assistance
                      settings: JSON
                      Typing Assistance
                      settings: YAML
                      Typing Assistance
                      settings: Markdown
                      Typing Assistance
                      settings: JavaScript
                      Typing Assistance
                      settings: SOL
                      Code Editing
                      Font
                      Color Scheme
                      Sa Orolo (= seta (=)
                      vy SOL
                      Case
                      Queries
                      DDL
                      Code
                      lle iia
                      an Orolo - Bota (=)
                      vy SOL
                      Case
                      Queries
                      DDL
                      Code
                      Expressions
                      Tabs and Indents
                      Wrapping
                      Code generation
                      ASP.NET (Razor)
                      OF:
                      C++
                      CoffeeScript
                      v Style Sheets
                      Css
                      TS)
                      Sass
                      Ores)
                      Stylus
                      F#
                      F# Script
                      lel
                      Stylus
                      eed
                      F# Script
                      [ei nl-le4in
                      HTML
                      JavaScript
                      JSON
                      Markdown code style
                      settings
                      Jade
                      VB.NET
                      Vue
                      XAML
                      XML
                      cee
                      Other File Types
                      vy Inspection Settings
                      Generated Code
                      v Inspection Severity
                      Other Languages
                      Code Annotations
                      Entity Framework
                      Other Languages
                      Code Annotations
                      Entity Framework
                      sess haw VET 1 hd =1 6)
                      Members Generation
                      File Encodings
                      Code Vision
                      Samat a ae)
                      Ser:
                      Parameter Name Hints
                      Type Name Hints
                      Type Conversion Hints
                      Interceptor Hints
                      Other
                      v Visual Basic
                      Parameter Name Hints
                      Other
                      eres
                      c=] e-TUT-1C-@ C
                      Aggregate Initialization
                      Type Name Hints
                      Type Conversion Hints
                      Aggregate Initialization
                      Type Name Hints
                      Type Conversion Hints
                      Unreal Blueprint Hints
                      Other
                      Other Languages
                      XAML
                      Code Cleanup
                      Context Actions
                      Emmet
                      File Header Template
                      vy File Templates
                      File and Code Templates
                      v Language injections
                      Language Injection Settings
                      dialog: Generic JavaScript
                      Language Injection Settings
                      dialog: SOL Type Injection
                      Language Injection Settings
                      dialog: XML Attribute
                      Injection
                      Language Injection Settings
                      dialog: XML Tag Injection
                      ~ Live Templates
                      ee? ae ee Te
                      Language Injection Settings
                      dialog: XML Tag Injection
                      ~ Live Templates
                      wv Live Templates
                      Edit Template Variables
                      dialog
                      vy Spelling
                      ReSpeller
                      TextMate Bundles
                      vy TODO
                      Add / Edit Pattern Dialog
                      Add / Edit Filter Dialog
                      Samad LULe iat)
                      Custom Plugin Repositories
                      Dialog
                      Environment
                      ~ Version Control
                      Changelists
                      Commit
                      Directory Mappings
                      Confirmation
                      ei
                      GitHub
                      Confirmation
                      eri
                      GitHub
                      Mercurial
                      Perforce
                      ~ Subversion
                      Edit Subversion Options
                      Related to Network Layers
                      Dialog
                      vy Build, Execution, Deployment
                      aa DT= Jolt lelel=14
                      wv Debugger. Data Views
                      Debugger. JavaScript
                      Debugger. Stepping
                      ~ Deployment
                      Deployment: Connection
                      Tab
                      Deployment: Mappings Tab
                      Deployment: Excluded
                      Paths Tab
                      Options
                      Files/Folders Default
                      i= 1 O01 E S10) ate lt] (ele)
                      .NET Console
                      Coverage
                      Files/Folders Default
                      Permissions dialog
                      -.NET Console
                      Coverage
                      ~ Docker
                      sare tea)
                      Tools
                      Console
                      Debug and Fast Mode
                      ~ dotCover
                      Highlighting
                      ale JA Tale)
                      dotMemory Profiler
                      vy dotTrace Profiler
                      Call Tree folding
                      y Dynamic Program Analysis
                      Filtering
                      Memory Allocation
                      Database
                      ASP
                      Leh)
                      Hot Reload settings
                      NuGet
                      ASP
                      Leh)
                      Hot Reload settings
                      iS TULe 1-34
                      Required plugins
                      y Toolset and Build
                      Presentation
                      Trusted Locations
                      vy Unit Testing
                      Test Runner
                      Test Linker
                      v Test Frameworks
                      NUnit
                      xUnit.net
                      Rew =t-a
                      VSTest
                      Continuous Testing
                      Xamarin
                      ~ Languages and Frameworks
                      baer hie toleisl et
                      vy JavaScript. Libraries
                      JavaScript. Usage Scope
                      Templates
                      Continuous Testing
                      yl ante lain)
                      ~ Languages and Frameworks
                      Sei hie- belong eo)
                      ~ JavaScript. Libraries
                      JavaScript. Usage Scope
                      Templates
                      Steyi-i6
                      Yeoman
                      ~ Schemas and DTDs
                      Default XML Schemas
                      XML Catalog
                      C# Interactive
                      aor
                      Inspections
                      Order of #includes
                      Code Completion
                      Code Generation
                      Clang-Tidy
                      Unreal Engine
                      Shaders
                      Unreal Engine
                      oe) et poe es ye
                      Unreal Engine
                      Shaders
                      Unreal Engine
                      F# Interactive
                      Markdown language settings
                      Node.js
                      SOL Resolution Scopes
                      Style Sheets
                      TypeScript
                      Unity Engine settings
                      Sa ele)
                      Web Browsers and Preview
                      ~ File Watchers
                      New Watcher Dialog
                      External Tools
                      Terminal
                      ~ Database
                      vy Query execution
                      Output and Results
                      User Parameters
                      Data Editor and Viewer
                      CSV Formats
                      rt ee ee ee oe
                      User Parameters
                      Data Editor and Viewer
                      CSV Formats
                      SQL Dialects
                      Other
                      SSH Configurations
                      SSH Terminal
                      Diagrams
                      ~ Diff & Merge
                      External Diff Tools
                      External Symbols
                      Remote SSH External Tools
                      seh BL
                      Settings: ReSharper
                      Server Certificates
                      Startup Tasks
                      Vagrant
                      Windows Forms Designer
                      XAML Preview
                      paar esd -1
                      Advanced Settings
                      ~ UI reference
                      paar aaa N=
                      Advanced Settings
                      ~ UI reference
                      vy Tool windows
                      Endpoints tool window
                      Documentation tool window
                      NPM window
                      TypeScript window
                      vy Version Control window
                      Console tab
                      Repository tab
                      History tab
                      Integrate to branch info
                      aaa
                      Repository and Incoming
                      tabs
                      Shelf tab
                      Update info tab
                      MQ: 'project_name'' Tab
                      ~ Dialogs
                      Non-Project Files Protection
                      dialog
                      a ataie
                      ~ Run/debug configurations
                      Non-Project Files Protection
                      dialog
                      rata
                      v Run/debug configurations
                      dialog
                      Cucumberjs
                      feel ale i
                      Database script
                      tSQLt Test
                      utPLSOL Test
                      Gulpjs
                      JavaScript Debug
                      Blasi
                      ante)
                      Mocha
                      Nodeunit
                      Oa
                      Protractor
                      Shell Script
                      XSLT
                      Profiling Configurations Dialog
                      ~ Diff Viewers
                      Diff Viewer for files
                      Profiling Configurations Dialog
                      ~ Diff Viewers
                      Diff Viewer for files
                      Diff Viewer for folders
                      ~ Version control reference
                      ~ Mercurial reference
                      Clone Mercurial Repository
                      dialog
                      Create Mercurial Repository
                      dialog
                      Merge dialog (Mercurial)
                      New Bookmark dialog
                      Pull dialog
                      Switch Working Directory
                      dialog
                      Tag dialog (Mercurial)
                      Update Project dialog
                      (Mercurial)
                      ~ Perforce Reference
                      Edit Jobs Linked to
                      Changelist dialog
                      Integrate File dialog
                      (Perforce)
                      Link Job to Changelist
                      dialog
                      Integrate File dialog
                      (m=) 800) (e1-)|
                      Link Job to Changelist
                      dialog
                      Perforce Options dialog
                      Update Project dialog
                      (Um) 800) (e1-)|
                      ~ Subversion reference
                      Authentication Required
                      Changes Browser
                      ~ Check Out From Subversion
                      dialog
                      SVN Checkout Options
                      dialog
                      Configure Subversion
                      Branches
                      Create Branch or Tag dialog
                      (Subversion)
                      Import into Subversion
                      Integrate Project dialog
                      (Subversion)
                      Integrate to Branch
                      Lock File dialog
                      (Subversion)
                      Mark Resolved dialog
                      (Subversion)
                      Select Branch
                      Integrate Project dialog
                      (Subversion)
                      Integrate to Branch
                      Lock File dialog
                      (Subversion)
                      Mark Resolved dialog
                      (Subversion)
                      Select Branch
                      Select Repository Location
                      dialog (Subversion)
                      Set Property dialog
                      (Subversion)
                      Subversion Options dialog
                      Subversion Working Copies
                      Information tab
                      SVN Repositories
                      Update Project dialog
                      (Subversion)
                      Apply Patch dialog
                      Commit Changes dialog
                      File status highlights
                      New Changelist dialog
                      Patch File Settings dialog
                      Push dialog (Mercurial, Git)
                      Revert Changes dialog
                      iw ae ta PT
                      Select Branch
                      Select Repository Location
                      dialog (Subversion)
                      Set Property dialog
                      (Subversion)
                      Subversion Options dialog
                      Subversion Working Copies
                      Information tab
                      SVN Repositories
                      Update Project dialog
                      (Subversion)
                      Apply Patch dialog
                      Commit Changes dialog
                      File status highlights
                      New Changelist dialog
                      Patch File Settings dialog
                      Push dialog (Mercurial, Git)
                      Revert Changes dialog
                      Select Target Changelist
                      dialog
                      Shelve Changes dialog
                      Built-in IDE macros
                      Regular expression syntax reference
                      JetBrains Rider's network activity
Rider+GitHub Copilot:
            Trigger inline copilot-box/chat  cs-g
            ## Open copilot chat  cs-c
            show completions  a-\  # ga-å
            apply next line of completion  ca-right
            apply next word of completion  c-right
            show next / prev. completions  c-. / c-,
Rider Snippets
                    evince -p 1 ~/Empire/Doks/Comp/editor/Jetbrains/JetbrainsDocs/rider-snippets_orig.pdf &
                C# ----
                    #if
                    #region
                        .
                        ()
                    Attribute (Attribute using recommended pattern)
                    Exception
                        asrt (Make an assertion)
                        asrtn (Assert expression not null)
                        attachedAvaloniaProperty (Avalonia Attached Property)
                        attachedProperty (Attached property)
                        cast (cast)
                        checked (checked block)
                    class
                ctor (Constructor)
                        .
                        ctx (Current file context)
                psvm (The "Main" method declaration)
                svm ('void Main' method)  @
                cw (Console.WriteLine)
                    .
                        dependencyProperty (Dependency property)
                        directProperty (Direct Property)
                        do (do...while loop)
                        ear (Create an empty array)
                        else (else statement)
                    enum
                        .
                        for (Simple "for" loop)
                    foreach (foreach block)
                        forr (Reverse 'for' loop)
                        if (if statement)
                        indexer
                        interface
                    itar (Iterate an array)
                    iterator (simple iterator)  @
                    itli (iterate a IList<T>)
                        lock (lock statement)
                        mbox (MessageBox.Show)
                        namespace
                        nguid (insert new GUID)
                        out (Print a string)
                    outv (Print value of a variable)
                    pci (public const int)
                    pcs (public const string)
                prop (Property)
                propg (Property with a 'get' accessor and a private 'set' accessor)
                    .
                    psr (public static readonly)
                        ritar (iterate an array in inverse order)
                        sfc (Safely cast variable)
                    sim ('int Main' method )
                    struct
                        .
                        styledProperty (Styled property)
                        switch (switch statement)
                        test
                        test
                        test
                        test
                        thr (throw new)
                        try (try catch)
                        tryf (try finally)
                        unchecked (unchecked block)
                        unsafe (unsafe statement)
                        using (using statement)
                    while (while loop)
                        {}
                        ~ (Destructor)
                        --
                        from (Language-Integrated Query)
                        join (Join clause in language integrated query)
                        ----
                        hal (ASP.NET MVC Html.ActionLink)
                        rta (ASP.NET Controller RedirectToAction)
                        ua (ASP.NET MVC Url.Action)
                        eprop (Godot exported properties)
                        print (Godot log objects/message)
                        baker (DOTS Baker)
                        componentdata (DOTS |ComponentData)
                        jobentity (DOTS lJob Entity)
                        cor (Unity coroutine method)
                        assetmenu (Unity CreateAssetMenu attribute)
                        log (Unity log object/message)
                        logerr (Unity log error)
                        logex (Unity log exception)
                        logvar (Unity log variable)
                        logwarn (Unity log warning)
                        menuitem (Unity menu item handler)
                        reqcomp (Unity RequireComponent attribute)
                        sfield (Unity serialized field)
                        sprop (Unity property with serialized backing field)

                C++ ----
                        #if...#endif
                        ()
                        UCLASS (UCLASS declaration)
                        UENUM (UENUM declaration)
                        UENUMCLASS (UENUM declaration using the "enum class" syntax)
                        UINTERFACE (UINTERFACE declaration)
                        USTRUCT (USTRUCT declaration)
                        cast (C-like cast expression)
                        cctor (Copy constructor declaration with body)
                        cerr (Write to standard error stream)
                        cin (Read from standard input stream)
                        class (Class declaration)
                        clog (Write to standard log stream)
                        const_cast (const_cast expression)
                        cout (Write to standard output stream)
                        ctor (Default constructor declaration with body)
                        ctx (Current file context)
                        do (do while loop)
                        doc (Documentation template)
                        dtor (Destructor declaration with body)
                        dynamic_cast (dynamic_cast expression)
                        else (else statement)
                        enum (Enum declaration)
                        enum_to_string (Function 'to_string' for enum)
                        enumclass (Enum class declaration)
                        foreach (range-based for loop)
                        fori (for loop pattern with integer index)
                        forr (Reversed for)
                        if (if statement)
                        if...else (if else statement)
                        incg (Include guard)
                        include_guard (include guard surround template)
                        main (main declaration)
                        mctor (Move constructor declaration with body)
                        namespace (namespace declaration)
                        namespace (Anonymous namespace declaration)
                        namespace ... (namespace declaration)
                        nguid (Insert new GUID)
                        reinterpret_cast (reinterpret_cast expression)
                        static_cast (static_cast expression)
                        struct (struct declaration)
                        switch (switch statement)
                        try (try catch statement)
                        union (union declaration)
                        vdtor (Virtual destructor declaration with body)
                        wceerr (Write to standard error stream)
                        wcin (Read from standard input stream)
                        wclog (Write to standard log stream)
                        wcout (Write to standard output stream)
                        while (while statement)
                        {}
                ___zzzz
                Razor ----  ____
                        <script (Create script tag)
                        @inherits (Razor inherits directive)  ___hm_eng
                        @model (Razor model directive)
                        @section (Razor section)
                        a (Create tag attribute)
                        ctx (Current file context)
                        link
                        nguid (Insert new GUID)
                        t (Create tag)
                        tag (tag)
                        tc (Create closed tag)
                ASP.NET ----  __
                        <asp:HyperLink (ASP.NET Hyperlink)
                        <script (Create script tag)
                        a (Create tag attribute)
                        ctx (Current file context)
                        foreach (foreach block)
                        foreach (For Each block)
                        link
                        nguid (Insert new GUID)
                        t (Create ASP.NET tag)
                        tag (tag)
                        tc (Create closed tag)
                Unity ----
                        assetmenu (Unity CreateAssetMenu attribute)
                        baker (DOTS Baker)
                        blendadditive (ShaderLab Blend additive (src + dst))
                        blendadditivesoft (ShaderLab Blend soft additive (src*(1-dst)+dst))
                        blendmultiplicative (ShaderLab Blend multiplicative (src*dst))
                        blendmultiplicative2x (ShaderLab Blend 2x multiplicative (srcdst+dstsrc))
                        blendtransparent (ShaderLab Blend traditional transparency (src*srcAlpha+(1-srcAlpha)*dst))
                        blendtransparentpremul (ShaderLab Blend premultiplied transparency (src+(1-srcAlpha)*dst))
                        color (ShaderLab Color property)
                        cor (Unity coroutine method)
                        ctx (Current file context)
                        cube (ShaderLab Cube property)
                        cubearr (ShaderLab CubeArray property)
                        float (ShaderLab Float property)
                        int (ShaderLab Integer property)
                        log (Unity log object/message)
                        logerr (Unity log error)
                        logex (Unity log exception)
                        logvar (Unity log variable)
                        logwarn (Unity log warning)
                        menuitem (Unity menu item handler)
                        nguid (Insert new GUID)
                        reqcomp (Unity RequireComponent attribute)
                        sfield (Unity serialized field)
                        shader (ShaderLab Shader block)
                        sprop (Unity property with serialized backing field)
                        surf (ShaderLab Surface Shader)
                        tex2d (ShaderLab 2D property)
                        tex2darr (ShaderLab 2DArray property)
                        tex3d (ShaderLab 3D property)
                        vec (ShaderLab Vector property)
                        vfpass (ShaderLab Vertex/Fragment Shader Pass)
                        vfshader (ShaderLab Vertex/Fragment Shader)
                GDScript ----
                        for (for loop)
                        forrange (for range loop)
                        func (define function)
                        if (if)
                        print (Print messages to console)
                        signal (signal declaration)
                        while (while)
                gRPC Request ----
                        grpcr (gRPC Request)

                        Handlebars
                        itar (Handlebars Each block)
                HTML/XML ----
                        CD (Surround with CDATA section)
                        T (Surround with <tag></tag>)
                HTTP Request ----
                        auth (Authorization configuration)
                        authObj (Authorization configurations object)
                        AuthorizationToken (Authorization header with token, e.g. OAuth2)
                        BearerToken (Bearer with token, e.g. from OAuth2 configuration)
                        env (HTTP Client Environment)
                        fptr (POST file by multipart/form-data)
                        gqlr (GraphQL Request)
                        gtr (GET http://example.com/get)
                        gtrp (GET http://example.com/get?id=99)
                        jsonPath (Filter response with JSONPath)
                        mptr (POST multipart/form-data)
                        ptr (POST http://example.com/add...)
                        ptrp (POST application/x-www-form-urlencoded)
                        ssl (SSL Configuration)
                        var (Environment variable)
                        wsr (WebSocket Request)
                        xpath (Filter response with XPath)
                JavaScript ----
                        arf (Surround with Arrow Function)
                        assert (console.assert())
                        defn (Inserts define() expression)
                        error (console.error())
                        exportall (Export statement - export * from 'a')
                        exportfrom (Export statement - export {b} from 'a')
                        exportitems (Export statement - export {b})
                        flow (Inserts @flow annotation)
                        fori (Create iteration loop)
                        forin (iterate (for..in))
                        forof (iterate (for..of))
                        importdefault (Import statement - import b from 'a')
                        importitems (Import statement - import {b} from 'a')
                        importns (Import statement - import * as b from 'a')
                        info (console.info())
                        itar (iterate elements of array)
                        iter (iterate (for..of))
                        itera (iterate (for await..of))
                        itin (iterate (for..in))
                        log (console.log())
                        moduleexports (Export statement - module.exports = a)
                        ref (inserts reference path comment)
                        ritar (iterate elements of array in reverse order)
                        trace (console.trace())
                        us (Inserts 'use strict' statement)
                        warn (console.warn())
                JavaScript Testing ----
                        af (Inserts after() block)
                        afe (Inserts afterEach() block)
                        bf (Inserts before() block)
                        bfe (inserts beforeEach() block)
                        descr (Inserts describe() block)
                        it (Inserts it() block)
                Kubernetes ----
                        kclusterrole (Kubernetes Cluster Role)
                        kclusterrolebinding (Kubernetes Cluster Role Binding)
                        kconfigmap (Kubernetes ConfigMap)
                        kcronjob (Kubernetes CronJob)
                        kcsr (Kubernetes Certificate Signing Request)
                        kdaemonset (Kubernetes Daemon Set)
                        kdeployment (Kubernetes Deployment)
                        kingress (Kubernetes Ingress)
                        knamespace (Kubernetes Namespace)
                        kpod (Kubernetes Pod)
                        kresource (Kubernetes Resource From Scratch)
                        krole (Kubernetes Role)
                        krolebinding (Kubernetes Role Binding)
                        ksecret (Kubernetes Secret)
                        kservice (Kubernetes Service)
                OpenAPI Specifications (.json) ----
                        endp (Inserts endpoint description section)
                        opnp (OpenAPI 3.1.0 Specification (.json))
                        swag (Swagger 2.0 Specification (.json))
                OpenAPI Specifications (.yaml) ----
                        endp (Inserts endpoint description section)
                        opnp (OpenAPI 3.1.0 Specification (.yaml))
                        swag (Swagger 2.0 Specification (.yaml))
                React ----
                        con (Constructor with props argument)
                        fsc (React Flow arrow function component)
                        fsf (React Flow function component)
                        props (this.props.)
                        rcc (React class component)
                        rccp (React class component with PropTypes)
                        rcfc (React class component with PropTypes and lifecycle methods)
                        rsc (React arrow function component)
                        rscp (React arrow function component with propTypes)
                        rsf (React function component)
                        rsfp (React function component with propTypes)
                        rsi (React arrow function component with implicit return)
                        state (this.state.)

                        React hooks
                        lazyimport (const Component = lazy(() => import('path')))
                        useCallback (const name = useCallback(() => (}, []))
                        useContext (const value = useContext(context))
                        useEffect (useEffect(() => {}, []))
                        useLayoutEffect (useLayoutEffect(() => {}, []))
                        useMemo (const cachedValue = useMemo(() => 4}, []))
                        useReducer (const [state, dispatch] = useReducer(params))
                        useRef (const ref = useRef(initialValue))
                        useState (const [state, setState] = useState())
                        useTransition (const [isPending, startTransition] = useTransition())
                Shell Script ----
                        array add (Add new item to the end of array)
                        array all (All array elements)
                        array at index (Elements at index)
                        array create (Create array)
                        array delete (Delete array)
                        array delete at (Delete from array)
                        array iteration (iterate through array)
                        array length (Array length)
                        array set element (Array set element at index)
                        cmd (Command substitution)
                        cmd success check (Cmd success check)
                        curl (Http request)
                        find (Find file or directory)
                        fori (For loop in list)
                        git branch create (Create branch)
                        git commit (Commit changes)
                        git push (Push branch to remote)
                        heredoc (Multiline string)
                        mkdir (Create directory)
                        rm (Remove file or dir)
                        system info linux (Linux system information)
                        system info mac (Mac OS system information)
                        system kernel info (Kernel information)
                        tar compress (tar compress)
                        tar decompress (tar decompress)
                        xargs (Execute commands from standard input)
                SQL ----
                        col (new column definition)
                        del (delete rows from a table)
                        first (select first N rows from a table)
                        ins (insert rows into a table)
                        lim (select first N rows from a table)
                        sel (select all rows from a table)
                        selc (select the number of specific rows in a table)
                        selw (select specific rows from a table)
                        tab (new table definition)
                        top (select first N rows from a table)
                        toprow (select first N rows from a table)
                        upd (update values in a table)
                        view (new view definition)
                Vue ----
                        v3computed (Vue Composition api - computed)
                        v3onbeforemount (Vue onBeforeMount Lifecycle hook)
                        v3onbeforeunmount ((beforeDestroy) Vue onBeforeUnmount Lifecycle hook)
                        v3onbeforeupdate (Vue onBeforeUpdate Lifecycle hook)
                        v3onerrorcaptured (Vue onErrorCaptured Lifecycle hook)
                        v3onmounted (Vue Mounted Lifecycle hook)
                        v3onunmounted ((destroyed) Vue onUnmounted Lifecycle hook)
                        v3onupdated (Vue onUpdated Lifecycle hook)
                        v3reactive (Vue Composition api - reactive)
                        v3reactive-setup (Vue Composition API Script with Reactive)
                        v3ref (Vue Ref)
                        v3useinoptions (Use Composition API within Options API)
                        v3watch (Vue Composition api - watcher single source)
                        v3watch-array (Vue Composition api - watch as array)
                        v3watcheffect (Vue Composition api - watchEffect)
                        vaction (Vuex action)
                        vaftereach (Vue Router global guards afterEach)
                        vanim (Vue transition component with JavaScript hooks)
                        vanimhook-js (Vue transition component js hooks)
                        vbase (Base for Vue File with SCSS)
                        vbase-3 (Base for Vue File Composition AP! with SCSS)
                        vbase-3-reactive (Base for Vue File Composition API with SCSS)
                        vbase-3-setup (Base for Vue File Setup Composition AP! with SCSS)
                        vbase-3-ts (Base for Vue File Composition API - Typescript)
                        vbase-3-ts-setup (Base for Vue File Setup Composition API - Typescript)
                        vbase-css (Base for Vue File with CSS)
                        vbase-less (Base for Vue File with PostCSS)
                        vbase-ns (Base for Vue File with no styles)
                        vbase-pcss (Base for Vue File with PostCSS)
                        vbase-sass (Base for Vue File with PostCSS)
                        vbase-styl (Base for Vue File with Stylus)
                        vbase-ts (Base for Vue File with Typescript)
                        vbase-ts-class (Base for Vue File with Class based Typescript format)
                        vbeforecreate (BeforeCreate lifecycle method)
                        vbeforedestroy (BeforeDestroy lifecycle method)
                        vbeforeeach (Vue Router global guards beforeEach)
                        vbeforeenter (Vue Router per-route guard beforeEnter)
                        vbeforemount (BeforeMount lifecycle method)
                        vbeforeresolve (Vue Router global guards beforeResolve)
                        vbeforerouteenter (Vue Router component guards beforeRouteEnter)
                        vbeforerouteleave (Vue Router component guards beforeRouteLeave)
                        vbeforerouteupdate (Vue Router component guards beforeRouteUpdate)
                        vbeforeupdate (BeforeUpdate lifecycle method)
                        vc-direct (Vue custom directive)
                        vclass (Vue class binding)
                        vclass-obj (Vue class binding)
                        vclass-obj-mult (Vue multiple conditional class bindings)
                        vcommit (Commit to vuex store in methods for mutation)
                        vcomponents (import one component into another, within export statement)
                        vcomputed (Computed value)
                        vconfig (Vue.config.js)
                        vcreated (Created lifecycle method)
                        vdata (Vue Component Data)
                        vdestroyed (Destroyed lifecycle method)
                        vdispatch (Dispatch to vuex store in methods for action)
                        vel-props (Vue component element with props)
                        vemit-child (Vue Emit from Child Component)
                        vemit-parent (Vue Emit to Parent Component)
                        vfilter (Vue filter)
                        vfor (Vue v-for statement)
                        vgetter (Vuex getter)
                        vimport (import one component into another)
                        vimport-dynamic (Import component that should be lazy loaded)
                        vimport-export (Import a component and include it in export default)
                        vimport-gsap (Import GSAP library)
                        vimport-lib (Import a library)
                        vmapactions (Mapactions inside a vue component)
                        vmapgetters (Mapgetters inside a vue component)
                        vmapmutations (Mapmutations inside a vue component)
                        vmapstate (Map getters inside a vue component)
                        vmethod (Vue method)
                        vmixin (Vue mixin)
                        vmixin-use (Vue use mixin)
                        vmodel (Vue v-model directive)
                        vmodel-num (Vue v-model directive number input)
                        vmodule (Vuex module)
                        vmounted (Mounted lifecycle method)
                        vmutation (Vuex mutation)
                        vnuxtl (Nuxt routing link)
                        von (Vue v-on click handler with arguments)
                        vplugin (import a plugin to main.js or plugins file)
                        vprops (Vue Props with Default)
                        vroute-named (Vue Router route with per route code-splitting)
                        vroutename (Named routing link)
                        vroutenameparam (Named routing link w/ params)
                        vroutepath (Path routing link)
                        vrouter (Base for Vue Router)
                        vscrollbehavior (Vue Router scrollBehavior)
                        vslot-named (Named slot)
                        vsrc (Vue image source binding)
                        vstore (Base for Vuex store)
                        vstore-import (Import vuex store into main.js)
                        vstore2 (Vuex store 2)
                        vstyle (Vue inline style binding)
                        vstyle-obj (Vue inline style binding, objects)
                        vtest (Unit test component)
                        vupdated (Updated lifecycle method)
                        vwatcher (Vue watcher)
                        vwatcher-options (Vue watcher with options)
                xsl ----
                        ai (Apply-imports.)
                        an (Attribute-Name.)
                        ats (Apply-Templates-Select.)
                        atsm (Apply-Templates-Select-Mode.)
                        cos (Copy-Of-Select.)
                        ctn (Call- Template-Name.)
                        ctnwp (Call- Template-Name-With-Param.)
                        cwt (Choose-When-Test.)
                        cwto (Choose-When-Test-Otherwise.)
                        fe (For-Each.)
                        it (if-Test.)
                        kn (Key-Name.)
                        o (Otherwise.)
                        pn (Param-Name.)
                        tm (Template-Match.)
                        tmm (Template-Match-Mode.)
                        tn (Template-Name.)
                        tt (Text.)
                        vn (Variable-Name.)
                        vns (Variable-Name-Select.)
                        vos (Value-Of-Select.)
                        wp (With-Param.)
                        wpn (With-Param-Name.)
                        wt (When-Test.)
                Zen CSS ----
                        ! (timportant)
                        ef
                        @f+
                        @eff
                        @i (@import uri(...);)
                        @import (@import uri(...);)
                        @kf (keyframes)
                        @m (@media screen {...})
                        ac (align-content:...;)
                        ac:c (align-content:center;)
                        ac:fe (align-content:flex-end;)
                        ac:fs (align-content:flex-start;)
                        ac:s (align-content:stretch;)
                        ac:sa (align-content:space-around;)
                        ac:sb (align-content:space-between;)
                        ai (align-items:...;)
                        ai:b (align-items:baseline;)
                        ai:c (align-items:center;)
                        ai:fe (align-items:flex-end;)
                        ai:fs (align-items:flex-start;)
                        ai:s (align-items:stretch;)
                        anim (animation:...;)
                        anim- (animation:...;)
                        animdel (animation-delay:...;)
                        animdir (animation-direction:...;)
                        animdir:a (animation-direction: alternate;)
                        animdir:ar (animation-direction: alternate-reverse;)
                        animdir:n (animation-direction: normal;)
                        animdir:r (animation-direction: reverse;)
                        animdur (animation-duration:...;)
                        animfm (animation-fill-mode:...;)
                        animfm:b (animation-fill-mode: backwards;)
                        animfm:bh (animation-fill-mode: both;)
                        animfm:bt (animation-fill-mode: both;)
                        animfm:f (animation-fill-mode: forwards;)
                        animic (animation-iteration-count:...;)
                        animic:i (animation-iteration-count: infinite;)
                        animn (animation-name:...;)
                        animps (animation-play-state:...;)
                        animps:p (animation-play-state: paused;)
                        animps:r (animation-play-state: running;)
                        animtf (animation-timing-function:...;)
                        animtf:cb (animation-timing-function: cubic-bezier(...);)
                        animtf:e (animation-timing-function: ease;)
                        animtf:ei (animation-timing-function: ease-in;)
                        animtf:eio (animation-timing-function: ease-in-out;)
                        animtf:eo (animation-timing-function: ease-out;)
                        animtf:| (animation-timing-function: linear;)
                        ap (appearance:...;)
                        as (align-self:...;)
                        as:a (align-self:auto;)
                        as:b (align-self:baseline;)
                        as:c (align-self:center;)
                        as:fe (align-self:flex-end;)
                        as:fs (align-self:flex-start;)
                        as:s (align-self:stretch;)
                        (bottom:...;)
                        b:a (bottom:auto;)
                        bb (border-bottom:...;)
                        bd (border:...;)
                        bd+ (border:1px solid #000;)
                        bd+ (border:1px solid #000;)
                        bd:n (border:none;)
                        bdb (border-bottom....;)
                        bdb+ (border-bottom:1px solid #000;)
                        bdb:n (border-bottom:none;)
                        bdbc (border-bottom-color:...;)
                        bdbc:t (border-bottom-color:transparent;)
                        bdbi (border-bottom-image:url(...);)
                        bdbi:n (border-bottom-image:none;)
                        bdbk (border-break:...;)
                        bdbk:c (border-break:close;)
                        bdbli (border-bottom-left-image:url(...);)
                        bdbli:c (border-bottom-left-image:continue;)
                        bdbii:n (border-bottom-left-image:none;)
                        bdbirs (border-bottom-left-radius:...;)
                        bdbri (border-bottom-right-image:url(...);)
                        bdbri:c (border-bottom-right-image:continue;)
                        bdbri:n (border-bottom-right-image:none;)
                        bdbrrs (border-bottom-right-radius:...;)
                        bdbs (border-bottom-style:...;)
                        bdbs:n (border-bottom-style:none;)
                        bdbw (border-bottom-width....;)
                        bdc (border-color:...;)
                        bdc:t (border-color: transparent;)
                        bdcl (border-corner-image:url(...);)
                        bdcl:c (border-corner-image:continue;)
                        bdcl:n (border-corner-image:none;)
                        bdcl (border-collapse:...;)
                        bdcl:c (border-collapse:collapse;)
                        bdcl:s (border-collapse:separate;)
                        bdf (border-fit:...;)
                        bdf:c (border-fit:clip;)
                        bdf:of (border-fit:overflow;)
                        bdf:ow (border-fit:overwrite;)
                        bdf:r (border-fit:repeat;)
                        bdf:sc (border-fit:scale;)
                        bdf:sp (border-fit:space;)
                        bdf:st (border-fit:stretch;)
                        bdi (border-image:url(...);)
                        bdi:n (border-image:none;)
                        bdl (border-left:...;)
                        bdl+ (border-left:1px solid #000;)
                        bdl:n (border-left:none;)
                        bdic (border-left-color:...;)
                        bdic:t (border-left-color:transparent;)
                        bdlen (border-length:...;)
                        bdlen:a (border-length:...;)
                        bdli (border-left-image:url(...);)
                        bdli:n (border-left-image:none;)
                        bdis (border-left-style:...;)
                        bdis:n (border-left-style:none;)
                        bdlw (border-left-width:...;)
                        bar (border-right:...;)
                        bdr+ (border-right:1px solid #000;)
                        bdr:n (border-right:none;)
                        bdrc (border-right-color:...;)
                        barc:t (border-right-color:transparent;)
                        bdri (border-right-image:url(...);)
                        bdri:n (border-right-image:none;)
                        bdrs (border-radius:...;)
                        bdrst (border-right-style:...;)
                        bdrst:n (border-right-style:none;)
                        bdrw (border-right-width:...;)
                        bds (border-style:...;)
                        bds:db (border-style:double;)
                        bds:ds (border-style:dashed;)
                        bds:dt (border-style:dotted;)
                        bds:dtds (border-style:dot-dash;)
                        bds:dtdtds (border-style:dot-dot-dash;)
                        bds:g (border-style:groove;)
                        bds:h (border-style:hidden;)
                        bds:i (border-style:inset;)
                        bds:n (border-style:none;)
                        bds:o (border-style:outset;)
                        bds:r (border-style:ridge;)
                        bds:s (border-style:solid;)
                        bds:w (border-style:wave;)
                        bdsp (border-spacing:...;)
                        bdt (border-top:...;)
                        bdt+ (border-top:1px solid #000;)
                        bdt:n (border-top:none;)
                        bdtc (border-top-color:...;)
                        batc:t (border-top-color:transparent;)
                        bdti (border-top-image:url(...);)
                        bati:n (border-top-image:none;)
                        batli (border-top-left-image:url(...);)
                        bdtli:c (border-top-left-image:continue;)
                        bdtli:n (border-top-left-image:none;)
                        bdtirs (border-top-left-radius:...;)
                        batri (border-top-right-image:url(...);)
                        batri:c (border-top-right-image:continue;)
                        batri:n (border-top-right-image:none;)
                        bdtrrs (border-top-right-radius:...;)
                        @ bdts (border-top-style:...;)
                        @ bdts:n (border-top-style:none;)
                        @ bdtw (border-top-width:...;)
                        ( bdw (border-width:...;)
                        @ bfv (backface-visibility:...;)
                        W bfv:h (backface-visibility:hidden;)
                        W bfv:v (backface-visibility:visible;)
                        @ bg (background:...;)
                        [v) bg+ (background:#fff url(...) 0 0 no-repeat;)
                        @ bg:ie (filter:progid:DXimageTransform.Microsoft.AlphalmageLoader(src='....png',sizingMethod="...');)
                        @ bg:n (background:none;)
                        @ bga (background-attachment:...;)
                        [Vv] bga:f (background-attachment:fixed;)
                        @ bga:s (background-attachment:scroll:)
                        @ bgbk (background-break:...;)
                        [Vv] bgbk:bb (background-break:bounding-box;)
                        [Vv] bgbk:c (background-break:continuous;)
                        @ bgbk:eb (background-break:each-box;)
                        @ bgc (background-color: #fff;)
                        @ bgc:t (background-color:transparent;)
                        @ bgcp (background-clip:...;)
                        @ bgcp:bb (background-clip:border-box;)
                        By default expand with [t> sv
                        ——- & S
                        @ bgcp (background-clip:...;)
                        [Vv] bgcp:bb (background-clip:border-box;)
                        @ bgcp:cb (background-clip:content-box;)
                        [Vv] bgcp:nc (background-clip:no-clip;)
                        @ bgcp:pb (background-clip:padding-box;)
                        @ bgi (background-image:url(...);)
                        [Vv] bgi:n (background-image:none;)
                        @ bgo (background-origin:...;)
                        [v] bgo:bb (background-origin:border-box;)
                        [Vv] bgo:cb (background-origin:content-box;)
                        @ bgo:pb (background-origin:padding-box;)
                        @ bgp (background-position:0 0;)
                        [Vv] bgpx (background-position-x:...;)
                        @ bgpy (background-position-y:...;)
                        @ bgr (background-repeat:...;)
                        [Vv] bgr:n (background-repeat:no-repeat;)
                        [v] bgr:rd (background-repeat: round;)
                        @ bgr:sp (background-repeat: space;)
                        [Vv] bgr:x (background-repeat:repeat-x;)
                        @ bgr:y (background-repeat:repeat-y;)
                        @ bgsz (background-size:...;)
                        [Vv] bgsz:a (background-size: auto;)
                        [Vv] bgsz:ct (background-size: contain;)
                        [Vv] bgsz:cv (background-size: cover;)
                        ) bi (border-left:...;)
                        @ br (border-right:...;)
                        @ bt (border-top:...;)
                        () bxsh (box-shadow:...;)
                        () bxsh:n (box-shadow: none;)
                         bxsh:r (box-shadow:... rgb();)
                        @ bxsh:ra (box-shadow:... rgba();)
                        @ bxz (box-sizing:...;)
                        By default expand with [t> sv
                        +—-—-o8S
                        @ bxsh:ra (box-shadow:... rgba();)
                        @ bxz (box-sizing:...;)
                        @ bxz:bb (box-sizing:border-box;)
                        ) bxz:cb (box-sizing:content-box;)
                         c (color:...;)
                        @ c:r (color: rgb();)
                        @ c:ra (color: rgba();)
                        cl (clear:...;)
                         cl:b (clear:both;)
                         cl:! (clear:left;)
                         cl:n (clear:none;)
                        @ cl:r (clear:right;)
                        @ cm (/* */)
                        cnt (content:...;)
                         cnt:a (content:attr(...);)
                         cnt:c (content:counter(...);)
                        @ cnt:cq (content:close-quote;)
                         cnt:cs (content:counters(...);)
                        @ cnt:n (content:normal;)
                        @ cnt:ncq (content:no-close-quote;)
                        @ cnt:nog (content:no-open-quote;)
                        @ cnt:oq (content:open-quote;)
                        coi (counter-increment:...;)
                         colm (columns:...;)
                         colme (column-count:...;)
                        @ colmf (column-fill:...;)
                        @ colmg (column-gap:...;)
                         colmr (column-rule:...;)
                        ( colmre (column-rule-color:...;)
                        @ colmrs (column-rule-style:...;)
                        @ colmrw (column-rule-width:...;)
                        @ colms (column-span:...;)
                        By default expand with [t> sv
                        +—-—-o8S
                        @ colmrw (column-rule-width:...;)
                        @ colms (column-span:...;)
                        @ colmw (column-width:...;)
                        ( cor (counter-reset:...;)
                        @ cp (clip:...;)
                        @ cp:a (clip:auto;)
                        @ cp:r (clip: rect(...);)
                        @ cps (caption-side:...;)
                        @ cps:b (caption-side:bottom;)
                        @ cps:t (caption-side:top;)
                        ct (content:...;)
                         ct:a (content:attr(...);)
                        (H ct:c (content:counter(...);)
                         ct:cq (content:close-quote;)
                         ct:cs (content:counters(...);)
                        H ct:n (content:normal;)
                        @ ct:ncq (content:no-close-quote;)
                         ct:nog (content:no-open-quote;)
                         ct:oq (content:open-quote;)
                        cur (cursor:...;)
                         cur:a (cursor:auto;)
                         cur:c (cursor:crosshair;)
                         cur:d (cursor:default;)
                         cur:ha (cursor:hand;)
                        @ cur:he (cursor:help;)
                         cur:m (cursor:move;)
                        @ cur:p (cursor:pointer;)
                         cur:t (cursor:text;)
                         d (display:...;)
                        @ d:b (display:block;)
                        @ d:cp (display:compact;)
                         d:f (display:flex;)
                        By default expand with [t> sv
                        +-oas
                        @ d:cp (display:compact;)
                        ( d:f (display:flex;)
                        @ d:i (display: inline;)
                        @ d:ib (display:inline-block;)
                        @ d:ib+ (display:inline-block; *display: inline; *zoom: 1;)
                        W d:if (display:inline-flex;)
                         d:itb (display:inline-table;)
                         d:li (display: list-item;)
                         d:n (display:none;)
                        @ d:rb (display:ruby;)
                        @ d:rbb (display:ruby-base;)
                        @ d:rbbg (display:ruby-base-group;)
                        W d:rbt (display:ruby-text;)
                        @ d:rbtg (display:ruby-text-group;)
                        @ d:ri (display:run-in;)
                        () d:tb (display:table;)
                         d:tbc (display:table-cell;)
                         d:tbcl (display:table-column;)
                        [Vv] d:tbclg (display:table-column-group;)
                        @ d:tbcp (display:table-caption;)
                        @ d:tbfg (display:table-footer-group;)
                        @ d:tbhg (display:table-header-group;)
                         d:tbr (display:table-row;)
                        [Vv] d:tbrg (display:table-row-group;)
                        @ ec (empty-cells:...;)
                        @ ec:h (empty-cells:hide;)
                        @ ec:s (empty-cells:show;)
                        Wf (font:...;)
                        (f+ (font:1em Arial,sans-serif;)
                         fef (font-effect:...;)
                        () fef:eb (font-effect:emboss;)
                        [Vv] fef:eg (font-effect:engrave;)
                        By default expand with [t> sv
                        +—- & S
                        W f (font:...;)
                        (f+ (font:1em Arial,sans-serif;)
                        W fef (font-effect:...;)
                        () fef:eb (font-effect:emboss;)
                        [v) fef:eg (font-effect:engrave;)
                         fef:n (font-effect:none;)
                        () fef:o (font-effect:outline;)
                        fem (font-emphasize:...;)
                        ( femp (font-emphasize-position:...;)
                        @ femp:a (font-emphasize-position:after;)
                        @ femp:b (font-emphasize-position:before;)
                        @ fems (font-emphasize-style:...;)
                        ( fems:ac (font-emphasize-style:accent;)
                        @ fems:c (font-emphasize-style:circle;)
                        @ fems:ds (font-emphasize-style:disc;)
                        @ fems:dt (font-emphasize-style:dot;)
                        @ fems:n (font-emphasize-style:none;)
                        @ ff (font-family:...;)
                         ff:a (font-family:Arial, "Helvetica Neue", Helvetica, sans-serif;)
                        @ ff:c (font-family:cursive;)
                        @ ff:f (font-family:fantasy;)
                        @ ff:m (font-family:monospace;)
                        @ ff:s (font-family:serif;)
                        @ ff:ss (font-family:sans-serif;)
                        @ ff:t (font-family:"Times New Roman", Times, Baskerville, Georgia, serif;)
                        ( ff:v (font-family: Verdana, Geneva, sans-serif;)
                        fi (float:...;)
                         fi:| (float:left;)
                        ( fi:n (float:none;)
                        @ fi:r (float:right;)
                        @ fs (font-style:...;)
                        @ fs:i (font-style:italic;)
                        By default expand with [t> sv
                        +—- & S
                        fs (font-style:...;)
                        @ fs:i (font-style:italic;)
                        @ fs:n (font-style:normal;)
                        @ fs:o0 (font-style:oblique;)
                        @ fsm (font-smooth....;)
                        @ fsm:a (font-smooth:auto;)
                        @ fsm:aw (font-smooth:always;)
                         fsm:n (font-smooth:never;)
                        fst (font-stretch:...;)
                         fst:c (font-stretch:condensed;)
                         fst:e (font-stretch:expanded;)
                         fst:ec (font-stretch:extra-condensed;)
                        @ fst:ee (font-stretch:extra-expanded;)
                         fst:n (font-stretch:normal;)
                         fst:sc (font-stretch:semi-condensed;)
                        @ fst:se (font-stretch:semi-expanded;)
                         fst:uc (font-stretch:ultra-condensed;)
                        @ fst:ue (font-stretch:ultra-expanded;)
                        fv (font-variant:...;)
                         fv:n (font-variant:normal;)
                        @ fv:sc (font-variant:small-caps;)
                        @ fw (font-weight:...;)
                        @ fw:b (font-weight:bold;)
                        @ fw:br (font-weight:bolder;)
                        @ fw:ir (font-weight:lighter;)
                        @ fw:n (font-weight:normal;)
                        ( fx (flex:...;)
                        ) fxb (flex-basis:...;)
                        (fxd (flex-direction:...;)
                        () fxd:c (flex-direction:column;)
                        () fxd:cr (flex-direction:column-reverse;)
                        ) fxd:r (flex-direction:row;)
                        By default expand with [t> sv
                        ——- & S
                        (W) fxd:cr (flex-direction:column-reverse;)
                         fxd:r (flex-direction:row;)
                        () fxd:rr (flex-direction:row-reverse;)
                        ( fxf (flex-flow:...;)
                        @ fxg (flex-grow:...;)
                         fxsh (flex-shrink:...;)
                        ( fxw (flex-wrap:;)
                        @ fxw:n (flex-wrap:nowrap;)
                        @ fxw:w (flex-wrap:wrap;)
                        @ fxw:wr (flex-wrap:wrap-reverse;)
                        () fz (font-size:...;)
                        @ fza (font-size-adjust:...;)
                        @ fza:n (font-size-adjust:none;)
                        @ h (height:...;)
                        @ h:a (height:auto;)
                        jc (justify-content:...;)
                        @ jc:c (justify-content:center;)
                         jc:fe (justify-content:flex-end;)
                        @ jc:fs (justify-content:flex-start;)
                        @ jc:sa (justify-content:space-around;)
                        @ jc:sb (justify-content:space-between;)
                        | (left:...;)
                        (H |:a (left:auto;)
                        [Vv] Ig (background-image: linear-gradient(...);)
                        @ th (line-height:...;)
                        (lis (list-style:...;)
                         lis:n (list-style:none;)
                         lisi (list-style-image:...;)
                         lisi:n (list-style-image:none;)
                        @ lisp (list-style-position:...;)
                         lisp:i (list-style-position:inside;)
                         lisp:o (list-style-position:outside;)
                        By default expand with [t> sv
                        4-6
                         lisp:i (list-style-position:inside;)
                        @ lisp:o (list-style-position:outside;)
                        list (list-style-type:...;)
                        @ list:c (list-style-type:circle;)
                         list:d (list-style-type:disc;)
                         list:dc (list-style-type:decimal;)
                         list:dclz (list-style-type:decimal-leading-zero;)
                        @ list:Ir (list-style-type:lower-roman;)
                        @ list:n (list-style-type:none;)
                         list:s (list-style-type:square;)
                        @ list:ur (list-style-type:upper-roman;)
                        Its (letter-spacing:...;)
                         Its-n (letter-spacing: normal;)
                        @ m (margin:...;)
                        @ m:a (margin:auto;)
                        @ mah (max-height:...;)
                        @ mah:n (max-height:none;)
                        ( mar (max-resolution:...;)
                        (maw (max-width:...;)
                        @ maw:n (max-width:none;)
                        @ mb (margin-bottom....;)
                        @ mb:a (margin-bottom:auto;)
                        @ mih (min-height:...;)
                        mir (min-resolution:...;)
                        @ miw (min-width:...;)
                        @ mi (margin-left:...;)
                        @ mi:a (margin-left:auto;)
                        @ mr (margin-right:...;)
                        @ mr:a (margin-right:auto;)
                        ( mt (margin-top:...;)
                        WH mt:a (margin-top:auto;)
                        ol (outline:...;)
                        By default expand with [t> sv
                        +—- & S
                        ( mt:a (margin-top:auto;)
                        ol (outline:...;)
                         ol:n (outline:none;)
                         olc (outline-color:...;)
                         olc:i (outline-color:invert;)
                         olo (outline-offset:...;)
                        @ ols (outline-style:...;)
                        @ ols:db (outline-style: double;)
                        @ ols:ds (outline-style: dashed;)
                        @ ols:dt (outline-style: dotted;)
                        [Vv] ols:g (outline-style: groove;)
                        @ ols:i (outline-style: inset;)
                        @ ols:n (outline-style: none;)
                        @ ols:o (outline-style: outset;)
                        @ ols:r (outline-style: ridge;)
                         ols:s (outline-style: solid;)
                         olw (outline-width:...;)
                         olw:m (outline-width: medium;)
                         olw:tc (outline-width: thick;)
                         olw:tn (outline-width: thin;)
                        @ op (opacity:...;)
                        @ op+ (opacity:...; filter: alpha(opacity...);)
                        W op:ie (filter: progid:DXimage Transform.Microsoft.Alpha(Opacity=100);)
                        @ op:ms (-ms-filter:'progid:DXimage Transform.Microsoft.Alpha(Opacity=100)';)
                        ) ord (order:...;)
                        ori (orientation:...;)
                        @ ori:| (orientation:landscape;)
                        @ ori:p (orientation:portrait;)
                        @ orp (orphans:...;)
                        ov (overflow:...;)
                        ) ov:a (overflow:auto;)
                        ) ov:h (overflow:hidden;)
                        By default expand with [t> sv
                        +—-o8d
                         ov:a (overflow:auto;)
                         ov:h (overflow:hidden;)
                         ov:s (overflow:scroll;)
                        ) ov:v (overflow:visible;)
                        @ ovs (overflow-style:...;)
                        @ ovs:a (overflow-style:auto;)
                        @ ovs:m (overflow-style:move;)
                        @ ovs:mq (overflow-style:marquee;)
                        @ ovs:p (overflow-style:panner;)
                        @ ovs:s (overflow-style:scrollbar;)
                         ovx (overflow-x:...;)
                        @ ovx:a (overflow-x:auto;)
                        ) ovx:h (overflow-x:hidden;)
                         ovx:s (overflow-x:scroll;)
                        W ovx:v (overflow-x:visible;)
                        @ ovy (overflow-y:...;)
                        @ ovy:a (overflow-y:auto;)
                        @ ovy:h (overflow-y:hidden;)
                        [v) ovy:s (overflow-y:scroll;)
                        @ ovy:v (overflow-y:visible;)
                        @ p (padding:...;)
                        @ pb (padding-bottom....;)
                        @ pgba (page-break-after:...;)
                        @ pgba:al (page-break-after:always;)
                        [Vv] pgba:au (page-break-after:auto;)
                        @ pgba:! (page-break-after:left;)
                        [v) pgba:r (page-break-after:right;)
                        @ pgbb (page-break-before:...;)
                        @ pgbb:al (page-break-before:always;)
                        @ pgbb:au (page-break-before:auto;)
                        @ pgbb:! (page-break-before:left;)
                        @ pgbb:r (page-break-before:right;)
                        By default expand with [t> sv
                        +—-oa85d
                        @ pgbb (page-break-before:...;)
                        @ pgbb:al (page-break-before:always;)
                        @ pgbb:au (page-break-before:auto;)
                        @ pgbb:! (page-break-before:left;)
                        [v) pgbb:r (page-break-before:right;)
                        @ pgbi (page-break-inside:...;)
                        [Vv] pgbi:au (page-break-inside:auto;)
                        [v) pgbi:av (page-break-inside:avoid;)
                        @ pl (padding-left:...;)
                        @ pos (position:...;)
                        @ pos:a (position:absolute;)
                        @ pos:f (position:fixed;)
                        @ pos:r (position:relative;)
                        @ pos:s (position:static;)
                        @ pr (padding-right:...;)
                        @ pt (padding-top:...;)
                        @ q (quotes:...;)
                        @ q:en (quotes:en;)
                        @ q:n (quotes:none;)
                        @ q:ru (quotes:ru;)
                        @ r (right:...;)
                        @ r:a (right:auto;)
                         rsz (resize:...;)
                        ( rsz:b (resize: both;)
                         rsz:h (resize: horizontal;)
                         rsz:n (resize: none;)
                        (W rsz:v (resize: vertical;)
                        Wt (top:...;)
                        ( t:a (top:auto;)
                        ( ta (text-align:...;)
                        @ ta-ist (text-align-last:...;)
                         ta:c (text-align:center;)
                        By default expand with [t> sv |
                        +—-o8S
                        @ ta-Ist (text-align-last:...;)
                         ta:c (text-align:center;)
                        @ ta:j (text-align:justify;)
                        @ ta:! (text-align:left;)
                         ta:r (text-align:right;)
                        W tal:a (text-align-last:auto;)
                         tal:c (text-align-last:center;)
                         tal:| (text-align-last:left;)
                        @ tal:r (text-align-last:right;)
                        @ tb! (table-layout:...;)
                         tbi:a (table-layout:auto;)
                        ( tbi:f (table-layout:fixed;)
                        (td (text-decoration:...;)
                        ta: (text-decoration:line-through;)
                        (W td:n (text-decoration:none;)
                        (H td:o (text-decoration:overline;)
                        (W td:u (text-decoration:underline;)
                        (J te (text-emphasis:...;)
                         te:a (text-emphasis:after;)
                        (H te:ac (text-emphasis:accent;)
                        (J te:b (text-emphasis:before;)
                         te:c (text-emphasis:circle;)
                         te:ds (text-emphasis:disc;)
                        ( te:dt (text-emphasis:dot;)
                         te:n (text-emphasis:none;)
                        @ th (text-height:...;)
                         th:a (text-height:auto;)
                        @ th:f (text-height:font-size;)
                        @ th:m (text-height:max-size;)
                        @ th:t (text-height:text-size;)
                        ( ti (text-indent:...;)
                        ( ti:- (text-indent:-9999px;)
                        By default expand with [t> sv
                        +—- 8 S
                        ti (text-indent:...;)
                         ti:- (text-indent:-9999px;)
                        tj (text-justify:...;)
                        @ tj:a (text-justify:auto;)
                         tj:d (text-justify:distribute;)
                        ( tj:ic (text-justify:inter-cluster;)
                        @ tj:ii (text-justify:inter-ideograph;)
                        @ tj:iw (text-justify:inter-word;)
                        ( tj:k (text-justify:kashida;)
                         tj:t (text-justify:tibetan;)
                        (to (text-outline:...;)
                        () to+ (text-outline:0 0 #000;)
                         to:n (text-outline:none;)
                        (H) tov (text-overflow:...;)
                        W tov:c (text-overflow: clip;)
                        W tov:e (text-overflow: ellipsis;)
                        ( tr (text-replace:...;)
                         tr:n (text-replace:none;)
                        ( trf (transform:...;)
                        ( trf:r (transform: rotate(angle);)
                        ( trf:rx (transform: rotateX(angle);)
                        @ trf:ry (transform: rotateY (angle);)
                        ( trf:rz (transform: rotateZ(angle);)
                        ( trf:sc (transform: scale(x, y);)
                         trf:sc3 (transform: scale3d(x, y, z);)
                        (W trf:scx (transform: scaleX(x);)
                        ( trf:scy (transform: scaleY (y);)
                        (W trf:scz (transform: scaleZ(z);)
                        ( trf:skx (transform: skewX(angle);)
                        ( trf:sky (transform: skewY (angle);)
                         trf:t (transform: translate(x, y);)
                        @ trf:t3 (transform: translate3d(x, y, z);)
                        By default expand with [t> sv |
                        +—- @ S
                        @ trf:t (transform: translate(x, y);)
                        @ trf:t3 (transform: translate3d(x, y, z);)
                        ( trf:tx (transform: translateX(x);)
                         trf:ty (transform: translateY (y);)
                         trf:tz (transform: translateZ(z);)
                        @ trfo (transform-origin:...;)
                         trfs (transform-style:...;)
                        @ trs (transition:prop time;)
                        ( trsde (transition-delay:time;)
                         trsdu (transition-duration:time;)
                        @ trsp (transition-property:prop;)
                        W trstf (transition-timing-function:tfunc;)
                        ( tsh (text-shadow:hoff voff blur #000;)
                        ( tsh+ (text-shadow:0 0 0 #000;)
                        ( tsh:n (text-shadow:none;)
                        ( tsh:r (text-shadow:hoff voff blur rgb();)
                        (W tsh:ra (text-shadow:hoff voff blur rgba();)
                        tt (text-transform:...;)
                         tt:c (text-transform:capitalize;)
                        ( tt:| (text-transform:lowercase;)
                        (H tt:n (text-transform:none;)
                        ( tt:u (text-transform:uppercase;)
                        tw (text-wrap:...;)
                        @ tw:n (text-wrap:normal;)
                         tw:no (text-wrap:none;)
                        @ tw:s (text-wrap:suppress;)
                        @ tw:u (text-wrap:unrestricted;)
                        us (user-select:...;)
                        @ v (visibility:...;)
                        @ v:c (visibility:collapse;)
                        @ v:h (visibility:hidden;)
                        @ v:v (visibility:visible;)
                        By default expand with [t> sv
                        —E—- 8 S
                        us (user-select:...;)
                        @ v (visibility:...;)
                        @ v:c (visibility:collapse;)
                        @ v:h (visibility:hidden;)
                        @ v:v (visibility:visible;)
                        @ va (vertical-align:...;)
                        @ va:b (vertical-align:bottom;)
                        ) va:b! (vertical-align:baseline;)
                        @ va:m (vertical-align:middle;)
                        @ va:sub (vertical-align:sub;)
                        @ va:sup (vertical-align:super;)
                        @ va:t (vertical-align:top;)
                        W va:tb (vertical-align:text-bottom;)
                        @ va:tt (vertical-align:text-top;)
                        @ w (width:...;)
                        @ w:a (width:auto;)
                        @ wfsm (-webkit-font-smoothing....;)
                        @ wfsm:a (-webkit-font-smoothing: antialiased;)
                        @ wfsm:n (-webkit-font-smoothing: none;)
                        @ wfsm:s (-webkit-font-smoothing: subpixel-antialiased;)
                        @ wfsm:sa (-webkit-font-smoothing: subpixel-antialiased;)
                        @ whs (white-space:...;)
                        @ whs:n (white-space:normal;)
                        @ whs:nw (white-space:nowrap;)
                        @ whs:p (white-space:pre;)
                        @ whs:p! (white-space:pre-line;)
                        @ whs:pw (white-space:pre-wrap;)
                        @ whsc (white-space-collapse:...;)
                        @ whsc:ba (white-space-collapse:break-all;)
                        @ whsc:bs (white-space-collapse:break-strict;)
                        @ whsc:k (white-space-collapse:keep-all;)
                        @ whsc:! (white-space-collapse:loose;)
                        By default expand with [t> sv
                        +t—-—- eS
                        @ whsc:ba (white-space-collapse:break-all;)
                        @ whsc:bs (white-space-collapse:break-strict;)
                        @ whsc:k (white-space-collapse:keep-all;)
                        @ whsc:! (white-space-collapse:loose;)
                        @ whsc:n (white-space-collapse:normal;)
                        @M wm (writing-mode:...;)
                        @ wm:bt! (writing-mode: bt-Ir;)
                        @ wm:btr (writing-mode: bt-rl;)
                        @ wm:irb (writing-mode: Ir-bt;)
                        @M wm:irt (writing-mode: Ir-tb;)
                        @ wm:rlb (writing-mode: rl-bt;)
                        @ wm:rit (writing-mode: rl-tb;)
                        @ wm:tb! (writing-mode: tb-Ir;)
                        @ wm:tbr (writing-mode: tb-rl;)
                        @ wob (word-break:...;)
                        @ wob:ba (word-break:break-all;)
                        ( wob:k (word-break:keep-all;)
                        ( wob:n (word-break:normal;)
                        @ wos (word-spacing:...;)
                        @ wow (word-wrap.:...;)
                        MH wow:b (word-wrap:break-word;)
                        @ wow:n (word-wrap:none;)
                        @ wow:nm (word-wrap:normal;)
                        @ wow:s (word-wrap:suppress;)
                        @ wow:u (word-wrap:unrestricted;)
                        (Wz (z-index:...;)
                        (W z:a (z-index:auto;)
                        zm (zoom:1;)
                        (W) zoo (zoom:1;)
                        > MZenHTML
                        > Zen XSL
                        By default expand with [t> sv
                        +-oa
                Zen HTML ----
                        !
                        !!! (<!doctype htmI>)
                        !!!4s (<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">)
                        !!!4t (<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "nttp://www.w3.org/TR/html4/loose.dtd">)
                        !!!xs (<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">)
                        !!!xt (<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">)
                        !!!xxs (<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtmi11.dtd">)
                        a (<a href="...">...</a>)
                        a:link (<a href="http://...">...</a>)
                        a:mail (<a href="mailto:...">...</a>)
                        a:tel (<a href="tel:+...">...</a>)
                        abbr (<abbr title="...">...</abbr>)
                        acr (<acronym title="...">...</acronym>)
                        acronym (<acronym title="...">...</acronym>)
                        adr (<address>...</address>)
                        area (<area shape="..." coords="..." href="..." alt="...">)
                        area:c (<area shape="circle" coords="..." href="..." alt="...">)
                        area:d (<area shape="default" coords="..." href="..." alt="...">)
                        area:p (<area shape="poly" coords="..." href="..." alt="...">)
                        area:r (<area shape="rect" coords="..." href="..." alt="...">)
                        art (<article>...</article>)
                        audio (<audio src="...">...</audio>)
                        b (<b>...</b>)
                        base (<base href="...">)
                        basefont (<basefont>)
                        bdo (<bdo dir="...">...</bdo>)
                        bdo:l (<bdo dir="Itr">...</bdo>)
                        bdo:r (<bdo dir="rtl">...</bdo>)
                        bq (<blockquote>...</blockquote>)
                        br (<br>)
                        btn (<button>...</button>)
                        btn:b (<button type="button">...</button>)
                        btn:d (<button disabled>...</button>)
                        btn:r (<button type="reset">...</button>)
                        btn:s (<button type="submit">...</button>)
                        button:d (<button disabled>...</button>)
                        button:disabled (<button disabled>...</button>)
                        button:r (<button type="reset"></button>)
                        button:reset (<button type="reset"></button>)
                        button:s (<button type="submit"></button>)
                        button:submit (<button type="submit"></button>)
                        c (<!-- -->)
                        cap (<caption>...</caption>)
                        cc:ie
                        cc:ie6
                        cc:noie
                        cmd (<command>)
                        col (<col>)
                        colg (<colgroup>...</colgroup>)
                        colg+
                        colgroup+
                        command (<command>)
                        datag (<datagrid>...</datagrid>)
                        datal (<datalist>...</datalist>)
                        det (<details>...</details>)
                        div (<div>...</div>)
                        di+
                        dig (<dialog>...</dialog>)
                        doc
                        doc4
                        emb (<embed src="..." type="...">)
                        embed (<embed src="..." type="...">)
                        fieldset:d (<fieldset disabled>...</fieldset>)
                        fieldset:disabled (<fieldset disabled>...</fieldset>)
                        fig (<figure>...</figure>)
                        figc (<figcaption>...</figcaption>)
                        form (<form action="...">...</form>)
                        form:get (<form action="..." method="get">...</form>)
                        form:post (<form action="..." method="post">...</form>)
                        frame (<frame>)
                        fset (<fieldset>...</fieldset>)
                        fset:d (<fieldset disabled>...</fieldset>)
                        fst (<fieldset>...</fieldset>)
                        fst:d (<fieldset disabled>...</fieldset>)
                        ftr (<footer>...</footer>)
                        h1 (<h1>...</h1>)
                        h2 (<h2>...</h2>)
                        h3 (<h3>...</h3>)
                        h4 (<h4>...</h4>)
                        h5 (<h5>...</h5>)
                        h6 (<h6>...</h6>)
                        hdr (<header>...</header>)
                        head (<head>...</head>)
                        header (<header>...</header>)
                        hr (<hr>)
                        html:5
                        i (<i>...</i>)
                        ifr (<iframe src="..." frameborder="0">...</iframe>)
                        iframe (<iframe src="..." frameborder="0">...</iframe>)
                        img (<img src="..." alt="...">)
                        img:s (<img src="..." alt="..." srcset="...">)
                        img:sizes (<img src="..." alt="..." sizes="..." srcset="...">)
                        img:srcset (<img src="..." alt="..." srcset="...">)
                        img:z (<img src="..." alt="..." sizes="..." srcset="...">)
                        inp (<input type="..." name="..." id="...">)
                        input (<input type="...">)
                        input:b (<input type="button" value="...">)
                        input:button (<input type="button" value="...">)
                        input:c (<input type="checkbox" name="..." id="...">)
                        input:checkbox (<input type="checkbox" name="..." id="...">)
                        input:color (<input type="color" name="..." id="...">)
                        input:date (<input type="date" name="..." id="...">)
                        input:datetime (<input type="datetime" name="..." id="...">)
                        input:datetime-local (<input type="datetime-local" name="..." id="...">)
                        input:email (<input type="email" name="..." id="...">)
                        input:f (<input type="file" name="..." id="...">)
                        input:file (<input type="file" name="..." id="...">)
                        input:h (<input type="hidden" name="...">)
                        input:hidden (<input type="hidden" name="...">)
                        input:i (<input type="image" src="..." alt="...">)
                        input:image (<input type="image" src="..." alt="...">)
                        input:month (<input type="month" name="..." id="...">)
                        input:number (<input type="number" name="..." id="...">)
                        input:p (<input type="password" name="..." id="...">)
                        input:password (<input type="password" name="..." id="...">)
                        input:r (<input type="radio" name="..." id="...">)
                        input:radio (<input type="radio" name="..." id="...">)
                        input:range (<input type="range" name="..." id="...">)
                        input:reset (<input type="reset" value="...">)
                        input:s (<input type="submit" value="...">)
                        input:search (<input type="search" name="..." id="...">)
                        input:submit (<input type="submit" value="...">)
                        input:t (<input type="text" name="..." id="...">)
                        input:tel (<input type="tel" name="..." id="...">)
                        input:text (<input type="text" name="..." id="...">)
                        input:time (<input type="time" name="..." id="...">)
                        input:url (<input type="url" name="..." id="...">)
                        input:week (<input type="week" name="..." id="...">)
                        isindex (<isindex>)
                        keygen (<keygen>)
                        kg (<keygen>)
                        label (<label for="...">...</label>)
                        leg (<legend>...</legend>)
                        li (<li>... </li>)
                        link (<link rel="stylesheet" href="...">)
                        link:atom (<link rel="alternate" href="atom.xml" type="application/atom+ xml" title="Atom">)
                        link:css (<link rel="stylesheet" href="style.css" >)
                        link:favicon (<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">)
                        link:im (<link rel="import" href="">)
                        link:import (<link rel="import" href="">)
                        link:print (<link rel="stylesheet" href="print.css" media="print">)
                        link:rss (<link rel="alternate" href="rss.xml" type="application/rss+xml" title="RSS">)
                        link:touch (<link rel="apple-touch-icon"" href="favicon.png">)
                        map (<map name="...">...</map>)
                        map+
                        marquee (<marquee behavior="..." direction="...">...</marquee>)
                        menu:c (<menu type="context">...</menu>)
                        menu:context (<menu type="context">...</menu>)
                        menu:t (<menu type="toolbar">...</menu>)
                        menu:toolbar (<menu type="toolbar">...</menu>)
                        meta (<meta>)
                        meta:compat (<meta http-equiv="X-UA-Compatible" content="IE=7">)
                        meta:edge (<meta http-equiv="X-UA-Compatible" content="ie=edge">)
                        meta:redirect (<meta http-equiv="refresh" content="0; url=http://example.com">)
                        meta:utf (<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">)
                        meta:vp (<meta name="viewport" content="width=device-width, initial-scale=1.0">)
                        meta:win (<meta http-equiv="Content-Type" content="text/html;charset=Win-1251">)
                        mn (<main>...</main>)
                        obj (<object data="..." type="...">...</object>)
                        object (<object data="..." type="...">...</object>)
                        ol (<ol>...</ol>)
                        ol+
                        opt (<option value="...">...</option>)
                        optg (<optgroup>...</optgroup>)
                        optg+
                        optgroup+
                        option (<option value="...">...</option>)
                        out (<output>...</output>)
                        p (<p>...</p>)
                        param (<param name="..." value="...">)
                        pic (<picture></picture>)
                        pic+
                        picture (<picture></picture>)
                        prog (<progress>...</progress>)
                        ri:a (<picture><source media="(...)" srcset="..."> <img src="..." alt="..."></picture>)
                        ri:art (<picture><source media="(...)" srcset="..."><img src="..." alt="..."></picture>)
                        ri:d (<img src="..." alt="..." srcset="...">)
                        ri:dpr (<img src="..." alt="..." srcset="...">)
                        ri:t (<picture><source srcset="..." type="..."><img src="..." alt="..."></picture>)
                        ri:type (<picture><source srcset="..." type="..."><img src="..." alt="..."></picture>)
                        ri:v (<img src="..." alt="..." sizes="..." srcset="...">)
                        ri:viewport (<img src="..." alt="..." sizes="..." srcset="...">)
                        script (<script>...</script>)
                        script:src (<script src="...">...</script>)
                        sect (<section>...</section>)
                        select (<select name="..." id="...">...</select>)
                        select+
                        select:d (<select name="..." id="..." disabled>...</select>)
                        select:disabled (<select name="..." id="..." disabled>...</select>)
                        source:media (<source media="(...)" srcset="...">)
                        source:media:sizes (<source media="(...)" srcset="..." sizes="...">)
                        source:media:type (<source media="(...)" srcset="..." type="...">)
                        source:sizes (<source sizes="..." srcset="...">)
                        source:sizes:type (<source sizes="..." srcset="..." type="...">)
                        source:src (<source src="..." type="...">)
                        source:srcset (<source srcset="...">)
                        source:type (<source srcset="..." type="...">)
                        span (<span>...</span>)
                        src (<source>)
                        src:m (<source media="(...)" srcset="...">)
                        src:mt (<source media="(...)" srcset="..." type="...">)
                        src:mz (<source media="(...)" srcset="..." sizes="...">)
                        src:s (<source srcset="...">)
                        src:sc (<source src="..." type="...">)
                        src:t (<source srcset="..." type="...">)
                        src:z (<source sizes="..." srcset="...">)
                        src:zt (<source sizes="..." srcset="..." type="...">)
                        str (<strong>...</strong>)
                        style (<style>...</style>)
                        table (<table>...</table>)
                        table+
                        tarea (<textarea name="..." id="..." cols="30" rows="10">...</textarea>)
                        td (<td>...</td>)
                        tem (<template>...</template>)
                        textarea (<textarea name="..." id="..." cols="30" rows="10">...</textarea>)
                        title (<title>...</title>)
                        tr+
                        ul (<ul>...</ul>)
                        ul+
                        video (<video src="...">...</video>)
                Zen XSL ----
                        !!! (<?xml version="1.0" encoding="UTF-8"?>)
                        ap (<xsl:apply-templates select="..." mode="..." />)
                        api (<xsl:apply-imports/>)
                        attr (<xsl:attripute name="...">...</xsl:attribute>)
                        attrs (<xsl:attribute-set name="...">...</xsl:attripute-set>)
                        call (<xsl:call-template name="..." />)
                        ch (<xsl:choose>...</xsl:choose>)
                        choose
                        co (<xsl:copy-of select="..." />)
                        com (<xsl:comment>...</xsl:comment>)
                        cp (<xsl:copy select="..."/>)
                        each (<xsl:for-each select="...">...</xsl:for-each>)
                        elem (<xsl:element name="...">...</xsl:element>)
                        fall (<xsl:fallback>...</xsl:fallback>)
                        for (<xsl:for-each select="...">...</xsl:for-each>)
                        if (<xsl:if test="...">...</xsl:if>)
                        imp (<xsl:import href="..."/>)
                        inc (<xsl:include href="..."/>)
                        key (<xsl:key name="..." match="..." use="..." />)
                        msg (<xsl:message terminate="no">...</xsl:message>)
                        nam (<namespace-alias stylesheet-prefix="..." result-prefix="..." />)
                        num (<xsl:number value="..." />)
                        ot (<xsl:otherwise></xsl:otherwise>)
                        par (<xsl:param name="...">...</xsl:param>)
                        pare (<xsl:param name="..." select="..." />)
                        pres (<xsl:preserve-space elements="..." />)
                        proc (<xsl:processing-instruction name="...">...</xsl:processing-instruction>)
                        sort (<xsl:sort select="..." order="..." />)
                        strip (<xsl:strip-space elements="..." />>)
                        tex (<xsl:text></xsl:text>)
                        tm (<xsl:template match="..." mode="...">...</xsl:template>)
                        tmatch (<xsl:template match="..." mode="...">...</xsl:template>)
                        tn (<xsl:template name="...">...</xsl:template>)
                        tname (<xsl:template name="...">...</xsl:template>)
                        val (<xsl:value-of select="..." />)
                        var (<xsl:variable name="...">...</xsl:variable>)
                        vare (<xsl:variable name="..." select="..." />)
                        wh (<xsl:when test="...">...</xsl:when>)
                        xsl
                        xsl:when (<xsl:when test="...">...</xsl:when>)
ReSharper/R#
                    https://resources.jetbrains.com/storage/products/resharper/docs/ReSharper_DefaultKeymap_IDEAscheme.pdf
                    EXPLORE
                    Go to everything Ctrl+N
                    Go to type Ctrl+N (second hit)
                    Go to symbol Ctrl+Shift+Alt+N
                    Go to word Ctrl+N+N+N
                    Go to file Ctrl+Shift+N
                    Go to file member Ctrl+F12
                    Find usages Alt+F7
                    Find usages (advanced) Shift+Alt+F7
                    Find Results window Ctrl+Alt+U
                    Highlight usages in file Ctrl+Shift+F7
                    Go to previous usage Ctrl+Alt+ ↑
                    Go to next usage Ctrl+Alt+ ↓
                    Analyze References window Ctrl+Alt+Y
                    Navigate to Ctrl+Shift+G
                    Go to declaration Ctrl+B
                    Go to type of symbol Ctrl+Shift+T
                    Go to implementation Ctrl+Shift+Alt+B
                    Go to base symbols Ctrl+U
                    Go to derived symbols Ctrl+Alt+B
                    Go to usage Ctrl+Alt+F7
                    File structure Ctrl+ F11
                    Go to next member/tag Alt+ ↓
                    Go to previous member/tag Alt+ ↑
                    Go to containing declaration Ctrl+[
                    To-do items Ctrl+Alt+.
                    Explore stack trace Ctrl+Shift+E
                    Locate in Solution Explorer Shift+Alt+L
                    Structural navigation Tab / Shift+Tab
                    CREATE
                    Symbol code completion Ctrl+Space
                    Smart code completion Ctrl+Shift+Space
                    Import symbol completion Ctrl+Alt+Space
                    Complete statement Ctrl+Shift+Enter
                    Parameter info Ctrl+P
                    Go to previous signature
                    (in parameter info) Ctrl+Shift+P
                    Quick documentation Ctrl+Q
                    Move code up / down / left / right Ctrl+Shift+Alt+ ↑ / ↓ / ← / →
                    Extend selection Ctrl+W
                    Shrink selection Ctrl+Shift+W
                    Duplicate a line or selection Ctrl+D
                    Select containing declaration Ctrl+Shift+[
                    Comment/uncomment line Ctrl+/
                    Comment/uncomment block Ctrl+Shift+/
                    Generate code (constructors,
                    properties, implementing/overriding
                    members, etc)
                    Alt+Ins
                    Insert live template Ctrl+J
                    Surround with template Ctrl+Alt+J
                    Create file from template Alt+Ins in Solution Explorer
                    or Ctrl + Alt + Ins
                    Go to last edit location Ctrl+Shift+Backspace
                    View recent files Ctrl+E
                    View recent edits Ctrl+Shift+Alt+Backspace
                    Go to related files Ctrl+Shift+Alt+G
                    View bookmarks Ctrl+`
                    Go to bookmark Ctrl+[0...9]
                    Set/remove bookmark Ctrl+Shift+[0...9]
                    IMPROVE
                    Show available quick-fixes and
                    context actions Alt+Enter
                    Inspect this Ctrl+Shift+Alt+A
                    View type hierarchy Ctrl+Alt+H
                    Go to next highlight
                    (error, warning or suggestion) F12
                    Go to previous highlight
                    (error, warning or suggestion) Shift +F12
                    Go to next error Alt+F12
                    Go to previous error Shift+Alt+F12
                    Refactor this Ctrl+Shift+R
                    Rename F2 or Shift+R
                    Move type or static member F6
                    Safe delete Alt+Del
                    Extract method Ctrl+Alt+M
                    Introduce variable Ctrl+Alt+V
                    Introduce field Ctrl+Alt+D
                    Introduce parameter Ctrl+Alt+P
                    Inline Ctrl+Alt+N
                    Change signature Ctrl+F6
                    Code cleanup Ctrl+Alt+F
                    Apply code style Ctrl+Alt+S
                    Reformat code Ctrl+Alt+L
                    Run unit tests Ctrl+T, R
                    Debug unit tests Ctrl+T, D
                    Run all tests from solution Ctrl+T, L
                    Run current session Ctrl+T, Y
                    Repeat previous run Ctrl+T, T
                    Unit Test Explorer Ctrl+Alt+T
                    Unit Test Sessions Ctrl+Alt+R
                    ----
                    https://duckduckgo.com/?q=resharper+shortcuts&t=newext&atb=v466-1&ia=cheatsheet&iax=cheatsheet
                    Resharper
                    Resharper 10 Keyboard Shortcuts
                    Create
                    Ctrl Space 	Symbol code completion
                    Ctrl Shift Space 	Smart code completion
                    Ctrl Alt Space 	Import symbol completion
                    Ctrl Shift Enter 	Complete statement
                    Ctrl P 	Parameter info
                    Ctrl Shift P 	Go to previous signature
                    Ctrl Q 	Quick documentation
                    Ctrl W 	Extend selection
                    Ctrl Shift W 	Shrink selection
                    Ctrl D 	Duplicate a line or selection
                    Ctrl Shift [ 	Select containing declaration
                    Ctrl / 	Comment/uncomment line
                    Ctrl Shift / 	Comment/uncomment block
                    Generate
                    Ctrl J 	Insert live template
                    Ctrl Alt J 	Surround with template
                    Ctrl Alt Insert 	Create file from template
                    Ctrl Shift Backspace 	Go to last edit location
                    Ctrl E 	View recent files
                    Ctrl Shift Alt Backspace 	View recent edits
                    Ctrl Shift Alt G 	Go to related files
                    Ctrl ` 	View bookmarks
                    Ctrl Numeric key 	Go to bookmark
                    Ctrl Shift Numeric Key 	Set/remove bookmark
                    Explore
                    Ctrl N 	Go to everything
                    Ctrl Shift Alt N 	Go to symbol
                    Ctrl Shift N 	Go to file
                    Ctrl F12 	Go to file member
                    Find
                    Alt F7 	Find usages
                    Shift Alt F7 	Find usages (advanced)
                    Ctrl Alt U 	Find Results window
                    Ctrl Shift F7 	Highlight usages in file
                    Ctrl Alt ↑ 	Go to previous usage
                    Ctrl Alt ↓ 	Go to next usage
                    Ctrl Alt Y 	Analyze References window
                    Navigation
                    Ctrl Shift G 	Navigate to
                    Ctrl B 	Go to declaration
                    Ctrl Shift T 	Go to type of symbol
                    Ctrl Shift Alt B 	Go to implementation
                    Ctrl U 	Go to base symbols
                    Ctrl Alt B 	Go to derived symbols
                    Ctrl Alt F7 	Go to usage
                    File Structure
                    Alt F11 	File Structure
                    Alt ↑ 	Go to next member/tag
                    Alt ↓ 	Go to previous member/tag
                    Ctrl [ 	Go to containing declaration
                    Ctrl Shift E 	Explore stack trace
                    Ctrl Alt L 	Locate in Solution Explorer
                    Improvement
                    Alt Enter 	Show available quick-fixes and context actions
                    Ctrl Shift Alt A 	Inspect this
                    Ctrl E, H 	View type hierarchy
                    F12 	Go to next highlight
                    Shift F12 	Go to previous highlight
                    Alt F12 	Go to next error
                    Shift Alt F12 	Go to previous error
                    Refactoring
                    Ctrl Shift R 	Refactor this
                    F2 	Rename
                    F6 	Move type or static member
                    Alt Delete 	Safe delete
                    Ctrl Alt M 	Extract method
                    Ctrl Alt V 	Introduce variable
                    Ctrl Alt D 	Introduce field
                    Ctrl Alt P 	Introduce parameter
                    Ctrl Alt N 	Inline
                    Ctrl F6 	Change signature
                    Unit Test
                    Ctrl T, R 	Run unit tests
                    Ctrl T, D 	Debug unit tests
                    Ctrl T, L 	Run all tests from solution
                    Ctrl T, Y 	Run current session
                    Ctrl T, T 	Repeat previous run
                    Ctrl Alt T 	Unit Test Explorer
                    Ctrl Alt R 	Unit Test Sessions
                    Miscellaneous
                    Ctrl Alt F 	Code Cleanup 
Avalonia:  ____
            CREATE AND EDIT
.???
            Show context actions
                
            a-Enter 
            Code completion
                
            Ctrl+Space
            Quick / External documentation
                
            Ctrl+Shift+F1 / F1
            Generate code
                
            a-Insert
            Start new line after current
                
            Ctrl+Enter
            Start new line before current
                
            Ctrl+Shift+Enter
            Comment / uncomment line / selection
                
            Ctrl+K,C
            Expand / Collapse code block
                
            Ctrl+Alt+Down /  Ctrl+Alt+Up 
            Recursive Expand / Collapse all / selection
                
            CtrlAlt+NumPad + /  Ctrl+Alt+NumPad -
            Reformat Code
                
            Ctrl+K,F
            Move line up / down
                
            Alt+Shift+Up / Alt+Shift+Down 
            Move statement up / down
                
            Ctrl+Alt+Shift+Up / Cltr+Alt+Shift+Down 
            Extend / Shrink selection
                
            Ctrl+Alt+Right / Ctrl+Alt+Left
            Add carets
                
            Double Ctrl+Up / Double Ctrl+Down
            Cut / Copy / Paste
                
            Ctrl+X / Ctrl+C / Ctrl+V
            Copy document path
                
            Ctrl+Shift+C
            Paste from clipboard history
                
            Ctrl+Shift+V
            Duplicate current line or selection
                
            Ctrl+D
            Delete line
                
            Ctrl+Shift+L
            Join line
                
            Ctrl+Shift+J
            Optimize imports
                
            ca-O
            Toggle case
                
            Ctrl+Shift+U
                    
            MASTER YOUR IDE
            Go to next / previous editor tab
                
            Alt+Right / Alt+Left
            Close editor tab
                
            Ctrl+W
            Settings
                
            ca-S
            Open/close a tool window
                
            Alt+[0-9]
            Hide active / all tool windows
                
            Shift+Esc / Ctrl+Shift+F12
            Toggle full screen mode
                
            Alt+Shift+Enter
            Jump to navigation bar
                
            Ctrl+F2
            Increase / Decrease font size
                
            Alt+NumPad+ / Alt+NumPad-
            FIND EVERYTHING
            Search everywhere
                
            Double Shift
            Find action
                
            Ctrl+Shift+A
            Find / Replace
                
            Ctrl+F / Ctrl+H
            Find / Replace in path
                
            Ctrl+Shift+F / Ctrl+Shift+H
            Next / Previous occurrence
                
            Down / Up
            Go to file member
                
            Alt+\
            NAVIGATE FROM SYMBOLS
            Navigate to
                
            Alt+`
            Declaration or usages
                
            F12
            Find usages
                
            Shift+F12
            Show usages
                
            Alt+Shift+F12
            REFACTOR AND CLEAN UP
            Refactor this
                
            Ctrl+Shift+R
            Rename
                
            Ctrl+R, R
            Safe delete
                
            Ctrl+R, D
            Move
                
            Ctrl+R, O
            Change signature
                
            Ctrl+R,S
            Inline
                
            Ctrl+R,I
                    
            NAVIGATE CONTEXT
            Back
                
            Ctrl+NumPad-
            Go to previous / next member
                
            Alt+Up /  Alt+Down
            Line/column
                
            Ctrl+G
            Containing declaration
                
            Ctrl+[
            Toggle bookmark
                
            Ctrl+K,K
            Next / Previous bookmark
                
            Ctrl+K,N / Ctrl+K,P
            Show bookmarks
                
            Ctrl+`
            Next / Previous highlighted error
                
            Alt+PgDown / Alt+PgUp
            Next / Previous error in solution
                
            Alt+Shift+PgDown /  Alt+Shift+PgUp
            Move caret to next / previous word
                
            Ctrl+Right / Ctrl+Left
            Scroll up / down
                
            Ctrl+Up / Ctrl+Down
            Scroll to center
                
            Ctrl+M,C
            BUILD, RUN, DEBUG
            Build solution
                
            Ctrl+Shift+B
            Toggle Unity Playmode
                
            Ctrl+P
            Pause / Resume Unity Playmode
                
            Ctrl+Shift+P
            Run / Stop debug
                
            F5 / Shift+F5
            Evaluate expression
                
            Shift+F9
            Step over
                
            F10
            Step into
                
            F11
            Step out
                
            Shift+F11
            Run to cursor
                
            Ctrl+F10
            Show execution point
                
            Alt+NumPad*
            Resume program
                
            F5
            Toggle breakpoint
                
            Ctrl+B,B
            Edit breakpoint
                
            Ctrl+B,E
            View breakpoints
                
            ca-B
unit testing
Rx.Net, R3, System.Reactive:  # handle and combine asynchronous data-streams well
        Key Considerations / Choices ----
        The choice of library or framework depends on your specific needs.
          ----
        - If you're primarily working with streams of events and data, Rx.NET is likely the best choice.
        - If you're building large-scale, distributed systems that require high concurrency and fault tolerance, Akka.NET is worth considering.
        - TPL Dataflow is very useful for data-processing pipelines.
----
Visual Studio:
                Microsoft Visual Studio
                Default keyboard shortcuts for Microsoft Visual Studio

                Build
                Ctrl Shift B 	Build Solution
                Ctrl Break 	Cancel
                Ctrl F7 	Compile
                Alt F11 	Run code analysis

                Debug
                Alt F10 	Apply code changes
                Ctrl Alt V, A 	Autos
                Ctrl Alt Break 	Break all
                Ctrl B 	Break at function
                Ctrl Alt B 	Breakpoints
                Ctrl Alt C 	Call stack
                Ctrl Shift F9 	Delete all breakpoints
                Alt F2 	Launch diagnostics hub
                Ctrl Alt D 	Disassembly
                Ctrl Alt V, D 	DOM explorer
                Ctrl F9 	Enable breakpoint
                Ctrl Alt E 	Debug exceptions
                Ctrl Shift F11 	Got to previous call or IntelliTrace event
                Alt F5 	Start graphics diagnostics
                Ctrl Alt I 	Intermmediate
                Ctrl Alt Y, T 	IntelliTrace calls
                Ctrl Alt Y, F 	IntelliTrace events
                Ctrl Alt Y, C 	JavaScript console
                Ctrl Alt V, L 	Default locals
                Ctrl 5 	Location toolbar - Process combo
                Ctrl 6 	Location toolbar - Thread combo
                Ctrl 7 	Location toolbar - Stack frame combo
                Ctrl 8 	Location toolbar - Toggle current thread flag state
                Ctrl 9 	Location toolbar - Toggle flagged threads
                Ctrl Alt M, 1-4 	Memory 1-4
                Ctrl Alt U 	Modules
                Ctrl Shift D, S 	Parallel stacks
                Ctrl Shift D, 1-4 	Parallel watch 1-4
                Ctrl Alt Z 	Debug processes
                Ctrl Alt Q 	Quick watch
                Ctrl Shift R 	Refresh windows app
                Ctrl Alt G 	Registers
                Ctrl Shift F5 	Restart
                Ctrl F10 	Run to cursor
                Ctrl Shift F10 	Set next statement
                Ctrl Shift ` 	Show call stack on code map
                Alt Num * 	Show next statement
                F5 	Start debug
                Alt F1 	Start Windows phone application analysis
                Ctrl F5 	Start without debugging
                F11 	Step into
                Ctrl Alt F11 	Step into specific
                Ctrl Shift Alt F11 	Step out current process
                F10 	Step over
                Ctrl Alt F10 	Step over current process
                Shift F5 	Stop debugging
                Shift Alt F2 	Stop performance analysis
                Ctrl Shift D, K 	Tasks
                Ctrl Alt H 	Threads
                F9 	Toggle break point
                Ctrl F11 	Toggle disassembly
                Ctrl Alt W, 1-4 	Watch 1-4

                Debugger Context Menus
                Alt F9, D 	Delete
                Alt F9, A 	Go to disassembly
                Alt F9, S 	Go to source code

                Diagnostics Hub
                Ctrl Alt F2 	Stop collection

                Edit
                Ctrl Shift v 	Cycle clipboard ring
                Ctrl Shift Ins 	Cycle clipboard ring
                Ctrl F 	Find
                Shift F12 	Find all references
                Ctrl Shift F 	Find in files
                F3 	Find next
                Ctrl F3 	Find next selected
                Shift F3 	Find previous
                Ctrl Shift F3 	Find previous select
                Ctrl K, Ctrl M 	Generate method
                Ctrl F12 	Go to declaration
                F12 	Go to definition
                Ctrl D 	Go to find combo
                F8 	Go to next location
                Shift F8 	Go to previous location
                Ctrl K, Ctrl X 	Insert snippet
                Ctrl ↓ 	Move control down
                ↓ 	Move control down grid
                Ctrl ← 	Move control left
                ← 	Move control left grid
                Ctrl → 	Move control right
                → 	Move control right grid
                Ctrl ↑ 	Move control up
                ↑ 	Move control up grid
                Ctrl , 	Navigate to
                Ctrl K, Ctrl N 	Next bookmark
                Ctrl Shift K, Ctrl Shift N 	Next bookmark in folder
                Shift Alt F12 	Quick find symbol
                Ctrl Shift J 	Refresh remote references
                Ctrl H 	Replace
                Ctrl Shift H 	Replace in files
                Enter 	Show tile grid
                Ctrl Shift ↓ 	Size control down
                Ctrl ↓ 	Size control down grid
                Ctrl Shift → 	Size control left
                Ctrl → 	Size control left grid
                Ctrl Shift → 	Size control right
                Ctrl → 	Size control down right
                Ctrl Shift ↑ 	Size control up
                Ctrl ↑ 	Size control up grid
                Alt F3, S 	Stop search
                Ctrl K, Ctrl S 	Surround with

                Editor Context Menus
                Alt F9, L 	Edit break point labels
                Ctrl ` 	Show item
                Ctrl Alt F5 	Execute
                Ctrl M, Ctrl G 	Go to view
                Ctrl K, Ctrl O 	Toggle header code view
                Ctrl K, Ctrl T 	View call hierarchy

                File
                Ctrl N 	New file
                Ctrl Shift N 	New project
                Ctrl Alt N 	New website
                Ctrl O 	Open file
                Ctrl Shift O 	Open project
                Ctrl Alt O 	Open web site
                Ctrl Shift W 	View in browser

                Help
                Ctrl Alt F1 	Add and remove help content
                Ctrl F1 	View help
                Shift F1 	Window help
                Load Test
                Ctrl R, Q 	Jump to counter pane

                Project
                Shift Alt A 	Add Existing Item
                Ctrl Shift A 	Add New Item
                Ctrl Shift X 	Class Wizard
                Ctrl Alt Ins 	Override
                Alt ;, Alt C 	Preview changes
                Alt ;, Alt P 	Publish selected files
                Alt ;, Alt R 	Replace selected files from server

                Project and Solution Context Menus
                Alt ↓ 	Move down
                Alt ↑ 	Move up

                Refactor
                Ctrl R, Ctrl E 	Encapsulate field
                Ctrl R, Ctrl I 	Extract interface
                Ctrl R, Ctrl M 	Extract method
                Ctrl R, Ctrl V 	Remove parameters
                Ctrl R, Ctrl R 	Rename
                Ctrl R, Ctrl O 	Reorder parameters

                Solution Explorer
                Ctrl [, O 	Open files filter
                Ctrl [, P 	Pending changes filter
                Ctrl [, S 	Sync with active document

                Team
                Ctrl 0, N 	Go to git branches
                Ctrl 0, G 	Go to git changes
                Ctrl ' 	Team explorer search

                Team Foundation Context Menus
                Ctrl 0, B 	Go to builds
                Ctrl 0, C 	Go to connect
                Ctrl 0, D 	Go to documents
                Ctrl 0, H 	Go to home
                Ctrl 0, M 	Go to my work
                Ctrl 0, P 	Go to pending changes
                Ctrl 0, R 	Go to reports
                Ctrl 0, S 	Go to settings
                Ctrl 0, A 	Go to web access
                Ctrl 0, W 	Go to work items

                Test
                Ctrl \, Ctrl C 	Coded UI test builder
                Ctrl \, Ctrl C 	Use existing action recording

                Test Explorer
                Ctrl R, Ctrl A 	Debug all tests
                Ctrl R, Ctrl T 	Debug all tests in context
                Ctrl R, L 	Repeat last run
                Ctrl R, A 	Run all tests
                Ctrl R, T 	Run all tests context

                Tools
                Ctrl Alt P 	Attach to process
                Ctrl K, Ctrl B 	Code snippets manager
                Ctrl Shift Alt F12 	Force garbage collection
                Ctrl / 	Go to command line

                View
                Shift Alt M 	All windows
                Ctrl \, Ctrl R 	Architecture explorer
                Alt ← 	Backward
                Ctrl K, Ctrl W 	Bookmark window
                Ctrl Shift 1 	Browse Next
                Ctrl Shift 2 	Browse Previous
                Ctrl Alt K 	Call heirarchy
                Ctrl Shift C 	Class view
                Ctrl K, Ctrl V 	Class view search combo
                Ctrl \, D 	Code definition window
                Ctrl Alt A 	Command window
                Ctrl Alt D 	Data sources
                Ctrl Alt T 	Document outline
                F2 	Edit label
                Ctrl \, E 	Error list
                Ctrl Alt F 	F# interactive
                Ctrl Alt F12 	Find symbol results
                Alt → 	Forward
                Ctrl Shift F7 	Forward browse context
                Shift Alt Enter 	Full screen
                Ctrl - 	Navigate backward
                Ctrl Shift - 	Navigate forward
                Ctrl Shift F12 	Next Error
                Ctrl W, N 	Notifications
                Ctrl Alt J 	Object browser
                Ctrl K, Ctrl R 	Object browser search combo
                Ctrl Alt O 	Output
                Ctrl Shift 8 	Pop browse context
                [F4] 	Properties window
                Shift F4 	Properties pages
                Ctrl Shift E 	Resource view
                Ctrl Alt S 	Server explorer
                Ctrl . 	Show smart tag
                Ctrl Alt L 	Solution explorer
                Ctrl \, Ctrl S 	SQL Server object explorer
                Ctrl \, T 	Task list
                Ctrl \, Ctrl M 	TFS team explorer
                Ctrl Alt X 	Toolbox
                Ctrl \, Ctrl U 	UML model explorer
                F7 	View code
                Shift F7 	View designer
                Ctrl Alt R 	Web browser
                Ctrl Shift . 	Zoom in
                Ctrl Shift , 	Zoom out

                Window
                [Esc] 	Activate document window
                Ctrl Shift Alt Space 	Add tab to selection
                Ctrl F4 	Close document window
                Shift Esc 	Close tool window
                Ctrl Alt Home 	Keep tab open
                Ctrl F2 	Move to navigation bar
                Ctrl F6 	Next document window
                Ctrl Tab 	Next document window nav
                Alt F6 	Next pane
                [F6] 	Next split pane
                Ctrl PgDn 	Next tab
                Ctrl Shift Alt PgDn 	Next tab and add to selection
                Alt F7 	Next tool window nav
                Ctrl Shift F6 	Previous document window
                Ctrl Shift Tab 	Previous document window nav
                Shift Alt F6 	Previous pane
                Shift F6 	Previous split pane
                Ctrl PgUp 	Previous tab
                Ctrl Shift Alt PgUp 	Previous tab and add to selection
                Shift Alt F7 	Previous tool window nav
                Ctrl Q 	Quick launch
                Ctrl Shift Q 	Quick launch previous category
                Alt - 	Show dock menu
                Ctrl Alt ↓ 	Show ez MDI file list
                Ctrl ; 	Solution explorer search
                Ctrl ` 	Window search

    private set;
ptools.Features-Hitlist
            Unit Testing
            .
DotNet (Classes etc) ----
                DDE
                    System.Web  [Caching, SessionState ]
                --------
                System.IO               # binary-/text-streams, files, ...
                System.Net              # http, tcp/ip, sockets, ...
                    Http
                System.Diagnostics
                    FileVersionInfo
                        FileVersion (=semver-number)
                    Process.Start()
                        Run executable file as a process
                System.Collections
                    Generic
                System.Text             # encodings, Regex, ...
                    JSON
                System.Globalization    # cultures, sorting, ...
                System.Security         # cryptog, permissions, ...
                    Cryptography.MD5.Create();
                System.Reflection       # metadata, IL-emit
                System.Threading
                System.Drawing
                    Drawing2d
                    Imaging
                    Printing
                    Text
                Windows.Forms   # + Test generating with F#(!!)
                    [event-driven, Windows Forms-designer, ]
                ----
                System.Configuration
                System.Resources
                System.ServiceProcess
                System.Runtime
                  InteropServices
                  Remoting
                  Serialization
                ----
                T@T@System.Data (incl. SQL, ADO, OLE)
                System.XML              # + Dom, xslt, xpath, schema ...
                ==== NuGet (=third-party) ====
                Spectre
                Avalonia/MAUI   # Avalonia/XAML-designer????
ptools
                dynamic memory (=managed heap)
                ---- functions --------
                FuncName(int start = 0, int end = 100)  // = optional parameters
                functions can return all datatypes (int, string, array, etc)
                signature =function's name + parameters
                return  to end a method  // can be used several times
                Method Overloading  = several functions with same name, but different signatures
                ---- basics, types --------
                  tip: (1000001UL instead of 1000001ul)
                bigNum = Int32.MaxValue;
                  'bitwise operators'
                Format
                Convert.ToString(result, 2).PadLeft(32, '0'));
                  ToBinary, ToLongDateString (...)
                  ToInt32, ToInt64
                !IsNullOrEmpty
                string[] capitals = ((string[])capitals.Clone())
                new (=Constructors)
                op. typeof returnerar System.Type objekt (=vilken sorts objekt)
                op. 'is' kontrollerar om ett objekt är kompatibelt med en given typ

                ---- arrays, lists --------
                myIntArray = { 1, 2, 3, 4, 5 };
                  int[] intArray = new int[5];
                int[,] matrix =
                {
                  {1, -2, 13, 47},
                  {52, 60, -7, 888},
                };
                int[][] jagged=new int[n][];
                for (int i=0; i<n; i++)
                ...  // Rank, Length, GetLength,  GenEnumerator, IndexOf,  Copy//Clone (+implement own for deep-clone)
                        Clear, CreateInstance  // +implements: ICloneable, IList, ICollection och IEnumerable
                     // Sort, Sort(IComparer),  Sort(Array, Comparison<T>) (+kan användas med lambda-uttryck  Array.BinarySearch()
                'Råd vid arbete med arrayer'  =TODO
                Trick to be able to use elements with different types in an Array
                  = Using type Object
                List<T>
                List<int> intList = new List<int>();  // +Add, Remove, Count,,  Count, Capacity
                TrimExcess (for Lists)

                parsing / validation --------
                Int.TryParse  DateTime.Parse / DateTime.TryParse  // returns 0 if indata is invalid
                int.Parse(string)
                int number = int.Parse(str);  // =efter Console.ReadLine
                do {
                } while (!Regex.IsMatch(pallid, "^[A-Z]{2}[0-9]{3}$"));
                "xxx0001".int.Parse(); (+fånga m. try-catch om kastar FormatException)
                int n = int.Parse(Console.ReadLine());
                 + 'ValidatingDemo'
                String.Length
                  Math.Pow(2,3), Math.Sqrt(4)
                    // hjälpklasser =instantieras inte som ett objekt + tillhandahåller behjälplig/allmänt tillgänglig funktionalitet
                s[0];  // 'H' in "Hello"
                if (int.TryParse(Console.ReadLine(), out choice))

                ---- strings, formatting --------
                string s = 42.ToString("D5");  // 00042
                                   // =något alla klasser har
                      {index(,alignment)(:formatString)}
                        double d = 0.375;
                        s = String.Format("{0,10:F5}", d);
                        // s = "   0,37500"
                          // d, M, y,  h, m, s
                int result = string.Compare(str1, str2, true);  // =ci
                  // or compare ci with '=='
                Substring (=från + hur många)
                String.Concat(str1, str2);  // +any object can be appended to a string
                      [tip: do not use '+' for concat for strings in loop]
                    IndexOf(), LastIndexOf()
                  Split(' ', '-', ':');
                    Replace(), Remove(), alpha.ToUpper/ToLower
                        Trim(), TrimStart, TrimEnd()
                  StringBuilder [Append, Remove, Insert, Replace, ToString...]

                ---- dates --------
                DateTime.AddHours(-2); (eg. DateTime.AddDays
                  Subtract(TimeSpan // DateTime)
                CultureInfo.InvariantCulture / CurrentCulture

                int num = new int(); // num = 0
                int?, double?  (instances of System.Nullable)
                  + for concat: non-string is converted to string
                  int? x = null;
                  int y = x ?? -1; // y blir -1
                                    6   4
                  Console.WriteLine(a > b ? "a > b" : "a <= b");
                [köra tillbaks sträng till nån av DateTime-konstruktorerna]
                System.Threading.Thread.CurrentThread.CurrentCulture = new CultureInfo("en-CA");
                  Console.Read()  (!!), Console.ReadKey()  // +Threading / Globalization
                --
                // Kom ihåg att lägga till en referens till
                // System.Numerics.dll

                explicit typeconversion can be specified even if not required by the compiler (=can clarify the code)
                  checked (=checked int etc)
                  catch (OverflowException e)
                  Console.WriteLine =är en statisk metod
                    (=olika hjälpklasser)
                icke-statiska klasser och metoder =måste instantieras med 'new'
                  [ Program progr = new Program(); ]
                  progr.Print(5)
                  (Blazor, MVC etc som jobbar mot nätet, använder inte  Toplevel  =innehåller inte en Main-metod)  (=är egentligen en Main-metod där man inte ser Main)

                ---- logic, conditions --------
                  demorgans laws (=for translatability between boolean expressions)
                if-statements etc: Put most common case highest (+hierarchy down)
                for: initialization, boolean test, steps
                  for (int i = 1, sum = 1; i <= 128; i = i * 2, sum += i)
                foreach: can iterate over collections (=list, array, string  =have elements of same type)  // read-only
                switch (value)  // +string, enum, and primitive datatypes can be used in the cases (incl. null)  // ! no fall through  // one block can have several cases  // same as if-etc: =Most common cases at top (+trickles down to less expected cases)

                ---- streams, files, io --------
                Data Streams  = sequential ordering of bytes  // files, networks, memory etc  // ger null när filen tar slut  // Flush(), AutoFlush
                  BinaryReader/Writer
                  System.IO.StreamReader
                FileStream (=ärver från Stream)  // FileMode, FileAccess, FileShare (None, Read, Write etc)
                  klassen File
                  Directory.GetFiles
                  + använd using-block  (+SEE MORE EXAMPLES)

                ---- errors, exceptions --------
                  System.Exception  (+användardefinierade exceptions bör ärva från denna)
                  throw
                  'Att välja typ av undantag'
                    'Skapa egna undantag'
                    (don't try to handle EVERY exception)
                try / catch  (FileNotFoundException

                ---- OOP ----
                fields / Properties
System.Windows.Forms
            MessageBox.Show("Välkommen " + namn);
            namn = InputBox.Show("Vad heter du?");
            DialogResult res = MessageBox.Show("Är du medlem?", "Fråga",
                                               MessageBoxButtons.YesNo);
            CheckBox, GroupBox, ComboBox, ListBox, RadioButton, TextBox, RichTextBox (etc)

Common Exceptions + Exception Hierarchy
            .
            // using System.Security.Cryptography.X509Certificates
            Console.WriteLine(Object.ReferenceEquals(a,b));
            // System.String (Class) is a reference-types
            // int, char etc are value-types
            // Strings are stored in the dynamic memory (=managed heap)
            string str1;  // gets value null
            System.String str2;
            string s = "Bla bla...";
            string s2 = s;  // points at the same string; =changing one changes all

            int result = string.Compare(str1, str2, true);  // = case-insensitive comparison

            string str = Console.ReadLine();
            int number;
            bool.parseResult = int.TryParse(str, out number);

            // num1, num2 = num2, num1
            Console.WriteLine(varname);
            @"Att ""använda"" citattecken kan vara besvärligt."
            string triangel = @"
                      ©
                     ©©©
                    ©©©©©
            ";

            Console.WriteLine("No 1 is " + num1 + " and no 2 is " + num2};
            Console.WriteLine("No 1 is {0}, and no 2 is {1}", num1, num2};
            Console.WriteLine($"No 1 is {num1}, and no 2 is {num2}"};

            int.Parse(varname);
            Convert.ToInt32(varname);

            var myString = new string('*', 10);
            StringBuilder sb = new StringBuilder();

            int startVal = 0;
            string myString = "*";
            while (startVal <= 5)
            {
              // string myString = new string('*', 10);
              Console.WriteLine(myString + "*");  // Output
              startVal++;
            }


            // 00000101
            string rightTail = bitstring.Substring(bitstring.Length -3);
            Console.WriteLine(rightTail.Substring(0));

            Console.WriteLine("Skriv in ditt Startvärde: ");
            int n = int.Parse(Console.ReadLine());

            Console.WriteLine("Skriv in hur många mer tal som du vill mata in: ");
            int runs = int.Parse(Console.ReadLine());

            for (int i = 0; i <= runs; i++)
            {
                Console.WriteLine("Ange nästa tal}");
                int tal = int.Parse(Console.ReadLine());
                n += tal;
            }

            Console.WriteLine("Summan av alla talen är: " + n);
complete list of c# exceptions  https://www.completecsharptutorial.com/basic/complete-system-exception.php
                System Exception
                Exception 	Condition
                AccessViolationException 	It is thrown when try to read or write protected memory.
                AggregateException 	Represents one or more errors that occur during application execution.
                AppDomainUnloadedException 	It is thrown when try to access an unloaded application domain.
                ApplicationException 	It is base class for application-defined exceptions.
                ArgumentException 	It is thrown when invalid argument provided to a method.
                ArgumentNullException 	It is thrown when a method requires argument but no argument is provided.
                ArgumentOutOfRangeException 	It is thrown when value of an argument is outside the allowable range.
                ArithmeticException 	It is thrown when doing arithmetic, casting, or conversion operation.
                ArrayTypeMismatchException 	It is thrown when try to store an element of the wrong type within an array.
                BadImageFormatException 	It is thrown when file image, dll or exe program is invalid.
                CannotUnloadAppDomainException 	It is thrown when try to unload an application domain fails.
                ContextMarshalException 	The exception that is thrown when an attempt to marshal an object across a context boundary fails.
                 
                DataMisalignedException 	It is thrown thrown when a unit of data is read from or written to an address that is not a multiple of the data size.
                DivideByZeroException 	It is thrown when there is an attempt to divide an integral or decimal value by zero.
                DllNotFoundException 	It is thrown when a DLL specified in a DLL import cannot be found.
                DuplicateWaitObjectException 	The exception that is thrown when an object appears more than once in an array of synchronization objects.
                EntryPointNotFoundException 	The exception that is thrown when an attempt to load a class fails due to the absence of an entry method.
                ExecutionEngineException 	The exception that is thrown when there is an internal error in the execution engine of the common language runtime.
                FieldAccessException 	It is thrown when there is an invalid attempt to access a private or protected field inside a class.
                FormatException 	The exception that is thrown when the format of an argument is invalid, or when a composite format string is not well formed.
                IndexOutOfRangeException 	The exception that is thrown when an attempt is made to access an element of an array or collection with an index that is outside its bounds.
                InsufficientMemoryException 	The exception that is thrown when a check for sufficient available memory fails. This class cannot be inherited.
                InvalidCastException 	The exception that is thrown for invalid casting or explicit conversion.
                InvalidOperationException 	The exception that is thrown when a method call is invalid for the object's current state.
                InvalidProgramException 	The exception that is thrown when a program contains invalid Microsoft intermediate language (MSIL) or metadata.
                InvalidTimeZoneException 	The exception that is thrown when time zone information is invalid.
                MemberAccessException 	The exception that is thrown when an attempt to access a class member fails.
                MethodAccessException 	The exception that is thrown when there is an invalid attempt to access a method, such as accessing a private method from partially trusted code.
                MissingFieldException 	The exception that is thrown when there is an attempt to dynamically access a field that does not exist.
                MissingMemberException 	The exception that is thrown when there is an attempt to dynamically access a class member that does not exist.
                MissingMethodException 	The exception that is thrown when there is an attempt to dynamically access a method that does not exist.
                MulticastNotSupportedException 	The exception that is thrown when there is an attempt to combine two delegates based on the Delegate type instead of the MulticastDelegate type.
                NotCancelableException 	It is thrown when an attempt is made to cancel an operation that is not cancelable.
                NotFiniteNumberException 	The exception that is thrown when a floating-point value is positive infinity, negative infinity, or Not-a-Number (NaN).
                NotImplementedException 	The exception that is thrown when a requested method or operation is not implemented.
                NotSupportedException 	The exception that is thrown when an invoked method is not supported, or when there is an attempt to read, seek, or write to a stream that does not support the invoked functionality.
                NullReferenceException 	The exception that is thrown when there is an attempt to dereference a null object reference.
                ObjectDisposedException 	The exception that is thrown when an operation is performed on a disposed object.
                OperationCanceledException 	The exception that is thrown in a thread upon cancellation of an operation that the thread was executing.
                OutOfMemoryException 	The exception that is thrown when there is not enough memory to continue the execution of a program.
                OverflowException 	The exception that is thrown when an arithmetic, casting, or conversion operation in a checked context results in an overflow.
                PlatformNotSupportedException 	The exception that is thrown when a feature does not run on a particular platform.
                RankException 	The exception that is thrown when an array with the wrong number of dimensions is passed to a method.
                StackOverflowException 	The exception that is thrown when the execution stack overflows because it contains too many nested method calls.
                SystemException 	Serves as the base class for system exceptions namespace.
                TimeoutException 	The exception that is thrown when the time allotted for a process or operation has expired.
                TimeZoneNotFoundException 	The exception that is thrown when a time zone cannot be found.
                TypeAccessException 	The exception that is thrown when a method attempts to use a type that it does not have access to.
                TypeInitializationException 	The exception that is thrown as a wrapper around the exception thrown by the class initializer. This class cannot be inherited.
                TypeLoadException 	The exception that is thrown when type-loading failures occur.
                TypeUnloadedException 	The exception that is thrown when there is an attempt to access an unloaded class.
                UnauthorizedAccessException 	The exception that is thrown when the operating system denies access because of an I/O error or a specific type of security error.
                UriFormatException 	The exception that is thrown when an invalid Uniform Resource Identifier (URI) is detected.

                System.Data Exception
                Exception 	Condition
                ConstraintException 	Represents the exception that is thrown when attempting an action that violates a constraint.
                DataException 	Represents the exception that is thrown when attempting an action that violates a constraint.
                DBConcurrencyException 	Gets or sets the value of the DataRow that generated the DBConcurrencyException.
                DeleteRowInaccessibleException 	Represents the exception that is thrown when an action is tried on a DataRow that has been deleted.
                DuplicateNameException 	Represents the exception that is thrown when a duplicate database object name is encountered during an add operation in a DataSet -related object.
                EvaluateException 	Represents the exception that is thrown when the Expression property of a DataColumn cannot be evaluated.
                InRowChangingEventException 	Represents the exception that is thrown when you call the EndEdit method within the RowChanging event.
                InvalidConstraintException 	Represents the exception that is thrown when incorrectly trying to create or access a relation.
                InvalidExpressionException 	Represents the exception that is thrown when you try to add a DataColumn that contains an invalid Expression to a DataColumnCollection.
                MissingPrimaryKeyException 	Represents the exception that is thrown when you try to access a row in a table that has no primary key.
                NoNullAllowedException 	Represents the exception that is thrown when you try to insert a null value into a column where AllowDBNull is set tofalse.
                OperationAbortedException 	This exception is thrown when an ongoing operation is aborted by the user.
                ReadOnlyException 	Represents the exception that is thrown when you try to change the value of a read-only column.
                RowNotInTableException 	Represents the exception that is thrown when you try to perform an operation on a DataRow that is not in a DataTable.
                StrongTypingException 	The exception that is thrown by a strongly typed DataSet when the user accesses a DBNull value.
                SyntaxErrorException 	Represents the exception that is thrown when the Expression property of a DataColumn contains a syntax error.
                TypedDataSetGeneratorException 	The exception that is thrown when a name conflict occurs while generating a strongly typed DataSet.
                VersionNotFoundException 	Represents the exception that is thrown when you try to return a version of a DataRow that has been deleted.
                 
                System.IO Exception
                Exception 	Condition
                DirectoryNotFoundException 	The exception that is thrown when part of a file or directory cannot be found.
                DriveNotFoundException 	The exception that is thrown when a drive that is referenced by an operation could not be found.
                EndOfStreamException 	An EndOfStreamException exception is thrown when there is an attempt to read past the end of a stream.
                FileFormatException 	The exception that is thrown when an input file or a data stream that is supposed to conform to a certain file format specification is malformed.
                FileLoadException 	The exception that is thrown when a managed assembly is found but cannot be loaded.
                FileNotFoundException 	The exception that is thrown when an attempt to access a file that does not exist on disk fails.
                InternalBufferOverflowException 	The exception thrown when the internal buffer overflows.
                InvalidDataException 	The exception that is thrown when a data stream is in an invalid format.
                IOException 	The exception that is thrown when an I/O error occurs.
                PathTooLongException 	The exception that is thrown when a path or file name is longer than the system-defined maximum length.
                PipeException 	Thrown when an error occurs within a named pipe.

~/Empire/Doks/Comp/lang/clangs/csharp/cheatsh-qref/csharp1.cheatsh.pdf
                Visual C# 2005 Express Edition

                Cheat Sheet : C# Language Basics
                Working With Numbers
                int i = 0;
                // convert from a string
                int i = int.Parse("1");
                // convert froma string and don't throw exceptions
                if (int.TryParse("1", out i)) {}
                i++; // increment by one
                i--; // decrement by one
                i += 10; // add 10
                i -= 10; // subtract 10
                i *= 10; // multiply by 10
                i /= 10; // divide by 10
                i = checked(i*2) // check for overﬂow
                i = unchecked(i*2) // ignore overﬂow

                Dates and Times
                DateTime now = DateTime.Now; // date and time
                DateTime today = DateTime.Today; // just the date
                DateTime tomorrow = today.AddDays(1);
                DateTime yesterday = today.AddDays(-1);
                TimeSpan time = tomorrow - today;
                int days = time.Days;
                int hours = time.Hours;
                int minutes = time.Minutes;
                int seconds = time.Seconds;
                int milliseconds = time.Milliseconds;
                time += new TimeSpan(days, hours, minutes, seconds,
                milliseconds);

                Conditional Logic

                if (i == 0) {}
                if (i <= 10) {} else {}
                switch (i) {
                case 0:
                case 1:
                break;
                case 2:
                break;
                default:
                break;
                }

                Compare Operators
                if (i == 0) // equal
                if (i != 0) // not equal
                if (i <= 0) // less than or equal
                if (i >= 0) // greater than or equal
                if (i > 0) // greater than
                if (i < 0) // less than
                if (o is MyClass) // check type of object
                if (o == null) // check if reference is null

                Loops
                for (int i=0; i<10; i++) {}
                while (i<10) { i++; }
                do { i++; } while (i<10);
                foreach (ListItem item in list.Items) {}

                www.LearnVisualStudio.NET

                Copyright © 2006, LearnVisualStudio.NET

                Define New Types
                struct MyValueType {} // defines a value type
                class MyClass { // defines a reference type
                // fields
                const string constName = "LearnVisualStudio.NET";
                static string staticName = "LearnVisualStudio.NET";
                readonly string readOnlyName;
                string instName;
                // properties
                public string Name
                { // read/write
                get { return instName; }
                set { instName = value; }
                }
                public string ReadOnlyName { get { return instName; } }
                // methods
                public void Print() { Console.WriteLine(instName); }
                public int Add(int a, int b) { return a + b; }
                public static void PrintStatic() {
                Console.WriteLine(staticName); }
                // constructors
                public MyClass() {} // default constructor
                public MyClass(string name)
                {
                readOnlyName = name;
                instName = name;
                }
                }

                Inheritance
                class MyClass : Object {
                // override inherited method
                public override string ToString() {
                // call base class version
                string s = base.ToString();
                return "Hello " + s;
                }
                }

                Working with XML
                using System.Xml;
                using System.IO;
                // Create an XML file
                using (XmlWriter xw = XmlWriter.Create(@"c:\names.xml"))
                {
                xw.WriteRaw("<names>");
                xw.WriteRaw("<name>Bob</name>");
                xw.WriteRaw("<name>David</name>");
                xw.WriteRaw("</names>");
                }
                // Load an XML file
                XmlDocument doc = new XmlDocument();
                doc.Load(@"c:\names.xml");
                foreach (XmlNode node in doc.SelectNodes("//name/text()"))
                {
                Console.WriteLine(node.Value);
                }

                Working With Text
                using System.Text;
                using System.IO;
                string name = "David";
                string hello1 = "Hello " + name;
                string hello2 = string.Format("Hello {0}", name);
                Console.WriteLine("Hello {0}", name);
                StringBuilder sb = new StringBuilder("Hello ");
                sb.AppendLine(name);
                sb.AppendFormat("Goodbye {0}", name);
                Console.WriteLine(sb.ToString());
                // Create a text file
                using (StreamWriter w = File.CreateText(@"c:\names.txt")) {
                w.WriteLine("Bob");
                w.WriteLine("David");
                }

                // Read from a text file

                using (StreamReader r = File.OpenText(@"c:\names.txt")) {
                while (!r.EndOfStream)
                {
                Console.WriteLine(r.ReadLine());
                }
                }
                foreach (string s in File.ReadAllLines(@"c:\names.txt")) {
                Console.WriteLine(s);
                }

                Working With a Database
                using System.Data;
                using System.Data.SqlClient;
                string cs = @"Data Source=.\SQLEXPRESS;" +
                string cs = @"Initial Catalog=NamesDB;" +
                string cs = @"Integrated Security=True;";
                using (SqlConnection con = new SqlConnection(cs)) {
                con.Open();
                string sql = "INSERT INTO Names(Name) VALUES(@Name)";
                // insert a record
                SqlCommand cmd1 = new SqlCommand(sql, con);
                cmd1.Parameters.Add("@Name", SqlDbType.NVarChar, 100);
                cmd1.Parameters["@Name"].Value = "Bob";
                cmd1.ExecuteNonQuery();
                // insert a second record
                cmd1.Parameters["@Name"].Value = "David";
                cmd1.ExecuteNonQuery();
                // read records
                sql = "SELECT * FROM Names";
                SqlCommand cmd2 = new SqlCommand(sql, con);
                using (SqlDataReader r = cmd2.ExecuteReader()) {
                int iName = r.GetOrdinal("Name");
                while (r.Read()) {
                Console.WriteLine(
                r.IsDBNull(iName)?"Null":r.GetString(iName)
                );
                }
                }
                // read a single value
                sql = "SELECT TOP 1 Name FROM Names";
                SqlCommand cmd3 = new SqlCommand(sql, con);
                Console.WriteLine(cmd3.ExecuteScalar());
                }

                
~/Empire/Doks/Comp/lang/clangs/csharp/cheatsh-qref/csharp2.cheatsh.pdf
            C# 4.0 Cheat Sheet

            Dynamic and Object
            In C# 4.0, the dynamic keyword allows you work with objects whose type is only known at run-time. In
            certain cases, it works differently than the general object type.

            C# type aliases

            Operators

            C# alias

            .NET class

            bool

            System.Boolean

            ++x x++ --x x--

            byte

            System.Byte

            Comparison

            == != > >= < <=

            char

            System.Char

            Logical (^ = xor, ! =
            not)

            &|^!

            decimal

            System.Decimal

            Assignment

            = += -= *= /= %= &=
            |= ^=

            double

            System.Double

            float

            System.Single

            int

            System.Int32

            long

            System.Int64

            object

            System.Object

            sbyte

            System.SByte

            short

            System.Int16

            string

            System.String

            uint

            System.UInt32

            ulong

            System.UInt64

            ushort

            System.UInt16

            Basic (~ = bit complement)

            + - * / %~

            Increment/decrement

            Conditional AND &
            OR

            && ||

            Shifting

            >> >>= << <<=

            Type testing

            is as

            Conditional ?:

            x == 5 ? true : false

            Null coalescing ??
            (nullable type testing)

            int? x = 5;
            int y = x + 1 ?? -1

            Lambda

            =>

            Data types (all value types unless specified)
            Signed integral types

            Unsigned integral
            types

            sbyte (8 bits, -128..127)
            short (16 bits)
            int (32 bits)
            long (64 bits)
            byte (8 bits, 0..255)
            ushort (16 bits)
            uint (32 bits, nonCLS)
            ulong (64 bits)

            Operation

            Example

            Notes

            Definitions 1:

            dynamic d = 123;
            object o = 123;

            assignment to a type

            Types at runtime

            MessageBox.Show(d.GetType().FullName);
            MessageBox.Show(o.GetType().FullName);

            returns System.Int32
            returns System.Int32

            Working with types

            int i = d + 10;
            int i = (int)o + 10;

            must cast to an int

            Definitions 2:

            private void Test(int param)
            {
            MessageBox.Show(param.ToString());
            }

            Passing as parameters

            Test(d);
            Test((int)o);

            must cast to an int

            Calling methods, compiletime behaviour

            d.MyMethod();
            o.MyMethod();

            compiles
            fails at compile-time

            Calling methods, run-time
            behaviour

            d.MyMethod();
            o.MyMethod();

            runtime exception
            n/a

            Regular Expressions

            Formatting strings

            Class used

            System.Text.RegularExpressions.Regex (in
            System.dll)

            Format string

            Example

            Result

            Definitions for numeric values:

            double d = 123.45;
            int i = 123;

            Culture: "en-US"

            Test if input string
            matches

            string input = "ABC123";
            string pattern = "[A-Z]{3}\d{3}";
            Regex.IsMatch(input, pattern); // match

            c or C (currency)

            string.Format("{0:c}", d);
            string.Format("{0:c}", i));

            $123.45
            $123.00

            Replace unwanted
            characters

            d or D (decimal; optional precision can be given as in "d8")

            string.Format("{0:d8}", d);
            string.Format("{0:d8}", i));

            (not valid for floats)
            00000123

            string input = " 329A 83";
            string invalid = "[^0-9]";
            string safe = Regex.Replace(
            input, invalid, ""); // safe becomes "32983"

            Common character
            escapes

            \t Tab (\u0009)
            \r Carriage return (\u000D)
            \n New line (\u000A)
            \x4F ASCII character code in hex
            \u0020 Unicode character code in hex

            Common character
            classes

            [aeiou] vowels
            [^aeiou] non-vowels
            [a-z]
            character range
            .
            period, matches any character
            \d
            decimal digits
            \w
            word characters
            \W
            non-word characters

            Common quantifiers

            +
            *
            ?
            {n}
            {n,}
            {n,m}

            e or E (scientific [exponential]) string.Format("{0:e}", d);
            string.Format("{0:e}", i));

            1.234500e+002
            1.230000e+002

            f or F (fixed-point; optional
            precision can be given as in
            "f1")

            string.Format("{0:f1}", d);
            string.Format("{0:f1}", i));

            123.5
            123.0

            g or G (general; optional preci- string.Format("{0:g}", d);
            sion can be given as in "g5")
            string.Format("{0:g}", i));

            123.45
            123

            n or N (number)

            string.Format("{0:n}", d);
            string.Format("{0:n}", i));

            123.45
            123.00

            x or X (hexadecimal; x = lowercase, X = uppercase)

            "string.Format("{0:x}", d);
            string.Format("{0:x}", i));
            string.Format("{0:X}", i));

            (not valid for floats)
            7b
            7B

            Floating-point types
            (IEEE)

            float (32 bits)
            double (64 bits)

            High-precision

            decimal (128 bits)

            Real value literals
            (default = double;
            lowercase or uppercase
            OK)

            float f = 123.45f;
            double d = 123.45d;
            decimal m = 123.45m;

            Overflow checking
            (default is on)

            z = checked(x+y);
            z = unchecked(x+y);

            Boolean

            bool

            Character and strings

            char string

            Structure

            struct

            Enumeration

            enum

            Miscellaneous

            Reference types

            class, interface, delegate, object, string

            Verbatim strings with the @
            character

            string path = "C:\\Path\\File.txt"";
            string path = @"C:\Path\File.txt";

            one or more occurrences
            zero or more occurrences
            zero or one occurrence
            exactly n occurrences
            at least n occurrences
            n to m occurrences

            C# 4.0 Cheat Sheet version 1.0 by
            Jani Järvinen <janij@dystopia.fi>
            Copyright © Internet.com 2010.

            Operator Precedence
            C# operators have equal precedence within a group.
            Operator group

            Operator examples

            Primary

            x.y // member access
            x(y) // method access
            x++ // post increment
            typeof(x) // type retrieval
            new X() // object creation

            Unary

            +x -x !x ~x ++x

            Multiplicative

            x*y x/y x%y

            Additive

            x+y x-y

            Shift

            x<<y x>>y

            Relational and type
            testing

            x<y x>y
            x is y
            x as y

            Equality

            x==y x!=y

            Logical AND

            x&y

            Logical XOR

            x^y

            Logical OR

            x|y

            Conditional AND

            x && y

            Conditional OR

            x || y

            Null coalescing

            x ?? y

            Conditional

            x?y:z

            Assignment or
            anonymous function

            x=y
            x += y
            x *= y
            x => y // lambda

            Language Keywords
            The following keywords have been defined for the C# language. An identifier can have the name of a keyword if it is prefixed with the @ sign: @readonly.

            Character Sets and Conversions
            Available encoding classes in
            the System.Text
            namespace

            ASCIIEncoding
            UTF7Encoding
            UTF8Encoding
            UnicodeEncoding
            UTF32Encoding

            Group

            Words

            Code pages

            Keywords

            abstract as base bool break byte case catch char checked class
            const continue decimal default delegate do double else enum event
            explicit extern false finally fixed float for foreach goto if implicit
            in int interface internal is lock long namespace new null object
            operator out override params private protected public readonly ref
            return sbyte sealed short sizeof stackalloc static string struct switch
            this throw true try typeof uint ulong unchecked unsafe ushort using
            virtual void volatile while

            UTF-7 = code page 65000
            UTF-8 = 65001
            Unicode, little endian = 1200
            Unicode, big endian = 1201
            UTF-32, little endian = 65005
            UTF-32, big endian = 65006

            Accessing
            Encoding class
            instances

            using System.Text;
            ...
            Encoding.ASCII
            Encoding.UTF7
            Encoding.UTF8
            Encoding.Unicode
            Encoding.UTF32

            Getting the bytes
            from a string in
            selected encoding

            string s =
            "Some data: åäö-αβγδ";
            byte[] bytes1 =
            Encoding.UTF8.GetBytes(s);
            byte[] bytes2 =
            Encoding.UTF32.GetBytes(s);
            ...

            Convert a byte
            array to a string
            based on a certain encoding

            byte[] bytes = ...;
            string s =
            Encoding.UTF7.GetString(
            bytes);

            Get BOM (Byte
            Order Mark) or
            preamble for a
            given encoding

            byte[] bom1 = Encoding.
            UTF8.GetPreamble();
            byte[] bom2 = Encoding.
            UTF32.GetPreamble();

            Contextual keywords

            get set var

            Explicit Conversions requiring Type Cast
            From

            To

            sbyte

            byte, ushort, uint, ulong, or char

            byte

            sbyte and char

            short

            sbyte, byte, ushort, uint, ulong, or char

            ushort

            sbyte, byte, short, or char

            int

            sbyte, byte, short, ushort, uint, ulong, or char

            uint

            sbyte, byte, short, ushort, int, or char

            long

            sbyte, byte, short, ushort, int, uint, ulong, or char

            ulong

            sbyte, byte, short, ushort, int, uint, long, or char

            char

            sbyte, byte, or short

            Pre-processing Directives

            float

            sbyte, byte, short, ushort, int, uint, long, ulong, char, or decimal

            Declaration directives

                #define symbol
                #undef symbol

            double

            sbyte, byte, short, ushort, int, uint, long, ulong, char, float, or decimal

            decimal

            sbyte, byte, short, ushort, int, uint, long, ulong, char, float, or double

            Conditional compilation directives

                #if
                #else
                #elif
                #endif

            Enumeration type

            sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, or decimal
            Any enumeration type

            Source code line
            directives

                #line number "filename"
                #line default
                #line hidden

            sbyte, byte, short,
            ushort, int, uint, long,
            ulong, char, float,
            double, or decimal

            Any reference type

            Diagnostic directives

                #warning
                #error

            Object (class instance)
            or dynamic
            Class T1

            Class T2, if T2 descends from T1

            Region directives

                #region
                #endregion

            Class T1

            Interface I2, if T1 is not sealed and T1 does not implement I2

            Pragma directives

                #pragma warning
                #pragma warning no(s)
                #pragma warning disable
                #pragma warning restore

            LINQ to Entities Inner Join
            Inner Join Query

            var innerJoinQuery = from category in categories
            join prod in products on category.ID equals prod.CategoryID
            select new { ProductName = prod.Name, Category = category.Name };

            Strings and Readers
            Convert string
            to a TextReader
            by using a
            StringReader
            (StringReader
            descends from
            the TextReader
            abstract class)

            using System.IO;
            ...
            string s = "ABCD...";
            StringReader reader =
            new StringReader(s);

            Read contents
            of a file into a
            string

            using System.IO;
            string filename =
            @"C:\Path\File.dat";
            string data =
            File.ReadAllText(filename);

            // example use:
            using System.Xml.XPath;
            ...
            XPathDocument doc =
            new XPathDocument(reader);

            
~/Empire/Doks/Comp/lang/clangs/csharp/cheatsh-qref/csh-commands.list.pdf
            Contents
            C# Keywords
            Types
            Value Types
            bool
            byte
            char
            decimal
            double
            enum
            float
            int
            long
            sbyte
            short
            struct
            uint
            ulong
            ushort
            Reference Types
            class
            delegate
            dynamic
            interface
            object
            string
            void
            var
            Reference tables for types
            Built-in types table

            Integral types table
            Floating-point types table
            Value types table
            Default values table
            Implicit numeric conversions table
            Explicit numeric conversions table
            Formatting numeric results table
            Modifiers
            Access Modifiers
            Accessibility Levels
            Accessibility Domain
            Restrictions on Using Accessibility Levels
            internal
            private
            protected
            public
            protected internal
            private protected
            abstract
            async
            const
            event
            extern
            in (Generic Modifier)
            out (Generic Modifier)
            override
            readonly
            sealed
            static
            unsafe
            virtual
            volatile

            Statement Keywords
            Selection Statements
            if-else
            switch
            Iteration Statements
            do
            for
            foreach, in
            while
            Jump Statements
            break
            continue
            goto
            return
            Exception Handling Statements
            throw
            try-catch
            try-finally
            try-catch-finally
            Checked and Unchecked
            checked
            unchecked
            fixed Statement
            lock Statement
            Method Parameters
            params
            in (Parameter Modifier)
            ref
            out (Parameter Modifier)
            Namespace Keywords
            namespace
            using

            using Directive
            using static Directive
            using Statement
            extern alias
            Operator Keywords
            as
            await
            is
            new
            new Operator
            new Modifier
            new Constraint
            sizeof
            typeof
            true
            true Operator
            true Literal
            false
            false Operator
            false Literal
            stackalloc
            nameof
            Conversion Keywords
            explicit
            implicit
            operator
            Access Keywords
            base
            this
            Literal Keywords
            null
            default

            Contextual Keywords
            add
            get
            global
            partial (Type)
            partial (Method)
            remove
            set
            when (filter condition)
            where (generic type constraint)
            value
            yield
            Query Keywords
            from clause
            where clause
            select clause
            group clause
            into
            orderby clause
            join clause
            let clause
            ascending
            descending
            on
            equals
            by
            in

            C# Keywords
            9/5/2018 • 2 minutes to read • Edit Online

            Keywords are predefined, reserved identifiers that have special meanings to the compiler. They
            cannot be used as identifiers in your program unless they include @ as a prefix. For example, @if
            is a valid identifier, but if is not because if is a keyword.
            The first table in this topic lists keywords that are reserved identifiers in any part of a C# program.
            The second table in this topic lists the contextual keywords in C#. Contextual keywords have special
            meaning only in a limited program context and can be used as identifiers outside that context.
            Generally, as new keywords are added to the C# language, they are added as contextual keywords
            in order to avoid breaking programs written in earlier versions.

            abstract

            as

            base

            bool

            break

            byte

            case

            catch

            char

            checked

            class

            const

            continue

            decimal

            default

            delegate

            do

            double

            else

            enum

            event

            explicit

            extern

            false

            finally

            fixed

            float

            for

            foreach

            goto

            if

            implicit

            in

            int

            interface

            internal

            is

            lock

            long

            namespace

            new

            null

            object

            operator

            out

            override

            params

            private

            protected

            public

            readonly

            ref

            return

            sbyte

            sealed

            short

            sizeof

            stackalloc

            static

            string

            struct

            switch

            this

            throw

            true

            try

            typeof

            uint

            ulong

            unchecked

            unsafe

            ushort

            using

            using static

            volatile

            while

            virtual

            void

            Contextual Keywords
            A contextual keyword is used to provide a specific meaning in the code, but it is not a reserved
            word in C#. Some contextual keywords, such as partial and where , have special meanings in two
            or more contexts.

            add

            alias

            ascending

            async

            await

            by

            descending

            dynamic

            equals

            from

            get

            global

            group

            into

            join

            let

            nameof

            on

            orderby

            partial (type)

            partial (method)

            remove

            select

            set

            value

            var

            when (filter condition)

            where (generic type constraint)

            where (query clause)

            yield

            See Also
            C# Reference
            C# Programming Guide

            Types (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The C# typing system contains the following categories:
            Value types
            Reference types
            Pointer types
            Variables that are value types store data, and those that are reference types store references to the actual data.
            Instances of reference types are also referred to as objects. Pointer types can be used only in unsafe mode.
            It's possible to convert a value type to a reference type, and back again to a value type, by using boxing and
            unboxing. With the exception of a boxed value type, you cannot convert a reference type to a value type.
            This section also introduces void.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Reference Tables for Types
            Casting and Type Conversions
            Types

            Value types (C# Reference)
            12/19/2018 • 2 minutes to read • Edit Online

            There are two kinds of value types:
            Structs
            Enumerations

            Main features of value types
            A variable of a value type contains a value of the type. For example, a variable of the int type might contain the
            value 42 . This differs from a variable of a reference type, which contains a reference to an instance of the type,
            also known as an object. When you assign a new value to a variable of a value type, that value is copied. When
            you assign a new value to a variable of a reference type, the reference is copied, not the object itself.
            All value types are derived implicitly from the System.ValueType.
            Unlike with reference types, you cannot derive a new type from a value type. However, like reference types,
            structs can implement interfaces.
            Value type variables cannot be null by default. However, variables of the corresponding nullable types can be
            null .
            Each value type has an implicit default constructor that initializes the default value of that type. For information
            about default values of value types, see Default values table.

            Simple types
            The simple types are a set of predefined struct types provided by C# and comprise the following types:
            Integral types: integer numeric types and the char type
            Floating-point types
            bool
            The simple types are identified through keywords, but these keywords are simply aliases for predefined struct
            types in the System namespace. For example, int is an alias of System.Int32. For a complete list of aliases, see
            Built-in types table.
            The simple types differ from other struct types in that they permit certain additional operations:
            Simple types can be initialized by using literals. For example, 'A' is a literal of the type char and 2001 is
            a literal of the type int .
            You can declare constants of the simple types with the const keyword. It's not possible to have constants of
            other struct types.
            Constant expressions, whose operands are all simple type constants, are evaluated at compile time.
            For more information, see the Simple types section of the C# language specification.

            Initializing value types
            Local variables in C# must be initialized before they are used. For example, you might declare a local variable

            without initialization as in the following example:
            int myInt;

            You cannot use it before you initialize it. You can initialize it using the following statement:
            myInt = new int(); // Invoke default constructor for int type.

            This statement is equivalent to the following statement:
            myInt = 0;

            // Assign an initial value, 0 in this example.

            You can, of course, have the declaration and the initialization in the same statement as in the following examples:
            int myInt = new int();

            –or–
            int myInt = 0;

            Using the new operator calls the default constructor of the specific type and assigns the default value to the
            variable. In the preceding example, the default constructor assigned the value 0 to myInt . For more information
            about values assigned by calling default constructors, see Default values table.
            With user-defined types, use new to invoke the default constructor. For example, the following statement invokes
            the default constructor of the Point struct:
            Point p = new Point(); // Invoke default constructor for the struct.

            After this call, the struct is considered to be definitely assigned; that is, all its members are initialized to their
            default values.
            For more information about the new operator, see new.
            For information about formatting the output of numeric types, see Formatting numeric results table.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Types
            Reference tables for types
            Reference Types
            Nullable types

            bool (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The bool keyword is an alias of System.Boolean. It is used to declare variables to store the Boolean values: true
            and false.
            NOTE
            If you require a Boolean variable that can also have a value of null , use bool? . For more information, see The bool?
            type section of the Using nullable types article.

            Literals
            You can assign a Boolean value to a bool variable. You can also assign an expression that evaluates to bool to
            a bool variable.
            public class BoolTest
            {
            static void Main()
            {
            bool b = true;
            // WriteLine automatically converts the value of b to text.
            Console.WriteLine(b);
            int days = DateTime.Now.DayOfYear;

            // Assign the result of a boolean expression to b.
            b = (days % 2 == 0);
            // Branch depending on whether b is true or false.
            if (b)
            {
            Console.WriteLine("days is an even number");
            }
            else
            {
            Console.WriteLine("days is an odd number");
            }
            }
            }
            /* Output:
            True
            days is an <even/odd> number
            */

            The default value of a bool variable is false . The default value of a bool? variable is null .

            Conversions
            In C++, a value of type bool can be converted to a value of type int ; in other words, false is equivalent to
            zero and true is equivalent to nonzero values. In C#, there is no conversion between the bool type and other
            types. For example, the following if statement is invalid in C#:

            int x = 123;
            // if (x) // Error: "Cannot implicitly convert type 'int' to 'bool'"
            {
            Console.Write("The value of x is nonzero.");
            }

            To test a variable of the type int , you have to explicitly compare it to a value, such as zero, as follows:

            if (x != 0) // The C# way
            {
            Console.Write("The value of x is nonzero.");
            }

            Example
            In this example, you enter a character from the keyboard and the program checks if the input character is a letter.
            If it is a letter, it checks if it is lowercase or uppercase. These checks are performed with the IsLetter, and IsLower,
            both of which return the bool type:
            public class BoolKeyTest
            {
            static void Main()
            {
            Console.Write("Enter a character: ");
            char c = (char)Console.Read();
            if (Char.IsLetter(c))
            {
            if (Char.IsLower(c))
            {
            Console.WriteLine("The character is lowercase.");
            }
            else
            {
            Console.WriteLine("The character is uppercase.");
            }
            }
            else
            {
            Console.WriteLine("Not an alphabetic character.");
            }
            }
            }
            /* Sample Output:
            Enter a character: X
            The character is uppercase.
            Enter a character: x
            The character is lowercase.
            Enter a character: 2
            The character is not an alphabetic character.
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Integral Types Table
            Built-In Types Table
            Implicit Numeric Conversions Table
            Explicit Numeric Conversions Table

            byte (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            byte denotes an integral type that stores values as indicated in the following table.
            TYPE

            RANGE

            SIZE

            .NET TYPE

            byte

            0 to 255

            Unsigned 8-bit integer

            System.Byte

            Literals
            You can declare and initialize a byte variable by assigning a decimal literal, a hexadecimal literal, or (starting
            with C# 7.0) a binary literal to it. If the integer literal is outside the range of byte (that is, if it is less than
            Byte.MinValue or greater than Byte.MaxValue), a compilation error occurs.
            In the following example, integers equal to 201 that are represented as decimal, hexadecimal, and binary literals
            are implicitly converted from int to byte values.
            byte byteValue1 = 201;
            Console.WriteLine(byteValue1);
            byte byteValue2 = 0x00C9;
            Console.WriteLine(byteValue2);
            byte byteValue3 = 0b1100_1001;
            Console.WriteLine(byteValue3);
            // The example displays the following output:
            //
            201
            //
            201
            //
            201

            NOTE
            You use the prefix 0x or 0X to denote a hexadecimal literal and the prefix 0b or 0B to denote a binary literal. Decimal
            literals have no prefix.

            Starting with C# 7.0, a couple of features have been added to enhance readability.
            C# 7.0 allows the usage of the underscore character, _ , as a digit separator.
            C# 7.2 allows _ to be used as a digit separator for a binary or hexadecimal literal, after the prefix. A decimal
            literal isn't permitted to have a leading underscore.
            Some examples are shown below.

            byte byteValue4 = 0b1100_1001;
            Console.WriteLine(byteValue4);
            byte byteValue5 = 0b_1100_1001;
            Console.WriteLine(byteValue5);
            // C# 7.2 onwards
            // The example displays the following output:
            //
            201
            //
            201

            Conversions
            There is a predefined implicit conversion from byte to short, ushort, int, uint, long, ulong, float, double, or
            decimal.
            You cannot implicitly convert non-literal numeric types of larger storage size to byte . For more information on
            the storage sizes of integral types, see Integral Types Table. Consider, for example, the following two byte
            variables x and y :
            byte x = 10, y = 20;

            The following assignment statement will produce a compilation error, because the arithmetic expression on the
            right-hand side of the assignment operator evaluates to int by default.
            // Error: conversion from int to byte:
            byte z = x + y;

            To fix this problem, use a cast:
            // OK: explicit conversion:
            byte z = (byte)(x + y);

            It is possible though, to use the following statements where the destination variable has the same storage size or
            a larger storage size:
            int x = 10, y = 20;
            int m = x + y;
            long n = x + y;

            Also, there is no implicit conversion from floating-point types to byte . For example, the following statement
            generates a compiler error unless an explicit cast is used:
            // Error: no implicit conversion from double:
            byte x = 3.0;
            // OK: explicit conversion:
            byte y = (byte)3.0;

            When calling overloaded methods, a cast must be used. Consider, for example, the following overloaded
            methods that use byte and int parameters:
            public static void SampleMethod(int i) {}
            public static void SampleMethod(byte b) {}

            Using the byte cast guarantees that the correct type is called, for example:
            // Calling the method with the int parameter:
            SampleMethod(5);
            // Calling the method with the byte parameter:
            SampleMethod((byte)5);

            For information on arithmetic expressions with mixed floating-point types and integral types, see float and
            double.
            For more information on implicit numeric conversion rules, see the Implicit Numeric Conversions Table.

            C# Language Specification
            For more information, see Integral types in the C# Language Specification. The language specification is the
            definitive source for C# syntax and usage.

            See Also
            Byte
            C# Reference
            C# Programming Guide
            C# Keywords
            Integral Types Table
            Built-In Types Table
            Implicit Numeric Conversions Table
            Explicit Numeric Conversions Table

            char (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The char keyword is used to declare an instance of the System.Char structure that the .NET Framework uses to
            represent a Unicode character. The value of a Char object is a 16-bit numeric (ordinal) value.
            Unicode characters are used to represent most of the written languages throughout the world.
            TYPE

            RANGE

            SIZE

            .NET TYPE

            char

            U+0000 to U+FFFF

            Unicode 16-bit character

            System.Char

            Literals
            Constants of the char type can be written as character literals, hexadecimal escape sequence, or Unicode
            representation. You can also cast the integral character codes. In the following example four char variables are
            initialized with the same character X :
            char[] chars = new char[4];
            chars[0] = 'X';
            chars[1] = '\x0058';
            chars[2] = (char)88;
            chars[3] = '\u0058';

            // Character literal
            // Hexadecimal
            // Cast from integral type
            // Unicode

            foreach (char c in chars)
            {
            Console.Write(c + " ");
            }
            // Output: X X X X

            Conversions
            A char can be implicitly converted to ushort, int, uint, long, ulong, float, double, or decimal. However, there are
            no implicit conversions from other types to the char type.
            The System.Char type provides several static methods for working with char values.

            C# language specification
            For more information, see Integral types in the C# Language Specification. The language specification is the
            definitive source for C# syntax and usage.

            See also
            Char
            C# Reference
            C# Programming Guide
            C# Keywords
            Integral Types Table

            Built-In Types Table
            Implicit Numeric Conversions Table
            Explicit Numeric Conversions Table
            Nullable Types
            Strings

            decimal (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The decimal keyword indicates a 128-bit data type. Compared to other floating-point types, the decimal type
            has more precision and a smaller range, which makes it appropriate for financial and monetary calculations. The
            approximate range and precision for the decimal type are shown in the following table.
            TYPE

            APPROXIMATE RANGE

            PRECISION

            .NET TYPE

            decimal

            ±1.0 x 10-28 to ±7.9228 x
            1028

            28-29 significant digits

            System.Decimal

            The default value of a decimal is 0m.

            Literals
            If you want a numeric real literal to be treated as decimal , use the suffix m or M, for example:
            decimal myMoney = 300.5m;

            Without the suffix m, the number is treated as a double and generates a compiler error.

            Conversions
            The integral types are implicitly converted to decimal and the result evaluates to decimal . Therefore you can
            initialize a decimal variable using an integer literal, without the suffix, as follows:
            decimal myMoney = 300;

            There is no implicit conversion between other floating-point types and the decimal type; therefore, a cast must
            be used to convert between these two types. For example:
            decimal myMoney = 99.9m;
            double x = (double)myMoney;
            myMoney = (decimal)x;

            You can also mix decimal and numeric integral types in the same expression. However, mixing decimal and
            other floating-point types without a cast causes a compilation error.
            For more information about implicit numeric conversions, see Implicit Numeric Conversions Table.
            For more information about explicit numeric conversions, see Explicit Numeric Conversions Table.

            Formatting decimal output
            You can format the results by using the String.Format method, or through the Console.Write method, which
            calls String.Format() . The currency format is specified by using the standard currency format string "C" or "c,"
            as shown in the second example later in this article. For more information about the String.Format method, see
            String.Format.

            Example
            The following example causes a compiler error by trying to add double and decimal variables.
            decimal dec = 0m;
            double dub = 9;
            // The following line causes an error that reads "Operator '+' cannot be applied to
            // operands of type 'double' and 'decimal'"
            Console.WriteLine(dec + dub);
            // You can fix the error by using explicit casting of either operand.
            Console.WriteLine(dec + (decimal)dub);
            Console.WriteLine((double)dec + dub);

            The result is the following error:
            Operator '+' cannot be applied to operands of type 'double' and 'decimal'

            In this example, a decimal and an int are mixed in the same expression. The result evaluates to the decimal
            type.
            public class TestDecimal
            {
            static void Main()
            {
            decimal d = 9.1m;
            int y = 3;
            Console.WriteLine(d + y);
            }
            }
            // Output: 12.1

            // Result converted to decimal

            Example
            In this example, the output is formatted by using the currency format string. Notice that x is rounded because
            the decimal places exceed $0.99. The variable y , which represents the maximum exact digits, is displayed
            exactly in the correct format.
            public class TestDecimalFormat
            {
            static void Main()
            {
            decimal x = 0.999m;
            decimal y = 9999999999999999999999999999m;
            Console.WriteLine("My amount = {0:C}", x);
            Console.WriteLine("Your amount = {0:C}", y);
            }
            }
            /* Output:
            My amount = $1.00
            Your amount = $9,999,999,999,999,999,999,999,999,999.00
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            Decimal
            C# Reference
            C# Programming Guide
            C# Keywords
            Integral Types Table
            Built-In Types Table
            Implicit Numeric Conversions Table
            Explicit Numeric Conversions Table
            Standard Numeric Format Strings

            double (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The double keyword signifies a simple type that stores 64-bit floating-point values. The following table
            shows the precision and approximate range for the double type.
            TYPE

            APPROXIMATE RANGE

            PRECISION

            .NET TYPE

            double

            ±5.0 × 10− 324 to ±1.7 ×
            10308

            ~15-17 digits

            System.Double

            Literals
            By default, a real numeric literal on the right side of the assignment operator is treated as double . However, if
            you want an integer number to be treated as double , use the suffix d or D, for example:
            double x = 3D;

            Conversions
            You can mix numeric integral types and floating-point types in an expression. In this case, the integral types
            are converted to floating-point types. The evaluation of the expression is performed according to the
            following rules:
            If one of the floating-point types is double , the expression evaluates to double , or to bool in relational
            comparisons and comparisons for equality.
            If there is no double type in the expression, it evaluates to float, or to bool in relational comparisons
            and comparisons for equality.
            A floating-point expression can contain the following sets of values:
            Positive and negative zero.
            Positive and negative infinity.
            Not-a-Number value (NaN ).
            The finite set of nonzero values.
            For more information about these values, see IEEE Standard for Binary Floating-Point Arithmetic, available on
            the IEEE Web site.

            Example
            In the following example, an int, a short, a float, and a double are added together giving a double result.

            // Mixing types in expressions
            class MixedTypes
            {
            static void Main()
            {
            int x = 3;
            float y = 4.5f;
            short z = 5;
            double w = 1.7E+3;
            // Result of the 2nd argument is a double:
            Console.WriteLine("The sum is {0}", x + y + z + w);
            }
            }
            // Output: The sum is 1712.5

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source
            for C# syntax and usage.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            Default Values Table
            Built-In Types Table
            Floating-Point Types Table
            Implicit Numeric Conversions Table
            Explicit Numeric Conversions Table

            enum (C# Reference)
            12/11/2018 • 4 minutes to read • Edit Online

            The enum keyword is used to declare an enumeration, a distinct type that consists of a set of named constants
            called the enumerator list.
            Usually it is best to define an enum directly within a namespace so that all classes in the namespace can access it
            with equal convenience. However, an enum can also be nested within a class or struct.
            By default, the first enumerator has the value 0, and the value of each successive enumerator is increased by 1.
            For example, in the following enumeration, Sat is 0 , Sun is 1 , Mon is 2 , and so forth.
            enum Day {Sat, Sun, Mon, Tue, Wed, Thu, Fri};

            Enumerators can use initializers to override the default values, as shown in the following example.
            enum Day {Sat=1, Sun, Mon, Tue, Wed, Thu, Fri};

            In this enumeration, the sequence of elements is forced to start from 1 instead of 0 . However, including a
            constant that has the value of 0 is recommended. For more information, see Enumeration Types.
            Every enumeration type has an underlying type, which can be any integral type except char. The default
            underlying type of enumeration elements is int. To declare an enum of another integral type, such as byte, use a
            colon after the identifier followed by the type, as shown in the following example.
            enum Day : byte {Sat=1, Sun, Mon, Tue, Wed, Thu, Fri};

            The approved types for an enum are byte, sbyte, short, ushort, int, uint, long, or ulong.
            A variable of an enumeration type can be assigned any value in the range of the underlying type; the values are
            not limited to the named constants.
            The default value of an enum E is the value produced by the expression (E)0 .
            NOTE
            An enumerator cannot contain white space in its name.

            The underlying type specifies how much storage is allocated for each enumerator. However, an explicit cast is
            necessary to convert from enum type to an integral type. For example, the following statement assigns the
            enumerator Sun to a variable of the type int by using a cast to convert from enum to int .
            int x = (int)Day.Sun;

            When you apply System.FlagsAttribute to an enumeration that contains elements that can be combined with a
            bitwise OR operation, the attribute affects the behavior of the enum when it is used with some tools. You can
            notice these changes when you use tools such as the Console class methods and the Expression Evaluator. (See
            the third example.)

            Robust programming
            Just as with any constant, all references to the individual values of an enum are converted to numeric literals at
            compile time. This can create potential versioning issues as described in Constants.
            Assigning additional values to new versions of enums, or changing the values of the enum members in a new
            version, can cause problems for dependent source code. Enum values often are used in switch statements. If
            additional elements have been added to the enum type, the default section of the switch statement can be selected
            unexpectedly.
            If other developers use your code, you should provide guidelines about how their code should react if new
            elements are added to any enum types.

            Example
            In the following example, an enumeration, Day , is declared. Two enumerators are explicitly converted to integer
            and assigned to integer variables.
            public class EnumTest
            {
            enum Day { Sun, Mon, Tue, Wed, Thu, Fri, Sat };
            static void Main()
            {
            int x = (int)Day.Sun;
            int y = (int)Day.Fri;
            Console.WriteLine("Sun = {0}", x);
            Console.WriteLine("Fri = {0}", y);
            }
            }
            /* Output:
            Sun = 0
            Fri = 5
            */

            Example
            In the following example, the base-type option is used to declare an enum whose members are of type long .
            Notice that even though the underlying type of the enumeration is long , the enumeration members still must be
            explicitly converted to type long by using a cast.
            public class EnumTest2
            {
            enum Range : long { Max = 2147483648L, Min = 255L };
            static void Main()
            {
            long x = (long)Range.Max;
            long y = (long)Range.Min;
            Console.WriteLine("Max = {0}", x);
            Console.WriteLine("Min = {0}", y);
            }
            }
            /* Output:
            Max = 2147483648
            Min = 255
            */

            Example

            The following code example illustrates the use and effect of the System.FlagsAttribute attribute on an enum
            declaration.
            // Add the attribute Flags or FlagsAttribute.
            [Flags]
            public enum CarOptions
            {
            // The flag for SunRoof is 0001.
            SunRoof = 0x01,
            // The flag for Spoiler is 0010.
            Spoiler = 0x02,
            // The flag for FogLights is 0100.
            FogLights = 0x04,
            // The flag for TintedWindows is 1000.
            TintedWindows = 0x08,
            }
            class FlagTest
            {
            static void Main()
            {
            // The bitwise OR of 0001 and 0100 is 0101.
            CarOptions options = CarOptions.SunRoof | CarOptions.FogLights;
            // Because the Flags attribute is specified, Console.WriteLine displays
            // the name of each enum element that corresponds to a flag that has
            // the value 1 in variable options.
            Console.WriteLine(options);
            // The integer value of 0101 is 5.
            Console.WriteLine((int)options);
            }
            }
            /* Output:
            SunRoof, FogLights
            5
            */

            Comments
            If you remove Flags , the example displays the following values:
            5
            5

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            Enumeration Types
            C# Keywords
            Integral Types Table
            Built-In Types Table
            Implicit Numeric Conversions Table
            Explicit Numeric Conversions Table

            Enum Naming Conventions

            float (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The float keyword signifies a simple type that stores 32-bit floating-point values. The following table shows
            the precision and approximate range for the float type.
            TYPE

            APPROXIMATE RANGE

            PRECISION

            .NET TYPE

            float

            ±1.5 x 10− 45 to ±3.4 x
            1038

            ~6-9 digits

            System.Single

            Literals
            By default, a real numeric literal on the right side of the assignment operator is treated as double. Therefore, to
            initialize a float variable, use the suffix f or F , as in the following example:
            float x = 3.5F;

            If you do not use the suffix in the previous declaration, you will get a compilation error because you are trying
            to store a double value into a float variable.

            Conversions
            You can mix numeric integral types and floating-point types in an expression. In this case, the integral types are
            converted to floating-point types. The evaluation of the expression is performed according to the following
            rules:
            If one of the floating-point types is double, the expression evaluates to double, or to bool in relational
            comparisons or comparisons for equality.
            If there is no double type in the expression, the expression evaluates to float , or to bool in relational
            comparisons or comparisons for equality.
            A floating-point expression can contain the following sets of values:
            Positive and negative zero
            Positive and negative infinity
            Not-a-Number value (NaN )
            The finite set of nonzero values
            For more information about these values, see IEEE Standard for Binary Floating-Point Arithmetic, available on
            the IEEE website.

            Example
            In the following example, an int, a short, and a float are included in a mathematical expression giving a
            float result. ( Remember that float is an alias for the System.Single type.) Notice that there is no double in
            the expression.

            class FloatTest
            {
            static void Main()
            {
            int x = 3;
            float y = 4.5f;
            short z = 5;
            var result = x * y / z;
            Console.WriteLine("The result is {0}", result);
            Type type = result.GetType();
            Console.WriteLine("result is of type {0}", type.ToString());
            }
            }
            /* Output:
            The result is 2.7
            result is of type System.Single //'float' is alias for 'Single'
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source
            for C# syntax and usage.

            See also
            Single
            C# Reference
            C# Programming Guide
            Casting and Type Conversions
            C# Keywords
            Integral Types Table
            Built-In Types Table
            Implicit Numeric Conversions Table
            Explicit Numeric Conversions Table

            int (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            int denotes an integral type that stores values according to the size and range shown in the following

            table.
            TYPE

            RANGE

            SIZE

            .NET TYPE

            int

            -2,147,483,648 to
            2,147,483,647

            Signed 32-bit integer

            System.Int32

            Literals
            You can declare and initialize an int variable by assigning a decimal literal, a hexadecimal literal, or
            (starting with C# 7.0) a binary literal to it. If the integer literal is outside the range of int (that is, if it is less
            than Int32.MinValue or greater than Int32.MaxValue), a compilation error occurs.
            In the following example, integers equal to 90,946 that are represented as decimal, hexadecimal, and binary
            literals are assigned to int values.
            int intValue1 = 90946;
            Console.WriteLine(intValue1);
            int intValue2 = 0x16342;
            Console.WriteLine(intValue2);
            int intValue3 = 0b0001_0110_0011_0100_0010;
            Console.WriteLine(intValue3);
            // The example displays the following output:
            //
            90946
            //
            90946
            //
            90946

            NOTE
            You use the prefix 0x or 0X to denote a hexadecimal literal and the prefix 0b or 0B to denote a binary literal.
            Decimal literals have no prefix.

            Starting with C# 7.0, a couple of features have been added to enhance readability.
            C# 7.0 allows the usage of the underscore character, _ , as a digit separator.
            C# 7.2 allows _ to be used as a digit separator for a binary or hexadecimal literal, after the prefix. A
            decimal literal isn't permitted to have a leading underscore.
            Some examples are shown below.

            int intValue1 = 90_946;
            Console.WriteLine(intValue1);
            int intValue2 = 0x0001_6342;
            Console.WriteLine(intValue2);
            int intValue3 = 0b0001_0110_0011_0100_0010;
            Console.WriteLine(intValue3);
            int intValue4 = 0x_0001_6342;
            Console.WriteLine(intValue4);

            // C# 7.2 onwards

            int intValue5 = 0b_0001_0110_0011_0100_0010;
            Console.WriteLine(intValue5);
            // The example displays the following output:
            //
            90946
            //
            90946
            //
            90946
            //
            90946
            //
            90946

            // C# 7.2 onwards

            Integer literals can also include a suffix that denotes the type, although there is no suffix that denotes the
            int type. If an integer literal has no suffix, its type is the first of the following types in which its value can be
            represented:
            1. int
            2. uint
            3. long
            4. ulong
            In these examples, the literal 90946 is of type int .

            Conversions
            There is a predefined implicit conversion from int to long, float, double, or decimal. For example:
            // '123' is an int, so an implicit conversion takes place here:
            float f = 123;

            There is a predefined implicit conversion from sbyte, byte, short, ushort, or char to int . For example, the
            following assignment statement will produce a compilation error without a cast:
            long aLong = 22;
            int i1 = aLong;
            // Error: no implicit conversion from long.
            int i2 = (int)aLong; // OK: explicit conversion.

            Notice also that there is no implicit conversion from floating-point types to int . For example, the following
            statement generates a compiler error unless an explicit cast is used:
            int x = 3.0;
            int y = (int)3.0;

            // Error: no implicit conversion from double.
            // OK: explicit conversion.

            For more information on arithmetic expressions with mixed floating-point types and integral types, see float
            and double.

            C# Language Specification
            For more information, see Integral types in the C# Language Specification. The language specification is the
            definitive source for C# syntax and usage.

            See Also
            Int32
            C# Reference
            C# Programming Guide
            C# Keywords
            Integral Types Table
            Built-In Types Table
            Implicit Numeric Conversions Table
            Explicit Numeric Conversions Table

            long (C# Reference)
            12/11/2018 • 3 minutes to read • Edit Online

            long denotes an integral type that stores values according to the size and range shown in the following table.
            TYPE

            RANGE

            SIZE

            .NET TYPE

            long

            9,223,372,036,854,775,808
            to
            9,223,372,036,854,775,807

            Signed 64-bit integer

            System.Int64

            Literals
            You can declare and initialize a long variable by assigning a decimal literal, a hexadecimal literal, or (starting
            with C# 7.0) a binary literal to it.
            In the following example, integers equal to 4,294,967,296 that are represented as decimal, hexadecimal, and
            binary literals are assigned to long values.
            long longValue1 = 4294967296;
            Console.WriteLine(longValue1);
            long longValue2 = 0x100000000;
            Console.WriteLine(longValue2);
            long longValue3 = 0b1_0000_0000_0000_0000_0000_0000_0000_0000;
            Console.WriteLine(longValue3);
            // The example displays the following output:
            //
            4294967296
            //
            4294967296
            //
            4294967296

            NOTE
            You use the prefix 0x or 0X to denote a hexadecimal literal and the prefix 0b or 0B to denote a binary literal.
            Decimal literals have no prefix.

            Starting with C# 7.0, a couple of features have been added to enhance readability.
            C# 7.0 allows the usage of the underscore character, _ , as a digit separator.
            C# 7.2 allows _ to be used as a digit separator for a binary or hexadecimal literal, after the prefix. A decimal
            literal isn't permitted to have a leading underscore.
            Some examples are shown below.

            long longValue1 = 4_294_967_296;
            Console.WriteLine(longValue1);
            long longValue2 = 0x1_0000_0000;
            Console.WriteLine(longValue2);
            long longValue3 = 0b1_0000_0000_0000_0000_0000_0000_0000_0000;
            Console.WriteLine(longValue3);
            long longValue4 = 0x_1_0000_0000;
            Console.WriteLine(longValue4);

            // C# 7.2 onwards

            long longValue5 = 0b_1_0000_0000_0000_0000_0000_0000_0000_0000;
            Console.WriteLine(longValue5);
            // The example displays the following output:
            //
            4294967296
            //
            4294967296
            //
            4294967296
            //
            4294967296
            //
            4294967296

            // C# 7.2 onwards

            Integer literals can also include a suffix that denotes the type. The suffix L denotes a long . The following
            example uses the L suffix to denote a long integer:
            long value = 4294967296L;

            NOTE
            You can also use the lowercase letter "l" as a suffix. However, this generates a compiler warning because the letter "l" is
            easily confused with the digit "1." Use "L" for clarity.

            When you use the suffix L , the type of the literal integer is determined to be either long or ulong, depending
            on its size. In this case, it is long because it less than the range of ulong.
            A common use of the suffix is to call overloaded methods. For example, the following overloaded methods have
            parameters of type long and int:
            public static void SampleMethod(int i) {}
            public static void SampleMethod(long l) {}

            The L suffix guarantees that the correct overload is called:
            SampleMethod(5);
            SampleMethod(5L);

            // Calls the method with the int parameter
            // Calls the method with the long parameter

            If an integer literal has no suffix, its type is the first of the following types in which its value can be represented:
            1. int
            2. uint
            3. long
            4. ulong
            The literal 4294967296 in the previous examples is of type long , because it exceeds the range of uint (see
            Integral Types Table for the storage sizes of integral types).

            If you use the long type with other integral types in the same expression, the expression is evaluated as long
            (or bool in the case of relational or Boolean expressions). For example, the following expression evaluates as
            long :
            898L + 88

            For information on arithmetic expressions with mixed floating-point types and integral types, see float and
            double.

            Conversions
            There is a predefined implicit conversion from long to float, double, or decimal. Otherwise a cast must be
            used. For example, the following statement will produce a compilation error without an explicit cast:
            int x = 8L;
            int y = (int)8L;

            // Error: no implicit conversion from long to int
            // OK: explicit conversion to int

            There is a predefined implicit conversion from sbyte, byte, short, ushort, int, uint, or char to long .
            Notice also that there is no implicit conversion from floating-point types to long . For example, the following
            statement generates a compiler error unless an explicit cast is used:
            long x = 3.0;
            long y = (long)3.0;

            // Error: no implicit conversion from double
            // OK: explicit conversion

            C# Language Specification
            For more information, see Integral types in the C# Language Specification. The language specification is the
            definitive source for C# syntax and usage.

            See Also
            Int64
            C# Reference
            C# Programming Guide
            C# Keywords
            Integral Types Table
            Built-In Types Table
            Implicit Numeric Conversions Table
            Explicit Numeric Conversions Table

            sbyte (C# Reference)
            12/11/2018 • 3 minutes to read • Edit Online

            sbyte denotes an integral type that stores values according to the size and range shown in the following table.
            TYPE

            RANGE

            SIZE

            .NET TYPE

            sbyte

            -128 to 127

            Signed 8-bit integer

            System.SByte

            Literals
            You can declare and initialize an sbyte variable by assigning a decimal literal, a hexadecimal literal, or (starting
            with C# 7.0) a binary literal to it.
            In the following example, integers equal to -102 that are represented as decimal, hexadecimal, and binary literals
            are converted from int to sbyte values.
            sbyte sbyteValue1 = -102;
            Console.WriteLine(sbyteValue1);
            unchecked {
            sbyte sbyteValue2 = (sbyte)0x9A;
            Console.WriteLine(sbyteValue2);
            sbyte sbyteValue3 = (sbyte)0b1001_1010;
            Console.WriteLine(sbyteValue3);
            }
            // The example displays the following output:
            //
            -102
            //
            -102
            //
            -102

            NOTE
            You use the prefix 0x or 0X to denote a hexadecimal literal and the prefix 0b or 0B to denote a binary literal. Decimal
            literals have no prefix.

            Starting with C# 7.0, a couple of features have been added to enhance readability.
            C# 7.0 allows the usage of the underscore character, _ , as a digit separator.
            C# 7.2 allows _ to be used as a digit separator for a binary or hexadecimal literal, after the prefix. A decimal
            literal isn't permitted to have a leading underscore.
            Some examples are shown below.

            unchecked {
            sbyte sbyteValue4 = (sbyte)0b1001_1010;
            Console.WriteLine(sbyteValue4);
            sbyte sbyteValue5 = (sbyte)0b_1001_1010;
            Console.WriteLine(sbyteValue5);

            // C# 7.2 onwards

            }
            // The example displays the following output:
            //
            -102
            //
            -102

            If the integer literal is outside the range of sbyte (that is, if it is less than SByte.MinValue or greater than
            SByte.MaxValue, a compilation error occurs. When an integer literal has no suffix, its type is the first of these
            types in which its value can be represented: int, uint, long, ulong. This means that, in this example, the numeric
            literals 0x9A and 0b10011010 are interpreted as 32-bit signed integers with a value of 156, which exceeds
            SByte.MaxValue. Because of this, the casting operator is needed, and the assignment must occur in an unchecked
            context.

            Compiler overload resolution
            A cast must be used when calling overloaded methods. Consider, for example, the following overloaded methods
            that use sbyte and int parameters:
            public static void SampleMethod(int i) {}
            public static void SampleMethod(sbyte b) {}

            Using the sbyte cast guarantees that the correct type is called, for example:
            // Calling the method with the int parameter:
            SampleMethod(5);
            // Calling the method with the sbyte parameter:
            SampleMethod((sbyte)5);

            Conversions
            There is a predefined implicit conversion from sbyte to short, int, long, float, double, or decimal.
            You cannot implicitly convert nonliteral numeric types of larger storage size to sbyte (see Integral Types Table
            for the storage sizes of integral types). Consider, for example, the following two sbyte variables x and y :
            sbyte x = 10, y = 20;

            The following assignment statement will produce a compilation error, because the arithmetic expression on the
            right side of the assignment operator evaluates to int by default.
            sbyte z = x + y;

            // Error: conversion from int to sbyte

            To fix this problem, cast the expression as in the following example:
            sbyte z = (sbyte)(x + y);

            // OK: explicit conversion

            It is possible though to use the following statements, where the destination variable has the same storage size or

            a larger storage size:
            sbyte x = 10, y = 20;
            int m = x + y;
            long n = x + y;

            Notice also that there is no implicit conversion from floating-point types to sbyte . For example, the following
            statement generates a compiler error unless an explicit cast is used:
            sbyte x = 3.0;
            // Error: no implicit conversion from double
            sbyte y = (sbyte)3.0; // OK: explicit conversion

            For information about arithmetic expressions with mixed floating-point types and integral types, see float and
            double.
            For more information about implicit numeric conversion rules, see the Implicit Numeric Conversions Table.

            C# Language Specification
            For more information, see Integral types in the C# Language Specification. The language specification is the
            definitive source for C# syntax and usage.

            See Also
            SByte
            C# Reference
            C# Programming Guide
            C# Keywords
            Integral Types Table
            Built-In Types Table
            Implicit Numeric Conversions Table
            Explicit Numeric Conversions Table

            short (C# Reference)
            12/11/2018 • 3 minutes to read • Edit Online

            short denotes an integral data type that stores values according to the size and range shown in the following

            table.
            TYPE

            RANGE

            SIZE

            .NET TYPE

            short

            -32,768 to 32,767

            Signed 16-bit integer

            System.Int16

            Literals
            You can declare and initialize a short variable by assigning a decimal literal, a hexadecimal literal, or (starting
            with C# 7.0) a binary literal to it. If the integer literal is outside the range of short (that is, if it is less than
            Int16.MinValue or greater than Int16.MaxValue), a compilation error occurs.
            In the following example, integers equal to 1,034 that are represented as decimal, hexadecimal, and binary
            literals are implicitly converted from int to short values.
            short shortValue1 = 1034;
            Console.WriteLine(shortValue1);
            short shortValue2 = 0x040A;
            Console.WriteLine(shortValue2);
            short shortValue3 = 0b0100_00001010;
            Console.WriteLine(shortValue3);
            // The example displays the following output:
            //
            1034
            //
            1034
            //
            1034

            NOTE
            You use the prefix 0x or 0X to denote a hexadecimal literal and the prefix 0b or 0B to denote a binary literal.
            Decimal literals have no prefix.

            Starting with C# 7.0, a couple of features have been added to enhance readability.
            C# 7.0 allows the usage of the underscore character, _ , as a digit separator.
            C# 7.2 allows _ to be used as a digit separator for a binary or hexadecimal literal, after the prefix. A decimal
            literal isn't permitted to have a leading underscore.
            Some examples are shown below.

            short shortValue1 = 1_034;
            Console.WriteLine(shortValue1);
            short shortValue2 = 0b00000100_00001010;
            Console.WriteLine(shortValue2);
            short shortValue3 = 0b_00000100_00001010;
            Console.WriteLine(shortValue3);
            // The example displays the following output:
            //
            1034
            //
            1034
            //
            1034

            // C# 7.2 onwards

            Compiler overload resolution
            A cast must be used when calling overloaded methods. Consider, for example, the following overloaded
            methods that use short and int parameters:
            public static void SampleMethod(int i) {}
            public static void SampleMethod(short s) {}

            Using the short cast guarantees that the correct type is called, for example:
            SampleMethod(5);
            // Calling the method with the int parameter
            SampleMethod((short)5); // Calling the method with the short parameter

            Conversions
            There is a predefined implicit conversion from short to int, long, float, double, or decimal.
            You cannot implicitly convert nonliteral numeric types of larger storage size to short (see Integral Types Table
            for the storage sizes of integral types). Consider, for example, the following two short variables x and y :
            short x = 5, y = 12;

            The following assignment statement produces a compilation error because the arithmetic expression on the
            right-hand side of the assignment operator evaluates to int by default.
            short z = x + y;

            // Compiler error CS0266: no conversion from int to short

            To fix this problem, use a cast:
            short z = (short)(x + y);

            // Explicit conversion

            It is also possible to use the following statements, where the destination variable has the same storage size or a
            larger storage size:
            int m = x + y;
            long n = x + y;

            There is no implicit conversion from floating-point types to short . For example, the following statement
            generates a compiler error unless an explicit cast is used:

            short x = 3.0;
            short y = (short)3.0;

            // Error: no implicit conversion from double
            // OK: explicit conversion

            For information on arithmetic expressions with mixed floating-point types and integral types, see float and
            double.
            For more information on implicit numeric conversion rules, see the Implicit Numeric Conversions Table.

            C# language specification
            For more information, see Integral types in the C# Language Specification. The language specification is the
            definitive source for C# syntax and usage.

            See also
            Int16
            C# Reference
            C# Programming Guide
            C# Keywords
            Integral Types Table
            Built-In Types Table
            Implicit Numeric Conversions Table
            Explicit Numeric Conversions Table

            struct (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            A struct type is a value type that is typically used to encapsulate small groups of related variables, such as the
            coordinates of a rectangle or the characteristics of an item in an inventory. The following example shows a simple
            struct declaration:
            public struct Book
            {
            public decimal price;
            public string title;
            public string author;
            }

            Remarks
            Structs can also contain constructors, constants, fields, methods, properties, indexers, operators, events, and
            nested types, although if several such members are required, you should consider making your type a class
            instead.
            For examples, see Using Structs.
            Structs can implement an interface but they cannot inherit from another struct. For that reason, struct members
            cannot be declared as protected .
            For more information, see Structs.

            Examples
            For examples and more information, see Using Structs.

            C# language specification
            For examples, see Using Structs.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Default Values Table
            Built-In Types Table
            Types
            Value Types
            class
            interface
            Classes and Structs

            uint (C# Reference)
            12/11/2018 • 3 minutes to read • Edit Online

            The uint keyword signifies an integral type that stores values according to the size and range shown in the
            following table.
            TYPE

            RANGE

            SIZE

            .NET TYPE

            uint

            0 to 4,294,967,295

            Unsigned 32-bit integer

            System.UInt32

            Note The uint type is not CLS -compliant. Use int whenever possible.

            Literals
            You can declare and initialize a uint variable by assigning a decimal literal, a hexadecimal literal, or (starting
            with C# 7.0) a binary literal to it. If the integer literal is outside the range of uint (that is, if it is less than
            UInt32.MinValue or greater than UInt32.MaxValue), a compilation error occurs.
            In the following example, integers equal to 3,000,000,000 that are represented as decimal, hexadecimal, and
            binary literals are assigned to uint values.
            uint uintValue1 = 3000000000;
            Console.WriteLine(uintValue1);
            uint uintValue2 = 0xB2D05E00;
            Console.WriteLine(uintValue2);
            uint uintValue3 = 0b1011_0010_1101_0000_0101_1110_0000_0000;
            Console.WriteLine(uintValue3);
            // The example displays the following output:
            //
            3000000000
            //
            3000000000
            //
            3000000000

            NOTE
            You use the prefix 0x or 0X to denote a hexadecimal literal and the prefix 0b or 0B to denote a binary literal.
            Decimal literals have no prefix.

            Starting with C# 7.0, a couple of features have been added to enhance readability:
            C# 7.0 allows the usage of the underscore character, _ , as a digit separator.
            C# 7.2 allows _ to be used as a digit separator for a binary or hexadecimal literal, after the prefix. A decimal
            literal isn't permitted to have a leading underscore.
            Some examples are shown below.

            uint uintValue1 = 3_000_000_000;
            Console.WriteLine(uintValue1);
            uint uintValue2 = 0xB2D0_5E00;
            Console.WriteLine(uintValue2);
            uint uintValue3 = 0b1011_0010_1101_0000_0101_1110_0000_0000;
            Console.WriteLine(uintValue3);
            uint uintValue4 = 0x_B2D0_5E00;
            Console.WriteLine(uintValue4);

            // C# 7.2 onwards

            uint uintValue5 = 0b_1011_0010_1101_0000_0101_1110_0000_0000;
            Console.WriteLine(uintValue5);
            // The example displays the following output:
            //
            3000000000
            //
            3000000000
            //
            3000000000
            //
            3000000000
            //
            3000000000

            // C# 7.2 onwards

            Integer literals can also include a suffix that denotes the type. The suffix U or 'u' denotes either a uint or a
            ulong , depending on the numeric value of the literal. The following example uses the u suffix to denote an
            unsigned integer of both types. Note that the first literal is a uint because its value is less than
            UInt32.MaxValue, while the second is a ulong because its value is greater than UInt32.MaxValue.
            object value1 = 4000000000u;
            Console.WriteLine($"{value1} ({4000000000u.GetType().Name})");
            object value2 = 6000000000u;
            Console.WriteLine($"{value2} ({6000000000u.GetType().Name})");

            If an integer literal has no suffix, its type is the first of the following types in which its value can be represented:
            1. int
            2. uint
            3. long
            4. ulong

            Conversions
            There is a predefined implicit conversion from uint to long, ulong, float, double, or decimal. For example:
            float myFloat = 4294967290;

            // OK: implicit conversion to float

            There is a predefined implicit conversion from byte, ushort, or char to uint . Otherwise you must use a cast.
            For example, the following assignment statement will produce a compilation error without a cast:
            long aLong = 22;
            // Error -- no implicit conversion from long:
            uint uInt1 = aLong;
            // OK -- explicit conversion:
            uint uInt2 = (uint)aLong;

            Notice also that there is no implicit conversion from floating-point types to uint . For example, the following
            statement generates a compiler error unless an explicit cast is used:

            // Error -- no implicit conversion from double:
            uint x = 3.0;
            // OK -- explicit conversion:
            uint y = (uint)3.0;

            For information about arithmetic expressions with mixed floating-point types and integral types, see float and
            double.
            For more information about implicit numeric conversion rules, see the Implicit Numeric Conversions Table.

            C# language specification
            For more information, see Integral types in the C# Language Specification. The language specification is the
            definitive source for C# syntax and usage.

            See also
            UInt32
            C# Reference
            C# Programming Guide
            C# Keywords
            Integral Types Table
            Built-In Types Table
            Implicit Numeric Conversions Table
            Explicit Numeric Conversions Table

            ulong (C# Reference)
            12/11/2018 • 3 minutes to read • Edit Online

            The ulong keyword denotes an integral type that stores values according to the size and range shown in the
            following table.
            TYPE

            RANGE

            SIZE

            .NET TYPE

            ulong

            0 to
            18,446,744,073,709,551,61
            5

            Unsigned 64-bit integer

            System.UInt64

            Literals
            You can declare and initialize a ulong variable by assigning a decimal literal, a hexadecimal literal, or (starting
            with C# 7.0) a binary literal to it. If the integer literal is outside the range of ulong (that is, if it is less than
            UInt64.MinValue or greater than UInt64.MaxValue), a compilation error occurs.
            In the following example, integers equal to 7,934,076,125 that are represented as decimal, hexadecimal, and
            binary literals are assigned to ulong values.
            ulong ulongValue1 = 7934076125;
            Console.WriteLine(ulongValue1);
            ulong ulongValue2 = 0x0001D8e864DD;
            Console.WriteLine(ulongValue2);
            ulong ulongValue3 = 0b0001_1101_1000_1110_1000_0110_0100_1101_1101;
            Console.WriteLine(ulongValue3);
            // The example displays the following output:
            //
            7934076125
            //
            7934076125
            //
            7934076125

            NOTE
            You use the prefix 0x or 0X to denote a hexadecimal literal and the prefix 0b or 0B to denote a binary literal.
            Decimal literals have no prefix.

            Starting with C# 7.0, a couple of features have been added to enhance readability:
            C# 7.0 allows the usage of the underscore character, _ , as a digit separator.
            C# 7.2 allows _ to be used as a digit separator for a binary or hexadecimal literal, after the prefix. A
            decimal literal isn't permitted to have a leading underscore.
            Some examples are shown below.

            long longValue1 = 4_294_967_296;
            Console.WriteLine(longValue1);
            long longValue2 = 0x1_0000_0000;
            Console.WriteLine(longValue2);
            long longValue3 = 0b1_0000_0000_0000_0000_0000_0000_0000_0000;
            Console.WriteLine(longValue3);
            long longValue4 = 0x_1_0000_0000;
            Console.WriteLine(longValue4);

            // C# 7.2 onwards

            long longValue5 = 0b_1_0000_0000_0000_0000_0000_0000_0000_0000;
            Console.WriteLine(longValue5);
            // The example displays the following output:
            //
            4294967296
            //
            4294967296
            //
            4294967296
            //
            4294967296
            //
            4294967296

            // C# 7.2 onwards

            Integer literals can also include a suffix that denotes the type. The suffix UL or ul unambiguously identifies a
            numeric literal as a ulong value. The L suffix denotes a ulong if the literal value exceeds Int64.MaxValue.
            And the U or u suffix denotes a ulong if the literal value exceeds UInt32.MaxValue. The following example
            uses the ul suffix to denote a long integer:
            object value1 = 700000000000ul;
            Console.WriteLine($"{value1} ({700000000000ul.GetType().Name})");

            If an integer literal has no suffix, its type is the first of the following types in which its value can be represented:
            1. int
            2. uint
            3. long
            4. ulong

            Compiler overload resolution
            A common use of the suffix is with calling overloaded methods. Consider, for example, the following
            overloaded methods that use ulong and int parameters:
            public static void SampleMethod(int i) {}
            public static void SampleMethod(ulong l) {}

            Using a suffix with the ulong parameter guarantees that the correct type is called, for example:
            SampleMethod(5);
            // Calling the method with the int parameter
            SampleMethod(5UL); // Calling the method with the ulong parameter

            Conversions
            There is a predefined implicit conversion from ulong to float, double, or decimal.
            There is no implicit conversion from ulong to any integral type. For example, the following statement will
            produce a compilation error without an explicit cast:

            long long1 = 8UL;

            // Error: no implicit conversion from ulong

            There is a predefined implicit conversion from byte, ushort, uint, or char to ulong .
            Also, there is no implicit conversion from floating-point types to ulong . For example, the following statement
            generates a compiler error unless an explicit cast is used:
            // Error -- no implicit conversion from double:
            ulong x = 3.0;
            // OK -- explicit conversion:
            ulong y = (ulong)3.0;

            For information on arithmetic expressions with mixed floating-point types and integral types, see float and
            double.
            For more information on implicit numeric conversion rules, see the Implicit Numeric Conversions Table.

            C# language specification
            For more information, see Integral types in the C# Language Specification. The language specification is the
            definitive source for C# syntax and usage.

            See also
            UInt64
            C# Reference
            C# Programming Guide
            C# Keywords
            Integral Types Table
            Built-In Types Table
            Implicit Numeric Conversions Table
            Explicit Numeric Conversions Table

            ushort (C# Reference)
            12/19/2018 • 3 minutes to read • Edit Online

            The ushort keyword indicates an integral data type that stores values according to the size and range shown in
            the following table.
            TYPE

            RANGE

            SIZE

            .NET TYPE

            ushort

            0 to 65,535

            Unsigned 16-bit integer

            System.UInt16

            Literals
            You can declare and initialize a ushort variable by assigning a decimal literal, a hexadecimal literal, or (starting
            with C# 7.0) a binary literal to it. If the integer literal is outside the range of ushort (that is, if it is less than
            UInt16.MinValue or greater than UInt16.MaxValue), a compilation error occurs.
            In the following example, integers equal to 65,034 that are represented as decimal, hexadecimal, and binary
            literals are implicitly converted from int to ushort values.
            ushort ushortValue1 = 65034;
            Console.WriteLine(ushortValue1);
            ushort ushortValue2 = 0xFE0A;
            Console.WriteLine(ushortValue2);
            ushort ushortValue3 = 0b1111_1110_0000_1010;
            Console.WriteLine(ushortValue3);
            // The example displays the following output:
            //
            65034
            //
            65034
            //
            65034

            NOTE
            You use the prefix 0x or 0X to denote a hexadecimal literal and the prefix 0b or 0B to denote a binary literal.
            Decimal literals have no prefix.

            Starting with C# 7.0, a couple of features have been added to enhance readability:
            C# 7.0 allows the usage of the underscore character, _ , as a digit separator.
            C# 7.2 allows _ to be used as a digit separator for a binary or hexadecimal literal, after the prefix. A decimal
            literal isn't permitted to have a leading underscore.
            Some examples are shown below.

            ushort ushortValue1 = 65_034;
            Console.WriteLine(ushortValue1);
            ushort ushortValue2 = 0b11111110_00001010;
            Console.WriteLine(ushortValue2);
            ushort ushortValue3 = 0b_11111110_00001010;
            Console.WriteLine(ushortValue3);
            // The example displays the following output:
            //
            65034
            //
            65034
            //
            65034

            // C# 7.2 onwards

            Compiler overload resolution
            A cast must be used when you call overloaded methods. Consider, for example, the following overloaded
            methods that use ushort and int parameters:
            public static void SampleMethod(int i) {}
            public static void SampleMethod(ushort s) {}

            Using the ushort cast guarantees that the correct type is called, for example:
            // Calls the method with the int parameter:
            SampleMethod(5);
            // Calls the method with the ushort parameter:
            SampleMethod((ushort)5);

            Conversions
            There is a predefined implicit conversion from ushort to int, uint, long, ulong, float, double, or decimal.
            There is a predefined implicit conversion from byte or char to ushort . Otherwise a cast must be used to
            perform an explicit conversion. Consider, for example, the following two ushort variables x and y :
            ushort x = 5, y = 12;

            The following assignment statement will produce a compilation error, because the arithmetic expression on the
            right side of the assignment operator evaluates to int by default.
            ushort z = x + y;

            // Error: conversion from int to ushort

            To fix this problem, use a cast:
            ushort z = (ushort)(x + y);

            // OK: explicit conversion

            It is possible though to use the following statements, where the destination variable has the same storage size or
            a larger storage size:
            int m = x + y;
            long n = x + y;

            Notice also that there is no implicit conversion from floating-point types to ushort . For example, the following
            statement generates a compiler error unless an explicit cast is used:
            // Error -- no implicit conversion from double:
            ushort x = 3.0;
            // OK -- explicit conversion:
            ushort y = (ushort)3.0;

            For information about arithmetic expressions with mixed floating-point types and integral types, see float and
            double.
            For more information about implicit numeric conversion rules, see the Implicit Numeric Conversions Table.

            C# language specification
            For more information, see Integral types in the C# Language Specification. The language specification is the
            definitive source for C# syntax and usage.

            See also
            UInt16
            C# Reference
            C# Programming Guide
            C# Keywords
            Integral Types Table
            Built-In Types Table
            Implicit Numeric Conversions Table
            Explicit Numeric Conversions Table

            Reference types (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            There are two kinds of types in C#: reference types and value types. Variables of reference types store references
            to their data (objects), while variables of value types directly contain their data. With reference types, two
            variables can reference the same object; therefore, operations on one variable can affect the object referenced by
            the other variable. With value types, each variable has its own copy of the data, and it is not possible for
            operations on one variable to affect the other (except in the case of in, ref and out parameter variables; see in, ref
            and out parameter modifier).
            The following keywords are used to declare reference types:
            class
            interface
            delegate
            C# also provides the following built-in reference types:
            dynamic
            object
            string

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Types
            Value Types

            class (C# Reference)
            12/12/2018 • 2 minutes to read • Edit Online

            Classes are declared using the keyword class , as shown in the following example:
            class TestClass
            {
            // Methods, properties, fields, events, delegates
            // and nested classes go here.
            }

            Remarks
            Only single inheritance is allowed in C#. In other words, a class can inherit implementation from one base class
            only. However, a class can implement more than one interface. The following table shows examples of class
            inheritance and interface implementation:
            INHERITANCE

            EXAMPLE

            None

            class ClassA { }

            Single

            class DerivedClass: BaseClass { }

            None, implements two interfaces

            class ImplClass: IFace1, IFace2 { }

            Single, implements one interface

            class ImplDerivedClass: BaseClass, IFace1 { }

            Classes that you declare directly within a namespace, not nested within other classes, can be either public or
            internal. Classes are internal by default.
            Class members, including nested classes, can be public, protected internal, protected, internal, private, or private
            protected. Members are private by default.
            For more information, see Access Modifiers.
            You can declare generic classes that have type parameters. For more information, see Generic Classes.
            A class can contain declarations of the following members:
            Constructors
            Constants
            Fields
            Finalizers
            Methods
            Properties
            Indexers
            Operators

            Events
            Delegates
            Classes
            Interfaces
            Structs
            Enumerations

            Example
            The following example demonstrates declaring class fields, constructors, and methods. It also demonstrates object
            instantiation and printing instance data. In this example, two classes are declared. The first class, Child , contains
            two private fields ( name and age ), two public constructors and one public method. The second class, StringTest ,
            is used to contain Main .

            class Child
            {
            private int age;
            private string name;
            // Default constructor:
            public Child()
            {
            name = "N/A";
            }
            // Constructor:
            public Child(string name, int age)
            {
            this.name = name;
            this.age = age;
            }
            // Printing method:
            public void PrintChild()
            {
            Console.WriteLine("{0}, {1} years old.", name, age);
            }
            }
            class StringTest
            {
            static void Main()
            {
            // Create objects by using the new operator:
            Child child1 = new Child("Craig", 11);
            Child child2 = new Child("Sally", 10);
            // Create an object using the default constructor:
            Child child3 = new Child();
            // Display results:
            Console.Write("Child #1: ");
            child1.PrintChild();
            Console.Write("Child #2: ");
            child2.PrintChild();
            Console.Write("Child #3: ");
            child3.PrintChild();
            }
            }
            /* Output:
            Child #1: Craig, 11 years old.
            Child #2: Sally, 10 years old.
            Child #3: N/A, 0 years old.
            */

            Comments
            Notice that in the previous example the private fields ( name and age ) can only be accessed through the public
            method of the Child class. For example, you cannot print the child's name, from the Main method, using a
            statement like this:
            Console.Write(child1.name);

            // Error

            Accessing private members of Child from Main would only be possible if Main were a member of the class.
            Types declared inside a class without an access modifier default to private , so the data members in this example

            would still be private if the keyword were removed.
            Finally, notice that for the object created using the default constructor ( child3 ), the age field was initialized to
            zero by default.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Reference Types

            delegate (C# Reference)
            12/12/2018 • 2 minutes to read • Edit Online

            The declaration of a delegate type is similar to a method signature. It has a return value and any number of
            parameters of any type:
            public delegate void TestDelegate(string message);
            public delegate int TestDelegate(MyType m, long num);

            A delegate is a reference type that can be used to encapsulate a named or an anonymous method. Delegates are
            similar to function pointers in C++; however, delegates are type-safe and secure. For applications of delegates, see
            Delegates and Generic Delegates.

            Remarks
            Delegates are the basis for Events.
            A delegate can be instantiated by associating it either with a named or anonymous method. For more information,
            see Named Methods and Anonymous Methods.
            The delegate must be instantiated with a method or lambda expression that has a compatible return type and
            input parameters. For more information on the degree of variance that is allowed in the method signature, see
            Variance in Delegates. For use with anonymous methods, the delegate and the code to be associated with it are
            declared together. Both ways of instantiating delegates are discussed in this section.

            Example

            // Declare delegate -- defines required signature:
            delegate double MathAction(double num);
            class DelegateTest
            {
            // Regular method that matches signature:
            static double Double(double input)
            {
            return input * 2;
            }
            static void Main()
            {
            // Instantiate delegate with named method:
            MathAction ma = Double;
            // Invoke delegate ma:
            double multByTwo = ma(4.5);
            Console.WriteLine("multByTwo: {0}", multByTwo);
            // Instantiate delegate with anonymous method:
            MathAction ma2 = delegate(double input)
            {
            return input * input;
            };
            double square = ma2(5);
            Console.WriteLine("square: {0}", square);
            // Instantiate delegate with lambda expression
            MathAction ma3 = s => s * s * s;
            double cube = ma3(4.375);
            Console.WriteLine("cube: {0}", cube);
            }
            // Output:
            // multByTwo: 9
            // square: 25
            // cube: 83.740234375
            }

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Reference Types
            Delegates
            Events
            Delegates with Named vs. Anonymous Methods
            Anonymous Methods
            Lambda Expressions

            dynamic (C# Reference)
            12/11/2018 • 3 minutes to read • Edit Online

            The dynamic type enables the operations in which it occurs to bypass compile-time type checking. Instead, these
            operations are resolved at run time. The dynamic type simplifies access to COM APIs such as the Office
            Automation APIs, and also to dynamic APIs such as IronPython libraries, and to the HTML Document Object
            Model (DOM ).
            Type dynamic behaves like type object in most circumstances. However, operations that contain expressions of
            type dynamic are not resolved or type checked by the compiler. The compiler packages together information
            about the operation, and that information is later used to evaluate the operation at run time. As part of the
            process, variables of type dynamic are compiled into variables of type object . Therefore, type dynamic exists
            only at compile time, not at run time.
            The following example contrasts a variable of type dynamic to a variable of type object . To verify the type of each
            variable at compile time, place the mouse pointer over dyn or obj in the WriteLine statements. IntelliSense
            shows dynamic for dyn and object for obj .
            class Program
            {
            static void Main(string[] args)
            {
            dynamic dyn = 1;
            object obj = 1;
            // Rest the mouse pointer over dyn and obj to see their
            // types at compile time.
            System.Console.WriteLine(dyn.GetType());
            System.Console.WriteLine(obj.GetType());
            }
            }

            The WriteLine statements display the run-time types of dyn and obj . At that point, both have the same type,
            integer. The following output is produced:
            System.Int32
            System.Int32

            To see the difference between dyn and obj at compile time, add the following two lines between the declarations
            and the WriteLine statements in the previous example.
            dyn = dyn + 3;
            obj = obj + 3;

            A compiler error is reported for the attempted addition of an integer and an object in expression obj + 3 .
            However, no error is reported for dyn + 3 . The expression that contains dyn is not checked at compile time
            because the type of dyn is dynamic .

            Context
            The dynamic keyword can appear directly or as a component of a constructed type in the following situations:

            In declarations, as the type of a property, field, indexer, parameter, return value, local variable, or type
            constraint. The following class definition uses dynamic in several different declarations.
            class ExampleClass
            {
            // A dynamic field.
            static dynamic field;
            // A dynamic property.
            dynamic prop { get; set; }
            // A dynamic return type and a dynamic parameter type.
            public dynamic exampleMethod(dynamic d)
            {
            // A dynamic local variable.
            dynamic local = "Local variable";
            int two = 2;
            if (d is int)
            {
            return local;
            }
            else
            {
            return two;
            }
            }
            }

            In explicit type conversions, as the target type of a conversion.
            static void convertToDynamic()
            {
            dynamic d;
            int i = 20;
            d = (dynamic)i;
            Console.WriteLine(d);
            string s = "Example string.";
            d = (dynamic)s;
            Console.WriteLine(d);
            DateTime dt = DateTime.Today;
            d = (dynamic)dt;
            Console.WriteLine(d);
            }
            // Results:
            // 20
            // Example string.
            // 7/25/2018 12:00:00 AM

            In any context where types serve as values, such as on the right side of an is operator or an as operator,
            or as the argument to typeof as part of a constructed type. For example, dynamic can be used in the
            following expressions.

            int i = 8;
            dynamic d;
            // With the is operator.
            // The dynamic type behaves like object. The following
            // expression returns true unless someVar has the value null.
            if (someVar is dynamic) { }
            // With the as operator.
            d = i as dynamic;
            // With typeof, as part of a constructed type.
            Console.WriteLine(typeof(List<dynamic>));
            // The following statement causes a compiler error.
            //Console.WriteLine(typeof(dynamic));

            Example
            The following example uses dynamic in several declarations. The Main method also contrasts compile-time type
            checking with run-time type checking.

            using System;
            namespace DynamicExamples
            {
            class Program
            {
            static void Main(string[] args)
            {
            ExampleClass ec = new ExampleClass();
            Console.WriteLine(ec.exampleMethod(10));
            Console.WriteLine(ec.exampleMethod("value"));
            // The following line causes a compiler error because exampleMethod
            // takes only one argument.
            //Console.WriteLine(ec.exampleMethod(10, 4));
            dynamic dynamic_ec = new ExampleClass();
            Console.WriteLine(dynamic_ec.exampleMethod(10));
            // Because dynamic_ec is dynamic, the following call to exampleMethod
            // with two arguments does not produce an error at compile time.
            // However, itdoes cause a run-time error.
            //Console.WriteLine(dynamic_ec.exampleMethod(10, 4));
            }
            }
            class ExampleClass
            {
            static dynamic field;
            dynamic prop { get; set; }
            public dynamic exampleMethod(dynamic d)
            {
            dynamic local = "Local variable";
            int two = 2;
            if (d is int)
            {
            return local;
            }
            else
            {
            return two;
            }
            }
            }
            }
            // Results:
            // Local variable
            // 2
            // Local variable

            For more information and examples, see Using Type dynamic.

            See also
            System.Dynamic.ExpandoObject
            System.Dynamic.DynamicObject
            Using Type dynamic
            object
            is
            as
            typeof

            How to: Safely cast Using pattern matching, as, and is Operators
            Walkthrough: Creating and Using Dynamic Objects

            interface (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            An interface contains only the signatures of methods, properties, events or indexers. A class or struct that
            implements the interface must implement the members of the interface that are specified in the interface
            definition. In the following example, class ImplementationClass must implement a method named SampleMethod
            that has no parameters and returns void .
            For more information and examples, see Interfaces.

            Example
            interface ISampleInterface
            {
            void SampleMethod();
            }
            class ImplementationClass : ISampleInterface
            {
            // Explicit interface member implementation:
            void ISampleInterface.SampleMethod()
            {
            // Method implementation.
            }
            static void Main()
            {
            // Declare an interface instance.
            ISampleInterface obj = new ImplementationClass();
            // Call the member.
            obj.SampleMethod();
            }
            }

            An interface can be a member of a namespace or a class and can contain signatures of the following members:
            Methods
            Properties
            Indexers
            Events
            An interface can inherit from one or more base interfaces.
            When a base type list contains a base class and interfaces, the base class must come first in the list.
            A class that implements an interface can explicitly implement members of that interface. An explicitly implemented
            member cannot be accessed through a class instance, but only through an instance of the interface.
            For more details and code examples on explicit interface implementation, see Explicit Interface Implementation.

            Example
            The following example demonstrates interface implementation. In this example, the interface contains the

            property declaration and the class contains the implementation. Any instance of a class that implements IPoint
            has integer properties x and y .
            interface IPoint
            {
            // Property signatures:
            int x
            {
            get;
            set;
            }
            int y
            {
            get;
            set;
            }
            }
            class Point : IPoint
            {
            // Fields:
            private int _x;
            private int _y;
            // Constructor:
            public Point(int x, int y)
            {
            _x = x;
            _y = y;
            }
            // Property implementation:
            public int x
            {
            get
            {
            return _x;
            }
            set
            {
            _x = value;
            }
            }
            public int y
            {
            get
            {
            return _y;
            }
            set
            {
            _y = value;
            }
            }
            }
            class MainClass
            {
            static void PrintPoint(IPoint p)
            {
            Console.WriteLine("x={0}, y={1}", p.x, p.y);
            }
            static void Main()
            {

            {
            IPoint p = new Point(2, 3);
            Console.Write("My Point: ");
            PrintPoint(p);
            }
            }
            // Output: My Point: x=2, y=3

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Reference Types
            Interfaces
            Using Properties
            Using Indexers
            class
            struct
            Interfaces

            object (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The object type is an alias for Object in .NET. In the unified type system of C#, all types, predefined and userdefined, reference types and value types, inherit directly or indirectly from Object. You can assign values of any
            type to variables of type object . When a variable of a value type is converted to object, it is said to be boxed.
            When a variable of type object is converted to a value type, it is said to be unboxed. For more information, see
            Boxing and Unboxing.

            Example
            The following sample shows how variables of type object can accept values of any data type and how variables
            of type object can use methods on Object from the .NET Framework.
            class ObjectTest
            {
            public int i = 10;
            }
            class MainClass2
            {
            static void Main()
            {
            object a;
            a = 1; // an example of boxing
            Console.WriteLine(a);
            Console.WriteLine(a.GetType());
            Console.WriteLine(a.ToString());
            a = new ObjectTest();
            ObjectTest classRef;
            classRef = (ObjectTest)a;
            Console.WriteLine(classRef.i);
            }
            }
            /* Output
            1
            System.Int32
            1
            * 10
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Reference Types
            Value Types

            string (C# Reference)
            12/12/2018 • 2 minutes to read • Edit Online

            The string type represents a sequence of zero or more Unicode characters. string is an alias for String in .NET.
            Although string is a reference type, the equality operators ( == and != ) are defined to compare the values of
            string objects, not references. This makes testing for string equality more intuitive. For example:
            string a = "hello";
            string b = "h";
            // Append to contents of 'b'
            b += "ello";
            Console.WriteLine(a == b);
            Console.WriteLine((object)a == (object)b);

            This displays "True" and then "False" because the content of the strings are equivalent, but a and b do not refer
            to the same string instance.
            The + operator concatenates strings:
            string a = "good " + "morning";

            This creates a string object that contains "good morning".
            Strings are immutable--the contents of a string object cannot be changed after the object is created, although the
            syntax makes it appear as if you can do this. For example, when you write this code, the compiler actually creates a
            new string object to hold the new sequence of characters, and that new object is assigned to b. The string "h" is
            then eligible for garbage collection.
            string b = "h";
            b += "ello";

            The [] operator can be used for readonly access to individual characters of a string :
            string str = "test";
            char x = str[2]; // x = 's';

            In similar fashion, the [] operator can also be used for iterating over each character in a string :
            string str = "test";
            for (int i = 0; i < str.Length; i++)
            {
            Console.Write(str[i] + " ");
            }
            // Output: t e s t

            String literals are of type string and can be written in two forms, quoted and @-quoted. Quoted string literals
            are enclosed in double quotation marks ("):

            "good morning" // a string literal

            String literals can contain any character literal. Escape sequences are included. The following example uses escape
            sequence \\ for backslash, \u0066 for the letter f, and \n for newline.
            string a = "\\\u0066\n";
            Console.WriteLine(a);

            NOTE
            The escape code \udddd (where dddd is a four-digit number) represents the Unicode character U+ dddd . Eight-digit
            Unicode escape codes are also recognized: \Udddddddd .

            Verbatim string literals start with @ and are also enclosed in double quotation marks. For example:
            @"good morning" // a string literal

            The advantage of verbatim strings is that escape sequences are not processed, which makes it easy to write, for
            example, a fully qualified file name:
            @"c:\Docs\Source\a.txt" // rather than "c:\\Docs\\Source\\a.txt"

            To include a double quotation mark in an @-quoted string, double it:
            @"""Ahoy!"" cried the captain." // "Ahoy!" cried the captain.

            For other uses of the @ special character, see @ -- verbatim identifier.
            For more information about strings in C#, see Strings.

            Example
            class SimpleStringTest
            {
            static void Main()
            {
            string a = "\u0068ello ";
            string b = "world";
            Console.WriteLine( a + b );
            Console.WriteLine( a + b == "Hello World" ); // == performs a case-sensitive comparison
            }
            }
            /* Output:
            hello world
            False
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            Best Practices for Using Strings
            C# Keywords
            Reference Types
            Value Types
            Basic String Operations
            Creating New Strings
            Formatting Numeric Results Table

            void (C# Reference)
            12/19/2018 • 2 minutes to read • Edit Online

            When used as the return type for a method, void specifies that the method doesn't return a value.
            void isn't allowed in the parameter list of a method. A method that takes no parameters and returns no value is

            declared as follows:
            public void SampleMethod()
            {
            // Body of the method.
            }

            void is also used in an unsafe context to declare a pointer to an unknown type. For more information, see Pointer

            types.
            void is an alias for the .NET Framework System.Void type.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Reference Types
            Value Types
            Methods
            Unsafe Code and Pointers

            var (C# Reference)
            12/19/2018 • 2 minutes to read • Edit Online

            Beginning in Visual C# 3.0, variables that are declared at method scope can have an implicit "type" var . An
            implicitly typed local variable is strongly typed just as if you had declared the type yourself, but the compiler
            determines the type. The following two declarations of i are functionally equivalent:
            var i = 10; // Implicitly typed.
            int i = 10; // Explicitly typed.

            For more information, see Implicitly Typed Local Variables and Type Relationships in LINQ Query Operations.

            Example
            The following example shows two query expressions. In the first expression, the use of var is permitted but is not
            required, because the type of the query result can be stated explicitly as an IEnumerable<string> . However, in the
            second expression, var allows the result to be a collection of anonymous types, and the name of that type is not
            accessible except to the compiler itself. Use of var eliminates the requirement to create a new class for the result.
            Note that in Example #2, the foreach iteration variable item must also be implicitly typed.
            // Example #1: var is optional when
            // the select clause specifies a string
            string[] words = { "apple", "strawberry", "grape", "peach", "banana" };
            var wordQuery = from word in words
            where word[0] == 'g'
            select word;
            // Because each element in the sequence is a string,
            // not an anonymous type, var is optional here also.
            foreach (string s in wordQuery)
            {
            Console.WriteLine(s);
            }
            // Example #2: var is required because
            // the select clause specifies an anonymous type
            var custQuery = from cust in customers
            where cust.City == "Phoenix"
            select new { cust.Name, cust.Phone };
            // var must be used because each item
            // in the sequence is an anonymous type
            foreach (var item in custQuery)
            {
            Console.WriteLine("Name={0}, Phone={1}", item.Name, item.Phone);
            }

            See also
            C# Reference
            C# Programming Guide
            Implicitly Typed Local Variables

            Reference tables for types (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The following reference tables summarize the C# types:
            TABLE

            DESCRIPTION

            Built-in types

            Lists built-in C# types and corresponding .NET types.

            Integral types

            Provides an overview of the integral types.

            Floating-point types

            Provides an overview of the floating-point types.

            Value types

            Lists C# value types.

            Default values

            Lists default values of C# value types.

            Implicit numeric conversions

            Provides an overview of supported implicit conversions
            between C# numeric types.

            Explicit numeric conversions

            Provides an overview of supported explicit conversions
            between C# numeric types.

            Formatting numeric results

            Provides an overview of standard numeric format strings.

            See also
            C# Reference
            C# Programming Guide
            Reference Types
            Value Types

            Built-in types table (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The following table shows the keywords for built-in C# types, which are aliases of predefined types in the
            System namespace.
            C# TYPE

            .NET TYPE

            bool

            System.Boolean

            byte

            System.Byte

            sbyte

            System.SByte

            char

            System.Char

            decimal

            System.Decimal

            double

            System.Double

            float

            System.Single

            int

            System.Int32

            uint

            System.UInt32

            long

            System.Int64

            ulong

            System.UInt64

            object

            System.Object

            short

            System.Int16

            ushort

            System.UInt16

            string

            System.String

            Remarks
            All of the types in the table, except object and string , are referred to as simple types.
            The C# type keywords and their aliases are interchangeable. For example, you can declare an integer variable
            by using either of the following declarations:
            int x = 123;
            System.Int32 y = 123;

            Use the typeof operator to get the System.Type instance that represents the specified type:

            Type stringType = typeof(string);
            Console.WriteLine(stringType.FullName);
            Type doubleType = typeof(System.Double);
            Console.WriteLine(doubleType.FullName);
            // Output:
            // System.String
            // System.Double

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Reference tables for types
            Value types
            Reference types
            Default values table
            dynamic

            Integral types table (C# Reference)
            12/14/2018 • 2 minutes to read • Edit Online

            The following table shows the sizes and ranges of the integral types, which constitute a subset of simple
            types.
            TYPE

            RANGE

            SIZE

            sbyte

            -128 to 127

            Signed 8-bit integer

            byte

            0 to 255

            Unsigned 8-bit integer

            char

            U+0000 to U+ffff

            Unicode 16-bit character

            short

            -32,768 to 32,767

            Signed 16-bit integer

            ushort

            0 to 65,535

            Unsigned 16-bit integer

            int

            -2,147,483,648 to 2,147,483,647

            Signed 32-bit integer

            uint

            0 to 4,294,967,295

            Unsigned 32-bit integer

            long

            -9,223,372,036,854,775,808 to
            9,223,372,036,854,775,807

            Signed 64-bit integer

            ulong

            0 to 18,446,744,073,709,551,615

            Unsigned 64-bit integer

            Remarks
            If the value represented by an integer literal exceeds UInt64.MaxValue, a compiler error CS1021 occurs.
            Use the System.Numerics.BigInteger structure to represent an arbitrarily large signed integer.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Reference tables for types
            Floating-point types table
            Default values table
            Formatting numeric results table
            Built-in types table
            Numerics in .NET

            Floating-point types table (C# Reference)
            12/14/2018 • 2 minutes to read • Edit Online

            The following table shows the precision and approximate ranges for the floating-point types.
            TYPE

            APPROXIMATE RANGE

            PRECISION

            float

            ±1.5 x 10− 45 to ±3.4 x 1038

            ~6-9 digits

            double

            ±5.0 × 10− 324 to ±1.7 × 10308

            ~15-17 digits

            decimal

            ±1.0 x 10-28 to ±7.9228 x 1028

            28-29 digits

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Reference tables for types
            Integral types table
            Default values table
            Formatting numeric results table
            Built-in types table
            Numerics in .NET
            System.Numerics.Complex

            Value types table (C# Reference)
            12/19/2018 • 2 minutes to read • Edit Online

            The following table shows the C# value types:
            VALUE TYPE

            CATEGORY

            TYPE SUFFIX

            bool

            Boolean

            byte

            Unsigned, numeric, integral

            char

            Unsigned, numeric, integral

            decimal

            Numeric, floating-point

            M or m

            double

            Numeric, floating-point

            D or d

            enum

            Enumeration

            float

            Numeric, floating-point

            int

            Signed, numeric, integral

            long

            Signed, numeric, integral

            sbyte

            Signed, numeric, integral

            short

            Signed, numeric, integral

            struct

            User-defined structure

            uint

            Unsigned, numeric, integral

            U or u

            ulong

            Unsigned, numeric, integral

            UL, Ul, uL, ul, LU, Lu, lU, or lu

            ushort

            Unsigned, numeric, integral

            F or f

            L or l

            Remarks
            You use a type suffix to specify a type of a numerical literal. For example:
            decimal a = 0.1M;

            If an integer numerical literal has no suffix, it has the first of the following types in which its value can be
            represented: int , uint , long , ulong .
            If a real numerical literal has no suffix, it's of type double .

            See also
            C# Reference
            C# Programming Guide
            Reference tables for types
            Default values table
            Value types
            Formatting numeric results table

            Default values table (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The following table shows the default values of value types.
            VALUE TYPE

            DEFAULT VALUE

            bool

            false

            byte

            0

            char

            '\0'

            decimal

            0M

            double

            0.0D

            enum

            The value produced by the expression (E)0 , where E is
            the enum identifier.

            float

            0.0F

            int

            0

            long

            0L

            sbyte

            0

            short

            0

            struct

            The value produced by setting all value-type fields to their
            default values and all reference-type fields to null .

            uint

            0

            ulong

            0

            ushort

            0

            Remarks
            You cannot use uninitialized variables in C#. You can initialize a variable with the default value of its type. You
            also can use the default value of a type to specify the default value of a method's optional argument.
            Use the default value expression to produce the default value of a type, as the following example shows:
            int a = default(int);

            Beginning with C# 7.1, you can use the default literal to initialize a variable with the default value of its type:

            int a = default;

            You also can use the default constructor or the implicit default constructor to produce the default value of a value
            type, as the following example shows. For more information about constructors, see the Constructors article.
            int a = new int();

            The default value of any reference type is null . The default value of a nullable type is an instance for which the
            HasValue property is false and the Value property is undefined.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Reference tables for types
            Value types
            Value types table
            Built-in types table

            Implicit numeric conversions table (C# Reference)
            1/5/2019 • 2 minutes to read • Edit Online

            The following table shows the predefined implicit conversions between .NET numeric types.
            FROM

            TO

            sbyte

            short , int , long , float , double , or decimal

            byte

            short , ushort , int , uint , long , ulong , float ,
            double , or decimal

            char

            ushort , int , uint , long , ulong , float , double ,
            or decimal

            short

            int , long , float , double , or decimal

            ushort

            int , uint , long , ulong , float , double , or
            decimal

            int

            long , float , double , or decimal

            uint

            long , ulong , float , double , or decimal

            long

            float , double , or decimal

            ulong

            float , double , or decimal

            float

            double

            Remarks
            Any integral type is implicitly convertible to any floating-point type.
            Precision but not magnitude might be lost in the conversions from int , uint , long , or ulong to
            float and from long or ulong to double .
            There are no implicit conversions to the char , byte and sbyte types.
            There are no implicit conversions from the char , double and decimal types.
            There are no implicit conversions between the decimal type and the float or double types.
            A value of a constant expression of type int (for example, a value represented by an integral literal)
            can be converted to sbyte , byte , short , ushort , uint , or ulong , provided it's within the range of
            the destination type:
            byte a = 13;
            byte b = 300;

            // Compiles
            // CS0031: Constant value '300' cannot be converted to a 'byte'

            For more information about implicit conversions, see the Implicit conversions section of the C# language
            specification.

            See also
            C# Reference
            C# Programming Guide
            Integral types table
            Floating-point types table
            Built-in types table
            Explicit numeric conversions table
            Casting and type conversions

            Explicit numeric conversions table (C# Reference)
            12/11/2018 • 3 minutes to read • Edit Online

            The following table shows the predefined explicit conversions between .NET numeric types for which there is
            no implicit conversion.
            FROM

            TO

            sbyte

            byte , ushort , uint , ulong , or char

            byte

            sbyte

            short

            sbyte , byte , ushort , uint , ulong , or char

            ushort

            sbyte , byte , short , or char

            int

            sbyte , byte , short , ushort , uint , ulong ,or

            or char

            char

            uint

            sbyte , byte , short , ushort , int , or char

            long

            sbyte , byte , short , ushort , int , uint , ulong ,
            or char

            ulong

            sbyte , byte , short , ushort , int , uint , long , or
            char

            char

            sbyte , byte , or short

            float

            sbyte , byte , short , ushort , int , uint , long ,
            ulong , char ,or decimal

            double

            sbyte , byte , short , ushort , int , uint , long ,
            ulong , char , float ,or decimal

            decimal

            sbyte , byte , short , ushort , int , uint , long ,
            ulong , char , float , or double

            Remarks
            The explicit numeric conversion may cause loss of precision or result in throwing an exception, typically
            an OverflowException.
            When you convert a value of an integral type to another integral type, the result depends on the
            overflow checking context. In a checked context, the conversion succeeds if the source value is within
            the range of the destination type. Otherwise, an OverflowException is thrown. In an unchecked context,
            the conversion always succeeds, and proceeds as follows:
            If the source type is larger than the destination type, then the source value is truncated by

            discarding its "extra" most significant bits. The result is then treated as a value of the destination
            type.
            If the source type is smaller than the destination type, then the source value is either signextended or zero-extended so that it is the same size as the destination type. Sign-extension is
            used if the source type is signed; zero-extension is used if the source type is unsigned. The result
            is then treated as a value of the destination type.
            If the source type is the same size as the destination type, then the source value is treated as a
            value of the destination type.
            When you convert a decimal value to an integral type, this value is rounded towards zero to the
            nearest integral value. If the resulting integral value is outside the range of the destination type, an
            OverflowException is thrown.
            When you convert a double or float value to an integral type, this value is rounded towards zero to
            the nearest integral value. If the resulting integral value is outside the range of the destination type, the
            result depends on the overflow checking context. In a checked context, an OverflowException is thrown,
            while in an unchecked context, the result is an unspecified value of the destination type.
            When you convert double to float , the double value is rounded to the nearest float value. If the
            double value is too small or too large to fit into the destination type, the result will be zero or infinity.
            When you convert float or double to decimal , the source value is converted to decimal
            representation and rounded to the nearest number after the 28th decimal place if required. Depending
            on the value of the source value, one of the following results may occur:
            If the source value is too small to be represented as a decimal , the result becomes zero.
            If the source value is NaN (not a number), infinity, or too large to be represented as a decimal ,
            an OverflowException is thrown.
            When you convert decimal to float or double , the decimal value is rounded to the nearest double
            or float value.
            For more information about explicit conversions, see the Explicit conversions section of the C# language
            specification.

            See also
            C# Reference
            C# Programming Guide
            Casting and type conversions
            () Operator
            Integral types table
            Floating-point types table
            Built-in types table
            Implicit numeric conversions table

            Formatting numeric results table (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The following table shows supported format specifiers for formatting numeric results. The formatted result in the
            last column corresponds to the "en-US" CultureInfo.
            FORMAT SPECIFIER

            DESCRIPTION

            EXAMPLES

            RESULT

            C or c

            Currency

            string s = $"{2.5:C}";

            $2.50

            string s = $"{-2.5:C}";

            ($2.50)

            D or d

            Decimal

            string s = $"{25:D5}";

            00025

            E or e

            Exponential

            string s = $"
            {250000:E2}";

            2.50E+005

            F or f

            Fixed-point

            string s = $"{2.5:F2}";

            2.50

            string s = $"{2.5:F0}";

            3

            G or g

            General

            string s = $"{2.5:G}";

            2.5

            N or n

            Numeric

            string s = $"
            {2500000:N}";

            2,500,000.00

            P or p

            Percent

            string s = $"{0.25:P}";

            25.00%

            R or r

            Round-trip

            string s = $"{2.5:R}";

            2.5

            X or x

            Hexadecimal

            string s = $"{250:X}";

            FA

            string s = $"
            {0xffff:X}";

            FFFF

            Remarks
            You use a format specifier to create a format string. The format string is of the following form: Axx , where
            A is the format specifier, which controls the type of formatting applied to the numeric value.
            xx is the precision specifier, which affects the number of digits in the formatted output. The value of the
            precision specifier ranges from 0 to 99.

            The decimal ("D" or "d") and hexadecimal ("X" or "x") format specifiers are supported only for integral types. The
            round-trip ("R" or "r") format specifier is supported only for Single, Double, and BigInteger types.
            Standard numeric format strings are supported by:
            Some overloads of the ToString method of all numeric types. For example, you can supply a numeric
            format string to the Int32.ToString(String) and Int32.ToString(String, IFormatProvider) methods.
            The .NET composite formatting feature, which is supported by the String.Format method, for example.

            Interpolated strings.
            For more information, see Standard Numeric Format Strings.

            See also
            C# Reference
            C# Programming Guide
            Reference tables for types
            Formatting types
            Composite formatting
            String interpolation
            string

            Modifiers (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Modifiers are used to modify declarations of types and type members. This section introduces the C# modifiers.
            MODIFIER

            PURPOSE

            Access Modifiers

            Specifies the declared accessibility of types and type
            members.

            - public
            - private
            - internal
            - protected
            abstract

            Indicates that a class is intended only to be a base class of
            other classes.

            async

            Indicates that the modified method, lambda expression, or
            anonymous method is asynchronous.

            const

            Specifies that the value of the field or the local variable
            cannot be modified.

            event

            Declares an event.

            extern

            Indicates that the method is implemented externally.

            new

            Explicitly hides a member inherited from a base class.

            override

            Provides a new implementation of a virtual member
            inherited from a base class.

            partial

            Defines partial classes, structs and methods throughout the
            same assembly.

            readonly

            Declares a field that can only be assigned values as part of
            the declaration or in a constructor in the same class.

            sealed

            Specifies that a class cannot be inherited.

            static

            Declares a member that belongs to the type itself instead of
            to a specific object.

            unsafe

            Declares an unsafe context.

            virtual

            Declares a method or an accessor whose implementation can
            be changed by an overriding member in a derived class.

            volatile

            Indicates that a field can be modified in the program by
            something such as the operating system, the hardware, or a
            concurrently executing thread.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords

            Access Modifiers (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Access modifiers are keywords used to specify the declared accessibility of a member or a type. This section
            introduces the four access modifiers:
            public
            protected
            internal
            private

            The following six accessibility levels can be specified using the access modifiers:
            public : Access is not restricted.
            protected : Access is limited to the containing class or types derived from the containing class.
            internal : Access is limited to the current assembly.
            protected internal : Access is limited to the current assembly or types derived from the containing class.
            private : Access is limited to the containing type.
            private protected : Access is limited to the containing class or types derived from the containing class

            within the current assembly.
            This section also introduces the following:
            Accessibility Levels: Using the four access modifiers to declare six levels of accessibility.
            Accessibility Domain: Specifies where, in the program sections, a member can be referenced.
            Restrictions on Using Accessibility Levels: A summary of the restrictions on using declared accessibility
            levels.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            Access Modifiers
            Access Keywords
            Modifiers

            Accessibility Levels (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Use the access modifiers, public , protected , internal , or private , to specify one of the following declared
            accessibility levels for members.
            DECLARED ACCESSIBILITY

            MEANING

            public

            Access is not restricted.

            protected

            Access is limited to the containing class or types derived from
            the containing class.

            internal

            Access is limited to the current assembly.

            protected internal

            Access is limited to the current assembly or types derived
            from the containing class.

            private

            Access is limited to the containing type.

            private protected

            Access is limited to the containing class or types derived from
            the containing class within the current assembly. Available
            since C# 7.2.

            Only one access modifier is allowed for a member or type, except when you use the protected internal or
            private protected combinations.
            Access modifiers are not allowed on namespaces. Namespaces have no access restrictions.
            Depending on the context in which a member declaration occurs, only certain declared accessibilities are
            permitted. If no access modifier is specified in a member declaration, a default accessibility is used.
            Top-level types, which are not nested in other types, can only have internal or public accessibility. The default
            accessibility for these types is internal .
            Nested types, which are members of other types, can have declared accessibilities as indicated in the following
            table.
            MEMBERS OF

            DEFAULT MEMBER ACCESSIBILITY

            ALLOWED DECLARED ACCESSIBILITY OF
            THE MEMBER

            enum

            public

            None

            MEMBERS OF

            DEFAULT MEMBER ACCESSIBILITY

            ALLOWED DECLARED ACCESSIBILITY OF
            THE MEMBER

            class

            private

            public
            protected
            internal
            private
            protected internal
            private protected

            interface

            public

            None

            struct

            private

            public
            internal
            private

            The accessibility of a nested type depends on its accessibility domain, which is determined by both the declared
            accessibility of the member and the accessibility domain of the immediately containing type. However, the
            accessibility domain of a nested type cannot exceed that of the containing type.

            C# Language Specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            Access Modifiers
            Accessibility Domain
            Restrictions on Using Accessibility Levels
            Access Modifiers
            public
            private
            protected
            internal

            Accessibility Domain (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The accessibility domain of a member specifies in which program sections a member can be referenced. If the
            member is nested within another type, its accessibility domain is determined by both the accessibility level of the
            member and the accessibility domain of the immediately containing type.
            The accessibility domain of a top-level type is at least the program text of the project that it is declared in. That is,
            the domain includes all of the source files of this project. The accessibility domain of a nested type is at least the
            program text of the type in which it is declared. That is, the domain is the type body, which includes all nested
            types. The accessibility domain of a nested type never exceeds that of the containing type. These concepts are
            demonstrated in the following example.

            Example
            This example contains a top-level type, T1 , and two nested classes, M1 and M2 . The classes contain fields that
            have different declared accessibilities. In the Main method, a comment follows each statement to indicate the
            accessibility domain of each member. Notice that the statements that try to reference the inaccessible members
            are commented out. If you want to see the compiler errors caused by referencing an inaccessible member, remove
            the comments one at a time.

            namespace AccessibilityDomainNamespace
            {
            public class T1
            {
            public static int publicInt;
            internal static int internalInt;
            private static int privateInt = 0;
            static T1()
            {
            // T1 can access public or internal members
            // in a public or private (or internal) nested class
            M1.publicInt = 1;
            M1.internalInt = 2;
            M2.publicInt = 3;
            M2.internalInt = 4;
            // Cannot access the private member privateInt
            // in either class:
            // M1.privateInt = 2; //CS0122
            }
            public class M1
            {
            public static int publicInt;
            internal static int internalInt;
            private static int privateInt = 0;
            }
            private class M2
            {
            public static int publicInt = 0;
            internal static int internalInt = 0;
            private static int privateInt = 0;
            }
            }

            class MainClass
            {
            static void Main()
            {
            // Access is unlimited:
            T1.publicInt = 1;
            // Accessible only in current assembly:
            T1.internalInt = 2;
            // Error CS0122: inaccessible outside T1:
            // T1.privateInt = 3;
            // Access is unlimited:
            T1.M1.publicInt = 1;
            // Accessible only in current assembly:
            T1.M1.internalInt = 2;
            // Error CS0122: inaccessible outside M1:
            //
            T1.M1.privateInt = 3;
            // Error CS0122: inaccessible outside T1:
            //
            T1.M2.publicInt = 1;
            // Error CS0122: inaccessible outside T1:
            //
            T1.M2.internalInt = 2;
            // Error CS0122: inaccessible outside M2:
            //
            T1.M2.privateInt = 3;
            // Keep the console open in debug mode.
            System.Console.WriteLine("Press any key to exit.");
            System.Console.ReadKey();
            }
            }
            }

            C# Language Specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            Access Modifiers
            Accessibility Levels
            Restrictions on Using Accessibility Levels
            Access Modifiers
            public
            private
            protected
            internal

            Restrictions on using accessibility levels (C#
            Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            When you specify a type in a declaration, check whether the accessibility level of the type is dependent on the
            accessibility level of a member or of another type. For example, the direct base class must be at least as accessible
            as the derived class. The following declarations cause a compiler error because the base class BaseClass is less
            accessible than MyClass :
            class BaseClass {...}
            public class MyClass: BaseClass {...} // Error

            The following table summarizes the restrictions on declared accessibility levels.
            CONTEX T

            REMARKS

            Classes

            The direct base class of a class type must be at least as
            accessible as the class type itself.

            Interfaces

            The explicit base interfaces of an interface type must be at
            least as accessible as the interface type itself.

            Delegates

            The return type and parameter types of a delegate type must
            be at least as accessible as the delegate type itself.

            Constants

            The type of a constant must be at least as accessible as the
            constant itself.

            Fields

            The type of a field must be at least as accessible as the field
            itself.

            Methods

            The return type and parameter types of a method must be at
            least as accessible as the method itself.

            Properties

            The type of a property must be at least as accessible as the
            property itself.

            Events

            The type of an event must be at least as accessible as the
            event itself.

            Indexers

            The type and parameter types of an indexer must be at least
            as accessible as the indexer itself.

            Operators

            The return type and parameter types of an operator must be
            at least as accessible as the operator itself.

            Constructors

            The parameter types of a constructor must be at least as
            accessible as the constructor itself.

            Example
            The following example contains erroneous declarations of different types. The comment following each
            declaration indicates the expected compiler error.
            // Restrictions on Using Accessibility Levels
            // CS0052 expected as well as CS0053, CS0056, and CS0057
            // To make the program work, change access level of both class B
            // and MyPrivateMethod() to public.
            using System;
            // A delegate:
            delegate int MyDelegate();
            class B
            {
            // A private method:
            static int MyPrivateMethod()
            {
            return 0;
            }
            }
            public class A
            {
            // Error: The type B is less accessible than the field A.myField.
            public B myField = new B();
            // Error: The type B is less accessible
            // than the constant A.myConst.
            public readonly B myConst = new B();
            public B MyMethod()
            {
            // Error: The type B is less accessible
            // than the method A.MyMethod.
            return new B();
            }
            // Error: The type B is less accessible than the property A.MyProp
            public B MyProp
            {
            set
            {
            }
            }
            MyDelegate d = new MyDelegate(B.MyPrivateMethod);
            // Even when B is declared public, you still get the error:
            // "The parameter B.MyPrivateMethod is not accessible due to
            // protection level."
            public static B operator +(A m1, B m2)
            {
            // Error: The type B is less accessible
            // than the operator A.operator +(A,B)
            return new B();
            }
            static void Main()
            {
            Console.Write("Compiled successfully");
            }
            }

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Access Modifiers
            Accessibility Domain
            Accessibility Levels
            Access Modifiers
            public
            private
            protected
            internal

            internal (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The internal keyword is an access modifier for types and type members.
            This page covers internal access. The internal keyword is also part of the protected internal access
            modifier.
            Internal types or members are accessible only within files in the same assembly, as in this example:
            public class BaseClass
            {
            // Only accessible within the same assembly
            internal static int x = 0;
            }

            For a comparison of internal with the other access modifiers, see Accessibility Levels and Access Modifiers.
            For more information about assemblies, see Assemblies and the Global Assembly Cache.
            A common use of internal access is in component-based development because it enables a group of
            components to cooperate in a private manner without being exposed to the rest of the application code. For
            example, a framework for building graphical user interfaces could provide Control and Form classes that
            cooperate by using members with internal access. Since these members are internal, they are not exposed to
            code that is using the framework.
            It is an error to reference a type or a member with internal access outside the assembly within which it was
            defined.

            Example
            This example contains two files, Assembly1.cs and Assembly1_a.cs . The first file contains an internal base class,
            BaseClass . In the second file, an attempt to instantiate BaseClass will produce an error.
            // Assembly1.cs
            // Compile with: /target:library
            internal class BaseClass
            {
            public static int intM = 0;
            }

            // Assembly1_a.cs
            // Compile with: /reference:Assembly1.dll
            class TestAccess
            {
            static void Main()
            {
            BaseClass myBase = new BaseClass();
            }
            }

            // CS0122

            Example
            In this example, use the same files you used in example 1, and change the accessibility level of BaseClass to
            public . Also change the accessibility level of the member IntM to internal . In this case, you can instantiate
            the class, but you cannot access the internal member.
            // Assembly2.cs
            // Compile with: /target:library
            public class BaseClass
            {
            internal static int intM = 0;
            }

            // Assembly2_a.cs
            // Compile with: /reference:Assembly2.dll
            public class TestAccess
            {
            static void Main()
            {
            BaseClass myBase = new BaseClass();
            BaseClass.intM = 444;
            // CS0117
            }
            }

            // Ok.

            C# Language Specification
            For more information, see Declared accessibility in the C# Language Specification. The language specification is
            the definitive source for C# syntax and usage.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            Access Modifiers
            Accessibility Levels
            Modifiers
            public
            private
            protected

            private (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The private keyword is a member access modifier.
            This page covers private access. The private keyword is also part of the private protected access
            modifier.
            Private access is the least permissive access level. Private members are accessible only within the body of the
            class or the struct in which they are declared, as in this example:
            class Employee
            {
            private int i;
            double d; // private access by default
            }

            Nested types in the same body can also access those private members.
            It is a compile-time error to reference a private member outside the class or the struct in which it is declared.
            For a comparison of private with the other access modifiers, see Accessibility Levels and Access Modifiers.

            Example
            In this example, the Employee class contains two private data members, name and salary . As private
            members, they cannot be accessed except by member methods. Public methods named GetName and Salary
            are added to allow controlled access to the private members. The name member is accessed by way of a public
            method, and the salary member is accessed by way of a public read-only property. (See Properties for more
            information.)

            class Employee2
            {
            private string name = "FirstName, LastName";
            private double salary = 100.0;
            public string GetName()
            {
            return name;
            }
            public double Salary
            {
            get { return salary; }
            }
            }
            class PrivateTest
            {
            static void Main()
            {
            Employee2 e = new Employee2();
            // The data members are inaccessible (private), so
            // they can't be accessed like this:
            //
            string n = e.name;
            //
            double s = e.salary;
            // 'name' is indirectly accessed via method:
            string n = e.GetName();
            // 'salary' is indirectly accessed via property
            double s = e.Salary;
            }
            }

            C# language specification
            For more information, see Declared accessibility in the C# Language Specification. The language specification is
            the definitive source for C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Access Modifiers
            Accessibility Levels
            Modifiers
            public
            protected
            internal

            protected (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The protected keyword is a member access modifier.
            This page covers protected access. The protected keyword is also part of the protected internal and
            private protected access modifiers.
            A protected member is accessible within its class and by derived class instances.
            For a comparison of protected with the other access modifiers, see Accessibility Levels.

            Example
            A protected member of a base class is accessible in a derived class only if the access occurs through the derived
            class type. For example, consider the following code segment:
            class A
            {
            protected int x = 123;
            }
            class B : A
            {
            static void Main()
            {
            A a = new A();
            B b = new B();
            // Error CS1540, because x can only be accessed by
            // classes derived from A.
            // a.x = 10;
            // OK, because this class derives from A.
            b.x = 10;
            }
            }

            The statement a.x = 10 generates an error because it is made within the static method Main, and not an
            instance of class B.
            Struct members cannot be protected because the struct cannot be inherited.

            Example
            In this example, the class DerivedPoint is derived from Point . Therefore, you can access the protected
            members of the base class directly from the derived class.

            class Point
            {
            protected int x;
            protected int y;
            }
            class DerivedPoint: Point
            {
            static void Main()
            {
            DerivedPoint dpoint = new DerivedPoint();
            // Direct access to protected members:
            dpoint.x = 10;
            dpoint.y = 15;
            Console.WriteLine("x = {0}, y = {1}", dpoint.x, dpoint.y);
            }
            }
            // Output: x = 10, y = 15

            If you change the access levels of x and y to private, the compiler will issue the error messages:
            'Point.y' is inaccessible due to its protection level.
            'Point.x' is inaccessible due to its protection level.

            C# language specification
            For more information, see Declared accessibility in the C# Language Specification. The language specification is
            the definitive source for C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Access Modifiers
            Accessibility Levels
            Modifiers
            public
            private
            internal
            Security concerns for internal virtual keywords

            public (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The public keyword is an access modifier for types and type members. Public access is the most permissive
            access level. There are no restrictions on accessing public members, as in this example:
            class SampleClass
            {
            public int x; // No access restrictions.
            }

            See Access Modifiers and Accessibility Levels for more information.

            Example
            In the following example, two classes are declared, PointTest and MainClass . The public members x and y
            of PointTest are accessed directly from MainClass .
            class PointTest
            {
            public int x;
            public int y;
            }
            class MainClass4
            {
            static void Main()
            {
            PointTest p = new PointTest();
            // Direct access to public members:
            p.x = 10;
            p.y = 15;
            Console.WriteLine("x = {0}, y = {1}", p.x, p.y);
            }
            }
            // Output: x = 10, y = 15

            If you change the public access level to private or protected, you will get the error message:
            'PointTest.y' is inaccessible due to its protection level.

            C# language specification
            For more information, see Declared accessibility in the C# Language Specification. The language specification is
            the definitive source for C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            Access Modifiers
            C# Keywords
            Access Modifiers

            Accessibility Levels
            Modifiers
            private
            protected
            internal

            protected internal (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The protected internal keyword combination is a member access modifier. A protected internal member is
            accessible from the current assembly or from types that are derived from the containing class. For a comparison
            of protected internal with the other access modifiers, see Accessibility Levels.

            Example
            A protected internal member of a base class is accessible from any type within its containing assembly. It is also
            accessible in a derived class located in another assembly only if the access occurs through a variable of the
            derived class type. For example, consider the following code segment:
            // Assembly1.cs
            // Compile with: /target:library
            public class BaseClass
            {
            protected internal int myValue = 0;
            }
            class TestAccess
            {
            void Access()
            {
            BaseClass baseObject = new BaseClass();
            baseObject.myValue = 5;
            }
            }

            // Assembly2.cs
            // Compile with: /reference:Assembly1.dll
            class DerivedClass : BaseClass
            {
            static void Main()
            {
            BaseClass baseObject = new BaseClass();
            DerivedClass derivedObject = new DerivedClass();
            // Error CS1540, because myValue can only be accessed by
            // classes derived from BaseClass.
            // baseObject.myValue = 10;
            // OK, because this class derives from BaseClass.
            derivedObject.myValue = 10;
            }
            }

            This example contains two files, Assembly1.cs and Assembly2.cs . The first file contains a public base class,
            BaseClass , and another class, TestAccess . BaseClass owns a protected internal member, myValue , which is
            accessed by the TestAccess type. In the second file, an attempt to access myValue through an instance of
            BaseClass will produce an error, while an access to this member through an instance of a derived class,
            DerivedClass will succeed.
            Struct members cannot be protected internal because the struct cannot be inherited.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Access Modifiers
            Accessibility Levels
            Modifiers
            public
            private
            internal
            Security concerns for internal virtual keywords

            private protected (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The private protected keyword combination is a member access modifier. A private protected member is
            accessible by types derived from the containing class, but only within its containing assembly. For a comparison
            of private protected with the other access modifiers, see Accessibility Levels.
            NOTE
            The private protected access modifier is valid in C# version 7.2 and later.

            Example
            A private protected member of a base class is accessible from derived types in its containing assembly only if the
            static type of the variable is the derived class type. For example, consider the following code segment:
            // Assembly1.cs
            // Compile with: /target:library
            public class BaseClass
            {
            private protected int myValue = 0;
            }
            public class DerivedClass1 : BaseClass
            {
            void Access()
            {
            BaseClass baseObject = new BaseClass();
            // Error CS1540, because myValue can only be accessed by
            // classes derived from BaseClass.
            // baseObject.myValue = 5;
            // OK, accessed through the current derived class instance
            myValue = 5;
            }
            }

            // Assembly2.cs
            // Compile with: /reference:Assembly1.dll
            class DerivedClass2 : BaseClass
            {
            void Access()
            {
            // Error CS0122, because myValue can only be
            // accessed by types in Assembly1
            // myValue = 10;
            }
            }

            This example contains two files, Assembly1.cs and Assembly2.cs . The first file contains a public base class,
            BaseClass , and a type derived from it, DerivedClass1 . BaseClass owns a private protected member, myValue ,
            which DerivedClass1 tries to access in two ways. The first attempt to access myValue through an instance of
            BaseClass will produce an error. However, the attempt to use it as an inherited member in DerivedClass1 will

            succeed. In the second file, an attempt to access myValue as an inherited member of DerivedClass2 will produce
            an error, as it is only accessible by derived types in Assembly1.
            Struct members cannot be private protected because the struct cannot be inherited.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Access Modifiers
            Accessibility Levels
            Modifiers
            public
            private
            internal
            Security concerns for internal virtual keywords

            abstract (C# Reference)
            12/11/2018 • 3 minutes to read • Edit Online

            The abstract modifier indicates that the thing being modified has a missing or incomplete implementation. The
            abstract modifier can be used with classes, methods, properties, indexers, and events. Use the abstract modifier
            in a class declaration to indicate that a class is intended only to be a base class of other classes. Members marked
            as abstract, or included in an abstract class, must be implemented by classes that derive from the abstract class.

            Example
            In this example, the class Square must provide an implementation of Area because it derives from ShapesClass :
            abstract class ShapesClass
            {
            abstract public int Area();
            }
            class Square : ShapesClass
            {
            int side = 0;
            public Square(int n)
            {
            side = n;
            }
            // Area method is required to avoid
            // a compile-time error.
            public override int Area()
            {
            return side * side;
            }
            static void Main()
            {
            Square sq = new Square(12);
            Console.WriteLine("Area of the square = {0}", sq.Area());
            }
            interface I
            {
            void M();
            }
            abstract class C : I
            {
            public abstract void M();
            }
            }
            // Output: Area of the square = 144

            Abstract classes have the following features:
            An abstract class cannot be instantiated.
            An abstract class may contain abstract methods and accessors.
            It is not possible to modify an abstract class with the sealed modifier because the two modifers have
            opposite meanings. The sealed modifier prevents a class from being inherited and the abstract modifier

            requires a class to be inherited.
            A non-abstract class derived from an abstract class must include actual implementations of all inherited
            abstract methods and accessors.
            Use the abstract modifier in a method or property declaration to indicate that the method or property does not
            contain implementation.
            Abstract methods have the following features:
            An abstract method is implicitly a virtual method.
            Abstract method declarations are only permitted in abstract classes.
            Because an abstract method declaration provides no actual implementation, there is no method body; the
            method declaration simply ends with a semicolon and there are no curly braces ({ }) following the
            signature. For example:
            public abstract void MyMethod();

            The implementation is provided by a method override, which is a member of a non-abstract class.
            It is an error to use the static or virtual modifiers in an abstract method declaration.
            Abstract properties behave like abstract methods, except for the differences in declaration and invocation syntax.
            It is an error to use the abstract modifier on a static property.
            An abstract inherited property can be overridden in a derived class by including a property declaration that
            uses the override modifier.
            For more information about abstract classes, see Abstract and Sealed Classes and Class Members.
            An abstract class must provide implementation for all interface members.
            An abstract class that implements an interface might map the interface methods onto abstract methods. For
            example:
            interface I
            {
            void M();
            }
            abstract class C : I
            {
            public abstract void M();
            }

            Example
            In this example, the class DerivedClass is derived from an abstract class BaseClass . The abstract class contains an
            abstract method, AbstractMethod , and two abstract properties, X and Y .

            abstract class BaseClass // Abstract class
            {
            protected int _x = 100;
            protected int _y = 150;
            public abstract void AbstractMethod(); // Abstract method
            public abstract int X
            { get; }
            public abstract int Y
            { get; }
            }
            class DerivedClass : BaseClass
            {
            public override void AbstractMethod()
            {
            _x++;
            _y++;
            }
            public override int X // overriding property
            {
            get
            {
            return _x + 10;
            }
            }
            public override int Y // overriding property
            {
            get
            {
            return _y + 10;
            }
            }
            static void Main()
            {
            DerivedClass o = new DerivedClass();
            o.AbstractMethod();
            Console.WriteLine("x = {0}, y = {1}", o.X, o.Y);
            }
            }
            // Output: x = 111, y = 161

            In the preceding example, if you attempt to instantiate the abstract class by using a statement like this:
            BaseClass bc = new BaseClass();

            // Error

            You will get an error saying that the compiler cannot create an instance of the abstract class 'BaseClass'.

            C# Language Specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See Also
            C# Reference
            C# Programming Guide
            Modifiers
            virtual
            override

            C# Keywords

            async (C# Reference)
            12/11/2018 • 4 minutes to read • Edit Online

            Use the async modifier to specify that a method, lambda expression, or anonymous method is asynchronous. If
            you use this modifier on a method or expression, it's referred to as an async method. The following example
            defines an async method named ExampleMethodAsync :
            public async Task<int> ExampleMethodAsync()
            {
            // . . . .
            }

            If you're new to asynchronous programming or do not understand how an async method uses the await
            keyword to do potentially long-running work without blocking the caller's thread, read the introduction in
            Asynchronous Programming with async and await. The following code is found inside an async method and calls
            the HttpClient.GetStringAsync method:
            string contents = await httpClient.GetStringAsync(requestUrl);

            An async method runs synchronously until it reaches its first await expression, at which point the method is
            suspended until the awaited task is complete. In the meantime, control returns to the caller of the method, as the
            example in the next section shows.
            If the method that the async keyword modifies doesn't contain an await expression or statement, the method
            executes synchronously. A compiler warning alerts you to any async methods that don't contain await
            statements, because that situation might indicate an error. See Compiler Warning (level 1) CS4014.
            The async keyword is contextual in that it's a keyword only when it modifies a method, a lambda expression, or
            an anonymous method. In all other contexts, it's interpreted as an identifier.

            Example
            The following example shows the structure and flow of control between an async event handler,
            StartButton_Click , and an async method, ExampleMethodAsync . The result from the async method is the number
            of characters of a web page. The code is suitable for a Windows Presentation Foundation (WPF ) app or Windows
            Store app that you create in Visual Studio; see the code comments for setting up the app.
            You can run this code in Visual Studio as a Windows Presentation Foundation (WPF ) app or a Windows Store
            app. You need a Button control named StartButton and a Textbox control named ResultsTextBox . Remember to
            set the names and handler so that you have something like this:
            <Button Content="Button" HorizontalAlignment="Left" Margin="88,77,0,0" VerticalAlignment="Top" Width="75"
            Click="StartButton_Click" Name="StartButton"/>
            <TextBox HorizontalAlignment="Left" Height="137" Margin="88,140,0,0" TextWrapping="Wrap"
            Text="&lt;Enter a URL&gt;" VerticalAlignment="Top" Width="310" Name="ResultsTextBox"/>

            To run the code as a WPF app:
            Paste this code into the MainWindow class in MainWindow.xaml.cs.
            Add a reference to System.Net.Http.

            Add a using directive for System.Net.Http.
            To run the code as a Windows Store app:
            Paste this code into the MainPage class in MainPage.xaml.cs.
            Add using directives for System.Net.Http and System.Threading.Tasks.
            private async void StartButton_Click(object sender, RoutedEventArgs e)
            {
            // ExampleMethodAsync returns a Task<int>, which means that the method
            // eventually produces an int result. However, ExampleMethodAsync returns
            // the Task<int> value as soon as it reaches an await.
            ResultsTextBox.Text += "\n";
            try
            {
            int length = await ExampleMethodAsync();
            // Note that you could put "await ExampleMethodAsync()" in the next line where
            // "length" is, but due to when '+=' fetches the value of ResultsTextBox, you
            // would not see the global side effect of ExampleMethodAsync setting the text.
            ResultsTextBox.Text += String.Format("Length: {0:N0}\n", length);
            }
            catch (Exception)
            {
            // Process the exception if one occurs.
            }
            }
            public async Task<int> ExampleMethodAsync()
            {
            var httpClient = new HttpClient();
            int exampleInt = (await httpClient.GetStringAsync("http://msdn.microsoft.com")).Length;
            ResultsTextBox.Text += "Preparing to finish ExampleMethodAsync.\n";
            // After the following return statement, any method that's awaiting
            // ExampleMethodAsync (in this case, StartButton_Click) can get the
            // integer result.
            return exampleInt;
            }
            // The example displays the following output:
            // Preparing to finish ExampleMethodAsync.
            // Length: 53292

            IMPORTANT
            For more information about tasks and the code that executes while waiting for a task, see Asynchronous Programming with
            async and await. For a full WPF example that uses similar elements, see Walkthrough: Accessing the Web by Using Async
            and Await.

            Return Types
            An async method can have the following return types:
            Task
            Task<TResult>
            void, which should only be used for event handlers.
            Starting with C# 7.0, any type that has an accessible GetAwaiter method. The
            System.Threading.Tasks.ValueTask<TResult> type is one such implementation. It is available by adding the
            NuGet package System.Threading.Tasks.Extensions .
            The async method can't declare any in, ref or out parameters, nor can it have a reference return value, but it can

            call methods that have such parameters.
            You specify Task<TResult> as the return type of an async method if the return statement of the method specifies
            an operand of type TResult . You use Task if no meaningful value is returned when the method is completed.
            That is, a call to the method returns a Task , but when the Task is completed, any await expression that's
            awaiting the Task evaluates to void .
            You use the void return type primarily to define event handlers, which require that return type. The caller of a
            void -returning async method can't await it and can't catch exceptions that the method throws.
            Starting with C# 7.0, you return another type, typically a value type, that has a GetAwaiter method to minimize
            memory allocations in performance-critical sections of code.
            For more information and examples, see Async Return Types.

            See Also
            AsyncStateMachineAttribute
            await
            Walkthrough: Accessing the Web by Using Async and Await
            Asynchronous Programming with async and await

            const (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            You use the const keyword to declare a constant field or a constant local. Constant fields and locals aren't
            variables and may not be modified. Constants can be numbers, Boolean values, strings, or a null reference. Don't
            create a constant to represent information that you expect to change at any time. For example, don't use a
            constant field to store the price of a service, a product version number, or the brand name of a company. These
            values can change over time, and because compilers propagate constants, other code compiled with your libraries
            will have to be recompiled to see the changes. See also the readonly keyword. For example:
            const int x = 0;
            public const double gravitationalConstant = 6.673e-11;
            private const string productName = "Visual C#";

            Remarks
            The type of a constant declaration specifies the type of the members that the declaration introduces. The initializer
            of a constant local or a constant field must be a constant expression that can be implicitly converted to the target
            type.
            A constant expression is an expression that can be fully evaluated at compile time. Therefore, the only possible
            values for constants of reference types are string and a null reference.
            The constant declaration can declare multiple constants, such as:
            public const double x = 1.0, y = 2.0, z = 3.0;

            The static modifier is not allowed in a constant declaration.
            A constant can participate in a constant expression, as follows:
            public const int c1 = 5;
            public const int c2 = c1 + 100;

            NOTE
            The readonly keyword differs from the const keyword. A const field can only be initialized at the declaration of the field.
            A readonly field can be initialized either at the declaration or in a constructor. Therefore, readonly fields can have
            different values depending on the constructor used. Also, although a const field is a compile-time constant, the
            readonly field can be used for run-time constants, as in this line:
            public static readonly uint l1 = (uint)DateTime.Now.Ticks;

            Example

            public class ConstTest
            {
            class SampleClass
            {
            public int x;
            public int y;
            public const int c1 = 5;
            public const int c2 = c1 + 5;
            public SampleClass(int p1, int p2)
            {
            x = p1;
            y = p2;
            }
            }
            static void Main()
            {
            SampleClass mC = new SampleClass(11, 22);
            Console.WriteLine("x = {0}, y = {1}", mC.x, mC.y);
            Console.WriteLine("c1 = {0}, c2 = {1}",
            SampleClass.c1, SampleClass.c2);
            }
            }
            /* Output
            x = 11, y = 22
            c1 = 5, c2 = 10
            */

            Example
            This example demonstrates how to use constants as local variables.
            public class SealedTest
            {
            static void Main()
            {
            const int c = 707;
            Console.WriteLine("My local constant = {0}", c);
            }
            }
            // Output: My local constant = 707

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Modifiers
            readonly

            event (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The event keyword is used to declare an event in a publisher class.

            Example
            The following example shows how to declare and raise an event that uses EventHandler as the underlying
            delegate type. For the complete code example that also shows how to use the generic
            EventHandler<TEventArgs> delegate type and how to subscribe to an event and create an event handler method,
            see How to: Publish Events that Conform to .NET Framework Guidelines.
            public class SampleEventArgs
            {
            public SampleEventArgs(string s) { Text = s; }
            public String Text { get; } // readonly
            }
            public class Publisher
            {
            // Declare the delegate (if using non-generic pattern).
            public delegate void SampleEventHandler(object sender, SampleEventArgs e);
            // Declare the event.
            public event SampleEventHandler SampleEvent;
            // Wrap the event in a protected virtual method
            // to enable derived classes to raise the event.
            protected virtual void RaiseSampleEvent()
            {
            // Raise the event by using the () operator.
            if (SampleEvent != null)
            SampleEvent(this, new SampleEventArgs("Hello"));
            }
            }

            Events are a special kind of multicast delegate that can only be invoked from within the class or struct where they
            are declared (the publisher class). If other classes or structs subscribe to the event, their event handler methods
            will be called when the publisher class raises the event. For more information and code examples, see Events and
            Delegates.
            Events can be marked as public, private, protected, internal, protected internal or private protected. These access
            modifiers define how users of the class can access the event. For more information, see Access Modifiers.

            Keywords and Events
            The following keywords apply to events.
            KEYWORD

            DESCRIPTION

            FOR MORE INFORMATION

            static

            Makes the event available to callers at
            any time, even if no instance of the
            class exists.

            Static Classes and Static Class Members

            KEYWORD

            DESCRIPTION

            FOR MORE INFORMATION

            virtual

            Allows derived classes to override the
            event behavior by using the override
            keyword.

            Inheritance

            sealed

            Specifies that for derived classes it is no
            longer virtual.

            abstract

            The compiler will not generate the
            add and remove event accessor
            blocks and therefore derived classes
            must provide their own
            implementation.

            An event may be declared as a static event by using the static keyword. This makes the event available to callers at
            any time, even if no instance of the class exists. For more information, see Static Classes and Static Class
            Members.
            An event can be marked as a virtual event by using the virtual keyword. This enables derived classes to override
            the event behavior by using the override keyword. For more information, see Inheritance. An event overriding a
            virtual event can also be sealed, which specifies that for derived classes it is no longer virtual. Lastly, an event can
            be declared abstract, which means that the compiler will not generate the add and remove event accessor blocks.
            Therefore derived classes must provide their own implementation.

            C# Language Specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            add
            remove
            Modifiers
            How to: Combine Delegates (Multicast Delegates)

            extern (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The extern modifier is used to declare a method that is implemented externally. A common use of the extern
            modifier is with the DllImport attribute when you are using Interop services to call into unmanaged code. In this
            case, the method must also be declared as static , as shown in the following example:
            [DllImport("avifil32.dll")]
            private static extern void AVIFileInit();

            The extern keyword can also define an external assembly alias, which makes it possible to reference different
            versions of the same component from within a single assembly. For more information, see extern alias.
            It is an error to use the abstract and extern modifiers together to modify the same member. Using the extern
            modifier means that the method is implemented outside the C# code, whereas using the abstract modifier
            means that the method implementation is not provided in the class.
            The extern keyword has more limited uses in C# than in C++. To compare the C# keyword with the C++ keyword,
            see Using extern to Specify Linkage in the C++ Language Reference.

            Example 1
            In this example, the program receives a string from the user and displays it inside a message box. The program
            uses the MessageBox method imported from the User32.dll library.
            //using System.Runtime.InteropServices;
            class ExternTest
            {
            [DllImport("User32.dll", CharSet=CharSet.Unicode)]
            public static extern int MessageBox(IntPtr h, string m, string c, int type);
            static int Main()
            {
            string myString;
            Console.Write("Enter your message: ");
            myString = Console.ReadLine();
            return MessageBox((IntPtr)0, myString, "My Message Box", 0);
            }
            }

            Example 2
            This example illustrates a C# program that calls into a C library (a native DLL ).
            1. Create the following C file and name it cmdll.c :

            // cmdll.c
            // Compile with: -LD
            int __declspec(dllexport) SampleMethod(int i)
            {
            return i*10;
            }

            2. Open a Visual Studio x64 (or x32) Native Tools Command Prompt window from the Visual Studio
            installation directory and compile the cmdll.c file by typing cl -LD cmdll.c at the command prompt.
            3. In the same directory, create the following C# file and name it cm.cs :
            // cm.cs
            using System;
            using System.Runtime.InteropServices;
            public class MainClass
            {
            [DllImport("Cmdll.dll")]
            public static extern int SampleMethod(int x);
            static void Main()
            {
            Console.WriteLine("SampleMethod() returns {0}.", SampleMethod(5));
            }
            }

            4. Open a Visual Studio x64 (or x32) Native Tools Command Prompt window from the Visual Studio installation
            directory and compile the cm.cs file by typing:
            csc cm.cs (for the x64 command prompt) —or— csc -platform:x86 cm.cs (for the x32 command prompt)
            This will create the executable file cm.exe .
            5. Run cm.exe . The SampleMethod method passes the value 5 to the DLL file, which returns the value multiplied
            by 10. The program produces the following output:
            SampleMethod() returns 50.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            DllImportAttribute
            C# Reference
            C# Programming Guide
            C# Keywords
            Modifiers

            in (Generic Modifier) (C# Reference)
            12/13/2018 • 2 minutes to read • Edit Online

            For generic type parameters, the in keyword specifies that the type parameter is contravariant. You can use the
            in keyword in generic interfaces and delegates.
            Contravariance enables you to use a less derived type than that specified by the generic parameter. This allows for
            implicit conversion of classes that implement contravariant interfaces and implicit conversion of delegate types.
            Covariance and contravariance in generic type parameters are supported for reference types, but they are not
            supported for value types.
            A type can be declared contravariant in a generic interface or delegate only if it defines the type of a method's
            parameters and not of a method's return type. In , ref , and out parameters must be invariant, meaning they are
            neither covariant or contravariant.
            An interface that has a contravariant type parameter allows its methods to accept arguments of less derived types
            than those specified by the interface type parameter. For example, in the IComparer<T> interface, type T is
            contravariant, you can assign an object of the IComparer<Person> type to an object of the IComparer<Employee> type
            without using any special conversion methods if Employee inherits Person .
            A contravariant delegate can be assigned another delegate of the same type, but with a less derived generic type
            parameter.
            For more information, see Covariance and Contravariance.

            Contravariant generic interface
            The following example shows how to declare, extend, and implement a contravariant generic interface. It also
            shows how you can use implicit conversion for classes that implement this interface.
            // Contravariant interface.
            interface IContravariant<in A> { }
            // Extending contravariant interface.
            interface IExtContravariant<in A> : IContravariant<A> { }
            // Implementing contravariant interface.
            class Sample<A> : IContravariant<A> { }
            class Program
            {
            static void Test()
            {
            IContravariant<Object> iobj = new Sample<Object>();
            IContravariant<String> istr = new Sample<String>();
            // You can assign iobj to istr because
            // the IContravariant interface is contravariant.
            istr = iobj;
            }
            }

            Contravariant generic delegate
            The following example shows how to declare, instantiate, and invoke a contravariant generic delegate. It also

            shows how you can implicitly convert a delegate type.
            // Contravariant delegate.
            public delegate void DContravariant<in A>(A argument);
            // Methods that match the delegate signature.
            public static void SampleControl(Control control)
            { }
            public static void SampleButton(Button button)
            { }
            public void Test()
            {
            // Instantiating the delegates with the methods.
            DContravariant<Control> dControl = SampleControl;
            DContravariant<Button> dButton = SampleButton;
            // You can assign dControl to dButton
            // because the DContravariant delegate is contravariant.
            dButton = dControl;
            // Invoke the delegate.
            dButton(new Button());
            }

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for C#
            syntax and usage.

            See also
            out
            Covariance and Contravariance
            Modifiers

            out (generic modifier) (C# Reference)
            12/13/2018 • 2 minutes to read • Edit Online

            For generic type parameters, the out keyword specifies that the type parameter is covariant. You can use the out
            keyword in generic interfaces and delegates.
            Covariance enables you to use a more derived type than that specified by the generic parameter. This allows for
            implicit conversion of classes that implement covariant interfaces and implicit conversion of delegate types.
            Covariance and contravariance are supported for reference types, but they are not supported for value types.
            An interface that has a covariant type parameter enables its methods to return more derived types than those
            specified by the type parameter. For example, because in .NET Framework 4, in IEnumerable<T>, type T is
            covariant, you can assign an object of the IEnumerable(Of String) type to an object of the IEnumerable(Of Object)
            type without using any special conversion methods.
            A covariant delegate can be assigned another delegate of the same type, but with a more derived generic type
            parameter.
            For more information, see Covariance and Contravariance.

            Example - covariant generic interface
            The following example shows how to declare, extend, and implement a covariant generic interface. It also shows
            how to use implicit conversion for classes that implement a covariant interface.
            // Covariant interface.
            interface ICovariant<out R> { }
            // Extending covariant interface.
            interface IExtCovariant<out R> : ICovariant<R> { }
            // Implementing covariant interface.
            class Sample<R> : ICovariant<R> { }
            class Program
            {
            static void Test()
            {
            ICovariant<Object> iobj = new Sample<Object>();
            ICovariant<String> istr = new Sample<String>();
            // You can assign istr to iobj because
            // the ICovariant interface is covariant.
            iobj = istr;
            }
            }

            In a generic interface, a type parameter can be declared covariant if it satisfies the following conditions:
            The type parameter is used only as a return type of interface methods and not used as a type of method
            arguments.

            NOTE
            There is one exception to this rule. If in a covariant interface you have a contravariant generic delegate as a method
            parameter, you can use the covariant type as a generic type parameter for this delegate. For more information about
            covariant and contravariant generic delegates, see Variance in Delegates and Using Variance for Func and Action
            Generic Delegates.

            The type parameter is not used as a generic constraint for the interface methods.

            Example - covariant generic delegate
            The following example shows how to declare, instantiate, and invoke a covariant generic delegate. It also shows
            how to implicitly convert delegate types.
            // Covariant delegate.
            public delegate R DCovariant<out R>();
            // Methods that match the delegate signature.
            public static Control SampleControl()
            { return new Control(); }
            public static Button SampleButton()
            { return new Button(); }
            public void Test()
            {
            // Instantiate the delegates with the methods.
            DCovariant<Control> dControl = SampleControl;
            DCovariant<Button> dButton = SampleButton;
            // You can assign dButton to dControl
            // because the DCovariant delegate is covariant.
            dControl = dButton;
            // Invoke the delegate.
            dControl();
            }

            In a generic delegate, a type can be declared covariant if it is used only as a method return type and not used for
            method arguments.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            Variance in Generic Interfaces
            in
            Modifiers

            override (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The override modifier is required to extend or modify the abstract or virtual implementation of an inherited
            method, property, indexer, or event.

            Example
            In this example, the Square class must provide an overridden implementation of Area because Area is
            inherited from the abstract ShapesClass :
            abstract class ShapesClass
            {
            abstract public int Area();
            }
            class Square : ShapesClass
            {
            int side = 0;
            public Square(int n)
            {
            side = n;
            }
            // Area method is required to avoid
            // a compile-time error.
            public override int Area()
            {
            return side * side;
            }
            static void Main()
            {
            Square sq = new Square(12);
            Console.WriteLine("Area of the square = {0}", sq.Area());
            }
            interface I
            {
            void M();
            }
            abstract class C : I
            {
            public abstract void M();
            }
            }
            // Output: Area of the square = 144

            An override method provides a new implementation of a member that is inherited from a base class. The
            method that is overridden by an override declaration is known as the overridden base method. The overridden
            base method must have the same signature as the override method. For information about inheritance, see
            Inheritance.
            You cannot override a non-virtual or static method. The overridden base method must be virtual , abstract , or
            override .

            An override declaration cannot change the accessibility of the virtual method. Both the override method
            and the virtual method must have the same access level modifier.
            You cannot use the new , static , or virtual modifiers to modify an override method.
            An overriding property declaration must specify exactly the same access modifier, type, and name as the
            inherited property, and the overridden property must be virtual , abstract , or override .
            For more information about how to use the override keyword, see Versioning with the Override and New
            Keywords and Knowing when to use Override and New Keywords.

            Example
            This example defines a base class named Employee , and a derived class named SalesEmployee . The
            SalesEmployee class includes an extra field, salesbonus , and overrides the method CalculatePay in order to take
            it into account.

            class TestOverride
            {
            public class Employee
            {
            public string name;
            // Basepay is defined as protected, so that it may be
            // accessed only by this class and derived classes.
            protected decimal basepay;
            // Constructor to set the name and basepay values.
            public Employee(string name, decimal basepay)
            {
            this.name = name;
            this.basepay = basepay;
            }
            // Declared virtual so it can be overridden.
            public virtual decimal CalculatePay()
            {
            return basepay;
            }
            }
            // Derive a new class from Employee.
            public class SalesEmployee : Employee
            {
            // New field that will affect the base pay.
            private decimal salesbonus;
            // The constructor calls the base-class version, and
            // initializes the salesbonus field.
            public SalesEmployee(string name, decimal basepay,
            decimal salesbonus) : base(name, basepay)
            {
            this.salesbonus = salesbonus;
            }
            // Override the CalculatePay method
            // to take bonus into account.
            public override decimal CalculatePay()
            {
            return basepay + salesbonus;
            }
            }
            static void Main()
            {
            // Create some new employees.
            SalesEmployee employee1 = new SalesEmployee("Alice",
            1000, 500);
            Employee employee2 = new Employee("Bob", 1200);
            Console.WriteLine("Employee4 " + employee1.name +
            " earned: " + employee1.CalculatePay());
            Console.WriteLine("Employee4 " + employee2.name +
            " earned: " + employee2.CalculatePay());
            }
            }
            /*
            Output:
            Employee4 Alice earned: 1500
            Employee4 Bob earned: 1200
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            Inheritance
            C# Keywords
            Modifiers
            abstract
            virtual
            new
            Polymorphism

            readonly (C# Reference)
            1/5/2019 • 3 minutes to read • Edit Online

            The readonly keyword is a modifier that can be used in three contexts:
            In a field declaration, readonly indicates that assignment to the field can only occur as part of the declaration
            or in a constructor in the same class.
            In a readonly struct definition, readonly indicates that the struct is immutable.
            In a ref readonly method return, the readonly modifier indicates that method returns a reference and writes
            are not allowed to that reference.
            The final two contexts were added in C# 7.2.

            Readonly field example
            In this example, the value of the field year cannot be changed in the method ChangeYear , even though it is
            assigned a value in the class constructor:
            class Age
            {
            readonly int year;
            Age(int year)
            {
            this.year = year;
            }
            void ChangeYear()
            {
            //year = 1967; // Compile error if uncommented.
            }
            }

            You can assign a value to a readonly field only in the following contexts:
            When the variable is initialized in the declaration, for example:
            public readonly int y = 5;

            In an instance constructor of the class that contains the instance field declaration.
            In the static constructor of the class that contains the static field declaration.
            These constructor contexts are also the only contexts in which it is valid to pass a readonly field as an out or ref
            parameter.
            NOTE
            The readonly keyword is different from the const keyword. A const field can only be initialized at the declaration of the
            field. A readonly field can be assigned multiple times in the field declaration and in any constructor. Therefore, readonly
            fields can have different values depending on the constructor used. Also, while a const field is a compile-time constant,
            the readonly field can be used for runtime constants as in the following example:

            public static readonly uint timeStamp = (uint)DateTime.Now.Ticks;

            class SampleClass
            {
            public int x;
            // Initialize a readonly field
            public readonly int y = 25;
            public readonly int z;
            public SampleClass()
            {
            // Initialize a readonly instance field
            z = 24;
            }
            public SampleClass(int p1, int p2, int p3)
            {
            x = p1;
            y = p2;
            z = p3;
            }
            public static void Main()
            {
            SampleClass p1 = new SampleClass(11, 21, 32); // OK
            Console.WriteLine($"p1: x={p1.x}, y={p1.y}, z={p1.z}");
            SampleClass p2 = new SampleClass();
            p2.x = 55; // OK
            Console.WriteLine($"p2: x={p2.x}, y={p2.y}, z={p2.z}");
            }
            /*
            Output:
            p1: x=11, y=21, z=32
            p2: x=55, y=25, z=24
            */
            }

            In the preceding example, if you use a statement like the following example:
            p2.y = 66; // Error

            you will get the compiler error message:
            A readonly field cannot be assigned to (except in a constructor or a variable initializer)

            Readonly struct example
            The readonly modifier on a struct definition declares that the struct is immutable. Every instance field of the
            struct must be marked readonly , as shown in the following example:
            public readonly struct Point
            {
            public double X { get; }
            public double Y { get; }
            public Point(double x, double y) => (X, Y) = (x, y);
            public override string ToString() => $"({X}, {Y})";
            }

            The preceding example uses readonly auto properties to declare its storage. That instructs the compiler to create

            readonly backing fields for those properties. You could also declare readonly fields directly:

            public readonly struct Point
            {
            public readonly double X;
            public readonly double Y;
            public Point(double x, double y) => (X, Y) = (x, y);
            public override string ToString() => $"({X}, {Y})";
            }

            Adding a field not marked readonly generates compiler error CS8340 : "Instance fields of readonly structs must
            be readonly."

            Ref readonly return example
            The readonly modifier on a ref return indicates that the returned reference cannot be modified. The following
            example returns a reference to the origin. It uses the readonly modifier to indicate that callers cannot modify the
            origin:
            private static readonly Point origin = new Point(0, 0);
            public static ref readonly Point Origin => ref origin;

            The type returned doesn't need to be a readonly struct . Any type that can be returned by ref can be returned
            by ref readonly

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Modifiers
            const
            Fields

            sealed (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            When applied to a class, the sealed modifier prevents other classes from inheriting from it. In the following
            example, class B inherits from class A , but no class can inherit from class B .
            class A {}
            sealed class B : A {}

            You can also use the sealed modifier on a method or property that overrides a virtual method or property in a
            base class. This enables you to allow classes to derive from your class and prevent them from overriding specific
            virtual methods or properties.

            Example
            In the following example, Z inherits from Y but Z cannot override the virtual function F that is declared in X
            and sealed in Y .
            class X
            {
            protected virtual void F() { Console.WriteLine("X.F"); }
            protected virtual void F2() { Console.WriteLine("X.F2"); }
            }
            class Y : X
            {
            sealed protected override void F() { Console.WriteLine("Y.F"); }
            protected override void F2() { Console.WriteLine("Y.F2"); }
            }
            class Z : Y
            {
            // Attempting to override F causes compiler error CS0239.
            // protected override void F() { Console.WriteLine("Z.F"); }
            // Overriding F2 is allowed.
            protected override void F2() { Console.WriteLine("Z.F2"); }
            }

            When you define new methods or properties in a class, you can prevent deriving classes from overriding them by
            not declaring them as virtual.
            It is an error to use the abstract modifier with a sealed class, because an abstract class must be inherited by a class
            that provides an implementation of the abstract methods or properties.
            When applied to a method or property, the sealed modifier must always be used with override.
            Because structs are implicitly sealed, they cannot be inherited.
            For more information, see Inheritance.
            For more examples, see Abstract and Sealed Classes and Class Members.

            Example

            sealed class SealedClass
            {
            public int x;
            public int y;
            }
            class SealedTest2
            {
            static void Main()
            {
            SealedClass sc = new SealedClass();
            sc.x = 110;
            sc.y = 150;
            Console.WriteLine("x = {0}, y = {1}", sc.x, sc.y);
            }
            }
            // Output: x = 110, y = 150

            In the previous example, you might try to inherit from the sealed class by using the following statement:
            class MyDerivedC: SealedClass {} // Error

            The result is an error message:
            'MyDerivedC': cannot derive from sealed type 'SealedClass'

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            Remarks
            To determine whether to seal a class, method, or property, you should generally consider the following two points:
            The potential benefits that deriving classes might gain through the ability to customize your class.
            The potential that deriving classes could modify your classes in such a way that they would no longer work
            correctly or as expected.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Static Classes and Static Class Members
            Abstract and Sealed Classes and Class Members
            Access Modifiers
            Modifiers
            override
            virtual

            static (C# Reference)
            12/11/2018 • 3 minutes to read • Edit Online

            Use the static modifier to declare a static member, which belongs to the type itself rather than to a specific
            object. The static modifier can be used with classes, fields, methods, properties, operators, events, and
            constructors, but it cannot be used with indexers, finalizers, or types other than classes. For more information, see
            Static Classes and Static Class Members.

            Example
            The following class is declared as static and contains only static methods:
            static class CompanyEmployee
            {
            public static void DoSomething() { /*...*/ }
            public static void DoSomethingElse() { /*...*/ }
            }

            A constant or type declaration is implicitly a static member.
            A static member cannot be referenced through an instance. Instead, it is referenced through the type name. For
            example, consider the following class:
            public class MyBaseC
            {
            public struct MyStruct
            {
            public static int x = 100;
            }
            }

            To refer to the static member x , use the fully qualified name, MyBaseC.MyStruct.x , unless the member is
            accessible from the same scope:
            Console.WriteLine(MyBaseC.MyStruct.x);

            While an instance of a class contains a separate copy of all instance fields of the class, there is only one copy of
            each static field.
            It is not possible to use this to reference static methods or property accessors.
            If the static keyword is applied to a class, all the members of the class must be static.
            Classes and static classes may have static constructors. Static constructors are called at some point between when
            the program starts and the class is instantiated.
            NOTE
            The static keyword has more limited uses than in C++. To compare with the C++ keyword, see Storage classes (C++).

            To demonstrate static members, consider a class that represents a company employee. Assume that the class

            contains a method to count employees and a field to store the number of employees. Both the method and the
            field do not belong to any instance employee. Instead they belong to the company class. Therefore, they should be
            declared as static members of the class.

            Example
            This example reads the name and ID of a new employee, increments the employee counter by one, and displays
            the information for the new employee and the new number of employees. For simplicity, this program reads the
            current number of employees from the keyboard. In a real application, this information should be read from a file.

            public class Employee4
            {
            public string id;
            public string name;
            public Employee4()
            {
            }
            public Employee4(string name, string id)
            {
            this.name = name;
            this.id = id;
            }
            public static int employeeCounter;
            public static int AddEmployee()
            {
            return ++employeeCounter;
            }
            }
            class MainClass : Employee4
            {
            static void Main()
            {
            Console.Write("Enter the employee's name: ");
            string name = Console.ReadLine();
            Console.Write("Enter the employee's ID: ");
            string id = Console.ReadLine();
            // Create and configure the employee object:
            Employee4 e = new Employee4(name, id);
            Console.Write("Enter the current number of employees: ");
            string n = Console.ReadLine();
            Employee4.employeeCounter = Int32.Parse(n);
            Employee4.AddEmployee();
            // Display the new information:
            Console.WriteLine("Name: {0}", e.name);
            Console.WriteLine("ID: {0}", e.id);
            Console.WriteLine("New Number of Employees: {0}",
            Employee4.employeeCounter);
            }
            }
            /*
            Input:
            Matthias Berndt
            AF643G
            15
            *
            Sample Output:
            Enter the employee's name: Matthias Berndt
            Enter the employee's ID: AF643G
            Enter the current number of employees: 15
            Name: Matthias Berndt
            ID: AF643G
            New Number of Employees: 16
            */

            Example
            This example shows that although you can initialize a static field by using another static field not yet declared, the
            results will be undefined until you explicitly assign a value to the static field.

            class Test
            {
            static int x = y;
            static int y = 5;
            static void Main()
            {
            Console.WriteLine(Test.x);
            Console.WriteLine(Test.y);
            Test.x = 99;
            Console.WriteLine(Test.x);
            }
            }
            /*
            Output:
            0
            5
            99
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Modifiers
            Static Classes and Static Class Members

            unsafe (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The unsafe keyword denotes an unsafe context, which is required for any operation involving pointers. For more
            information, see Unsafe Code and Pointers.
            You can use the unsafe modifier in the declaration of a type or a member. The entire textual extent of the type or
            member is therefore considered an unsafe context. For example, the following is a method declared with the
            unsafe modifier:
            unsafe static void FastCopy(byte[] src, byte[] dst, int count)
            {
            // Unsafe context: can use pointers here.
            }

            The scope of the unsafe context extends from the parameter list to the end of the method, so pointers can also be
            used in the parameter list:
            unsafe static void FastCopy ( byte* ps, byte* pd, int count ) {...}

            You can also use an unsafe block to enable the use of an unsafe code inside this block. For example:
            unsafe
            {
            // Unsafe context: can use pointers here.
            }

            To compile unsafe code, you must specify the /unsafe compiler option. Unsafe code is not verifiable by the
            common language runtime.

            Example
            // compile with: -unsafe
            class UnsafeTest
            {
            // Unsafe method: takes pointer to int:
            unsafe static void SquarePtrParam(int* p)
            {
            *p *= *p;
            }
            unsafe static void Main()
            {
            int i = 5;
            // Unsafe method: uses address-of operator (&):
            SquarePtrParam(&i);
            Console.WriteLine(i);
            }
            }
            // Output: 25

            C# language specification
            For more information, see Unsafe code in the C# Language Specification. The language specification is the
            definitive source for C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            fixed Statement
            Unsafe Code and Pointers
            Fixed Size Buffers

            virtual (C# Reference)
            12/19/2018 • 3 minutes to read • Edit Online

            The virtual keyword is used to modify a method, property, indexer, or event declaration and allow for it to be
            overridden in a derived class. For example, this method can be overridden by any class that inherits it:
            public virtual double Area()
            {
            return x * y;
            }

            The implementation of a virtual member can be changed by an overriding member in a derived class. For more
            information about how to use the virtual keyword, see Versioning with the Override and New Keywords and
            Knowing When to Use Override and New Keywords.

            Remarks
            When a virtual method is invoked, the run-time type of the object is checked for an overriding member. The
            overriding member in the most derived class is called, which might be the original member, if no derived class
            has overridden the member.
            By default, methods are non-virtual. You cannot override a non-virtual method.
            You cannot use the virtual modifier with the static , abstract , private , or override modifiers. The
            following example shows a virtual property:

            class MyBaseClass
            {
            // virtual auto-implemented property. Overrides can only
            // provide specialized behavior if they implement get and set accessors.
            public virtual string Name { get; set; }
            // ordinary virtual property with backing field
            private int num;
            public virtual int Number
            {
            get { return num; }
            set { num = value; }
            }
            }
            class MyDerivedClass : MyBaseClass
            {
            private string name;
            // Override auto-implemented property with ordinary property
            // to provide specialized accessor behavior.
            public override string Name
            {
            get
            {
            return name;
            }
            set
            {
            if (value != String.Empty)
            {
            name = value;
            }
            else
            {
            name = "Unknown";
            }
            }
            }
            }

            Virtual properties behave like abstract methods, except for the differences in declaration and invocation syntax.
            It is an error to use the virtual modifier on a static property.
            A virtual inherited property can be overridden in a derived class by including a property declaration that
            uses the override modifier.

            Example
            In this example, the Shape class contains the two coordinates x , y , and the Area() virtual method. Different
            shape classes such as Circle , Cylinder , and Sphere inherit the Shape class, and the surface area is calculated
            for each figure. Each derived class has its own override implementation of Area() .
            Notice that the inherited classes Circle , Sphere , and Cylinder all use constructors that initialize the base class,
            as shown in the following declaration.
            public Cylinder(double r, double h): base(r, h) {}

            The following program calculates and displays the appropriate area for each figure by invoking the appropriate
            implementation of the Area() method, according to the object that is associated with the method.

            class TestClass
            {
            public class Shape
            {
            public const double PI = Math.PI;
            protected double x, y;
            public Shape()
            {
            }
            public Shape(double x, double y)
            {
            this.x = x;
            this.y = y;
            }
            public virtual double Area()
            {
            return x * y;
            }
            }
            public class Circle : Shape
            {
            public Circle(double r) : base(r, 0)
            {
            }
            public override double Area()
            {
            return PI * x * x;
            }
            }
            class Sphere : Shape
            {
            public Sphere(double r) : base(r, 0)
            {
            }
            public override double Area()
            {
            return 4 * PI * x * x;
            }
            }
            class Cylinder : Shape
            {
            public Cylinder(double r, double h) : base(r, h)
            {
            }
            public override double Area()
            {
            return 2 * PI * x * x + 2 * PI * x * y;
            }
            }
            static void Main()
            {
            double r = 3.0, h = 5.0;
            Shape c = new Circle(r);
            Shape s = new Sphere(r);
            Shape l = new Cylinder(r, h);
            // Display results:
            Console.WriteLine("Area of Circle
            Console.WriteLine("Area of Sphere

            = {0:F2}", c.Area());
            = {0:F2}", s.Area());

            Console.WriteLine("Area of Cylinder = {0:F2}", l.Area());
            }
            }
            /*
            Output:
            Area of Circle = 28.27
            Area of Sphere = 113.10
            Area of Cylinder = 150.80
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            Modifiers
            C# Keywords
            Polymorphism
            abstract
            override
            new

            volatile (C# Reference)
            12/19/2018 • 3 minutes to read • Edit Online

            The volatile keyword indicates that a field might be modified by multiple threads that are executing at the same
            time. The compiler, the runtime system, and even hardware may rearrange reads and writes to memory locations
            for performance reasons. Fields that are declared volatile are not subject to these optimizations. Adding the
            volatile modifier ensures that all threads will observe volatile writes performed by any other thread in the order
            in which they were performed. There is no guarantee of a single total ordering of volatile writes as seen from all
            threads of execution.
            The volatile keyword can be applied to fields of these types:
            Reference types.
            Pointer types (in an unsafe context). Note that although the pointer itself can be volatile, the object that it points
            to cannot. In other words, you cannot declare a "pointer to volatile."
            Simple types such as sbyte , byte , short , ushort , int , uint , char , float , and bool .
            An enum type with one of the following base types: byte , sbyte , short , ushort , int , or uint .
            Generic type parameters known to be reference types.
            IntPtr and UIntPtr.
            Other types, including double and long , cannot be marked volatile because reads and writes to fields of those
            types cannot be guaranteed to be atomic. To protect multi-threaded access to those types of fields, use the
            Interlocked class members or protect access using the lock statement.
            The volatile keyword can only be applied to fields of a class or struct . Local variables cannot be declared
            volatile .

            Example
            The following example shows how to declare a public field variable as volatile .
            class VolatileTest
            {
            public volatile int sharedStorage;
            public void Test(int _i)
            {
            sharedStorage = _i;
            }
            }

            The following example demonstrates how an auxiliary or worker thread can be created and used to perform
            processing in parallel with that of the primary thread. For more information about multithreading, see Managed
            Threading.

            public class Worker
            {
            // This method is called when the thread is started.
            public void DoWork()
            {
            while (!_shouldStop)
            {
            Console.WriteLine("Worker thread: working...");
            }
            Console.WriteLine("Worker thread: terminating gracefully.");
            }
            public void RequestStop()
            {
            _shouldStop = true;
            }
            // Keyword volatile is used as a hint to the compiler that this data
            // member is accessed by multiple threads.
            private volatile bool _shouldStop;
            }
            public class WorkerThreadExample
            {
            public static void Main()
            {
            // Create the worker thread object. This does not start the thread.
            Worker workerObject = new Worker();
            Thread workerThread = new Thread(workerObject.DoWork);
            // Start the worker thread.
            workerThread.Start();
            Console.WriteLine("Main thread: starting worker thread...");
            // Loop until the worker thread activates.
            while (!workerThread.IsAlive)
            ;
            // Put the main thread to sleep for 1 millisecond to
            // allow the worker thread to do some work.
            Thread.Sleep(1);
            // Request that the worker thread stop itself.
            workerObject.RequestStop();
            // Use the Thread.Join method to block the current thread
            // until the object's thread terminates.
            workerThread.Join();
            Console.WriteLine("Main thread: worker thread has terminated.");
            }
            // Sample output:
            // Main thread: starting worker thread...
            // Worker thread: working...
            // Worker thread: working...
            // Worker thread: working...
            // Worker thread: working...
            // Worker thread: working...
            // Worker thread: working...
            // Worker thread: terminating gracefully.
            // Main thread: worker thread has terminated.
            }

            With the volatile modifier added to the declaration of _shouldStop in place, you'll always get the same results
            (similar to the excerpt shown in the preceding code). However, without that modifier on the _shouldStop member,
            the behavior is unpredictable. The DoWork method may optimize the member access, resulting in reading stale
            data. Because of the nature of multi-threaded programming, the number of stale reads is unpredictable. Different
            runs of the program will produce somewhat different results.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# language specification: volatile keyword
            C# Reference
            C# Programming Guide
            C# Keywords
            Modifiers
            lock statement
            Interlocked class

            Statement keywords (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Statements are program instructions. Except as described in the topics referenced in the following table,
            statements are executed in sequence. The following table lists the C# statement keywords. For more information
            about statements that are not expressed with any keyword, see Statements.
            CATEGORY

            C# KEYWORDS

            Selection statements

            if, else, switch, case

            Iteration statements

            do, for, foreach, in, while

            Jump statements

            break, continue, default, goto, return, yield

            Exception handling statements

            throw, try-catch, try-finally, try-catch-finally

            Checked and unchecked

            checked, unchecked

            fixed statement

            fixed

            lock statement

            lock

            See Also
            C# Reference
            Statements
            C# Keywords

            Selection statements (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            A selection statement causes the program control to be transferred to a specific flow based upon whether a certain
            condition is true or not.
            The following keywords are used in selection statements:
            if
            else
            switch
            case
            default

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Statement Keywords

            if-else (C# Reference)
            1/8/2019 • 5 minutes to read • Edit Online

            An if statement identifies which statement to run based on the value of a Boolean expression. In the following
            example, the bool variable condition is set to true and then checked in the if statement. The output is
            The variable is set to true. .
            bool condition = true;
            if (condition)
            {
            Console.WriteLine("The variable is set to true.");
            }
            else
            {
            Console.WriteLine("The variable is set to false.");
            }

            You can run the examples in this topic by placing them in the Main method of a console app.
            An if statement in C# can take two forms, as the following example shows.
            // if-else statement
            if (condition)
            {
            then-statement;
            }
            else
            {
            else-statement;
            }
            // Next statement in the program.
            // if statement without an else
            if (condition)
            {
            then-statement;
            }
            // Next statement in the program.

            In an if-else statement, if condition evaluates to true, the then-statement runs. If condition is false, the
            else-statement runs. Because condition can't be simultaneously true and false, the then-statement and the
            else-statement of an if-else statement can never both run. After the then-statement or the else-statement
            runs, control is transferred to the next statement after the if statement.
            In an if statement that doesn't include an else statement, if condition is true, the then-statement runs. If
            condition is false, control is transferred to the next statement after the if statement.
            Both the then-statement and the else-statement can consist of a single statement or multiple statements that
            are enclosed in braces ( {} ). For a single statement, the braces are optional but recommended.
            The statement or statements in the then-statement and the else-statement can be of any kind, including
            another if statement nested inside the original if statement. In nested if statements, each else clause
            belongs to the last if that doesn't have a corresponding else . In the following example, Result1 appears if
            both m > 10 and n > 20 evaluate to true. If m > 10 is true but n > 20 is false, Result2 appears.

            // Try with m = 12 and then with m = 8.
            int m = 12;
            int n = 18;
            if (m > 10)
            if (n > 20)
            {
            Console.WriteLine("Result1");
            }
            else
            {
            Console.WriteLine("Result2");
            }

            If, instead, you want Result2 to appear when (m > 10) is false, you can specify that association by using braces
            to establish the start and end of the nested if statement, as the following example shows.
            // Try with m = 12 and then with m = 8.
            if (m > 10)
            {
            if (n > 20)
            Console.WriteLine("Result1");
            }
            else
            {
            Console.WriteLine("Result2");
            }

            Result2 appears if the condition (m > 10) evaluates to false.

            Example
            In the following example, you enter a character from the keyboard, and the program uses a nested if statement
            to determine whether the input character is an alphabetic character. If the input character is an alphabetic
            character, the program checks whether the input character is lowercase or uppercase. A message appears for
            each case.

            Console.Write("Enter a character: ");
            char c = (char)Console.Read();
            if (Char.IsLetter(c))
            {
            if (Char.IsLower(c))
            {
            Console.WriteLine("The character is lowercase.");
            }
            else
            {
            Console.WriteLine("The character is uppercase.");
            }
            }
            else
            {
            Console.WriteLine("The character isn't an alphabetic character.");
            }
            //Sample Output:
            //Enter a character: 2
            //The character isn't an alphabetic character.
            //Enter a character: A
            //The character is uppercase.
            //Enter a character: h
            //The character is lowercase.

            Example
            You also can nest an if statement inside an else block, as the following partial code shows. The example nests
            if statements inside two else blocks and one then block. The comments specify which conditions are true or
            false in each block.

            // Change the values of these variables to test the results.
            bool Condition1 = true;
            bool Condition2 = true;
            bool Condition3 = true;
            bool Condition4 = true;
            if (Condition1)
            {
            // Condition1 is true.
            }
            else if (Condition2)
            {
            // Condition1 is false and Condition2 is true.
            }
            else if (Condition3)
            {
            if (Condition4)
            {
            // Condition1 and Condition2 are false. Condition3 and Condition4 are true.
            }
            else
            {
            // Condition1, Condition2, and Condition4 are false. Condition3 is true.
            }
            }
            else
            {
            // Condition1, Condition2, and Condition3 are false.
            }

            Example
            The following example determines whether an input character is a lowercase letter, an uppercase letter, or a
            number. If all three conditions are false, the character isn't an alphanumeric character. The example displays a
            message for each case.

            Console.Write("Enter a character: ");
            char ch = (char)Console.Read();
            if (Char.IsUpper(ch))
            {
            Console.WriteLine("The character is an uppercase letter.");
            }
            else if (Char.IsLower(ch))
            {
            Console.WriteLine("The character is a lowercase letter.");
            }
            else if (Char.IsDigit(ch))
            {
            Console.WriteLine("The character is a number.");
            }
            else
            {
            Console.WriteLine("The character is not alphanumeric.");
            }
            //Sample Input and Output:
            //Enter a character: E
            //The character is an uppercase letter.
            //Enter a character: e
            //The character is a lowercase letter.
            //Enter a character: 4
            //The character is a number.
            //Enter a character: =
            //The character is not alphanumeric.

            Just as a statement in the else block or the then block can be any valid statement, you can use any valid Boolean
            expression for the condition. You can use logical operators such as &&, &, ||, | and ! to make compound
            conditions. The following code shows examples.

            // NOT
            bool result = true;
            if (!result)
            {
            Console.WriteLine("The condition is true (result is false).");
            }
            else
            {
            Console.WriteLine("The condition is false (result is true).");
            }
            // Short-circuit AND
            int m = 9;
            int n = 7;
            int p = 5;
            if (m >= n && m >= p)
            {
            Console.WriteLine("Nothing is larger than m.");
            }
            // AND and NOT
            if (m >= n && !(p > m))
            {
            Console.WriteLine("Nothing is larger than m.");
            }
            // Short-circuit OR
            if (m > n || m > p)
            {
            Console.WriteLine("m isn't the smallest.");
            }
            // NOT and OR
            m = 4;
            if (!(m >= n || m >= p))
            {
            Console.WriteLine("Now m is the smallest.");
            }
            // Output:
            // The condition is false (result is true).
            // Nothing is larger than m.
            // Nothing is larger than m.
            // m isn't the smallest.
            // Now m is the smallest.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            ?: Operator
            if-else Statement (C++)
            switch

            switch (C# reference)
            1/8/2019 • 15 minutes to read • Edit Online

            switch is a selection statement that chooses a single switch section to execute from a list of candidates based

            on a pattern match with the match expression.
            using System;
            public class Example
            {
            public static void Main()
            {
            int caseSwitch = 1;
            switch (caseSwitch)
            {
            case 1:
            Console.WriteLine("Case 1");
            break;
            case 2:
            Console.WriteLine("Case 2");
            break;
            default:
            Console.WriteLine("Default case");
            break;
            }
            }
            }
            // The example displays the following output:
            //
            Case 1

            The switch statement is often used as an alternative to an if-else construct if a single expression is tested
            against three or more conditions. For example, the following switch statement determines whether a variable
            of type Color has one of three values:

            using System;
            public enum Color { Red, Green, Blue }
            public class Example
            {
            public static void Main()
            {
            Color c = (Color) (new Random()).Next(0, 3);
            switch (c)
            {
            case Color.Red:
            Console.WriteLine("The color is red");
            break;
            case Color.Green:
            Console.WriteLine("The color is green");
            break;
            case Color.Blue:
            Console.WriteLine("The color is blue");
            break;
            default:
            Console.WriteLine("The color is unknown.");
            break;
            }
            }
            }

            It is equivalent to the following example that uses an if - else construct.
            using System;
            public enum Color { Red, Green, Blue }
            public class Example
            {
            public static void Main()
            {
            Color c = (Color) (new Random()).Next(0, 3);
            if (c == Color.Red)
            Console.WriteLine("The color is red");
            else if (c == Color.Green)
            Console.WriteLine("The color is green");
            else if (c == Color.Blue)
            Console.WriteLine("The color is blue");
            else
            Console.WriteLine("The color is unknown.");
            }
            }
            // The example displays the following output:
            //
            The color is red

            The match expression
            The match expression provides the value to match against the patterns in case labels. Its syntax is:
            switch (expr)

            In C# 6, the match expression must be an expression that returns a value of the following types:
            a char.
            a string.

            a bool.
            an integral value, such as an int or a long.
            an enum value.
            Starting with C# 7.0, the match expression can be any non-null expression.

            The switch section
            A switch statement includes one or more switch sections. Each switch section contains one or more case
            labels (either a case or default label) followed by one or more statements. The switch statement may include
            at most one default label placed in any switch section. The following example shows a simple switch
            statement that has three switch sections, each containing two statements. The second switch section contains
            the case 2: and case 3: labels.
            A switch statement can include any number of switch sections, and each section can have one or more case
            labels, as shown in the following example. However, no two case labels may contain the same expression.
            using System;
            public class Example
            {
            public static void Main()
            {
            Random rnd = new Random();
            int caseSwitch = rnd.Next(1,4);
            switch (caseSwitch)
            {
            case 1:
            Console.WriteLine("Case 1");
            break;
            case 2:
            case 3:
            Console.WriteLine($"Case {caseSwitch}");
            break;
            default:
            Console.WriteLine($"An unexpected value ({caseSwitch})");
            break;
            }
            }
            }
            // The example displays output like the following:
            //
            Case 1

            Only one switch section in a switch statement executes. C# does not allow execution to continue from one
            switch section to the next. Because of this, the following code generates a compiler error, CS0163: "Control
            cannot fall through from one case label () to another."
            switch (caseSwitch)
            {
            // The following switch section causes an error.
            case 1:
            Console.WriteLine("Case 1...");
            // Add a break or other jump statement here.
            case 2:
            Console.WriteLine("... and/or Case 2");
            break;
            }

            This requirement is usually met by explicitly exiting the switch section by using a break, goto, or return

            statement. However, the following code is also valid, because it ensures that program control cannot fall
            through to the default switch section.
            switch (caseSwitch)
            {
            // The following switch section causes an error.
            case 1:
            Console.WriteLine("Case 1...");
            break;
            case 2:
            case 3:
            Console.WriteLine("... and/or Case 2");
            break;
            case 4:
            while (true)
            Console.WriteLine("Endless looping. . . .");
            default:
            Console.WriteLine("Default value...");
            break;
            }

            Execution of the statement list in the switch section with a case label that matches the match expression begins
            with the first statement and proceeds through the statement list, typically until a jump statement, such as a
            break , goto case , goto label , return , or throw , is reached. At that point, control is transferred outside the
            switch statement or to another case label. A goto statement, if it is used, must transfer control to a constant
            label. This restriction is necessary, since attempting to transfer control to a non-constant label can have
            undesirable side-effects, such transferring control to an unintended location in code or creating an endless
            loop.

            Case labels
            Each case label specifies a pattern to compare to the match expression (the caseSwitch variable in the previous
            examples). If they match, control is transferred to the switch section that contains the first matching case label.
            If no case label pattern matches the match expression, control is transferred to the section with the default
            case label, if there is one. If there is no default case, no statements in any switch section are executed, and
            control is transferred outside the switch statement.
            For information on the switch statement and pattern matching, see the Pattern matching with the switch
            statement section.
            Because C# 6 supports only the constant pattern and does not allow the repetition of constant values, case
            labels define mutually exclusive values, and only one pattern can match the match expression. As a result, the
            order in which case statements appear is unimportant.
            In C# 7.0, however, because other patterns are supported, case labels need not define mutually exclusive values,
            and multiple patterns can match the match expression. Because only the statements in the first switch section
            that contains the matching pattern are executed, the order in which case statements appear is now important.
            If C# detects a switch section whose case statement or statements are equivalent to or are subsets of previous
            statements, it generates a compiler error, CS8120, "The switch case has already been handled by a previous
            case."
            The following example illustrates a switch statement that uses a variety of non-mutually exclusive patterns. If
            you move the case 0: switch section so that it is no longer the first section in the switch statement, C#
            generates a compiler error because an integer whose value is zero is a subset of all integers, which is the
            pattern defined by the case int val statement.
            using System;
            using System.Collections.Generic;

            using System.Collections.Generic;
            using System.Linq;
            public class Example
            {
            public static void Main()
            {
            var values = new List<object>();
            for (int ctr = 0; ctr <= 7; ctr++) {
            if (ctr == 2)
            values.Add(DiceLibrary.Roll2());
            else if (ctr == 4)
            values.Add(DiceLibrary.Pass());
            else
            values.Add(DiceLibrary.Roll());
            }
            Console.WriteLine($"The sum of { values.Count } die is { DiceLibrary.DiceSum(values) }");
            }
            }
            public static class DiceLibrary
            {
            // Random number generator to simulate dice rolls.
            static Random rnd = new Random();
            // Roll a single die.
            public static int Roll()
            {
            return rnd.Next(1, 7);
            }
            // Roll two dice.
            public static List<object> Roll2()
            {
            var rolls = new List<object>();
            rolls.Add(Roll());
            rolls.Add(Roll());
            return rolls;
            }
            // Calculate the sum of n dice rolls.
            public static int DiceSum(IEnumerable<object> values)
            {
            var sum = 0;
            foreach (var item in values)
            {
            switch (item)
            {
            // A single zero value.
            case 0:
            break;
            // A single value.
            case int val:
            sum += val;
            break;
            // A non-empty collection.
            case IEnumerable<object> subList when subList.Any():
            sum += DiceSum(subList);
            break;
            // An empty collection.
            case IEnumerable<object> subList:
            break;
            // A null reference.
            case null:
            break;
            // A value that is neither an integer nor a collection.
            default:
            throw new InvalidOperationException("unknown item type");

            }
            }
            return sum;
            }
            public static object Pass()
            {
            if (rnd.Next(0, 2) == 0)
            return null;
            else
            return new List<object>();
            }
            }

            You can correct this issue and eliminate the compiler warning in one of two ways:
            By changing the order of the switch sections.
            By using a when clause in the case label.

            The default case
            The default case specifies the switch section to execute if the match expression does not match any other
            case label. If a default case is not present and the match expression does not match any other case label,
            program flow falls through the switch statement.
            The default case can appear in any order in the switch statement. Regardless of its order in the source code,
            it is always evaluated last, after all case labels have been evaluated.

            Pattern matching with the switch statement
            Each case statement defines a pattern that, if it matches the match expression, causes its containing switch
            section to be executed. All versions of C# support the constant pattern. The remaining patterns are supported
            beginning with C# 7.0.
            Constant pattern
            The constant pattern tests whether the match expression equals a specified constant. Its syntax is:
            case constant:

            where constant is the value to test for. constant can be any of the following constant expressions:
            A bool literal, either true or false .
            Any integral constant, such as an int, a long, or a byte.
            The name of a declared const variable.
            An enumeration constant.
            A char literal.
            A string literal.
            The constant expression is evaluated as follows:
            If expr and constant are integral types, the C# equality operator determines whether the expression
            returns true (that is, whether expr == constant ).
            Otherwise, the value of the expression is determined by a call to the static Object.Equals(expr, constant)
            method.

            The following example uses the constant pattern to determine whether a particular date is a weekend, the first
            day of the work week, the last day of the work week, or the middle of the work week. It evaluates the
            DateTime.DayOfWeek property of the current day against the members of the DayOfWeek enumeration.
            using System;
            class Program
            {
            static void Main()
            {
            switch (DateTime.Now.DayOfWeek)
            {
            case DayOfWeek.Sunday:
            case DayOfWeek.Saturday:
            Console.WriteLine("The weekend");
            break;
            case DayOfWeek.Monday:
            Console.WriteLine("The first day of the work week.");
            break;
            case DayOfWeek.Friday:
            Console.WriteLine("The last day of the work week.");
            break;
            default:
            Console.WriteLine("The middle of the work week.");
            break;
            }
            }
            }
            // The example displays output like the following:
            //
            The middle of the work week.

            The following example uses the constant pattern to handle user input in a console application that simulates an
            automatic coffee machine.

            using System;
            class Example
            {
            static void Main()
            {
            Console.WriteLine("Coffee sizes: 1=small 2=medium 3=large");
            Console.Write("Please enter your selection: ");
            string str = Console.ReadLine();
            int cost = 0;
            // Because of the goto statements in cases 2 and 3, the base cost of 25
            // cents is added to the additional cost for the medium and large sizes.
            switch (str)
            {
            case "1":
            case "small":
            cost += 25;
            break;
            case "2":
            case "medium":
            cost += 25;
            goto case "1";
            case "3":
            case "large":
            cost += 50;
            goto case "1";
            default:
            Console.WriteLine("Invalid selection. Please select 1, 2, or 3.");
            break;
            }
            if (cost != 0)
            {
            Console.WriteLine("Please insert {0} cents.", cost);
            }
            Console.WriteLine("Thank you for your business.");
            }
            }
            // The example displays output like the following:
            //
            Coffee sizes: 1=small 2=medium 3=large
            //
            Please enter your selection: 2
            //
            Please insert 50 cents.
            //
            Thank you for your business.

            Type pattern
            The type pattern enables concise type evaluation and conversion. When used with the switch statement to
            perform pattern matching, it tests whether an expression can be converted to a specified type and, if it can be,
            casts it to a variable of that type. Its syntax is:
            case type varname

            where type is the name of the type to which the result of expr is to be converted, and varname is the object to
            which the result of expr is converted if the match succeeds.
            The case expression is true if any of the following is true:
            expr is an instance of the same type as type.
            expr is an instance of a type that derives from type. In other words, the result of expr can be upcast to an
            instance of type.

            expr has a compile-time type that is a base class of type, and expr has a runtime type that is type or is
            derived from type. The compile-time type of a variable is the variable's type as defined in its type
            declaration. The runtime type of a variable is the type of the instance that is assigned to that variable.
            expr is an instance of a type that implements the type interface.
            If the case expression is true, varname is definitely assigned and has local scope within the switch section only.
            Note that null does not match a type. To match a null , you use the following case label:
            case null:

            The following example uses the type pattern to provide information about various kinds of collection types.

            using System;
            using System.Collections;
            using System.Collections.Generic;
            using System.Linq;
            class Example
            {
            static void Main(string[] args)
            {
            int[] values = { 2, 4, 6, 8, 10 };
            ShowCollectionInformation(values);
            var names = new List<string>();
            names.AddRange( new string[] { "Adam", "Abigail", "Bertrand", "Bridgette" } );
            ShowCollectionInformation(names);
            List<int> numbers = null;
            ShowCollectionInformation(numbers);
            }
            private static void ShowCollectionInformation(object coll)
            {
            switch (coll)
            {
            case Array arr:
            Console.WriteLine($"An array with {arr.Length} elements.");
            break;
            case IEnumerable<int> ieInt:
            Console.WriteLine($"Average: {ieInt.Average(s => s)}");
            break;
            case IList list:
            Console.WriteLine($"{list.Count} items");
            break;
            case IEnumerable ie:
            string result = "";
            foreach (var item in ie)
            result += "${e} ";
            Console.WriteLine(result);
            break;
            case null:
            // Do nothing for a null.
            break;
            default:
            Console.WriteLine($"A instance of type {coll.GetType().Name}");
            break;
            }
            }
            }
            // The example displays the following output:
            //
            An array with 5 elements.
            //
            4 items

            Without pattern matching, this code might be written as follows. The use of type pattern matching produces
            more compact, readable code by eliminating the need to test whether the result of a conversion is a null or to
            perform repeated casts.

            using System;
            using System.Collections;
            using System.Collections.Generic;
            using System.Linq;
            class Example
            {
            static void Main(string[] args)
            {
            int[] values = { 2, 4, 6, 8, 10 };
            ShowCollectionInformation(values);
            var names = new List<string>();
            names.AddRange( new string[] { "Adam", "Abigail", "Bertrand", "Bridgette" } );
            ShowCollectionInformation(names);
            List<int> numbers = null;
            ShowCollectionInformation(numbers);
            }
            private static void ShowCollectionInformation(object coll)
            {
            if (coll is Array) {
            Array arr = (Array) coll;
            Console.WriteLine($"An array with {arr.Length} elements.");
            }
            else if (coll is IEnumerable<int>) {
            IEnumerable<int> ieInt = (IEnumerable<int>) coll;
            Console.WriteLine($"Average: {ieInt.Average(s => s)}");
            }
            else if (coll is IList) {
            IList list = (IList) coll;
            Console.WriteLine($"{list.Count} items");
            }
            else if (coll is IEnumerable) {
            IEnumerable ie = (IEnumerable) coll;
            string result = "";
            foreach (var item in ie)
            result += "${e} ";
            Console.WriteLine(result);
            }
            else if (coll == null) {
            // Do nothing.
            }
            else {
            Console.WriteLine($"An instance of type {coll.GetType().Name}");
            }
            }
            }
            // The example displays the following output:
            //
            An array with 5 elements.
            //
            4 items

            The case statement and the when clause
            Starting with C# 7.0, because case statements need not be mutually exclusive, you can add a when clause to
            specify an additional condition that must be satisfied for the case statement to evaluate to true. The when
            clause can be any expression that returns a Boolean value.
            The following example defines a base Shape class, a Rectangle class that derives from Shape , and a Square
            class that derives from Rectangle . It uses the when clause to ensure that the ShowShapeInfo treats a
            Rectangle object that has been assigned equal lengths and widths as a Square even if it has not been
            instantiated as a Square object. The method does not attempt to display information either about an object

            that is null or a shape whose area is zero.
            using System;
            public abstract class Shape
            {
            public abstract double Area { get; }
            public abstract double Circumference { get; }
            }
            public class Rectangle : Shape
            {
            public Rectangle(double length, double width)
            {
            Length = length;
            Width = width;
            }
            public double Length { get; set; }
            public double Width { get; set; }
            public override double Area
            {
            get { return Math.Round(Length * Width,2); }
            }
            public override double Circumference
            {
            get { return (Length + Width) * 2; }
            }
            }
            public class Square : Rectangle
            {
            public Square(double side) : base(side, side)
            {
            Side = side;
            }
            public double Side { get; set; }
            }
            public class Circle : Shape
            {
            public Circle(double radius)
            {
            Radius = radius;
            }
            public double Radius { get; set; }
            public override double Circumference
            {
            get { return 2 * Math.PI * Radius; }
            }
            public override double Area
            {
            get { return Math.PI * Math.Pow(Radius, 2); }
            }
            }
            public class Example
            {
            public static void Main()
            {
            Shape sh = null;
            Shape[] shapes = { new Square(10), new Rectangle(5, 7),

            Shape[] shapes = { new Square(10), new Rectangle(5, 7),
            sh, new Square(0), new Rectangle(8, 8),
            new Circle(3) };
            foreach (var shape in shapes)
            ShowShapeInfo(shape);
            }
            private static void ShowShapeInfo(Shape sh)
            {
            switch (sh)
            {
            // Note that this code never evaluates to true.
            case Shape shape when shape == null:
            Console.WriteLine($"An uninitialized shape (shape == null)");
            break;
            case null:
            Console.WriteLine($"An uninitialized shape");
            break;
            case Shape shape when sh.Area == 0:
            Console.WriteLine($"The shape: {sh.GetType().Name} with no dimensions");
            break;
            case Square sq when sh.Area > 0:
            Console.WriteLine("Information about square:");
            Console.WriteLine($" Length of a side: {sq.Side}");
            Console.WriteLine($" Area: {sq.Area}");
            break;
            case Rectangle r when r.Length == r.Width && r.Area > 0:
            Console.WriteLine("Information about square rectangle:");
            Console.WriteLine($" Length of a side: {r.Length}");
            Console.WriteLine($" Area: {r.Area}");
            break;
            case Rectangle r when sh.Area > 0:
            Console.WriteLine("Information about rectangle:");
            Console.WriteLine($" Dimensions: {r.Length} x {r.Width}");
            Console.WriteLine($" Area: {r.Area}");
            break;
            case Shape shape when sh != null:
            Console.WriteLine($"A {sh.GetType().Name} shape");
            break;
            default:
            Console.WriteLine($"The {nameof(sh)} variable does not represent a Shape.");
            break;
            }
            }
            }
            // The example displays the following output:
            //
            Information about square:
            //
            Length of a side: 10
            //
            Area: 100
            //
            Information about rectangle:
            //
            Dimensions: 5 x 7
            //
            Area: 35
            //
            An uninitialized shape
            //
            The shape: Square with no dimensions
            //
            Information about square rectangle:
            //
            Length of a side: 8
            //
            Area: 64
            //
            A Circle shape

            Note that the when clause in the example that attempts to test whether a Shape object is null does not
            execute. The correct type pattern to test for a null is case null: .

            C# language specification
            For more information, see The switch statement in the C# Language Specification. The language specification
            is the definitive source for C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            if-else
            Pattern Matching

            Iteration Statements (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            You can create loops by using the iteration statements. Iteration statements cause embedded statements to be
            executed a number of times, subject to the loop-termination criteria. These statements are executed in order,
            except when a jump statement is encountered.
            The following keywords are used in iteration statements:
            do
            for
            foreach, in
            while

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Statement Keywords

            do (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The do statement executes a statement or a block of statements while a specified Boolean expression evaluates
            to true . Because that expression is evaluated after each execution of the loop, a do-while loop executes one or
            more times. This differs from the while loop, which executes zero or more times.
            At any point within the do statement block, you can break out of the loop by using the break statement.
            You can step directly to the evaluation of the while expression by using the continue statement. If the expression
            evaluates to true , execution continues at the first statement in the loop. Otherwise, execution continues at the
            first statement after the loop.
            You also can exit a do-while loop by the goto, return, or throw statements.

            Example
            The following example shows the usage of the do statement. Select Run to run the example code. After that you
            can modify the code and run it again.
            int n = 0;
            do
            {
            Console.WriteLine(n);
            n++;
            } while (n < 5);

            C# language specification
            For more information, see The do statement section of the C# language specification.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Iteration Statements
            while statement

            for (C# reference)
            12/6/2018 • 2 minutes to read • Edit Online

            The for statement executes a statement or a block of statements while a specified Boolean expression evaluates
            to true .
            At any point within the for statement block, you can break out of the loop by using the break statement, or step
            to the next iteration in the loop by using the continue statement. You also can exit a for loop by the goto, return,
            or throw statements.

            Structure of the for statement
            The for statement defines initializer, condition, and iterator sections:
            for (initializer; condition; iterator)
            body

            All three sections are optional. The body of the loop is either a statement or a block of statements.
            The following example shows the for statement with all of the sections defined:
            for (int i = 0; i < 5; i++)
            {
            Console.WriteLine(i);
            }

            The initializer section
            The statements in the initializer section are executed only once, before entering the loop. The initializer section is
            either of the following:
            The declaration and initialization of a local loop variable, which can't be accessed from outside the loop.
            Zero or more statement expressions from the following list, separated by commas:
            assignment statement
            invocation of a method
            prefix or postfix increment expression, such as ++i or i++
            prefix or postfix decrement expression, such as --i or i-creation of an object by using new keyword
            await expression
            The initializer section in the example above declares and initializes the local loop variable i :
            int i = 0

            The condition section
            The condition section, if present, must be a boolean expression. That expression is evaluated before every loop

            iteration. If the condition section is not present or the boolean expression evaluates to true , the next loop
            iteration is executed; otherwise, the loop is exited.
            The condition section in the example above determines if the loop terminates based on the value of the local loop
            variable:
            i < 5

            The iterator section
            The iterator section defines what happens after each iteration of the body of the loop. The iterator section
            contains zero or more of the following statement expressions, separated by commas:
            assignment statement
            invocation of a method
            prefix or postfix increment expression, such as ++i or i++
            prefix or postfix decrement expression, such as --i or i-creation of an object by using new keyword
            await expression
            The iterator section in the example above increments the local loop variable:
            i++

            Examples
            The following example illustrates several less common usages of the for statement sections: assigning a value to
            an external loop variable in the initializer section, invoking a method in both the initializer and the iterator
            sections, and changing the values of two variables in the iterator section. Select Run to run the example code.
            After that you can modify the code and run it again.
            int i;
            int j = 10;
            for (i = 0, Console.WriteLine($"Start: i={i}, j={j}"); i < j; i++, j--, Console.WriteLine($"Step: i={i}, j=
            {j}"))
            {
            // Body of the loop.
            }

            The following example defines the infinite for loop:
            for ( ; ; )
            {
            // Body of the loop.
            }

            C# language specification
            For more information, see The for statement section of the C# language specification.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Iteration Statements
            foreach, in

            foreach, in (C# reference)
            11/22/2018 • 2 minutes to read • Edit Online

            The foreach statement executes a statement or a block of statements for each element in an instance of the type
            that implements the System.Collections.IEnumerable or System.Collections.Generic.IEnumerable<T> interface.
            The foreach statement is not limited to those types and can be applied to an instance of any type that satisfies
            the following conditions:
            has the public parameterless GetEnumerator method whose return type is either class, struct, or interface type,
            the return type of the GetEnumerator method has the public Current property and the public parameterless
            MoveNext method whose return type is Boolean.
            Beginning with C# 7.3, if the enumerator's Current property returns a reference return value ( ref T where T
            is the type of the collection element), you can declare the iteration variable with the ref or ref readonly
            modifier.
            At any point within the foreach statement block, you can break out of the loop by using the break statement, or
            step to the next iteration in the loop by using the continue statement. You also can exit a foreach loop by the
            goto, return, or throw statements.

            Examples
            NOTE
            The C# examples in this article run in the Try.NET inline code runner and playground. Select the Run button to run an
            example in an interactive window. Once you execute the code, you can modify it and run the modified code by selecting
            Run again. The modified code either runs in the interactive window or, if compilation fails, the interactive window displays
            all C# compiler error messages.

            The following example shows usage of the foreach statement with an instance of the List<T> type that
            implements the IEnumerable<T> interface:
            var fibNumbers = new List<int> { 0, 1, 1, 2, 3, 5, 8, 13 };
            int count = 0;
            foreach (int element in fibNumbers)
            {
            count++;
            Console.WriteLine($"Element #{count}: {element}");
            }
            Console.WriteLine($"Number of elements: {count}");

            The next example uses the foreach statement with an instance of the System.Span<T> type, which doesn't
            implement any interfaces:

            public class IterateSpanExample
            {
            public static void Main()
            {
            Span<int> numbers = new int[] { 3, 14, 15, 92, 6 };
            foreach (int number in numbers)
            {
            Console.Write($"{number} ");
            }
            Console.WriteLine();
            }
            }

            The following example uses a ref iteration variable to set the value of each item in a stackalloc array. The
            ref readonly version iterates the collection to print all the values. The readonly declaration uses an implicit
            local variable declaration. Implicit variable declarations can be used with either ref or ref readonly
            declarations, as can explicitly typed variable declarations.
            public class ForeachRefExample
            {
            public static void Main()
            {
            Span<int> storage = stackalloc int[10];
            int num = 0;
            foreach (ref int item in storage)
            {
            item = num++;
            }
            foreach (ref readonly var item in storage)
            {
            Console.Write($"{item} ");
            }
            // Output:
            // 0 1 2 3 4 5 6 7 8 9
            }
            }

            C# language specification
            For more information, see The foreach statement section of the C# language specification.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Iteration Statements
            Using foreach with arrays
            for statement

            while (C# Reference)
            1/11/2019 • 2 minutes to read • Edit Online

            The while statement executes a statement or a block of statements while a specified Boolean expression
            evaluates to true . Because that expression is evaluated before each execution of the loop, a while loop executes
            zero or more times. This differs from the do loop, which executes one or more times.
            At any point within the while statement block, you can break out of the loop by using the break statement.
            You can step directly to the evaluation of the while expression by using the continue statement. If the expression
            evaluates to true , execution continues at the first statement in the loop. Otherwise, execution continues at the
            first statement after the loop.
            You also can exit a while loop by the goto, return, or throw statements.

            Example
            The following example shows the usage of the while statement. Select Run to run the example code. After that
            you can modify the code and run it again.
            int n = 0;
            while (n < 5)
            {
            Console.WriteLine(n);
            n++;
            }

            C# language specification
            For more information, see The while statement section of the C# language specification.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Iteration Statements
            do statement

            Jump Statements (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Branching is performed using jump statements, which cause an immediate transfer of the program control. The
            following keywords are used in jump statements:
            break
            continue
            goto
            return
            throw

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            Statement Keywords

            break (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The break statement terminates the closest enclosing loop or switch statement in which it appears. Control is
            passed to the statement that follows the terminated statement, if any.

            Example
            In this example, the conditional statement contains a counter that is supposed to count from 1 to 100; however,
            the break statement terminates the loop after 4 counts.
            class BreakTest
            {
            static void Main()
            {
            for (int i = 1; i <= 100; i++)
            {
            if (i == 5)
            {
            break;
            }
            Console.WriteLine(i);
            }
            // Keep the console open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /*
            Output:
            1
            2
            3
            4
            */

            Example
            In this example, the break statement is used to break out of an inner nested loop, and return control to the outer
            loop.

            class BreakInNestedLoops
            {
            static void Main(string[] args)
            {
            int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
            char[] letters = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j' };
            // Outer loop
            for (int x = 0; x < numbers.Length; x++)
            {
            Console.WriteLine("num = {0}", numbers[x]);
            // Inner loop
            for (int y = 0; y < letters.Length; y++)
            {
            if (y == x)
            {
            // Return control to outer loop
            break;
            }
            Console.Write(" {0} ", letters[y]);
            }
            Console.WriteLine();
            }
            // Keep the console open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /*
            * Output:
            num = 0
            num = 1
            a
            num = 2
            a b
            num = 3
            a b c
            num = 4
            a b c
            num = 5
            a b c
            num = 6
            a b c
            num = 7
            a b c
            num = 8
            a b c
            num = 9
            a b c

            d
            d e
            d e f
            d e f g
            d e f g h
            d e f g h i

            */

            Example
            This example demonstrates the use of break in a switch statement.

            class Switch
            {
            static void Main()
            {
            Console.Write("Enter your selection (1, 2, or 3): ");
            string s = Console.ReadLine();
            int n = Int32.Parse(s);
            switch (n)
            {
            case 1:
            Console.WriteLine("Current value is {0}", 1);
            break;
            case 2:
            Console.WriteLine("Current value is {0}", 2);
            break;
            case 3:
            Console.WriteLine("Current value is {0}", 3);
            break;
            default:
            Console.WriteLine("Sorry, invalid selection.");
            break;
            }
            // Keep the console open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /*
            Sample Input: 1
            Sample Output:
            Enter your selection (1, 2, or 3): 1
            Current value is 1
            */

            If you entered 4 , the output would be:
            Enter your selection (1, 2, or 3): 4
            Sorry, invalid selection.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            switch
            Jump Statements
            Iteration Statements

            continue (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The continue statement passes control to the next iteration of the enclosing while, do, for, or foreach statement
            in which it appears.

            Example
            In this example, a counter is initialized to count from 1 to 10. By using the continue statement in conjunction
            with the expression (i < 9) , the statements between continue and the end of the for body are skipped.
            class ContinueTest
            {
            static void Main()
            {
            for (int i = 1; i <= 10; i++)
            {
            if (i < 9)
            {
            continue;
            }
            Console.WriteLine(i);
            }
            // Keep the console open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /*
            Output:
            9
            10
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            break Statement
            Jump Statements

            goto (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The goto statement transfers the program control directly to a labeled statement.
            A common use of goto is to transfer control to a specific switch-case label or the default label in a switch
            statement.
            The goto statement is also useful to get out of deeply nested loops.

            Example
            The following example demonstrates using goto in a switch statement.
            class SwitchTest
            {
            static void Main()
            {
            Console.WriteLine("Coffee sizes: 1=Small 2=Medium 3=Large");
            Console.Write("Please enter your selection: ");
            string s = Console.ReadLine();
            int n = int.Parse(s);
            int cost = 0;
            switch (n)
            {
            case 1:
            cost += 25;
            break;
            case 2:
            cost += 25;
            goto case 1;
            case 3:
            cost += 50;
            goto case 1;
            default:
            Console.WriteLine("Invalid selection.");
            break;
            }
            if (cost != 0)
            {
            Console.WriteLine("Please insert {0} cents.", cost);
            }
            Console.WriteLine("Thank you for your business.");
            // Keep the console open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /*
            Sample Input: 2
            Sample Output:
            Coffee sizes: 1=Small 2=Medium 3=Large
            Please enter your selection: 2
            Please insert 50 cents.
            Thank you for your business.
            */

            Example
            The following example demonstrates using goto to break out from nested loops.
            public class GotoTest1
            {
            static void Main()
            {
            int x = 200, y = 4;
            int count = 0;
            string[,] array = new string[x, y];
            // Initialize the array:
            for (int i = 0; i < x; i++)
            for (int j = 0; j < y; j++)
            array[i, j] = (++count).ToString();
            // Read input:
            Console.Write("Enter the number to search for: ");
            // Input a string:
            string myNumber = Console.ReadLine();
            // Search:
            for (int i = 0; i < x; i++)
            {
            for (int j = 0; j < y; j++)
            {
            if (array[i, j].Equals(myNumber))
            {
            goto Found;
            }
            }
            }
            Console.WriteLine("The number {0} was not found.", myNumber);
            goto Finish;
            Found:
            Console.WriteLine("The number {0} is found.", myNumber);
            Finish:
            Console.WriteLine("End of search.");

            // Keep the console open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /*
            Sample Input: 44
            Sample Output
            Enter the number to search for: 44
            The number 44 is found.
            End of search.
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            goto Statement (C++)
            Jump Statements

            return (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The return statement terminates execution of the method in which it appears and returns control to the calling
            method. It can also return an optional value. If the method is a void type, the return statement can be omitted.
            If the return statement is inside a try block, the finally block, if one exists, will be executed before control
            returns to the calling method.

            Example
            In the following example, the method CalculateArea() returns the local variable area as a double value.
            class ReturnTest
            {
            static double CalculateArea(int r)
            {
            double area = r * r * Math.PI;
            return area;
            }
            static void Main()
            {
            int radius = 5;
            double result = CalculateArea(radius);
            Console.WriteLine("The area is {0:0.00}", result);
            // Keep the console open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            // Output: The area is 78.54

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            return Statement
            Jump Statements

            Exception Handling Statements (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            C# provides built-in support for handling anomalous situations, known as exceptions, which may occur during the
            execution of your program. These exceptions are handled by code that is outside the normal flow of control.
            The following exception handling topics are explained in this section:
            throw
            try-catch
            try-finally
            try-catch-finally

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            Statement Keywords
            Exceptions and Exception Handling

            throw (C# Reference)
            12/11/2018 • 3 minutes to read • Edit Online

            Signals the occurrence of an exception during program execution.

            Remarks
            The syntax of throw is:
            throw [e]

            where e is an instance of a class derived from System.Exception. The following example uses the throw
            statement to throw an IndexOutOfRangeException if the argument passed to a method named GetNumber does
            not correspond to a valid index of an internal array.
            using System;
            public class NumberGenerator
            {
            int[] numbers = { 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 };
            public int GetNumber(int index)
            {
            if (index < 0 || index >= numbers.Length) {
            throw new IndexOutOfRangeException();
            }
            return numbers[index];
            }
            }

            Method callers then use a try-catch or try-catch-finally block to handle the thrown exception. The following
            example handles the exception thrown by the GetNumber method.
            using System;
            public class Example
            {
            public static void Main()
            {
            var gen = new NumberGenerator();
            int index = 10;
            try {
            int value = gen.GetNumber(index);
            Console.WriteLine($"Retrieved {value}");
            }
            catch (IndexOutOfRangeException e)
            {
            Console.WriteLine($"{e.GetType().Name}: {index} is outside the bounds of the array");
            }
            }
            }
            // The example displays the following output:
            //
            IndexOutOfRangeException: 10 is outside the bounds of the array

            Re-throwing an exception
            throw can also be used in a catch block to re-throw an exception handled in a catch block. In this case,
            throw does not take an exception operand. It is most useful when a method passes on an argument from a

            caller to some other library method, and the library method throws an exception that must be passed on to the
            caller. For example, the following example re-throws an NullReferenceException that is thrown when attempting
            to retrieve the first character of an uninitialized string.
            using System;
            public class Sentence
            {
            public Sentence(string s)
            {
            Value = s;
            }
            public string Value { get; set; }
            public char GetFirstCharacter()
            {
            try {
            return Value[0];
            }
            catch (NullReferenceException e) {
            throw;
            }
            }
            }
            public class Example
            {
            public static void Main()
            {
            var s = new Sentence(null);
            Console.WriteLine($"The first character is {s.GetFirstCharacter()}");
            }
            }
            // The example displays the following output:
            //
            Unhandled Exception: System.NullReferenceException: Object reference not set to an instance of an
            object.
            //
            at Sentence.GetFirstCharacter()
            //
            at Example.Main()

            IMPORTANT
            You can also use the throw e syntax in a catch block to instantiate a new exception that you pass on to the caller. In
            this case, the stack trace of the original exception, which is available from the StackTrace property, is not preserved.

            The throw expression
            Starting with C# 7.0, throw can be used as an expression as well as a statement. This allows an exception to be
            thrown in contexts that were previously unsupported. These include:
            the conditional operator. The following example uses a throw expression to throw an
            ArgumentException if a method is passed an empty string array. Before C# 7.0, this logic would need to
            appear in an if / else statement.

            private static void DisplayFirstNumber(string[] args)
            {
            string arg = args.Length >= 1 ? args[0] :
            throw new ArgumentException("You must supply an argument");
            if (Int64.TryParse(arg, out var number))
            Console.WriteLine($"You entered {number:F0}");
            else
            Console.WriteLine($"{arg} is not a number.");
            }

            the null-coalescing operator. In the following example, a throw expression is used with a null-coalescing
            operator to throw an exception if the string assigned to a Name property is null .
            public string Name
            {
            get => name;
            set => name = value ??
            throw new ArgumentNullException("Name cannot be null", nameof(value));
            }

            an expression-bodied lambda or method. The following example illustrates an expression-bodied method
            that throws an InvalidCastException because a conversion to a DateTime value is not supported.
            DateTime ToDateTime(IFormatProvider provider) =>
            throw new InvalidCastException("Conversion to a DateTime is not supported.");

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            try-catch
            The try, catch, and throw Statements in C++
            C# Keywords
            Exception Handling Statements
            How to: Explicitly Throw Exceptions

            try-catch (C# Reference)
            12/11/2018 • 8 minutes to read • Edit Online

            The try-catch statement consists of a try block followed by one or more catch clauses, which specify handlers
            for different exceptions.

            Remarks
            When an exception is thrown, the common language runtime (CLR ) looks for the catch statement that handles
            this exception. If the currently executing method does not contain such a catch block, the CLR looks at the
            method that called the current method, and so on up the call stack. If no catch block is found, then the CLR
            displays an unhandled exception message to the user and stops execution of the program.
            The try block contains the guarded code that may cause the exception. The block is executed until an exception
            is thrown or it is completed successfully. For example, the following attempt to cast a null object raises the
            NullReferenceException exception:
            object o2 = null;
            try
            {
            int i2 = (int)o2;
            }

            // Error

            Although the catch clause can be used without arguments to catch any type of exception, this usage is not
            recommended. In general, you should only catch those exceptions that you know how to recover from.
            Therefore, you should always specify an object argument derived from System.Exception For example:
            catch (InvalidCastException e)
            {
            }

            It is possible to use more than one specific catch clause in the same try-catch statement. In this case, the order
            of the catch clauses is important because the catch clauses are examined in order. Catch the more specific
            exceptions before the less specific ones. The compiler produces an error if you order your catch blocks so that a
            later block can never be reached.
            Using catch arguments is one way to filter for the exceptions you want to handle. You can also use an exception
            filter that further examines the exception to decide whether to handle it. If the exception filter returns false, then
            the search for a handler continues.
            catch (ArgumentException e) when (e.ParamName == "...")
            {
            }

            Exception filters are preferable to catching and rethrowing (explained below ) because filters leave the stack
            unharmed. If a later handler dumps the stack, you can see where the exception originally came from, rather than
            just the last place it was rethrown. A common use of exception filter expressions is logging. You can create a filter
            that always returns false that also outputs to a log, you can log exceptions as they go by without having to
            handle them and rethrow.

            A throw statement can be used in a catch block to re-throw the exception that is caught by the catch
            statement. The following example extracts source information from an IOException exception, and then throws
            the exception to the parent method.
            catch (FileNotFoundException e)
            {
            // FileNotFoundExceptions are handled here.
            }
            catch (IOException e)
            {
            // Extract some information from this exception, and then
            // throw it to the parent method.
            if (e.Source != null)
            Console.WriteLine("IOException source: {0}", e.Source);
            throw;
            }

            You can catch one exception and throw a different exception. When you do this, specify the exception that you
            caught as the inner exception, as shown in the following example.
            catch (InvalidCastException e)
            {
            // Perform some action here, and then throw a new exception.
            throw new YourCustomException("Put your error message here.", e);
            }

            You can also re-throw an exception when a specified condition is true, as shown in the following example.
            catch (InvalidCastException e)
            {
            if (e.Data == null)
            {
            throw;
            }
            else
            {
            // Take some action.
            }
            }

            NOTE
            It is also possible to use an exception filter to get a similar result in an often cleaner fashion (as well as not modifying the
            stack, as explained earlier in this document). The following example has a similar behavior for callers as the previous
            example. The function throws the InvalidCastException back to the caller when e.Data is null .
            catch (InvalidCastException e) when (e.Data != null)
            {
            // Take some action.
            }

            From inside a try block, initialize only variables that are declared therein. Otherwise, an exception can occur
            before the execution of the block is completed. For example, in the following code example, the variable n is
            initialized inside the try block. An attempt to use this variable outside the try block in the Write(n)
            statement will generate a compiler error.

            static void Main()
            {
            int n;
            try
            {
            // Do not initialize this variable here.
            n = 123;
            }
            catch
            {
            }
            // Error: Use of unassigned local variable 'n'.
            Console.Write(n);
            }

            For more information about catch, see try-catch-finally.

            Exceptions in Async Methods
            An async method is marked by an async modifier and usually contains one or more await expressions or
            statements. An await expression applies the await operator to a Task or Task<TResult>.
            When control reaches an await in the async method, progress in the method is suspended until the awaited
            task completes. When the task is complete, execution can resume in the method. For more information, see
            Asynchronous Programming with async and await and Control Flow in Async Programs.
            The completed task to which await is applied might be in a faulted state because of an unhandled exception in
            the method that returns the task. Awaiting the task throws an exception. A task can also end up in a canceled
            state if the asynchronous process that returns it is canceled. Awaiting a canceled task throws an
            OperationCanceledException . For more information about how to cancel an asynchronous process, see FineTuning Your Async Application.
            To catch the exception, await the task in a try block, and catch the exception in the associated catch block. For
            an example, see the "Example" section.
            A task can be in a faulted state because multiple exceptions occurred in the awaited async method. For example,
            the task might be the result of a call to Task.WhenAll. When you await such a task, only one of the exceptions is
            caught, and you can't predict which exception will be caught. For an example, see the "Example" section.

            Example
            In the following example, the try block contains a call to the ProcessString method that may cause an
            exception. The catch clause contains the exception handler that just displays a message on the screen. When
            the throw statement is called from inside MyMethod , the system looks for the catch statement and displays the
            message Exception caught .

            class TryFinallyTest
            {
            static void ProcessString(string s)
            {
            if (s == null)
            {
            throw new ArgumentNullException();
            }
            }
            static void Main()
            {
            string s = null; // For demonstration purposes.
            try
            {
            ProcessString(s);
            }
            catch (Exception e)
            {
            Console.WriteLine("{0} Exception caught.", e);
            }
            }
            }
            /*
            Output:
            System.ArgumentNullException: Value cannot be null.
            at TryFinallyTest.Main() Exception caught.
            * */

            Example
            In the following example, two catch blocks are used, and the most specific exception, which comes first, is caught.
            To catch the least specific exception, you can replace the throw statement in ProcessString with the following
            statement: throw new Exception() .
            If you place the least-specific catch block first in the example, the following error message appears:
            A previous catch clause already catches all exceptions of this or a super type ('System.Exception') .

            class ThrowTest3
            {
            static void ProcessString(string s)
            {
            if (s == null)
            {
            throw new ArgumentNullException();
            }
            }
            static void Main()
            {
            try
            {
            string s = null;
            ProcessString(s);
            }
            // Most specific:
            catch (ArgumentNullException e)
            {
            Console.WriteLine("{0} First exception caught.", e);
            }
            // Least specific:
            catch (Exception e)
            {
            Console.WriteLine("{0} Second exception caught.", e);
            }
            }
            }
            /*
            Output:
            System.ArgumentNullException: Value cannot be null.
            at Test.ThrowTest3.ProcessString(String s) ... First exception caught.
            */

            Example
            The following example illustrates exception handling for async methods. To catch an exception that an async task
            throws, place the await expression in a try block, and catch the exception in a catch block.
            Uncomment the throw new Exception line in the example to demonstrate exception handling. The task's
            IsFaulted property is set to True , the task's Exception.InnerException property is set to the exception, and the
            exception is caught in the catch block.
            Uncomment the throw new OperationCancelledException line to demonstrate what happens when you cancel an
            asynchronous process. The task's IsCanceled property is set to true , and the exception is caught in the catch
            block. Under some conditions that don't apply to this example, the task's IsFaulted property is set to true and
            IsCanceled is set to false .

            public async Task DoSomethingAsync()
            {
            Task<string> theTask = DelayAsync();
            try
            {
            string result = await theTask;
            Debug.WriteLine("Result: " + result);
            }
            catch (Exception ex)
            {
            Debug.WriteLine("Exception Message: " + ex.Message);
            }
            Debug.WriteLine("Task IsCanceled: " + theTask.IsCanceled);
            Debug.WriteLine("Task IsFaulted: " + theTask.IsFaulted);
            if (theTask.Exception != null)
            {
            Debug.WriteLine("Task Exception Message: "
            + theTask.Exception.Message);
            Debug.WriteLine("Task Inner Exception Message: "
            + theTask.Exception.InnerException.Message);
            }
            }
            private async Task<string> DelayAsync()
            {
            await Task.Delay(100);
            // Uncomment each of the following lines to
            // demonstrate exception handling.
            //throw new OperationCanceledException("canceled");
            //throw new Exception("Something happened.");
            return "Done";
            }
            // Output when no exception is thrown in the awaited method:
            // Result: Done
            // Task IsCanceled: False
            // Task IsFaulted: False
            // Output when an Exception is thrown in the awaited method:
            // Exception Message: Something happened.
            // Task IsCanceled: False
            // Task IsFaulted: True
            // Task Exception Message: One or more errors occurred.
            // Task Inner Exception Message: Something happened.
            // Output when a OperationCanceledException or TaskCanceledException
            // is thrown in the awaited method:
            // Exception Message: canceled
            // Task IsCanceled: True
            // Task IsFaulted: False

            Example
            The following example illustrates exception handling where multiple tasks can result in multiple exceptions. The
            try block awaits the task that's returned by a call to Task.WhenAll. The task is complete when the three tasks to
            which WhenAll is applied are complete.
            Each of the three tasks causes an exception. The catch block iterates through the exceptions, which are found in
            the Exception.InnerExceptions property of the task that was returned by Task.WhenAll.

            public async Task DoMultipleAsync()
            {
            Task theTask1 = ExcAsync(info: "First Task");
            Task theTask2 = ExcAsync(info: "Second Task");
            Task theTask3 = ExcAsync(info: "Third Task");
            Task allTasks = Task.WhenAll(theTask1, theTask2, theTask3);
            try
            {
            await allTasks;
            }
            catch (Exception ex)
            {
            Debug.WriteLine("Exception: " + ex.Message);
            Debug.WriteLine("Task IsFaulted: " + allTasks.IsFaulted);
            foreach (var inEx in allTasks.Exception.InnerExceptions)
            {
            Debug.WriteLine("Task Inner Exception: " + inEx.Message);
            }
            }
            }
            private async Task ExcAsync(string info)
            {
            await Task.Delay(100);
            throw new Exception("Error-" + info);
            }
            // Output:
            // Exception: Error-First Task
            // Task IsFaulted: True
            // Task Inner Exception: Error-First Task
            // Task Inner Exception: Error-Second Task
            // Task Inner Exception: Error-Third Task

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            try, throw, and catch Statements (C++)
            Exception Handling Statements
            throw
            try-finally
            How to: Explicitly Throw Exceptions

            try-finally (C# Reference)
            12/11/2018 • 3 minutes to read • Edit Online

            By using a finally block, you can clean up any resources that are allocated in a try block, and you can run code
            even if an exception occurs in the try block. Typically, the statements of a finally block run when control
            leaves a try statement. The transfer of control can occur as a result of normal execution, of execution of a break
            , continue , goto , or return statement, or of propagation of an exception out of the try statement.
            Within a handled exception, the associated finally block is guaranteed to be run. However, if the exception is
            unhandled, execution of the finally block is dependent on how the exception unwind operation is triggered.
            That, in turn, is dependent on how your computer is set up.
            Usually, when an unhandled exception ends an application, whether or not the finally block is run is not
            important. However, if you have statements in a finally block that must be run even in that situation, one
            solution is to add a catch block to the try - finally statement. Alternatively, you can catch the exception that
            might be thrown in the try block of a try - finally statement higher up the call stack. That is, you can catch
            the exception in the method that calls the method that contains the try - finally statement, or in the method
            that calls that method, or in any method in the call stack. If the exception is not caught, execution of the finally
            block depends on whether the operating system chooses to trigger an exception unwind operation.

            Example
            In the following example, an invalid conversion statement causes a System.InvalidCastException exception. The
            exception is unhandled.

            public class ThrowTestA
            {
            static void Main()
            {
            int i = 123;
            string s = "Some string";
            object obj = s;
            try
            {
            // Invalid conversion; obj contains a string, not a numeric type.
            i = (int)obj;
            // The following statement is not run.
            Console.WriteLine("WriteLine at the end of the try block.");
            }
            finally
            {
            // To run the program in Visual Studio, type CTRL+F5. Then
            // click Cancel in the error dialog.
            Console.WriteLine("\nExecution of the finally block after an unhandled\n" +
            "error depends on how the exception unwind operation is triggered.");
            Console.WriteLine("i = {0}", i);
            }
            }
            // Output:
            // Unhandled Exception: System.InvalidCastException: Specified cast is not valid.
            //
            // Execution of the finally block after an unhandled
            // error depends on how the exception unwind operation is triggered.
            // i = 123
            }

            In the following example, an exception from the TryCast method is caught in a method farther up the call stack.

            public class ThrowTestB
            {
            static void Main()
            {
            try
            {
            // TryCast produces an unhandled exception.
            TryCast();
            }
            catch (Exception ex)
            {
            // Catch the exception that is unhandled in TryCast.
            Console.WriteLine
            ("Catching the {0} exception triggers the finally block.",
            ex.GetType());
            // Restore the original unhandled exception. You might not
            // know what exception to expect, or how to handle it, so pass
            // it on.
            throw;
            }
            }
            public static void TryCast()
            {
            int i = 123;
            string s = "Some string";
            object obj = s;
            try
            {
            // Invalid conversion; obj contains a string, not a numeric type.
            i = (int)obj;
            // The following statement is not run.
            Console.WriteLine("WriteLine at the end of the try block.");
            }
            finally
            {
            // Report that the finally block is run, and show that the value of
            // i has not been changed.
            Console.WriteLine("\nIn the finally block in TryCast, i = {0}.\n", i);
            }
            }
            // Output:
            // In the finally block in TryCast, i = 123.
            // Catching the System.InvalidCastException exception triggers the finally block.
            // Unhandled Exception: System.InvalidCastException: Specified cast is not valid.
            }

            For more information about finally , see try-catch-finally.
            C# also contains the using statement, which provides similar functionality for IDisposable objects in a convenient
            syntax.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See Also

            C# Reference
            C# Programming Guide
            C# Keywords
            try, throw, and catch Statements (C++)
            Exception Handling Statements
            throw
            try-catch
            How to: Explicitly Throw Exceptions

            try-catch-finally (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            A common usage of catch and finally together is to obtain and use resources in a try block, deal with
            exceptional circumstances in a catch block, and release the resources in the finally block.
            For more information and examples on re-throwing exceptions, see try-catch and Throwing Exceptions. For more
            information about the finally block, see try-finally.

            Example
            public class EHClass
            {
            void ReadFile(int index)
            {
            // To run this code, substitute a valid path from your local machine
            string path = @"c:\users\public\test.txt";
            System.IO.StreamReader file = new System.IO.StreamReader(path);
            char[] buffer = new char[10];
            try
            {
            file.ReadBlock(buffer, index, buffer.Length);
            }
            catch (System.IO.IOException e)
            {
            Console.WriteLine("Error reading from {0}. Message = {1}", path, e.Message);
            }
            finally
            {
            if (file != null)
            {
            file.Close();
            }
            }
            // Do something with buffer...
            }
            }

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            try, throw, and catch Statements (C++)
            Exception Handling Statements
            throw

            How to: Explicitly Throw Exceptions
            using Statement

            Checked and Unchecked (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            C# statements can execute in either checked or unchecked context. In a checked context, arithmetic overflow raises
            an exception. In an unchecked context, arithmetic overflow is ignored and the result is truncated by discarding any
            high-order bits that don't fit in the destination type.
            checked Specify checked context.
            unchecked Specify unchecked context.
            The following operations are affected by the overflow checking:
            Expressions using the following predefined operators on integral types:
            ++ , -- , unary - , + , - , * , /

            Explicit numeric conversions between integral types, or from float or double to an integral type.
            If neither checked nor unchecked is specified, the default context for non-constant expressions (expressions that
            are evaluated at run time) is defined by the value of the -checked compiler option. By default the value of that
            option is unset and arithmetic operations are executed in an unchecked context.
            For constant expressions (expressions that can be fully evaluated at compile time), the default context is always
            checked. Unless a constant expression is explicitly placed in an unchecked context, overflows that occur during the
            compile-time evaluation of the expression cause compile-time errors.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            Statement Keywords

            checked (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The checked keyword is used to explicitly enable overflow checking for integral-type arithmetic operations and
            conversions.
            By default, an expression that contains only constant values causes a compiler error if the expression produces a
            value that is outside the range of the destination type. If the expression contains one or more non-constant values,
            the compiler does not detect the overflow. Evaluating the expression assigned to i2 in the following example
            does not cause a compiler error.
            // The following example causes compiler error CS0220 because 2147483647
            // is the maximum value for integers.
            //int i1 = 2147483647 + 10;
            // The following example, which includes variable ten, does not cause
            // a compiler error.
            int ten = 10;
            int i2 = 2147483647 + ten;
            // By default, the overflow in the previous statement also does
            // not cause a run-time exception. The following line displays
            // -2,147,483,639 as the sum of 2,147,483,647 and 10.
            Console.WriteLine(i2);

            By default, these non-constant expressions are not checked for overflow at run time either, and they do not raise
            overflow exceptions. The previous example displays -2,147,483,639 as the sum of two positive integers.
            Overflow checking can be enabled by compiler options, environment configuration, or use of the checked
            keyword. The following examples demonstrate how to use a checked expression or a checked block to detect the
            overflow that is produced by the previous sum at run time. Both examples raise an overflow exception.
            // If the previous sum is attempted in a checked environment, an
            // OverflowException error is raised.
            // Checked expression.
            Console.WriteLine(checked(2147483647 + ten));
            // Checked block.
            checked
            {
            int i3 = 2147483647 + ten;
            Console.WriteLine(i3);
            }

            The unchecked keyword can be used to prevent overflow checking.

            Example
            This sample shows how to use checked to enable overflow checking at run time.

            class OverFlowTest
            {
            // Set maxIntValue to the maximum value for integers.
            static int maxIntValue = 2147483647;
            // Using a checked expression.
            static int CheckedMethod()
            {
            int z = 0;
            try
            {
            // The following line raises an exception because it is checked.
            z = checked(maxIntValue + 10);
            }
            catch (System.OverflowException e)
            {
            // The following line displays information about the error.
            Console.WriteLine("CHECKED and CAUGHT: " + e.ToString());
            }
            // The value of z is still 0.
            return z;
            }
            // Using an unchecked expression.
            static int UncheckedMethod()
            {
            int z = 0;
            try
            {
            // The following calculation is unchecked and will not
            // raise an exception.
            z = maxIntValue + 10;
            }
            catch (System.OverflowException e)
            {
            // The following line will not be executed.
            Console.WriteLine("UNCHECKED and CAUGHT: " + e.ToString());
            }
            // Because of the undetected overflow, the sum of 2147483647 + 10 is
            // returned as -2147483639.
            return z;
            }
            static void Main()
            {
            Console.WriteLine("\nCHECKED output value is: {0}",
            CheckedMethod());
            Console.WriteLine("UNCHECKED output value is: {0}",
            UncheckedMethod());
            }
            /*
            Output:
            CHECKED and CAUGHT: System.OverflowException: Arithmetic operation resulted
            in an overflow.
            at ConsoleApplication1.OverFlowTest.CheckedMethod()
            CHECKED output value is: 0
            UNCHECKED output value is: -2147483639
            */
            }

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Checked and Unchecked
            unchecked

            unchecked (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The unchecked keyword is used to suppress overflow -checking for integral-type arithmetic operations and
            conversions.
            In an unchecked context, if an expression produces a value that is outside the range of the destination type, the
            overflow is not flagged. For example, because the calculation in the following example is performed in an
            unchecked block or expression, the fact that the result is too large for an integer is ignored, and int1 is assigned
            the value -2,147,483,639.
            unchecked
            {
            int1 = 2147483647 + 10;
            }
            int1 = unchecked(ConstantMax + 10);

            If the unchecked environment is removed, a compilation error occurs. The overflow can be detected at compile
            time because all the terms of the expression are constants.
            Expressions that contain non-constant terms are unchecked by default at compile time and run time. See checked
            for information about enabling a checked environment.
            Because checking for overflow takes time, the use of unchecked code in situations where there is no danger of
            overflow might improve performance. However, if overflow is a possibility, a checked environment should be
            used.

            Example
            This sample shows how to use the unchecked keyword.

            class UncheckedDemo
            {
            static void Main(string[] args)
            {
            // int.MaxValue is 2,147,483,647.
            const int ConstantMax = int.MaxValue;
            int int1;
            int int2;
            int variableMax = 2147483647;
            // The following statements are checked by default at compile time. They do not
            // compile.
            //int1 = 2147483647 + 10;
            //int1 = ConstantMax + 10;
            // To enable the assignments to int1 to compile and run, place them inside
            // an unchecked block or expression. The following statements compile and
            // run.
            unchecked
            {
            int1 = 2147483647 + 10;
            }
            int1 = unchecked(ConstantMax + 10);
            // The sum of 2,147,483,647 and 10 is displayed as -2,147,483,639.
            Console.WriteLine(int1);

            // The following statement is unchecked by default at compile time and run
            // time because the expression contains the variable variableMax. It causes
            // overflow but the overflow is not detected. The statement compiles and runs.
            int2 = variableMax + 10;
            // Again, the sum of 2,147,483,647 and 10 is displayed as -2,147,483,639.
            Console.WriteLine(int2);
            // To catch the overflow in the assignment to int2 at run time, put the
            // declaration in a checked block or expression. The following
            // statements compile but raise an overflow exception at run time.
            checked
            {
            //int2 = variableMax + 10;
            }
            //int2 = checked(variableMax + 10);
            // Unchecked sections frequently are used to break out of a checked
            // environment in order to improve performance in a portion of code
            // that is not expected to raise overflow exceptions.
            checked
            {
            // Code that might cause overflow should be executed in a checked
            // environment.
            unchecked
            {
            // This section is appropriate for code that you are confident
            // will not result in overflow, and for which performance is
            // a priority.
            }
            // Additional checked code here.
            }
            }
            }

            C# language specification

            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Checked and Unchecked
            checked

            fixed Statement (C# Reference)
            12/11/2018 • 4 minutes to read • Edit Online

            The fixed statement prevents the garbage collector from relocating a movable variable. The fixed statement is
            only permitted in an unsafe context. fixed can also be used to create fixed size buffers.
            The fixed statement sets a pointer to a managed variable and "pins" that variable during the execution of the
            statement. Pointers to movable managed variables are useful only in a fixed context. Without a fixed context,
            garbage collection could relocate the variables unpredictably. The C# compiler only lets you assign a pointer to a
            managed variable in a fixed statement.
            class Point
            {
            public int x;
            public int y;
            }
            unsafe private static void ModifyFixedStorage()
            {
            // Variable pt is a managed variable, subject to garbage collection.
            Point pt = new Point();
            // Using fixed allows the address of pt members to be taken,
            // and "pins" pt so that it is not relocated.
            fixed (int* p = &pt.x)
            {
            *p = 1;
            }
            }

            You can initialize a pointer by using an array, a string, a fixed-size buffer, or the address of a variable. The following
            example illustrates the use of variable addresses, arrays, and strings. For more information about fixed-size
            buffers, see Fixed Size Buffers.
            Point point = new Point();
            double[] arr = { 0, 1.5, 2.3, 3.4, 4.0, 5.9 };
            string str = "Hello World";
            // The following two assignments are equivalent. Each assigns the address
            // of the first element in array arr to pointer p.
            // You can initialize a pointer by using an array.
            fixed (double* p = arr) { /*...*/ }
            // You can initialize a pointer by using the address of a variable.
            fixed (double* p = &arr[0]) { /*...*/ }
            // The following assignment initializes p by using a string.
            fixed (char* p = str) { /*...*/ }
            // The following assignment is not valid, because str[0] is a char,
            // which is a value, not a variable.
            //fixed (char* p = &str[0]) { /*...*/ }

            Starting with C# 7.3, the fixed statement operates on additional types beyond arrays, strings, fixed-size buffers,

            or unmanaged variables. Any type that implements a method named GetPinnableReference can be pinned. The
            GetPinnableReference must return a ref variable to an unmanaged type. See the topic on pointer types for more
            information. The .NET types System.Span<T> and System.ReadOnlySpan<T> introduced in .NET Core 2.0 make
            use of this pattern and can be pinned. This is shown in the following example:
            unsafe private static void FixedSpanExample()
            {
            int[] PascalsTriangle = {
            1,
            1, 1,
            1, 2, 1,
            1, 3, 3, 1,
            1, 4, 6, 4, 1,
            1, 5, 10, 10, 5, 1
            };
            Span<int> RowFive = new Span<int>(PascalsTriangle, 10, 5);
            fixed (int* ptrToRow = RowFive)
            {
            // Sum the numbers 1,4,6,4,1
            var sum = 0;
            for (int i = 0; i < RowFive.Length; i++)
            {
            sum += *(ptrToRow + i);
            }
            Console.WriteLine(sum);
            }
            }

            If you are creating types that should participate in this pattern, see Span<T>.GetPinnableReference() for an
            example of implementing the pattern.
            Multiple pointers can be initialized in one statement if they are all the same type:
            fixed (byte* ps = srcarray, pd = dstarray) {...}

            To initialize pointers of different types, simply nest fixed statements, as shown in the following example.
            fixed (int* p1 = &point.x)
            {
            fixed (double* p2 = &arr[5])
            {
            // Do something with p1 and p2.
            }
            }

            After the code in the statement is executed, any pinned variables are unpinned and subject to garbage collection.
            Therefore, do not point to those variables outside the fixed statement. The variables declared in the fixed
            statement are scoped to that statement, making this easier:
            fixed (byte* ps = srcarray, pd = dstarray)
            {
            ...
            }
            // ps and pd are no longer in scope here.

            Pointers initialized in fixed statements are readonly variables. If you want to modify the pointer value, you must

            declare a second pointer variable, and modify that. The variable declared in the fixed statement cannot be
            modified:
            fixed (byte* ps = srcarray, pd = dstarray)
            {
            byte* pSourceCopy = ps;
            pSourceCopy++; // point to the next element.
            ps++; // invalid: cannot modify ps, as it is declared in the fixed statement.
            }

            In unsafe mode, you can allocate memory on the stack, where it is not subject to garbage collection and therefore
            does not need to be pinned. For more information, see stackalloc.
            // Unsafe method: takes a pointer to an int.
            unsafe static void SquarePtrParam(int* p)
            {
            *p *= *p;
            }
            unsafe static void SquarePointValue()
            {
            Point pt = new Point
            {
            x = 5,
            y = 6
            };
            // Pin pt in place:
            fixed (int* p = &pt.x)
            {
            SquarePtrParam(p);
            }
            // pt now unpinned.
            Console.WriteLine("{0} {1}", pt.x, pt.y);
            /*
            Output:
            25 6
            */
            }

            C# Language Specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            unsafe
            Fixed Size Buffers

            lock statement (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The lock statement acquires the mutual-exclusion lock for a given object, executes a statement block, and then
            releases the lock. While a lock is held, the thread that holds the lock can again acquire and release the lock. Any
            other thread is blocked from acquiring the lock and waits until the lock is released.
            The lock statement is of the form
            lock (x)
            {
            // Your code...
            }

            where x is an expression of a reference type. It's precisely equivalent to
            object __lockObj = x;
            bool __lockWasTaken = false;
            try
            {
            System.Threading.Monitor.Enter(__lockObj, ref __lockWasTaken);
            // Your code...
            }
            finally
            {
            if (__lockWasTaken) System.Threading.Monitor.Exit(__lockObj);
            }

            Since the code uses a try...finally block, the lock is released even if an exception is thrown within the body of a
            lock statement.
            You can't use the await keyword in the body of a lock statement.

            Remarks
            When you synchronize thread access to a shared resource, lock on a dedicated object instance (for example,
            private readonly object balanceLock = new object(); ) or another instance that is unlikely to be used as a lock
            object by unrelated parts of the code. Avoid using the same lock object instance for different shared resources, as
            it might result in deadlock or lock contention. In particular, avoid using the following as lock objects:
            this , as it might be used by the callers as a lock.

            Type instances, as those might be obtained by the typeof operator or reflection.
            string instances, including string literals, as those might be interned.

            Example
            The following example defines an Account class that synchronizes access to its private balance field by locking
            on a dedicated balanceLock instance. Using the same instance for locking ensures that the balance field cannot
            be updated simultaneously by two threads attempting to call the Debit or Credit methods simultaneously.
            using System;
            using System.Threading.Tasks;

            public class Account
            {
            private readonly object balanceLock = new object();
            private decimal balance;
            public Account(decimal initialBalance)
            {
            balance = initialBalance;
            }
            public decimal Debit(decimal amount)
            {
            lock (balanceLock)
            {
            if (balance >= amount)
            {
            Console.WriteLine($"Balance before debit :{balance, 5}");
            Console.WriteLine($"Amount to remove
            :{amount, 5}");
            balance = balance - amount;
            Console.WriteLine($"Balance after debit :{balance, 5}");
            return amount;
            }
            else
            {
            return 0;
            }
            }
            }
            public void Credit(decimal amount)
            {
            lock (balanceLock)
            {
            Console.WriteLine($"Balance before credit:{balance, 5}");
            Console.WriteLine($"Amount to add
            :{amount, 5}");
            balance = balance + amount;
            Console.WriteLine($"Balance after credit :{balance, 5}");
            }
            }
            }
            class AccountTest
            {
            static void Main()
            {
            var account = new Account(1000);
            var tasks = new Task[100];
            for (int i = 0; i < tasks.Length; i++)
            {
            tasks[i] = Task.Run(() => RandomlyUpdate(account));
            }
            Task.WaitAll(tasks);
            }
            static void RandomlyUpdate(Account account)
            {
            var rnd = new Random();
            for (int i = 0; i < 10; i++)
            {
            var amount = rnd.Next(1, 100);
            bool doCredit = rnd.NextDouble() < 0.5;
            if (doCredit)
            {
            account.Credit(amount);
            }
            else
            {
            account.Debit(amount);
            }

            }
            }
            }
            }

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            System.Threading.Monitor
            System.Threading.SpinLock
            System.Threading.Interlocked
            C# Reference
            C# Keywords
            Statement Keywords
            Overview of synchronization primitives

            Method Parameters (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Parameters declared for a method without in, ref or out, are passed to the called method by value. That value can
            be changed in the method, but the changed value will not be retained when control passes back to the calling
            procedure. By using a method parameter keyword, you can change this behavior.
            This section describes the keywords you can use when declaring method parameters:
            params specifies that this parameter may take a variable number of arguments.
            in specifies that this parameter is passed by reference but is only read by the called method.
            ref specifies that this parameter is passed by reference and may be read or written by the called method.
            out specifies that this parameter is passed by reference and is written by the called method.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords

            params (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            By using the params keyword, you can specify a method parameter that takes a variable number of arguments.
            You can send a comma-separated list of arguments of the type specified in the parameter declaration or an array
            of arguments of the specified type. You also can send no arguments. If you send no arguments, the length of the
            params list is zero.
            No additional parameters are permitted after the params keyword in a method declaration, and only one params
            keyword is permitted in a method declaration.
            The declared type of the params parameter must be a single-dimensional array, as the following example shows.
            Otherwise, a compiler error CS0225 occurs.

            Example
            The following example demonstrates various ways in which arguments can be sent to a params parameter.

            public class MyClass
            {
            public static void UseParams(params int[] list)
            {
            for (int i = 0; i < list.Length; i++)
            {
            Console.Write(list[i] + " ");
            }
            Console.WriteLine();
            }
            public static void UseParams2(params object[] list)
            {
            for (int i = 0; i < list.Length; i++)
            {
            Console.Write(list[i] + " ");
            }
            Console.WriteLine();
            }
            static void Main()
            {
            // You can send a comma-separated list of arguments of the
            // specified type.
            UseParams(1, 2, 3, 4);
            UseParams2(1, 'a', "test");
            // A params parameter accepts zero or more arguments.
            // The following calling statement displays only a blank line.
            UseParams2();
            // An array argument can be passed, as long as the array
            // type matches the parameter type of the method being called.
            int[] myIntArray = { 5, 6, 7, 8, 9 };
            UseParams(myIntArray);
            object[] myObjArray = { 2, 'b', "test", "again" };
            UseParams2(myObjArray);
            // The following call causes a compiler error because the object
            // array cannot be converted into an integer array.
            //UseParams(myObjArray);
            // The following call does not cause an error, but the entire
            // integer array becomes the first element of the params array.
            UseParams2(myIntArray);
            }
            }
            /*
            Output:
            1 2 3 4
            1 a test
            5 6 7 8 9
            2 b test again
            System.Int32[]
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also

            C# Reference
            C# Programming Guide
            C# Keywords
            Method Parameters

            in parameter modifier (C# Reference)
            12/11/2018 • 4 minutes to read • Edit Online

            The in keyword causes arguments to be passed by reference. It is like the ref or out keywords, except that in
            arguments cannot be modified by the called method. Whereas ref arguments may be modified, out arguments
            must be modified by the called method, and those modifications are observable in the calling context.
            int readonlyArgument = 44;
            InArgExample(readonlyArgument);
            Console.WriteLine(readonlyArgument);

            // value is still 44

            void InArgExample(in int number)
            {
            // Uncomment the following line to see error CS8331
            //number = 19;
            }

            The preceding example demonstrates that the in modifier is usually unnecessary at the call site. It is only
            required in the method declaration.
            NOTE
            The in keyword can also be used with a generic type parameter to specify that the type parameter is contravariant, as
            part of a foreach statement, or as part of a join clause in a LINQ query. For more information on the use of the in
            keyword in these contexts, see in, which provides links to all those uses.

            Variables passed as in arguments must be initialized before being passed in a method call. However, the called
            method may not assign a value or modify the argument.
            Although the in , ref , and out keywords cause different run-time behavior, they are not considered part of the
            method signature at compile time. Therefore, methods cannot be overloaded if the only difference is that one
            method takes a ref or in argument and the other takes an out argument. The following code, for example,
            will not compile:
            class CS0663_Example
            {
            // Compiler error CS0663: "Cannot define overloaded
            // methods that differ only on in, ref and out".
            public void SampleMethod(in int i) { }
            public void SampleMethod(ref int i) { }
            }

            Overloading based on the presence of in is allowed:
            class InOverloads
            {
            public void SampleMethod(in int i) { }
            public void SampleMethod(int i) { }
            }

            Overload resolution rules

            You can understand the overload resolution rules for methods with by value vs. in arguments by understanding
            the motivation for in arguments. Defining methods using in parameters is a potential performance
            optimization. Some struct type arguments may be large in size, and when methods are called in tight loops or
            critical code paths, the cost of copying those structures is critical. Methods declare in parameters to specify that
            arguments may be passed by reference safely because the called method does not modify the state of that
            argument. Passing those arguments by reference avoids the (potentially) expensive copy.
            Specifying in for arguments at the call site is typically optional. There is no semantic difference between passing
            arguments by value and passing them by reference using the in modifier. The in modifier at the call site is
            optional because you don't need to indicate that the argument's value might be changed. You explicitly add the
            in modifier at the call site to ensure the argument is passed by reference, not by value. Explicitly using in has
            the following two effects:
            First, specifying in at the call site forces the compiler to select a method defined with a matching in parameter.
            Otherwise, when two methods differ only in the presence of in , the by value overload is a better match.
            Second, specifying in declares your intent to pass an argument by reference. The argument used with in must
            represent a location that can be directly referred to. The same general rules for out and ref arguments apply:
            You cannot use constants, ordinary properties, or other expressions that produce values. Otherwise, omitting in
            at the call site informs the compiler that you will allow it to create a temporary variable to pass by read-only
            reference to the method. The compiler creates a temporary variable to overcome several restrictions with in
            arguments:
            A temporary variable allows compile-time constants as in parameters.
            A temporary variable allows properties, or other expressions for in parameters.
            A temporary variable allows arguments where there is an implicit conversion from the argument type to the
            parameter type.
            In all the preceding instances, the compiler creates a temporary variable that stores the value of the constant,
            property, or other expression.
            The following code illustrates these rules:
            static void Method(in int argument)
            {
            // implementation removed
            }
            Method(5); // OK, temporary variable created.
            Method(5L); // CS1503: no implicit conversion from long to int
            short s = 0;
            Method(s); // OK, temporary int created with the value 0
            Method(in s); // CS1503: cannot convert from in short to in int
            int i = 42;
            Method(i); // passed by readonly reference
            Method(in i); // passed by readonly reference, explicitly using `in`

            Now, suppose another method using by value arguments was available. The results change as shown in the
            following code:

            static void Method(int argument)
            {
            // implementation removed
            }
            static void Method(in int argument)
            {
            // implementation removed
            }
            Method(5); // Calls overload passed by value
            Method(5L); // CS1503: no implicit conversion from long to int
            short s = 0;
            Method(s); // Calls overload passed by value.
            Method(in s); // CS1503: cannot convert from in short to in int
            int i = 42;
            Method(i); // Calls overload passed by value
            Method(in i); // passed by readonly reference, explicitly using `in`

            The only method call where the argument is passed by reference is the final one.
            NOTE
            The preceding code uses int as the argument type for simplicity. Because int is no larger than a reference in most
            modern machines, there is no benefit to passing a single int as a readonly reference.

            Limitations on in parameters
            You can't use the in , ref , and out keywords for the following kinds of methods:
            Async methods, which you define by using the async modifier.
            Iterator methods, which include a yield return or yield break statement.

            C# Language Specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            Method Parameters
            Write safe efficient code

            ref (C# Reference)
            12/11/2018 • 9 minutes to read • Edit Online

            The ref keyword indicates a value that is passed by reference. It is used in four different contexts:
            In a method signature and in a method call, to pass an argument to a method by reference. For more
            information, see Passing an argument by reference.
            In a method signature, to return a value to the caller by reference. For more information, see Reference return
            values.
            In a member body, to indicate that a reference return value is stored locally as a reference that the caller
            intends to modify or, in general, a local variable accesses another value by reference. For more information,
            see Ref locals.
            In a struct declaration to declare a ref struct or a ref readonly struct . For more information, see ref
            struct types.

            Passing an argument by reference
            When used in a method's parameter list, the ref keyword indicates that an argument is passed by reference, not
            by value. The effect of passing by reference is that any change to the argument in the called method is reflected
            in the calling method. For example, if the caller passes a local variable expression or an array element access
            expression, and the called method replaces the object to which the ref parameter refers, then the caller's local
            variable or the array element now refers to the new object when the method returns.
            NOTE
            Do not confuse the concept of passing by reference with the concept of reference types. The two concepts are not the
            same. A method parameter can be modified by ref regardless of whether it is a value type or a reference type. There is
            no boxing of a value type when it is passed by reference.

            To use a ref parameter, both the method definition and the calling method must explicitly use the ref
            keyword, as shown in the following example.
            void Method(ref int refArgument)
            {
            refArgument = refArgument + 44;
            }
            int number = 1;
            Method(ref number);
            Console.WriteLine(number);
            // Output: 45

            An argument that is passed to a ref or in parameter must be initialized before it is passed. This differs from
            out parameters, whose arguments do not have to be explicitly initialized before they are passed.
            Members of a class can't have signatures that differ only by ref , in , or out . A compiler error occurs if the
            only difference between two members of a type is that one of them has a ref parameter and the other has an
            out , or in parameter. The following code, for example, doesn't compile.

            class CS0663_Example
            {
            // Compiler error CS0663: "Cannot define overloaded
            // methods that differ only on ref and out".
            public void SampleMethod(out int i) { }
            public void SampleMethod(ref int i) { }
            }

            However, methods can be overloaded when one method has a ref , in , or out parameter and the other has a
            value parameter, as shown in the following example.
            class RefOverloadExample
            {
            public void SampleMethod(int i) { }
            public void SampleMethod(ref int i) { }
            }

            In other situations that require signature matching, such as hiding or overriding, in , ref , and out are part of
            the signature and don't match each other.
            Properties are not variables. They are methods, and cannot be passed to ref parameters.
            You can't use the ref , in , and out keywords for the following kinds of methods:
            Async methods, which you define by using the async modifier.
            Iterator methods, which include a yield return or yield break statement.

            Passing an argument by reference: An example
            The previous examples pass value types by reference. You can also use the ref keyword to pass reference types
            by reference. Passing a reference type by reference enables the called method to replace the object to which the
            reference parameter refers in the caller. The storage location of the object is passed to the method as the value of
            the reference parameter. If you change the value in the storage location of the parameter (to point to a new
            object), you also change the storage location to which the caller refers. The following example passes an instance
            of a reference type as a ref parameter.

            class Product
            {
            public Product(string name, int newID)
            {
            ItemName = name;
            ItemID = newID;
            }
            public string ItemName { get; set; }
            public int ItemID { get; set; }
            }
            private static void ChangeByReference(ref Product itemRef)
            {
            // Change the address that is stored in the itemRef parameter.
            itemRef = new Product("Stapler", 99999);
            // You can change the value of one of the properties of
            // itemRef. The change happens to item in Main as well.
            itemRef.ItemID = 12345;
            }
            private static void ModifyProductsByReference()
            {
            // Declare an instance of Product and display its initial values.
            Product item = new Product("Fasteners", 54321);
            System.Console.WriteLine("Original values in Main. Name: {0}, ID: {1}\n",
            item.ItemName, item.ItemID);
            // Pass the product instance to ChangeByReference.
            ChangeByReference(ref item);
            System.Console.WriteLine("Back in Main. Name: {0}, ID: {1}\n",
            item.ItemName, item.ItemID);
            }
            // This method displays the following output:
            // Original values in Main. Name: Fasteners, ID: 54321
            // Back in Main. Name: Stapler, ID: 12345

            For more information about how to pass reference types by value and by reference, see Passing Reference-Type
            Parameters.

            Reference return values
            Reference return values (or ref returns) are values that a method returns by reference to the caller. That is, the
            caller can modify the value returned by a method, and that change is reflected in the state of the object that
            contains the method.
            A reference return value is defined by using the ref keyword:
            In the method signature. For example, the following method signature indicates that the GetCurrentPrice
            method returns a Decimal value by reference.
            public ref decimal GetCurrentPrice()

            Between the return token and the variable returned in a return statement in the method. For example:
            return ref DecimalArray[0];

            In order for the caller to modify the object's state, the reference return value must be stored to a variable that is
            explicitly defined as a ref local.
            The called method may also declare the return value as ref readonly to return the value by reference, and
            enforce that the calling code cannot modify the returned value. The calling method can avoid copying the
            returned valued by storing the value in a local ref readonly variable.
            For an example, see A ref returns and ref locals example.

            Ref locals
            A ref local variable is used to refer to values returned using return ref . A ref local variable cannot be initialized
            to a non-ref return value. In other words, the right hand side of the initialization must be a reference. Any
            modifications to the value of the ref local are reflected in the state of the object whose method returned the value
            by reference.
            You define a ref local by using the ref keyword before the variable declaration, as well as immediately before
            the call to the method that returns the value by reference.
            For example, the following statement defines a ref local value that is returned by a method named
            GetEstimatedValue :
            ref decimal estValue = ref Building.GetEstimatedValue();

            You can access a value by reference in the same way. In some cases, accessing a value by reference increases
            performance by avoiding a potentially expensive copy operation. For example, the following statement shows
            how one can define a ref local value that is used to reference a value.
            ref VeryLargeStruct reflocal = ref veryLargeStruct;

            Note that in both examples the ref keyword must be used in both places, or the compiler generates error
            CS8172, "Cannot initialize a by-reference variable with a value."
            Beginning with C# 7.3, the iteration variable of the foreach statement can be ref local or ref readonly local
            variable. For more information, see the foreach statement article.

            Ref readonly locals
            A ref readonly local is used to refer to values returned by the method or property that has ref readonly in its
            signature and uses return ref . A ref readonly variable combines the properties of a ref local variable with a
            readonly variable: it is an alias to the storage it's assigned to, and it cannot be modified.

            A ref returns and ref locals example
            The following example defines a Book class that has two String fields, Title and Author . It also defines a
            BookCollection class that includes a private array of Book objects. Individual book objects are returned by
            reference by calling its GetBookByTitle method.

            public class Book
            {
            public string Author;
            public string Title;
            }
            public class BookCollection
            {
            private Book[] books = { new Book { Title = "Call of the Wild, The", Author = "Jack London" },
            new Book { Title = "Tale of Two Cities, A", Author = "Charles Dickens" }
            };
            private Book nobook = null;
            public ref Book GetBookByTitle(string title)
            {
            for (int ctr = 0; ctr < books.Length; ctr++)
            {
            if (title == books[ctr].Title)
            return ref books[ctr];
            }
            return ref nobook;
            }
            public void ListBooks()
            {
            foreach (var book in books)
            {
            Console.WriteLine($"{book.Title}, by {book.Author}");
            }
            Console.WriteLine();
            }
            }

            When the caller stores the value returned by the GetBookByTitle method as a ref local, changes that the caller
            makes to the return value are reflected in the BookCollection object, as the following example shows.
            var bc = new BookCollection();
            bc.ListBooks();
            ref var book = ref bc.GetBookByTitle("Call of the Wild, The");
            if (book != null)
            book = new Book { Title = "Republic, The", Author = "Plato" };
            bc.ListBooks();
            // The example displays the following output:
            //
            Call of the Wild, The, by Jack London
            //
            Tale of Two Cities, A, by Charles Dickens
            //
            //
            Republic, The, by Plato
            //
            Tale of Two Cities, A, by Charles Dickens

            Ref struct types
            Adding the ref modifier to a struct declaration defines that instances of that type must be stack allocated. In
            other words, instances of these types can never be created on the heap as a member of another class. The
            primary motivation for this feature was Span<T> and related structures.
            The goal of keeping a ref struct type as a stack-allocated variable introduces several rules that the compiler
            enforces for all ref struct types.
            You can't box a ref struct . You cannot assign a ref struct type to a variable of type object , dynamic , or
            any interface type.

            ref struct types cannot implement interfaces.

            You can't declare a ref struct as a member of a class or a normal struct.
            You cannot declare local variables that are ref struct types in async methods. You can declare them in
            synchronous methods that return Task, Task<TResult> or Task -like types.
            You cannot declare ref struct local variables in iterators.
            You cannot capture ref struct variables in lambda expressions or local functions.
            These restrictions ensure you don't accidentally use a ref struct in a manner that could promote it to the
            managed heap.
            You can combine modifiers to declare a struct as readonly ref . A readonly ref struct combines the benefits
            and restrictions of ref struct and readonly struct declarations.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            Write safe efficient code
            Ref returns and ref locals
            Conditional ref expression
            ref assignment operator
            Passing Parameters
            Method Parameters
            C# Reference
            C# Programming Guide
            C# Keywords

            out parameter modifier (C# Reference)
            12/11/2018 • 3 minutes to read • Edit Online

            The out keyword causes arguments to be passed by reference. It is like the ref keyword, except that ref
            requires that the variable be initialized before it is passed. It is also like the in keyword, except that in does not
            allow the called method to modify the argument value. To use an out parameter, both the method definition and
            the calling method must explicitly use the out keyword. For example:
            int initializeInMethod;
            OutArgExample(out initializeInMethod);
            Console.WriteLine(initializeInMethod);

            // value is now 44

            void OutArgExample(out int number)
            {
            number = 44;
            }

            NOTE
            The out keyword can also be used with a generic type parameter to specify that the type parameter is covariant. For
            more information on the use of the out keyword in this context, see out (Generic Modifier).

            Variables passed as out arguments do not have to be initialized before being passed in a method call. However,
            the called method is required to assign a value before the method returns.
            Although the in , ref , and out keywords cause different run-time behavior, they are not considered part of the
            method signature at compile time. Therefore, methods cannot be overloaded if the only difference is that one
            method takes a ref or in argument and the other takes an out argument. The following code, for example,
            will not compile:
            class CS0663_Example
            {
            // Compiler error CS0663: "Cannot define overloaded
            // methods that differ only on ref and out".
            public void SampleMethod(out int i) { }
            public void SampleMethod(ref int i) { }
            }

            Overloading is legal, however, if one method takes a ref , in , or out argument and the other has none of
            those modifiers, like this:
            class OutOverloadExample
            {
            public void SampleMethod(int i) { }
            public void SampleMethod(out int i) => i = 5;
            }

            The compiler chooses the best overload by matching the parameter modifiers at the call site to the parameter
            modifiers used in the method call.
            Properties are not variables and therefore cannot be passed as out parameters.

            You can't use the in , ref , and out keywords for the following kinds of methods:
            Async methods, which you define by using the async modifier.
            Iterator methods, which include a yield return or yield break statement.

            Declaring out arguments
            Declaring a method with out arguments is useful when you want a method to return multiple values. The
            following example uses out to return three variables with a single method call. Note that the third argument is
            assigned to null. This enables methods to return values optionally.
            void Method(out int answer, out string message, out string stillNull)
            {
            answer = 44;
            message = "I've been returned";
            stillNull = null;
            }
            int argNumber;
            string argMessage, argDefault;
            Method(out argNumber, out argMessage, out argDefault);
            Console.WriteLine(argNumber);
            Console.WriteLine(argMessage);
            Console.WriteLine(argDefault == null);
            // The example displays the following output:
            //
            44
            //
            I've been returned
            //
            True

            The Try pattern involves returning a bool to indicate whether an operation succeeded or failed, and returning
            the value produced by the operation in an out argument. A number of parsing methods, such as the
            DateTime.TryParse method, use this pattern.

            Calling a method with an out argument
            In C# 6 and earlier, you must declare a variable in a separate statement before you pass it as an out argument.
            The following example declares a variable named number before it is passed to the Int32.TryParse method, which
            attempts to convert a string to a number.
            string numberAsString = "1640";
            int number;
            if (Int32.TryParse(numberAsString, out number))
            Console.WriteLine($"Converted '{numberAsString}' to {number}");
            else
            Console.WriteLine($"Unable to convert '{numberAsString}'");
            // The example displays the following output:
            //
            Converted '1640' to 1640

            Starting with C# 7.0, you can declare the out variable in the argument list of the method call, rather than in a
            separate variable declaration. This produces more compact, readable code, and also prevents you from
            inadvertently assigning a value to the variable before the method call. The following example is like the previous
            example, except that it defines the number variable in the call to the Int32.TryParse method.

            string numberAsString = "1640";
            if (Int32.TryParse(numberAsString, out int number))
            Console.WriteLine($"Converted '{numberAsString}' to {number}");
            else
            Console.WriteLine($"Unable to convert '{numberAsString}'");
            // The example displays the following output:
            //
            Converted '1640' to 1640

            In the previous example, the number variable is strongly typed as an int . You can also declare an implicitly
            typed local variable, as the following example does.
            string numberAsString = "1640";
            if (Int32.TryParse(numberAsString, out var number))
            Console.WriteLine($"Converted '{numberAsString}' to {number}");
            else
            Console.WriteLine($"Unable to convert '{numberAsString}'");
            // The example displays the following output:
            //
            Converted '1640' to 1640

            C# Language Specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            Method Parameters

            Namespace Keywords (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            This section describes the keywords and operators that are associated with using namespaces:
            namespace
            using
            using static
            . Operator
            :: Operator
            extern alias

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            Namespaces

            namespace (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The namespace keyword is used to declare a scope that contains a set of related objects. You can use a namespace
            to organize code elements and to create globally unique types.
            namespace SampleNamespace
            {
            class SampleClass { }
            interface ISampleInterface { }
            struct SampleStruct { }
            enum SampleEnum { a, b }
            delegate void SampleDelegate(int i);
            namespace Nested
            {
            class SampleClass2 { }
            }
            }

            Remarks
            Within a namespace, you can declare zero or more of the following types:
            another namespace
            class
            interface
            struct
            enum
            delegate
            Whether or not you explicitly declare a namespace in a C# source file, the compiler adds a default namespace. This
            unnamed namespace, sometimes referred to as the global namespace, is present in every file. Any identifier in the
            global namespace is available for use in a named namespace.
            Namespaces implicitly have public access and this is not modifiable. For a discussion of the access modifiers you
            can assign to elements in a namespace, see Access Modifiers.
            It is possible to define a namespace in two or more declarations. For example, the following example defines two
            classes as part of the MyCompany namespace:

            namespace MyCompany.Proj1
            {
            class MyClass
            {
            }
            }
            namespace MyCompany.Proj1
            {
            class MyClass1
            {
            }
            }

            Example
            The following example shows how to call a static method in a nested namespace.
            namespace SomeNameSpace
            {
            public class MyClass
            {
            static void Main()
            {
            Nested.NestedNameSpaceClass.SayHello();
            }
            }
            // a nested namespace
            namespace Nested
            {
            public class NestedNameSpaceClass
            {
            public static void SayHello()
            {
            Console.WriteLine("Hello");
            }
            }
            }
            }
            // Output: Hello

            Related resources
            For more information about using namespaces, see the following topics:
            Namespaces
            Using Namespaces
            How to: Use the Global Namespace Alias

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference

            C# Programming Guide
            C# Keywords
            Namespace Keywords
            using

            using (C# Reference)
            12/19/2018 • 2 minutes to read • Edit Online

            The using keyword has two major uses:
            As a directive, when it is used to create an alias for a namespace or to import types defined in other
            namespaces. See using directive.
            As a statement, when it defines a scope at the end of which an object will be disposed. See using statement.
            In addition, the using static directive lets you define a type whose static members you can access without
            specifying a type name.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Namespace Keywords
            Namespaces
            extern

            using directive (C# Reference)
            1/4/2019 • 3 minutes to read • Edit Online

            The using directive has three uses:
            To allow the use of types in a namespace so that you do not have to qualify the use of a type in that
            namespace:
            using System.Text;

            To allow you to access static members and nested types of a type without having to qualify the access with
            the type name.
            using static System.Math;

            For more information, see the using static directive.
            To create an alias for a namespace or a type. This is called a using alias directive.
            using Project = PC.MyCompany.Project;

            The using keyword is also used to create using statements, which help ensure that IDisposable objects such as
            files and fonts are handled correctly. See using Statement for more information.

            Using static type
            You can access static members of a type without having to qualify the access with the type name:
            using static System.Console;
            using static System.Math;
            class Program
            {
            static void Main()
            {
            WriteLine(Sqrt(3*3 + 4*4));
            }
            }

            Remarks
            The scope of a using directive is limited to the file in which it appears.
            The using directive can appear:
            At the beginning of a source code file, before any namespace or type definitions.
            In any namespace, but before any namespace or types declared in this namespace.
            Otherwise, compiler error CS1529 is generated.
            Create a using alias directive to make it easier to qualify an identifier to a namespace or type. In any using
            directive, the fully-qualified namespace or type must be used regardless of the using directives that come before

            it. No using alias can be used in the declaration of a using directive. For example, the following generates a
            compiler error:
            using s = System.Text;
            using s.RegularExpressions;

            Create a using directive to use the types in a namespace without having to specify the namespace. A using
            directive does not give you access to any namespaces that are nested in the namespace you specify.
            Namespaces come in two categories: user-defined and system-defined. User-defined namespaces are namespaces
            defined in your code. For a list of the system-defined namespaces, see .NET API Browser.
            For examples on referencing methods in other assemblies, see Create and Use Assemblies Using the Command
            Line.

            Example 1
            The following example shows how to define and use a using alias for a namespace:
            namespace PC
            {
            // Define an alias for the nested namespace.
            using Project = PC.MyCompany.Project;
            class A
            {
            void M()
            {
            // Use the alias
            Project.MyClass mc = new Project.MyClass();
            }
            }
            namespace MyCompany
            {
            namespace Project
            {
            public class MyClass { }
            }
            }
            }

            A using alias directive cannot have an open generic type on the right hand side. For example, you cannot create a
            using alias for a List<T> , but you can create one for a List<int> .

            Example 2
            The following example shows how to define a using directive and a using alias for a class:

            using System;
            // Using alias directive for a class.
            using AliasToMyClass = NameSpace1.MyClass;
            // Using alias directive for a generic class.
            using UsingAlias = NameSpace2.MyClass<int>;
            namespace NameSpace1
            {
            public class MyClass
            {
            public override string ToString()
            {
            return "You are in NameSpace1.MyClass.";
            }
            }
            }
            namespace NameSpace2
            {
            class MyClass<T>
            {
            public override string ToString()
            {
            return "You are in NameSpace2.MyClass.";
            }
            }
            }
            namespace NameSpace3
            {
            // Using directive:
            using NameSpace1;
            // Using directive:
            using NameSpace2;
            class MainClass
            {
            static void Main()
            {
            AliasToMyClass instance1 = new AliasToMyClass();
            Console.WriteLine(instance1);
            UsingAlias instance2 = new UsingAlias();
            Console.WriteLine(instance2);
            }
            }
            }
            // Output:
            //
            You are in NameSpace1.MyClass.
            //
            You are in NameSpace2.MyClass.

            C# language specification
            For more information, see Using directives in the C# Language Specification. The language specification is the
            definitive source for C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide

            Using Namespaces
            C# Keywords
            Namespace Keywords
            Namespaces
            using Statement

            using static directive (C# Reference)
            12/19/2018 • 3 minutes to read • Edit Online

            The using static directive designates a type whose static members and nested types you can access without
            specifying a type name. Its syntax is:
            using static <fully-qualified-type-name>;

            where fully-qualified -type-name is the name of the type whose static members and nested types can be
            referenced without specifying a type name. If you do not provide a fully qualified type name (the full namespace
            name along with the type name), C# generates compiler error CS0246: "The type or namespace name
            'type/namespace' could not be found (are you missing a using directive or an assembly reference?)".
            The using static directive applies to any type that has static members (or nested types), even if it also has
            instance members. However, instance members can only be invoked through the type instance.
            The using static directive was introduced in C# 6.

            Remarks
            Ordinarily, when you call a static member, you provide the type name along with the member name. Repeatedly
            entering the same type name to invoke members of the type can result in verbose, obscure code. For example, the
            following definition of a Circle class references a number of members of the Math class.
            using System;
            public class Circle
            {
            public Circle(double radius)
            {
            Radius = radius;
            }
            public double Radius { get; set; }
            public double Diameter
            {
            get { return 2 * Radius; }
            }
            public double Circumference
            {
            get { return 2 * Radius * Math.PI; }
            }
            public double Area
            {
            get { return Math.PI * Math.Pow(Radius, 2); }
            }
            }

            By eliminating the need to explicitly reference the Math class each time a member is referenced, the using static
            directive produces much cleaner code:

            using System;
            using static System.Math;
            public class Circle
            {
            public Circle(double radius)
            {
            Radius = radius;
            }
            public double Radius { get; set; }
            public double Diameter
            {
            get { return 2 * Radius; }
            }
            public double Circumference
            {
            get { return 2 * Radius * PI; }
            }
            public double Area
            {
            get { return PI * Pow(Radius, 2); }
            }
            }

            using static imports only accessible static members and nested types declared in the specified type. Inherited

            members are not imported. You can import from any named type with a using static directive, including Visual
            Basic modules. If F# top-level functions appear in metadata as static members of a named type whose name is a
            valid C# identifier, then the F# functions can be imported.
            using static makes extension methods declared in the specified type available for extension method lookup.
            However, the names of the extension methods are not imported into scope for unqualified reference in code.

            Methods with the same name imported from different types by different using static directives in the same
            compilation unit or namespace form a method group. Overload resolution within these method groups follows
            normal C# rules.

            Example
            The following example uses the using static directive to make the static members of the Console, Math, and
            String classes available without having to specify their type name.

            using System;
            using static System.Console;
            using static System.Math;
            using static System.String;
            class Program
            {
            static void Main()
            {
            Write("Enter a circle's radius: ");
            var input = ReadLine();
            if (!IsNullOrEmpty(input) && double.TryParse(input, out var radius)) {
            var c = new Circle(radius);
            string s = "\nInformation about the circle:\n";
            s = s + Format(" Radius: {0:N2}\n", c.Radius);
            s = s + Format(" Diameter: {0:N2}\n", c.Diameter);
            s = s + Format(" Circumference: {0:N2}\n", c.Circumference);
            s = s + Format(" Area: {0:N2}\n", c.Area);
            WriteLine(s);
            }
            else {
            WriteLine("Invalid input...");
            }
            }
            }
            public class Circle
            {
            public Circle(double radius)
            {
            Radius = radius;
            }
            public double Radius { get; set; }
            public double Diameter
            {
            get { return 2 * Radius; }
            }
            public double Circumference
            {
            get { return 2 * Radius * PI; }
            }
            public double Area
            {
            get { return PI * Pow(Radius, 2); }
            }
            }
            // The example displays the following output:
            //
            Enter a circle's radius: 12.45
            //
            //
            Information about the circle:
            //
            Radius: 12.45
            //
            Diameter: 24.90
            //
            Circumference: 78.23
            //
            Area: 486.95

            In the example, the using static directive could also have been applied to the Double type. This would have
            made it possible to call the TryParse(String, Double) method without specifying a type name. However, this creates
            less readable code, since it becomes necessary to check the using static statements to determine which numeric
            type's TryParse method is called.

            See also
            using directive
            C# Reference
            C# Keywords
            Using Namespaces
            Namespace Keywords
            Namespaces

            using statement (C# Reference)
            12/19/2018 • 2 minutes to read • Edit Online

            Provides a convenient syntax that ensures the correct use of IDisposable objects.

            Example
            The following example shows how to use the using statement.
            using (Font font1 = new Font("Arial", 10.0f))
            {
            byte charset = font1.GdiCharSet;
            }

            Remarks
            File and Font are examples of managed types that access unmanaged resources (in this case file handles and
            device contexts). There are many other kinds of unmanaged resources and class library types that encapsulate
            them. All such types must implement the IDisposable interface.
            When the lifetime of an IDisposable object is limited to a single method, you should declare and instantiate it in
            the using statement. The using statement calls the Dispose method on the object in the correct way, and (when
            you use it as shown earlier) it also causes the object itself to go out of scope as soon as Dispose is called. Within
            the using block, the object is read-only and cannot be modified or reassigned.
            The using statement ensures that Dispose is called even if an exception occurs within the using block. You can
            achieve the same result by putting the object inside a try block and then calling Dispose in a finally block; in
            fact, this is how the using statement is translated by the compiler. The code example earlier expands to the
            following code at compile time (note the extra curly braces to create the limited scope for the object):
            {
            Font font1 = new Font("Arial", 10.0f);
            try
            {
            byte charset = font1.GdiCharSet;
            }
            finally
            {
            if (font1 != null)
            ((IDisposable)font1).Dispose();
            }
            }

            For more information about the try - finally statement, see the try-finally topic.
            Multiple instances of a type can be declared in the using statement, as shown in the following example:
            using (Font font3 = new Font("Arial", 10.0f),
            font4 = new Font("Arial", 10.0f))
            {
            // Use font3 and font4.
            }

            You can instantiate the resource object and then pass the variable to the using statement, but this is not a best
            practice. In this case, after control leaves the using block, the object remains in scope but probably has no access
            to its unmanaged resources. In other words, it's not fully initialized anymore. If you try to use the object outside
            the using block, you risk causing an exception to be thrown. For this reason, it's generally better to instantiate
            the object in the using statement and limit its scope to the using block.
            Font font2 = new Font("Arial", 10.0f);
            using (font2) // not recommended
            {
            // use font2
            }
            // font2 is still in scope
            // but the method call throws an exception
            float f = font2.GetHeight();

            For more information about disposing of IDisposable objects, see Using objects that implement IDisposable.

            C# language specification
            For more information, see The using statement in the C# Language Specification. The language specification is
            the definitive source for C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            using Directive
            Garbage Collection
            Using objects that implement IDisposable
            IDisposable interface

            extern alias (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            You might have to reference two versions of assemblies that have the same fully-qualified type names. For
            example, you might have to use two or more versions of an assembly in the same application. By using an external
            assembly alias, the namespaces from each assembly can be wrapped inside root-level namespaces named by the
            alias, which enables them to be used in the same file.
            NOTE
            The extern keyword is also used as a method modifier, declaring a method written in unmanaged code.

            To reference two assemblies with the same fully-qualified type names, an alias must be specified at a command
            prompt, as follows:
            /r:GridV1=grid.dll
            /r:GridV2=grid20.dll

            This creates the external aliases GridV1 and GridV2 . To use these aliases from within a program, reference them
            by using the extern keyword. For example:
            extern alias GridV1;
            extern alias GridV2;

            Each extern alias declaration introduces an additional root-level namespace that parallels (but does not lie within)
            the global namespace. Thus types from each assembly can be referred to without ambiguity by using their fully
            qualified name, rooted in the appropriate namespace-alias.
            In the previous example, GridV1::Grid would be the grid control from grid.dll , and GridV2::Grid would be the
            grid control from grid20.dll .

            C# Language Specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            Namespace Keywords
            :: Operator
            /reference (C# Compiler Options)

            Operator Keywords (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Used to perform miscellaneous actions such as creating objects, checking the run-time type of an object, obtaining
            the size of a type, and other actions. This section introduces the following keywords:
            as Converts an object to a compatible type.
            await Suspends an async method until an awaited task is completed.
            is Checks the run-time type of an object, or (starting with C# 7.0) tests an expression against a pattern.
            new
            new Operator Creates objects.
            new Modifier Hides an inherited member.
            new Constraint Qualifies a type parameter.
            nameof Obtains the simple (unqualified) string name of a variable, type, or member.
            sizeof Obtains the size of an unmanaged type.
            typeof Obtains the System.Type object for a type.
            true
            true Operator Returns the bool value true to indicate that the operand is definitely true.
            true Literal Represents the bool value true .
            false
            false Operator Returns the bool value true to indicate that the operand is definitely false.
            false Literal Represents the bool value false .
            stackalloc Allocates a block of memory on the stack.
            The following keywords, which can be used as operators and as statements, are covered in the Statements section:
            checked Specifies checked context.
            unchecked Specifies unchecked context.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            C# Operators

            as (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            You can use the as operator to perform certain types of conversions between compatible reference types or
            nullable types. The following code shows an example.
            class csrefKeywordsOperators
            {
            class Base
            {
            public override string ToString()
            {
            return "Base";
            }
            }
            class Derived : Base
            { }
            class Program
            {
            static void Main()
            {
            Derived d = new Derived();
            Base b = d as Base;
            if (b != null)
            {
            Console.WriteLine(b.ToString());
            }
            }
            }
            }

            As the example shows, you need to compare the result of the as expression with null to check if a conversion is
            successful. Beginning with C# 7.0, you can use the is expression both to test that a conversion succeeds and
            conditionally assign a variable when the conversion succeeds. In many scenarios, it's more concise than using the
            as operator. For more information, see the Type pattern section of the is operator article.

            Remarks
            The as operator is like a cast operation. However, if the conversion isn't possible, as returns null instead of
            raising an exception. Consider the following example:
            expression as type

            The code is equivalent to the following expression except that the expression variable is evaluated only one time.
            expression is type ? (type)expression : (type)null

            Note that the as operator performs only reference conversions, nullable conversions, and boxing conversions.
            The as operator can't perform other conversions, such as user-defined conversions, which should instead be
            performed by using cast expressions.

            Example
            class ClassA { }
            class ClassB { }
            class MainClass
            {
            static void Main()
            {
            object[] objArray = new object[6];
            objArray[0] = new ClassA();
            objArray[1] = new ClassB();
            objArray[2] = "hello";
            objArray[3] = 123;
            objArray[4] = 123.4;
            objArray[5] = null;
            for (int i = 0; i < objArray.Length; ++i)
            {
            string s = objArray[i] as string;
            Console.Write("{0}:", i);
            if (s != null)
            {
            Console.WriteLine("'" + s + "'");
            }
            else
            {
            Console.WriteLine("not a string");
            }
            }
            }
            }
            /*
            Output:
            0:not a string
            1:not a string
            2:'hello'
            3:not a string
            4:not a string
            5:not a string
            */

            C# Language Specification
            For more information, see The as operator in the C# Language Specification. The language specification is the
            definitive source for C# syntax and usage.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords
            is
            ?: Operator
            Operator Keywords

            await (C# Reference)
            12/11/2018 • 4 minutes to read • Edit Online

            The await operator is applied to a task in an asynchronous method to insert a suspension point in the execution
            of the method until the awaited task completes. The task represents ongoing work.
            await can only be used in an asynchronous method modified by the async keyword. Such a method, defined by

            using the async modifier and usually containing one or more await expressions, is referred to as an async
            method.
            NOTE
            The async and await keywords were introduced in C# 5. For an introduction to async programming, see Asynchronous
            Programming with async and await.

            The task to which the await operator is applied typically is returned by a call to a method that implements the
            Task-Based Asynchronous Pattern. They include methods that return Task, Task<TResult>, and
            System.Threading.Tasks.ValueType<TResult> objects.
            In the following example, the HttpClient.GetByteArrayAsync method returns a Task<byte[]> . The task is a
            promise to produce the actual byte array when the task is complete. The await operator suspends execution
            until the work of the GetByteArrayAsync method is complete. In the meantime, control is returned to the caller of
            GetPageSizeAsync . When the task finishes execution, the await expression evaluates to a byte array.
            using System;
            using System.Net.Http;
            using System.Threading;
            using System.Threading.Tasks;
            public class Example
            {
            public static void Main()
            {
            string[] args = Environment.GetCommandLineArgs();
            if (args.Length > 1)
            GetPageSizeAsync(args[1]).Wait();
            else
            Console.WriteLine("Enter at least one URL on the command line.");
            }
            private static async Task GetPageSizeAsync(string url)
            {
            var client = new HttpClient();
            var uri = new Uri(Uri.EscapeUriString(url));
            byte[] urlContents = await client.GetByteArrayAsync(uri);
            Console.WriteLine($"{url}: {urlContents.Length/2:N0} characters");
            }
            }
            // The following call from the command line:
            //
            await1 http://docs.microsoft.com
            // displays output like the following:
            // http://docs.microsoft.com: 7,967 characters

            IMPORTANT
            For the complete example, see Walkthrough: Accessing the Web by Using Async and Await. You can download the sample
            from Developer Code Samples on the Microsoft website. The example is in the AsyncWalkthrough_HttpClient project.

            As shown in the previous example, if await is applied to the result of a method call that returns a Task<TResult> ,
            then the type of the await expression is TResult . If await is applied to the result of a method call that returns a
            Task , then the type of the await expression is void . The following example illustrates the difference.
            // await keyword used with a method that returns a Task<TResult>.
            TResult result = await AsyncMethodThatReturnsTaskTResult();
            // await keyword used with a method that returns a Task.
            await AsyncMethodThatReturnsTask();
            // await keyword used with a method that returns a ValueTask<TResult>.
            TResult result = await AsyncMethodThatReturnsValueTaskTResult();

            An await expression does not block the thread on which it is executing. Instead, it causes the compiler to sign up
            the rest of the async method as a continuation on the awaited task. Control then returns to the caller of the async
            method. When the task completes, it invokes its continuation, and execution of the async method resumes where
            it left off.
            An await expression can occur only in the body of its enclosing method, lambda expression, or anonymous
            method, which must be marked with an async modifier. The term await serves as a keyword only in that context.
            Elsewhere, it is interpreted as an identifier. Within the method, lambda expression, or anonymous method, an
            await expression cannot occur in the body of a synchronous function, in a query expression, in the block of a
            lock statement, or in an unsafe context.

            Exceptions
            Most async methods return a Task or Task<TResult>. The properties of the returned task carry information about
            its status and history, such as whether the task is complete, whether the async method caused an exception or
            was canceled, and what the final result is. The await operator accesses those properties by calling methods on
            the object returned by the GetAwaiter method.
            If you await a task-returning async method that causes an exception, the await operator rethrows the exception.
            If you await a task-returning async method that's canceled, the await operator rethrows an
            OperationCanceledException.
            A single task that is in a faulted state can reflect multiple exceptions. For example, the task might be the result of
            a call to Task.WhenAll. When you await such a task, the await operation rethrows only one of the exceptions.
            However, you can't predict which of the exceptions is rethrown.
            For examples of error handling in async methods, see try-catch.

            Example
            The following example returns the total number of characters in the pages whose URLs are passed to it as
            command line arguments. The example calls the GetPageLengthsAsync method, which is marked with the async
            keyword. The GetPageLengthsAsync method in turn uses the await keyword to await calls to the
            HttpClient.GetStringAsync method.

            using System;
            using System.Linq;
            using System.Net.Http;
            using System.Threading;
            using System.Threading.Tasks;
            class Example
            {
            static async Task Main()
            {
            string[] args = Environment.GetCommandLineArgs();
            if (args.Length < 2)
            throw new ArgumentNullException("No URIs specified on the command line.");
            // Don't pass the executable file name
            var uris = args.Skip(1).ToArray();
            long characters = await GetPageLengthsAsync(uris);
            Console.WriteLine($"{uris.Length} pages, {characters:N0} characters");
            }
            private static async Task<long> GetPageLengthsAsync(string[] uris)
            {
            var client = new HttpClient();
            long pageLengths = 0;
            foreach (var uri in uris)
            {
            var escapedUri = new Uri(Uri.EscapeUriString(uri));
            string pageContents = await client.GetStringAsync(escapedUri);
            Interlocked.Add(ref pageLengths, pageContents.Length);
            }
            return pageLengths;
            }
            }

            The preceding example uses C# 7.1, which supports the async Main method. Because earlier C# versions don't
            support application entry points that return Task or Task<TResult>, you cannot apply the async modifier to the
            Main method and await the GetPageLengthsAsync method call. In that case, you can ensure that the Main
            method waits for the async operation to complete by retrieving the value of the Task<TResult>.Result property.
            For tasks that do not return a value, you can call the Task.Wait method. For information about how to select the
            language version, see Select the C# language version.

            See also
            Asynchronous Programming with async and await
            Walkthrough: Accessing the Web by Using Async and Await
            async

            is (C# Reference)
            12/11/2018 • 10 minutes to read • Edit Online

            Checks if an object is compatible with a given type, or (starting with C# 7.0) tests an expression against a pattern.

            Testing for type compatibility
            The is keyword evaluates type compatibility at runtime. It determines whether an object instance or the result
            of an expression can be converted to a specified type. It has the syntax
            expr is type

            where expr is an expression that evaluates to an instance of some type, and type is the name of the type to which
            the result of expr is to be converted. The is statement is true if expr is non-null and the object that results
            from evaluating the expression can be converted to type; otherwise, it returns false .
            For example, the following code determines if obj can be cast to an instance of the Person type:
            if (obj is Person) {
            // Do something if obj is a Person.
            }

            The is statement is true if:
            expr is an instance of the same type as type.
            expr is an instance of a type that derives from type. In other words, the result of expr can be upcast to an
            instance of type.
            expr has a compile-time type that is a base class of type, and expr has a runtime type that is type or is
            derived from type. The compile-time type of a variable is the variable's type as defined in its declaration.
            The runtime type of a variable is the type of the instance that is assigned to that variable.
            expr is an instance of a type that implements the type interface.
            The following example shows that the is expression evaluates to true for each of these conversions.

            using System;
            public class Class1 : IFormatProvider
            {
            public object GetFormat(Type t)
            {
            if (t.Equals(this.GetType()))
            return this;
            return null;
            }
            }
            public class Class2 : Class1
            {
            public int Value { get; set; }
            }
            public class Example
            {
            public static void Main()
            {
            var cl1 = new Class1();
            Console.WriteLine(cl1 is IFormatProvider);
            Console.WriteLine(cl1 is Object);
            Console.WriteLine(cl1 is Class1);
            Console.WriteLine(cl1 is Class2);
            Console.WriteLine();
            var cl2 = new Class2();
            Console.WriteLine(cl2 is IFormatProvider);
            Console.WriteLine(cl2 is Class2);
            Console.WriteLine(cl2 is Class1);
            Console.WriteLine();
            Class1 cl = cl2;
            Console.WriteLine(cl is Class1);
            Console.WriteLine(cl is Class2);
            }
            }
            // The example displays the following output:
            //
            True
            //
            True
            //
            True
            //
            False
            //
            //
            True
            //
            True
            //
            True
            //
            //
            True
            //
            True

            The is keyword generates a compile-time warning if the expression is known to always be either true or
            false . It only considers reference conversions, boxing conversions, and unboxing conversions; it does not
            consider user-defined conversions or conversions defined by a type's implicit and explicit operators. The
            following example generates warnings because the result of the conversion is known at compile-time. Note that
            the is expression for conversions from int to long and double return false, since these conversions are
            handled by the implicit operator.

            Console.WriteLine(3 is int);
            Console.WriteLine();
            int value = 6;
            Console.WriteLine(value is long);
            Console.WriteLine(value is double);
            Console.WriteLine(value is object);
            Console.WriteLine(value is ValueType);
            Console.WriteLine(value is int);
            // Compilation generates the following compiler warnings:
            // is2.cs(8,25): warning CS0183: The given expression is always of the provided ('int') type
            // is2.cs(12,25): warning CS0184: The given expression is never of the provided ('long') type
            // is2.cs(13,25): warning CS0184: The given expression is never of the provided ('double') type
            // is2.cs(14,25): warning CS0183: The given expression is always of the provided ('object') type
            // is2.cs(15,25): warning CS0183: The given expression is always of the provided ('ValueType') type
            // is2.cs(16,25): warning CS0183: The given expression is always of the provided ('int') type

            expr can be any expression that returns a value, with the exception of anonymous methods and lambda

            expressions. The following example uses is to evaluate the return value of a method call.
            using System;
            public class Example
            {
            public static void Main()
            {
            double number1 = 12.63;
            if (Math.Ceiling(number1) is double)
            Console.WriteLine("The expression returns a double.");
            else if (Math.Ceiling(number1) is decimal)
            Console.WriteLine("The expression returns a decimal.");
            decimal number2 = 12.63m;
            if (Math.Ceiling(number2) is double)
            Console.WriteLine("The expression returns a double.");
            else if (Math.Ceiling(number2) is decimal)
            Console.WriteLine("The expression returns a decimal.");
            }
            }
            // The example displays the following output:
            //
            The expression returns a double.
            //
            The expression returns a decimal.

            Starting with C# 7.0, you can use pattern matching with the type pattern to write more concise code that uses the
            is statement.

            Pattern matching with is
            Starting with C# 7.0, the is and switch statements support pattern matching. The is keyword supports the
            following patterns:
            Type pattern, which tests whether an expression can be converted to a specified type and, if it can be, casts
            it to a variable of that type.
            Constant pattern, which tests whether an expression evaluates to a specified constant value.
            var pattern, a match that always succeeds and binds the value of an expression to a new local variable.
            Type pattern
            When using the type pattern to perform pattern matching, is tests whether an expression can be converted to a

            specified type and, if it can be, casts it to a variable of that type. It is a straightforward extension of the is
            statement that enables concise type evaluation and conversion. The general form of the is type pattern is:
            expr is type varname

            where expr is an expression that evaluates to an instance of some type, type is the name of the type to which the
            result of expr is to be converted, and varname is the object to which the result of expr is converted if the is test
            is true .
            The is expression is true if expr is not null , and any of the following is true:
            expr is an instance of the same type as type.
            expr is an instance of a type that derives from type. In other words, the result of expr can be upcast to an
            instance of type.
            expr has a compile-time type that is a base class of type, and expr has a runtime type that is type or is
            derived from type. The compile-time type of a variable is the variable's type as defined in its declaration.
            The runtime type of a variable is the type of the instance that is assigned to that variable.
            expr is an instance of a type that implements the type interface.
            If expr is true and is is used with an if statement, varname is assigned and has local scope within the if
            statement only.
            The following example uses the is type pattern to provide the implementation of a type's
            IComparable.CompareTo(Object) method.
            using System;
            public class Employee : IComparable
            {
            public String Name { get; set; }
            public int Id { get; set; }
            public int CompareTo(Object o)
            {
            if (o is Employee e)
            {
            return Name.CompareTo(e.Name);
            }
            throw new ArgumentException("o is not an Employee object.");
            }
            }

            Without pattern matching, this code might be written as follows. The use of type pattern matching produces
            more compact, readable code by eliminating the need to test whether the result of a conversion is a null .

            using System;
            public class Employee : IComparable
            {
            public String Name { get; set; }
            public int Id { get; set; }
            public int CompareTo(Object o)
            {
            var e = o as Employee;
            if (e == null)
            {
            throw new ArgumentException("o is not an Employee object.");
            }
            return Name.CompareTo(e.Name);
            }
            }

            The is type pattern also produces more compact code when determining the type of a value type. The following
            example uses the is type pattern to determine whether an object is a Person or a Dog instance before
            displaying the value of an appropriate property.

            using System;
            public class Example
            {
            public static void Main()
            {
            Object o = new Person("Jane");
            ShowValue(o);
            o = new Dog("Alaskan Malamute");
            ShowValue(o);
            }
            public static void ShowValue(object o)
            {
            if (o is Person p) {
            Console.WriteLine(p.Name);
            }
            else if (o is Dog d) {
            Console.WriteLine(d.Breed);
            }
            }
            }
            public struct Person
            {
            public string Name { get; set; }
            public Person(string name) : this()
            {
            Name = name;
            }
            }
            public struct Dog
            {
            public string Breed { get; set; }
            public Dog(string breedName) : this()
            {
            Breed = breedName;
            }
            }
            // The example displays the following output:
            // Jane
            // Alaskan Malamute

            The equivalent code without pattern matching requires a separate assignment that includes an explicit cast.

            using System;
            public class Example
            {
            public static void Main()
            {
            Object o = new Person("Jane");
            ShowValue(o);
            o = new Dog("Alaskan Malamute");
            ShowValue(o);
            }
            public static void ShowValue(object o)
            {
            if (o is Person) {
            Person p = (Person) o;
            Console.WriteLine(p.Name);
            }
            else if (o is Dog) {
            Dog d = (Dog) o;
            Console.WriteLine(d.Breed);
            }
            }
            }
            public struct Person
            {
            public string Name { get; set; }
            public Person(string name) : this()
            {
            Name = name;
            }
            }
            public struct Dog
            {
            public string Breed { get; set; }
            public Dog(string breedName) : this()
            {
            Breed = breedName;
            }
            }
            // The example displays the following output:
            //
            Jane
            //
            Alaskan Malamute

            Constant pattern
            When performing pattern matching with the constant pattern, is tests whether an expression equals a specified
            constant. In C# 6 and earlier versions, the constant pattern is supported by the switch statement. Starting with C#
            7.0, it is supported by the is statement as well. Its syntax is:
            expr is constant

            where expr is the expression to evaluate, and constant is the value to test for. constant can be any of the following
            constant expressions:
            A literal value.
            The name of a declared const variable.

            An enumeration constant.
            The constant expression is evaluated as follows:
            If expr and constant are integral types, the C# equality operator determines whether the expression returns
            true (that is, whether expr == constant ).
            Otherwise, the value of the expression is determined by a call to the static Object.Equals(expr, constant)
            method.
            The following example combines the type and constant patterns to test whether an object is a Dice instance and,
            if it is, to determine whether the value of a dice roll is 6.
            using System;
            public class Dice
            {
            Random rnd = new Random();
            public Dice()
            {
            }
            public int Roll()
            {
            return rnd.Next(1, 7);
            }
            }
            class Program
            {
            static void Main(string[] args)
            {
            var d1 = new Dice();
            ShowValue(d1);
            }
            private static void ShowValue(object o)
            {
            const int HIGH_ROLL = 6;
            if (o is Dice d && d.Roll() is HIGH_ROLL)
            Console.WriteLine($"The value is {HIGH_ROLL}!");
            else
            Console.WriteLine($"The dice roll is not a {HIGH_ROLL}!");
            }
            }
            // The example displays output like the following:
            //
            The value is 6!

            Checking for null can be performed using the constant pattern. The null keyword is supported by the is
            statement. Its syntax is:
            expr is null

            The following example shows a comparison of null checks:

            using System;
            class Program
            {
            static void Main(string[] args)
            {
            object o = null;
            if (o is null)
            {
            Console.WriteLine("o does not have a value");
            }
            else
            {
            Console.WriteLine($"o is {o}");
            }
            int? x = 10;
            if (x is null)
            {
            Console.WriteLine("x does not have a value");
            }
            else
            {
            Console.WriteLine($"x is {x.Value}");
            }
            // 'null' check comparison
            Console.WriteLine($"'is' constant pattern 'null' check result : { o is null }");
            Console.WriteLine($"object.ReferenceEquals 'null' check result : { object.ReferenceEquals(o, null)
            }");
            Console.WriteLine($"Equality operator (==) 'null' check result : { o == null }");
            }
            // The example displays the following output:
            // o does not have a value
            // x is 10
            // 'is' constant pattern 'null' check result : True
            // object.ReferenceEquals 'null' check result : True
            // Equality operator (==) 'null' check result : True
            }

            var pattern
            A pattern match with the var pattern always succeeds. Its syntax is
            expr is var varname

            where the value of expr is always assigned to a local variable named varname. varname is a static variable of the
            same type as expr. The following example uses the var pattern to assign an expression to a variable named obj .
            It then displays the value and the type of obj .

            using System;
            class Program
            {
            static void Main()
            {
            object[] items = { new Book("The Tempest"), new Person("John") };
            foreach (var item in items) {
            if (item is var obj)
            Console.WriteLine($"Type: {obj.GetType().Name}, Value: {obj}");
            }
            }
            }
            class Book
            {
            public Book(string title)
            {
            Title = title;
            }
            public string Title { get; set; }
            public override string ToString()
            {
            return Title;
            }
            }
            class Person
            {
            public Person(string name)
            {
            Name = name;
            }
            public string Name
            { get; set; }
            public override string ToString()
            {
            return Name;
            }
            }
            // The example displays the following output:
            //
            Type: Book, Value: The Tempest
            //
            Type: Person, Value: John

            Note that if expr is null , the is expression still is true and assigns null to varname.

            C# Language Specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Keywords
            typeof
            as
            Operator Keywords

            new (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            In C#, the new keyword can be used as an operator, a modifier, or a constraint.
            new Operator
            Used to create objects and invoke constructors.
            new Modifier
            Used to hide an inherited member from a base class member.
            new Constraint
            Used to restrict types that might be used as arguments for a type parameter in a generic declaration.

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords

            new operator (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Used to create objects and invoke constructors. For example:
            Class1 obj = new Class1();

            It is also used to create instances of anonymous types:
            var query = from cust in customers
            select new { Name = cust.Name, Address = cust.PrimaryAddress };

            The new operator is also used to invoke the default constructor for value types. For example:
            int i = new int();

            In the preceding statement, i is initialized to 0 , which is the default value for the type int . The statement has
            the same effect as the following:
            int i = 0;

            For a complete list of default values, see Default Values Table.
            Remember that it is an error to declare a default constructor for a struct because every value type implicitly has a
            public default constructor. It is possible to declare parameterized constructors on a struct type to set its initial
            values, but this is only necessary if values other than the default are required.
            Both value-type objects such as structs and reference-type objects such as classes are destroyed automatically, but
            value-type objects are destroyed when their containing context is destroyed, whereas reference-type objects are
            destroyed by the garbage collector at an unspecified time after the last reference to them is removed. For types
            that contain resources such as file handles, or network connections, it is desirable to employ deterministic cleanup
            to ensure that the resources they contain are released as soon as possible. For more information, see using
            Statement.
            The new operator cannot be overloaded.
            If the new operator fails to allocate memory, it throws the exception, OutOfMemoryException.

            Example
            In the following example, a struct object and a class object are created and initialized by using the new operator
            and then assigned values. The default and the assigned values are displayed.

            struct SampleStruct
            {
            public int x;
            public int y;
            public SampleStruct(int x, int y)
            {
            this.x = x;
            this.y = y;
            }
            }
            class SampleClass
            {
            public string name;
            public int id;
            public SampleClass() {}
            public SampleClass(int id, string name)
            {
            this.id = id;
            this.name = name;
            }
            }
            class ProgramClass
            {
            static void Main()
            {
            // Create objects using default constructors:
            SampleStruct Location1 = new SampleStruct();
            SampleClass Employee1 = new SampleClass();
            // Display values:
            Console.WriteLine("Default values:");
            Console.WriteLine(" Struct members: {0}, {1}",
            Location1.x, Location1.y);
            Console.WriteLine(" Class members: {0}, {1}",
            Employee1.name, Employee1.id);
            // Create objects using parameterized constructors:
            SampleStruct Location2 = new SampleStruct(10, 20);
            SampleClass Employee2 = new SampleClass(1234, "Cristina Potra");
            // Display values:
            Console.WriteLine("Assigned values:");
            Console.WriteLine(" Struct members: {0}, {1}",
            Location2.x, Location2.y);
            Console.WriteLine(" Class members: {0}, {1}",
            Employee2.name, Employee2.id);
            }
            }
            /*
            Output:
            Default values:
            Struct members: 0, 0
            Class members: , 0
            Assigned values:
            Struct members: 10, 20
            Class members: Cristina Potra, 1234
            */

            Notice in the example that the default value of a string is null . Therefore, it is not displayed.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Operator Keywords
            new
            Anonymous Types

            new modifier (C# Reference)
            12/11/2018 • 3 minutes to read • Edit Online

            When used as a declaration modifier, the new keyword explicitly hides a member that is inherited from a base
            class. When you hide an inherited member, the derived version of the member replaces the base class version.
            Although you can hide members without using the new modifier, you get a compiler warning. If you use new to
            explicitly hide a member, it suppresses this warning.
            To hide an inherited member, declare it in the derived class by using the same member name, and modify it with
            the new keyword. For example:
            public class BaseC
            {
            public int x;
            public void Invoke() { }
            }
            public class DerivedC : BaseC
            {
            new public void Invoke() { }
            }

            In this example, BaseC.Invoke is hidden by DerivedC.Invoke . The field x is not affected because it is not hidden
            by a similar name.
            Name hiding through inheritance takes one of the following forms:
            Generally, a constant, field, property, or type that is introduced in a class or struct hides all base class members that
            share its name. There are special cases. For example, if you declare a new field with name N to have a type that is
            not invocable, and a base type declares N to be a method, the new field does not hide the base declaration in
            invocation syntax. See the C# 5.0 language specification for details (see section "Member Lookup" in section
            "Expressions").
            A method introduced in a class or struct hides properties, fields, and types that share that name in the base class. It
            also hides all base class methods that have the same signature.
            An indexer introduced in a class or struct hides all base class indexers that have the same signature.
            It is an error to use both new and override on the same member, because the two modifiers have mutually
            exclusive meanings. The new modifier creates a new member with the same name and causes the original
            member to become hidden. The override modifier extends the implementation for an inherited member.
            Using the new modifier in a declaration that does not hide an inherited member generates a warning.

            Example
            In this example, a base class, BaseC , and a derived class, DerivedC , use the same field name x , which hides the
            value of the inherited field. The example demonstrates the use of the new modifier. It also demonstrates how to
            access the hidden members of the base class by using their fully qualified names.

            public class BaseC
            {
            public static int x = 55;
            public static int y = 22;
            }
            public class DerivedC : BaseC
            {
            // Hide field 'x'.
            new public static int x = 100;
            static void Main()
            {
            // Display the new value of x:
            Console.WriteLine(x);
            // Display the hidden value of x:
            Console.WriteLine(BaseC.x);
            // Display the unhidden member y:
            Console.WriteLine(y);
            }
            }
            /*
            Output:
            100
            55
            22
            */

            Example
            In this example, a nested class hides a class that has the same name in the base class. The example demonstrates
            how to use the new modifier to eliminate the warning message and how to access the hidden class members by
            using their fully qualified names.

            public class BaseC
            {
            public class NestedC
            {
            public int x = 200;
            public int y;
            }
            }
            public class DerivedC : BaseC
            {
            // Nested type hiding the base type members.
            new public class NestedC
            {
            public int x = 100;
            public int y;
            public int z;
            }
            static void Main()
            {
            // Creating an object from the overlapping class:
            NestedC c1 = new NestedC();
            // Creating an object from the hidden class:
            BaseC.NestedC c2 = new BaseC.NestedC();
            Console.WriteLine(c1.x);
            Console.WriteLine(c2.x);
            }
            }
            /*
            Output:
            100
            200
            */

            If you remove the new modifier, the program will still compile and run, but you will get the following warning:
            The keyword new is required on 'MyDerivedC.x' because it hides inherited member 'MyBaseC.x'.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Operator Keywords
            Modifiers
            Versioning with the Override and New Keywords
            Knowing When to Use Override and New Keywords

            new constraint (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The new constraint specifies that any type argument in a generic class declaration must have a public
            parameterless constructor. To use the new constraint, the type cannot be abstract.

            Example
            Apply the new constraint to a type parameter when your generic class creates new instances of the type, as shown
            in the following example:
            class ItemFactory<T> where T : new()
            {
            public T GetNewItem()
            {
            return new T();
            }
            }

            Example
            When you use the new() constraint with other constraints, it must be specified last:
            public class ItemFactory2<T>
            where T : IComparable, new()
            {
            }

            For more information, see Constraints on Type Parameters.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            System.Collections.Generic
            C# Reference
            C# Programming Guide
            C# Keywords
            Operator Keywords
            Generics

            sizeof (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Used to obtain the size in bytes for an unmanaged type.
            Unmanaged types include:
            The simple types that are listed in the following table:
            EXPRESSION

            CONSTANT VALUE

            sizeof(sbyte)

            1

            sizeof(byte)

            1

            sizeof(short)

            2

            sizeof(ushort)

            2

            sizeof(int)

            4

            sizeof(uint)

            4

            sizeof(long)

            8

            sizeof(ulong)

            8

            sizeof(char)

            2 (Unicode)

            sizeof(float)

            4

            sizeof(double)

            8

            sizeof(decimal)

            16

            sizeof(bool)

            1

            Enum types.
            Pointer types.
            User-defined structs that do not contain any instance fields or auto-implemented instance properties that
            are reference types or constructed types.
            The following example shows how to retrieve the size of an int :
            // Constant value 4:
            int intSize = sizeof(int);

            Remarks
            Starting with version 2.0 of C#, applying sizeof to simple or enum types no longer requires that code be
            compiled in an unsafe context.
            The sizeof operator cannot be overloaded. The values returned by the sizeof operator are of type int . The
            previous table shows the constant values that are substituted for sizeof expressions that have certain simple
            types as operands.
            For all other types, including structs, the sizeof operator can be used only in unsafe code blocks. Although you
            can use the Marshal.SizeOf method, the value returned by this method is not always the same as the value
            returned by sizeof . Marshal.SizeOf returns the size after the type has been marshaled, whereas sizeof returns
            the size as it has been allocated by the common language runtime, including any padding.

            Example
            class MainClass
            {
            // unsafe not required for primitive types
            static void Main()
            {
            Console.WriteLine("The size of short is {0}.", sizeof(short));
            Console.WriteLine("The size of int is {0}.", sizeof(int));
            Console.WriteLine("The size of long is {0}.", sizeof(long));
            }
            }
            /*
            Output:
            The size of short is 2.
            The size of int is 4.
            The size of long is 8.
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Operator Keywords
            enum
            Unsafe Code and Pointers
            Structs
            Constants

            typeof (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Used to obtain the System.Type object for a type. A typeof expression takes the following form:
            System.Type type = typeof(int);

            Remarks
            To obtain the run-time type of an expression, you can use the .NET Framework method GetType, as in the
            following example:
            int i = 0;
            System.Type type = i.GetType();

            The typeof operator cannot be overloaded.
            The typeof operator can also be used on open generic types. Types with more than one type parameter must
            have the appropriate number of commas in the specification. The following example shows how to determine
            whether the return type of a method is a generic IEnumerable<T>. Type.GetInterface will return null if the
            return type is not an IEnumerable<T> generic type.
            using System;
            using System.Collections.Generic;
            using System.Reflection;
            class Example
            {
            static void Main()
            {
            MethodInfo method = typeof(string).GetMethod("Copy");
            Type t = method.ReturnType.GetInterface(typeof(IEnumerable<>).Name);
            if (t != null)
            Console.WriteLine(t);
            else
            Console.WriteLine("The return type is not IEnumerable<T>.");
            /*
            Output:
            System.Collections.Generic.IEnumerable`1[System.Char]
            */
            }
            }

            Example

            public class ExampleClass
            {
            public int sampleMember;
            public void SampleMethod() {}
            static void Main()
            {
            Type t = typeof(ExampleClass);
            // Alternatively, you could use
            // ExampleClass obj = new ExampleClass();
            // Type t = obj.GetType();
            Console.WriteLine("Methods:");
            System.Reflection.MethodInfo[] methodInfo = t.GetMethods();
            foreach (System.Reflection.MethodInfo mInfo in methodInfo)
            Console.WriteLine(mInfo.ToString());
            Console.WriteLine("Members:");
            System.Reflection.MemberInfo[] memberInfo = t.GetMembers();
            foreach (System.Reflection.MemberInfo mInfo in memberInfo)
            Console.WriteLine(mInfo.ToString());
            }
            }
            /*
            Output:
            Methods:
            Void SampleMethod()
            System.String ToString()
            Boolean Equals(System.Object)
            Int32 GetHashCode()
            System.Type GetType()
            Members:
            Void SampleMethod()
            System.String ToString()
            Boolean Equals(System.Object)
            Int32 GetHashCode()
            System.Type GetType()
            Void .ctor()
            Int32 sampleMember
            */

            Example
            This sample uses the GetType method to determine the type that is used to contain the result of a numeric
            calculation. This depends on the storage requirements of the resulting number.

            class GetTypeTest
            {
            static void Main()
            {
            int radius = 3;
            Console.WriteLine("Area = {0}", radius * radius * Math.PI);
            Console.WriteLine("The type is {0}",
            (radius * radius * Math.PI).GetType()
            );
            }
            }
            /*
            Output:
            Area = 28.2743338823081
            The type is System.Double
            */

            C# language specification
            For more information, see The typeof operator in the C# Language Specification. The language specification is
            the definitive source for C# syntax and usage.

            See also
            System.Type
            C# Reference
            C# Programming Guide
            C# Keywords
            is
            Operator Keywords

            true (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Used as an overloaded operator or as a literal:
            true operator
            true literal

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            false

            true and false operators (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The true operator returns the bool value true to indicate that an operand is definitely true. The false operator
            returns the bool value true to indicate that an operand is definitely false. The true and false operators are not
            guaranteed to complement each other. That is, both the true and false operator might return the bool value
            false for the same operand. If a type defines one of the two operators, it must also define another operator.
            If a type with the defined true and false operators overloads the logical OR operator | or the logical AND
            operator & in a certain way, the conditional logical OR operator || or conditional logical AND operator && ,
            respectively, can be evaluated for the operands of that type. For more information, see the User-defined conditional
            logical operators section of the C# language specification.
            A type with the defined true operator can be the type of a result of a controlling conditional expression in the if,
            do, while, and for statements and in the conditional operator ?: . For more information, see the Boolean
            expressions section of the C# language specification.
            TIP
            Use the bool? type, if you need to support the three-valued logic, for example, when you work with databases that support
            a three-valued logical type. For more information, see The bool? type section of the Using nullable types article.

            The following example presents the type that defines both true and false operators. Moreover, it overloads the
            logical AND operator & in such a way that the operator && also can be evaluated for the operands of that type.

            using System;
            public struct LaunchStatus
            {
            public static readonly LaunchStatus Green = new LaunchStatus(0);
            public static readonly LaunchStatus Yellow = new LaunchStatus(1);
            public static readonly LaunchStatus Red = new LaunchStatus(2);
            private int status;
            private LaunchStatus(int status)
            {
            this.status = status;
            }
            public static bool operator true(LaunchStatus x) => x == Green || x == Yellow;
            public static bool operator false(LaunchStatus x) => x == Red;
            public static LaunchStatus operator &(LaunchStatus x, LaunchStatus y)
            {
            if (x == Red || y == Red || (x == Yellow && y == Yellow))
            {
            return Red;
            }
            if (x == Yellow || y == Yellow)
            {
            return Yellow;
            }
            return Green;
            }
            public static bool operator ==(LaunchStatus x, LaunchStatus y) => x.status == y.status;
            public static bool operator !=(LaunchStatus x, LaunchStatus y) => !(x == y);
            public override bool Equals(object obj) => obj is LaunchStatus other && this == other;
            public override int GetHashCode() => status;
            }
            public class LaunchStatusTest
            {
            public static void Main()
            {
            LaunchStatus okToLaunch = GetFuelLaunchStatus() && GetNavigationLaunchStatus();
            Console.WriteLine(okToLaunch ? "Ready to go!" : "Wait!");
            }
            static LaunchStatus GetFuelLaunchStatus()
            {
            Console.WriteLine("Getting fuel launch status...");
            return LaunchStatus.Red;
            }
            static LaunchStatus GetNavigationLaunchStatus()
            {
            Console.WriteLine("Getting navigation launch status...");
            return LaunchStatus.Yellow;
            }
            }

            Notice the short-circuiting behavior of the && operator. When the GetFuelLaunchStatus method returns
            LaunchStatus.Red , the second operand of the && operator is not evaluated. That is because LaunchStatus.Red is
            definitely false. Then the result of the logical AND doesn't depend on the value of the second operand. The output
            of the example is as follows:

            Getting fuel launch status...
            Wait!

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            C# Operators
            true literal
            false literal

            true literal (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Represents the bool value true :
            bool check = true;
            Console.WriteLine(check ? "Passed" : "Not passed");
            // Output:
            // Passed

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            false
            true and false operators
            ?: Operator

            false (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Used as an overloaded operator or as a literal:
            false operator
            false literal

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            true

            true and false operators (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The true operator returns the bool value true to indicate that an operand is definitely true. The false
            operator returns the bool value true to indicate that an operand is definitely false. The true and false
            operators are not guaranteed to complement each other. That is, both the true and false operator might
            return the bool value false for the same operand. If a type defines one of the two operators, it must also define
            another operator.
            If a type with the defined true and false operators overloads the logical OR operator | or the logical AND
            operator & in a certain way, the conditional logical OR operator || or conditional logical AND operator && ,
            respectively, can be evaluated for the operands of that type. For more information, see the User-defined
            conditional logical operators section of the C# language specification.
            A type with the defined true operator can be the type of a result of a controlling conditional expression in the if,
            do, while, and for statements and in the conditional operator ?: . For more information, see the Boolean
            expressions section of the C# language specification.
            TIP
            Use the bool? type, if you need to support the three-valued logic, for example, when you work with databases that
            support a three-valued logical type. For more information, see The bool? type section of the Using nullable types article.

            The following example presents the type that defines both true and false operators. Moreover, it overloads
            the logical AND operator & in such a way that the operator && also can be evaluated for the operands of that
            type.

            using System;
            public struct LaunchStatus
            {
            public static readonly LaunchStatus Green = new LaunchStatus(0);
            public static readonly LaunchStatus Yellow = new LaunchStatus(1);
            public static readonly LaunchStatus Red = new LaunchStatus(2);
            private int status;
            private LaunchStatus(int status)
            {
            this.status = status;
            }
            public static bool operator true(LaunchStatus x) => x == Green || x == Yellow;
            public static bool operator false(LaunchStatus x) => x == Red;
            public static LaunchStatus operator &(LaunchStatus x, LaunchStatus y)
            {
            if (x == Red || y == Red || (x == Yellow && y == Yellow))
            {
            return Red;
            }
            if (x == Yellow || y == Yellow)
            {
            return Yellow;
            }
            return Green;
            }
            public static bool operator ==(LaunchStatus x, LaunchStatus y) => x.status == y.status;
            public static bool operator !=(LaunchStatus x, LaunchStatus y) => !(x == y);
            public override bool Equals(object obj) => obj is LaunchStatus other && this == other;
            public override int GetHashCode() => status;
            }
            public class LaunchStatusTest
            {
            public static void Main()
            {
            LaunchStatus okToLaunch = GetFuelLaunchStatus() && GetNavigationLaunchStatus();
            Console.WriteLine(okToLaunch ? "Ready to go!" : "Wait!");
            }
            static LaunchStatus GetFuelLaunchStatus()
            {
            Console.WriteLine("Getting fuel launch status...");
            return LaunchStatus.Red;
            }
            static LaunchStatus GetNavigationLaunchStatus()
            {
            Console.WriteLine("Getting navigation launch status...");
            return LaunchStatus.Yellow;
            }
            }

            Notice the short-circuiting behavior of the && operator. When the GetFuelLaunchStatus method returns
            LaunchStatus.Red , the second operand of the && operator is not evaluated. That is because LaunchStatus.Red is
            definitely false. Then the result of the logical AND doesn't depend on the value of the second operand. The output
            of the example is as follows:

            Getting fuel launch status...
            Wait!

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            C# Operators
            true literal
            false literal

            false literal (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Represents the bool value false :
            bool check = false;
            Console.WriteLine(check ? "Passed" : "Not passed");
            // Output:
            // Not passed

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            true
            true and false operators
            ?: Operator

            stackalloc (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The stackalloc keyword is used in an unsafe code context to allocate a block of memory on the stack.
            int* block = stackalloc int[100];

            Remarks
            The keyword is valid only in local variable initializers. The following code causes compiler errors.
            int* block;
            // The following assignment statement causes compiler errors. You
            // can use stackalloc only when declaring and initializing a local
            // variable.
            block = stackalloc int[100];

            Beginning with C# 7.3, you can use array initializer syntax for stackalloc arrays. All the following declarations
            declare an array with three elements whose values are the integers 1 , 2 , and 3 :
            // Valid starting with C# 7.3
            int* first = stackalloc int[3] { 1, 2, 3 };
            int* second = stackalloc int[] { 1, 2, 3 };
            int* third = stackalloc[] { 1, 2, 3 };

            Because pointer types are involved, stackalloc requires an unsafe context. For more information, see Unsafe
            Code and Pointers.
            stackalloc is like _alloca in the C run-time library.

            Examples
            The following example calculates and displays the first 20 numbers in the Fibonacci sequence. Each number is the
            sum of the previous two numbers. In the code, a block of memory of sufficient size to contain 20 elements of type
            int is allocated on the stack, not the heap. The address of the block is stored in the pointer fib . This memory is
            not subject to garbage collection and therefore does not have to be pinned (by using fixed). The lifetime of the
            memory block is limited to the lifetime of the method that defines it. You cannot free the memory before the
            method returns.

            const int arraySize = 20;
            int* fib = stackalloc int[arraySize];
            int* p = fib;
            // The sequence begins with 1, 1.
            *p++ = *p++ = 1;
            for (int i = 2; i < arraySize; ++i, ++p)
            {
            // Sum the previous two numbers.
            *p = p[-1] + p[-2];
            }
            for (int i = 0; i < arraySize; ++i)
            {
            Console.WriteLine(fib[i]);
            }
            /* Output:
            1
            1
            2
            3
            5
            8
            13
            21
            34
            55
            89
            144
            233
            377
            610
            987
            1597
            2584
            4181
            6765
            */

            The following example initializes a stackalloc array of integers to a bit mask with one bit set in each element.
            This demonstrates the new initializer syntax available starting in C# 7.3:

            int* mask = stackalloc[] {
            0b_0000_0000_0000_0001,
            0b_0000_0000_0000_0010,
            0b_0000_0000_0000_0100,
            0b_0000_0000_0000_1000,
            0b_0000_0000_0001_0000,
            0b_0000_0000_0010_0000,
            0b_0000_0000_0100_0000,
            0b_0000_0000_1000_0000,
            0b_0000_0001_0000_0000,
            0b_0000_0010_0000_0000,
            0b_0000_0100_0000_0000,
            0b_0000_1000_0000_0000,
            0b_0001_0000_0000_0000,
            0b_0010_0000_0000_0000,
            0b_0100_0000_0000_0000,
            0b_1000_0000_0000_0000
            };
            for (int i = 0; i < 16; i++)
            Console.WriteLine(mask[i]);
            /* Output:
            1
            2
            4
            8
            16
            32
            64
            128
            256
            512
            1024
            2048
            4096
            8192
            16384
            32768
            */

            Security
            Unsafe code is less secure than safe alternatives. However, the use of stackalloc automatically enables buffer
            overrun detection features in the common language runtime (CLR ). If a buffer overrun is detected, the process is
            terminated as quickly as possible to minimize the chance that malicious code is executed.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Operator Keywords
            Unsafe Code and Pointers

            nameof (C# Reference)
            12/11/2018 • 3 minutes to read • Edit Online

            Used to obtain the simple (unqualified) string name of a variable, type, or member.
            When reporting errors in code, hooking up model-view -controller (MVC ) links, firing property changed events,
            etc., you often want to capture the string name of a method. Using nameof helps keep your code valid when
            renaming definitions. Before, you had to use string literals to refer to definitions, which is brittle when renaming
            code elements because tools do not know to check these string literals.
            A nameof expression has this form:
            if (x == null) throw new ArgumentNullException(nameof(x));
            WriteLine(nameof(person.Address.ZipCode)); // prints "ZipCode"

            Key Use Cases
            These examples show the key use cases for nameof .
            Validate parameters:
            void f(string s) {
            if (s == null) throw new ArgumentNullException(nameof(s));
            }

            MVC Action links:
            <%= Html.ActionLink("Sign up",
            @typeof(UserController),
            @nameof(UserController.SignUp))
            %>

            INotifyPropertyChanged:
            int p {
            get { return this.p; }
            set { this.p = value; PropertyChanged(this, new PropertyChangedEventArgs(nameof(this.p)); } // nameof(p)
            works too
            }

            XAML dependency property:
            public static DependencyProperty AgeProperty = DependencyProperty.Register(nameof(Age), typeof(int),
            typeof(C));

            Logging:

            void f(int i) {
            Log(nameof(f), "method entry");
            }

            Attributes:
            [DebuggerDisplay("={" + nameof(GetString) + "()}")]
            class C {
            string GetString() { }
            }

            Examples
            Some C# examples:
            using Stuff = Some.Cool.Functionality
            class C {
            static int Method1 (string x, int y) {}
            static int Method1 (string x, string y) {}
            int Method2 (int z) {}
            string f<T>() => nameof(T);
            }
            var c = new C()
            class Test {
            static void Main (string[] args) {
            Console.WriteLine(nameof(C)); // -> "C"
            Console.WriteLine(nameof(C.Method1)); // -> "Method1"
            Console.WriteLine(nameof(C.Method2)); // -> "Method2"
            Console.WriteLine(nameof(c.Method1)); // -> "Method1"
            Console.WriteLine(nameof(c.Method2)); // -> "Method2"
            // Console.WriteLine(nameof(z)); -> "z" [inside of Method2 ok, inside Method1 is a compiler error]
            Console.WriteLine(nameof(Stuff)); // -> "Stuff"
            // Console.WriteLine(nameof(T)); -> "T" [works inside of method but not in attributes on the method]
            Console.WriteLine(nameof(f)); // -> "f"
            // Console.WriteLine(nameof(f<T>)); -> [syntax error]
            // Console.WriteLine(nameof(f<>)); -> [syntax error]
            // Console.WriteLine(nameof(Method2())); -> [error "This expression does not have a name"]
            }
            }

            Remarks
            The argument to nameof must be a simple name, qualified name, member access, base access with a specified
            member, or this access with a specified member. The argument expression identifies a code definition, but it is
            never evaluated.
            Because the argument needs to be an expression syntactically, there are many things disallowed that are not useful
            to list. The following are worth mentioning that produce errors: predefined types (for example, int or void ),
            nullable types ( Point? ), array types ( Customer[,] ), pointer types ( Buffer* ), qualified alias ( A::B ), and unbound
            generic types ( Dictionary<,> ), preprocessing symbols ( DEBUG ), and labels ( loop: ).
            If you need to get the fully-qualified name, you can use the typeof expression along with nameof . For example:

            class C {
            void f(int i) {
            Log($"{typeof(C)}.{nameof(f)}", "method entry");
            }
            }

            Unfortunately typeof is not a constant expression like nameof , so typeof cannot be used in conjunction with
            nameof in all the same places as nameof . For example, the following would cause a CS0182 compile error:
            [DebuggerDisplay("={" + typeof(C) + nameof(GetString) + "()}")]
            class C {
            string GetString() { }
            }

            In the examples you see that you can use a type name and access an instance method name. You do not need to
            have an instance of the type, as required in evaluated expressions. Using the type name can be very convenient in
            some situations, and since you are just referring to the name and not using instance data, you do not need to
            contrive an instance variable or expression.
            You can reference the members of a class in attribute expressions on the class.
            There is no way to get a signatures information such as " Method1 (str, str) ". One way to do that is to use an
            Expression, Expression e = () => A.B.Method1("s1", "s2") , and pull the MemberInfo from the resulting expression
            tree.

            Language Specifications
            For more information, see Nameof expressions in the C# Language Specification. The language specification is the
            definitive source for C# syntax and usage.

            See Also
            C# Reference
            C# Programming Guide
            typeof

            Conversion Keywords (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            This section describes keywords used in type conversions:
            explicit
            implicit
            operator

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords

            explicit (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The explicit keyword declares a user-defined type conversion operator that must be invoked with a cast.
            The following example defines the operator that converts from a Fahrenheit class to a Celsius class. The
            operator must be defined either inside a Fahrenheit class or a Celsius class:
            public static explicit operator Celsius(Fahrenheit fahr)
            {
            return new Celsius((5.0f / 9.0f) * (fahr.Degrees - 32));
            }

            You invoke the defined conversion operator with a cast, as the following example shows:
            Fahrenheit fahr = new Fahrenheit(100.0f);
            Console.Write($"{fahr.Degrees} Fahrenheit");
            Celsius c = (Celsius)fahr;

            The conversion operator converts from a source type to a target type. The source type provides the conversion
            operator. Unlike implicit conversion, explicit conversion operators must be invoked by means of a cast. If a
            conversion operation can cause exceptions or lose information, you should mark it explicit . This prevents the
            compiler from silently invoking the conversion operation with possibly unforeseen consequences.
            Omitting the cast results in compile-time error CS0266.
            For more information, see Using Conversion Operators.

            Example
            The following example provides a Fahrenheit and a Celsius class, each of which provides an explicit conversion
            operator to the other class.

            class Celsius
            {
            public Celsius(float temp)
            {
            Degrees = temp;
            }
            public float Degrees { get; }
            public static explicit operator Fahrenheit(Celsius c)
            {
            return new Fahrenheit((9.0f / 5.0f) * c.Degrees + 32);
            }
            }
            class Fahrenheit
            {
            public Fahrenheit(float temp)
            {
            Degrees = temp;
            }
            public float Degrees { get; }
            public static explicit operator Celsius(Fahrenheit fahr)
            {
            return new Celsius((5.0f / 9.0f) * (fahr.Degrees - 32));
            }
            }
            class MainClass
            {
            static void Main()
            {
            Fahrenheit fahr = new Fahrenheit(100.0f);
            Console.Write($"{fahr.Degrees} Fahrenheit");
            Celsius c = (Celsius)fahr;
            Console.Write($" = {c.Degrees} Celsius");
            Fahrenheit fahr2 = (Fahrenheit)c;
            Console.WriteLine($" = {fahr2.Degrees} Fahrenheit");
            }
            }
            // Output:
            // 100 Fahrenheit = 37.77778 Celsius = 100 Fahrenheit

            Example
            The following example defines a struct, Digit , that represents a single decimal digit. An operator is defined for
            conversions from byte to Digit , but because not all bytes can be converted to a Digit , the conversion is
            explicit.

            struct Digit
            {
            byte value;
            public Digit(byte value)
            {
            if (value > 9)
            {
            throw new ArgumentException();
            }
            this.value = value;
            }
            // Define explicit byte-to-Digit conversion operator:
            public static explicit operator Digit(byte b)
            {
            Digit d = new Digit(b);
            Console.WriteLine("conversion occurred");
            return d;
            }
            }
            class ExplicitTest
            {
            static void Main()
            {
            try
            {
            byte b = 3;
            Digit d = (Digit)b; // explicit conversion
            }
            catch (Exception e)
            {
            Console.WriteLine("{0} Exception caught.", e);
            }
            }
            }
            /*
            Output:
            conversion occurred
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            implicit
            operator (C# Reference)
            How to: Implement User-Defined Conversions Between Structs
            Chained user-defined explicit conversions in C#

            implicit (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The implicit keyword is used to declare an implicit user-defined type conversion operator. Use it to enable
            implicit conversions between a user-defined type and another type, if the conversion is guaranteed not to cause a
            loss of data.

            Example
            class Digit
            {
            public Digit(double d) { val = d; }
            public double val;
            // ...other members
            // User-defined conversion from Digit to double
            public static implicit operator double(Digit d)
            {
            return d.val;
            }
            // User-defined conversion from double to Digit
            public static implicit operator Digit(double d)
            {
            return new Digit(d);
            }
            }
            class Program
            {
            static void Main(string[] args)
            {
            Digit dig = new Digit(7);
            //This call invokes the implicit "double" operator
            double num = dig;
            //This call invokes the implicit "Digit" operator
            Digit dig2 = 12;
            Console.WriteLine("num = {0} dig2 = {1}", num, dig2.val);
            Console.ReadLine();
            }
            }

            By eliminating unnecessary casts, implicit conversions can improve source code readability. However, because
            implicit conversions do not require programmers to explicitly cast from one type to the other, care must be taken
            to prevent unexpected results. In general, implicit conversion operators should never throw exceptions and never
            lose information so that they can be used safely without the programmer's awareness. If a conversion operator
            cannot meet those criteria, it should be marked explicit . For more information, see Using Conversion
            Operators.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also

            C# Reference
            C# Programming Guide
            C# Keywords
            explicit
            operator (C# Reference)
            How to: Implement User-Defined Conversions Between Structs

            operator (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Use the operator keyword to overload a built-in operator or to provide a user-defined conversion in a class or
            struct declaration.
            To overload an operator on a custom class or struct, you create an operator declaration in the corresponding type.
            The operator declaration that overloads a built-in C# operator must satisfy the following rules:
            It includes both a public and a static modifier.
            It includes operator X where X is the name or symbol of the operator being overloaded.
            Unary operators have one parameter, and binary operators have two parameters. In each case, at least one
            parameter must be the same type as the class or struct that declares the operator.
            For information about how to define conversion operators, see the explicit and implicit keyword articles.
            For an overview of the C# operators that can be overloaded, see the Overloadable operators article.

            Example
            The following example defines a Fraction type that represents fractional numbers. It overloads the + and *
            operators to perform fractional addition and multiplication, and also provides a conversion operator that converts
            a Fraction type to a double type.

            class Fraction
            {
            int num, den;
            public Fraction(int num, int den)
            {
            this.num = num;
            this.den = den;
            }
            // overload operator +
            public static Fraction operator +(Fraction a, Fraction b)
            {
            return new Fraction(a.num * b.den + b.num * a.den,
            a.den * b.den);
            }
            // overload operator *
            public static Fraction operator *(Fraction a, Fraction b)
            {
            return new Fraction(a.num * b.num, a.den * b.den);
            }
            // user-defined conversion from Fraction to double
            public static implicit operator double(Fraction f)
            {
            return (double)f.num / f.den;
            }
            }
            class Test
            {
            static void Main()
            {
            Fraction a = new Fraction(1, 2);
            Fraction b = new Fraction(3, 7);
            Fraction c = new Fraction(2, 3);
            Console.WriteLine((double)(a * b + c));
            }
            }
            /*
            Output
            0.880952380952381
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            implicit
            explicit
            Overloadable operators
            How to: Implement User-Defined Conversions Between Structs

            Access Keywords (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            This section introduces the following access keywords:
            base
            Accesses the members of the base class.
            this
            Refers to the current instance of the class.

            See Also
            C# Reference
            C# Programming Guide
            Access Modifiers
            C# Keywords

            base (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The base keyword is used to access members of the base class from within a derived class:
            Call a method on the base class that has been overridden by another method.
            Specify which base-class constructor should be called when creating instances of the derived class.
            A base class access is permitted only in a constructor, an instance method, or an instance property accessor.
            It is an error to use the base keyword from within a static method.
            The base class that is accessed is the base class specified in the class declaration. For example, if you specify
            class ClassB : ClassA , the members of ClassA are accessed from ClassB, regardless of the base class of ClassA.

            Example
            In this example, both the base class, Person , and the derived class, Employee , have a method named Getinfo . By
            using the base keyword, it is possible to call the Getinfo method on the base class, from within the derived class.
            public class Person
            {
            protected string ssn = "444-55-6666";
            protected string name = "John L. Malgraine";
            public virtual void GetInfo()
            {
            Console.WriteLine("Name: {0}", name);
            Console.WriteLine("SSN: {0}", ssn);
            }
            }
            class Employee : Person
            {
            public string id = "ABC567EFG";
            public override void GetInfo()
            {
            // Calling the base class GetInfo method:
            base.GetInfo();
            Console.WriteLine("Employee ID: {0}", id);
            }
            }
            class TestClass
            {
            static void Main()
            {
            Employee E = new Employee();
            E.GetInfo();
            }
            }
            /*
            Output
            Name: John L. Malgraine
            SSN: 444-55-6666
            Employee ID: ABC567EFG
            */

            For additional examples, see new, virtual, and override.

            Example
            This example shows how to specify the base-class constructor called when creating instances of a derived class.
            public class BaseClass
            {
            int num;
            public BaseClass()
            {
            Console.WriteLine("in BaseClass()");
            }
            public BaseClass(int i)
            {
            num = i;
            Console.WriteLine("in BaseClass(int i)");
            }
            public int GetNum()
            {
            return num;
            }
            }
            public class DerivedClass : BaseClass
            {
            // This constructor will call BaseClass.BaseClass()
            public DerivedClass() : base()
            {
            }
            // This constructor will call BaseClass.BaseClass(int i)
            public DerivedClass(int i) : base(i)
            {
            }
            static void Main()
            {
            DerivedClass md = new DerivedClass();
            DerivedClass md1 = new DerivedClass(1);
            }
            }
            /*
            Output:
            in BaseClass()
            in BaseClass(int i)
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            this

            this (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The this keyword refers to the current instance of the class and is also used as a modifier of the first parameter
            of an extension method.
            NOTE
            This article discusses the use of this with class instances. For more information about its use in extension methods, see
            Extension Methods.

            The following are common uses of this :
            To qualify members hidden by similar names, for example:
            public class Employee
            {
            private string alias;
            private string name;
            public Employee(string name, string alias)
            {
            // Use this to qualify the members of the class
            // instead of the constructor parameters.
            this.name = name;
            this.alias = alias;
            }
            }

            To pass an object as a parameter to other methods, for example:
            CalcTax(this);

            To declare indexers, for example:
            public int this[int param]
            {
            get { return array[param]; }
            set { array[param] = value; }
            }

            Static member functions, because they exist at the class level and not as part of an object, do not have a this
            pointer. It is an error to refer to this in a static method.

            Example
            In this example, this is used to qualify the Employee class members, name and alias , which are hidden by
            similar names. It is also used to pass an object to the method CalcTax , which belongs to another class.

            class Employee
            {
            private string name;
            private string alias;
            private decimal salary = 3000.00m;
            // Constructor:
            public Employee(string name, string alias)
            {
            // Use this to qualify the fields, name and alias:
            this.name = name;
            this.alias = alias;
            }
            // Printing method:
            public void printEmployee()
            {
            Console.WriteLine("Name: {0}\nAlias: {1}", name, alias);
            // Passing the object to the CalcTax method by using this:
            Console.WriteLine("Taxes: {0:C}", Tax.CalcTax(this));
            }
            public decimal Salary
            {
            get { return salary; }
            }
            }
            class Tax
            {
            public static decimal CalcTax(Employee E)
            {
            return 0.08m * E.Salary;
            }
            }
            class MainClass
            {
            static void Main()
            {
            // Create objects:
            Employee E1 = new Employee("Mingda Pan", "mpan");
            // Display results:
            E1.printEmployee();
            }
            }
            /*
            Output:
            Name: Mingda Pan
            Alias: mpan
            Taxes: $240.00
            */

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide

            C# Keywords
            base
            Methods

            Literal Keywords (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            C# has the following literal keywords:
            null
            true
            false
            default

            See Also
            C# Reference
            C# Programming Guide
            C# Keywords

            null (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The null keyword is a literal that represents a null reference, one that does not refer to any object. null is the
            default value of reference-type variables. Ordinary value types cannot be null. However, C# 2.0 introduced nullable
            value types. See Nullable Types.
            The following example demonstrates some behaviors of the null keyword:

            class Program
            {
            class MyClass
            {
            public void MyMethod() { }
            }
            static void Main(string[] args)
            {
            // Set a breakpoint here to see that mc = null.
            // However, the compiler considers it "unassigned."
            // and generates a compiler error if you try to
            // use the variable.
            MyClass mc;
            // Now the variable can be used, but...
            mc = null;
            // ... a method call on a null object raises
            // a run-time NullReferenceException.
            // Uncomment the following line to see for yourself.
            // mc.MyMethod();
            // Now mc has a value.
            mc = new MyClass();
            // You can call its method.
            mc.MyMethod();
            // Set mc to null again. The object it referenced
            // is no longer accessible and can now be garbage-collected.
            mc = null;
            // A null string is not the same as an empty string.
            string s = null;
            string t = String.Empty; // Logically the same as ""
            // Equals applied to any null object returns false.
            bool b = (t.Equals(s));
            Console.WriteLine(b);
            // Equality operator also returns false when one
            // operand is null.
            Console.WriteLine("Empty string {0} null string", s == t ? "equals": "does not equal");
            // Returns true.
            Console.WriteLine("null == null is {0}", null == null);

            // A value type cannot be null
            // int i = null; // Compiler error!
            // Use a nullable value type instead:
            int? i = null;
            // Keep the console window open in debug mode.
            System.Console.WriteLine("Press any key to exit.");
            System.Console.ReadKey();
            }
            }

            C# language specification

            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords
            Literal Keywords
            Default Values Table
            Nothing

            default (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The default keyword can be used in the switch statement or in a default value expression:
            The switch statement: Specifies the default label.
            Default value expressions: Produces the default value of a type.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords

            Contextual Keywords (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            A contextual keyword is used to provide a specific meaning in the code, but it is not a reserved word in C#. The
            following contextual keywords are introduced in this section:
            KEYWORD

            DESCRIPTION

            add

            Defines a custom event accessor that is invoked when client
            code subscribes to the event.

            async

            Indicates that the modified method, lambda expression, or
            anonymous method is asynchronous.

            await

            Suspends an async method until an awaited task is completed.

            dynamic

            Defines a reference type that enables operations in which it
            occurs to bypass compile-time type checking.

            get

            Defines an accessor method for a property or an indexer.

            global

            Specifies the default global namespace, which is otherwise
            unnamed.

            partial

            Defines partial classes, structs, and interfaces throughout the
            same compilation unit.

            remove

            Defines a custom event accessor that is invoked when client
            code unsubscribes from the event.

            set

            Defines an accessor method for a property or an indexer.

            value

            Used to set accessors and to add or remove event handlers.

            var

            Enables the type of a variable declared at method scope to be
            determined by the compiler.

            when

            Specifies a filter condition for a catch block or the case
            label of a switch statement.

            where

            Adds constraints to a generic declaration. (See also where).

            yield

            Used in an iterator block to return a value to the enumerator
            object or to signal the end of iteration.

            All query keywords introduced in C# 3.0 are also contextual. For more information, see Query Keywords (LINQ ).

            See Also
            C# Reference
            C# Programming Guide

            C# Keywords

            add (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The add contextual keyword is used to define a custom event accessor that is invoked when client code
            subscribes to your event. If you supply a custom add accessor, you must also supply a remove accessor.

            Example
            The following example shows an event that has custom add and remove accessors. For the full example, see How
            to: Implement Interface Events.

            class Events : IDrawingObject
            {
            event EventHandler PreDrawEvent;
            event EventHandler IDrawingObject.OnDraw
            {
            add
            {
            lock (PreDrawEvent)
            {
            PreDrawEvent += value;
            }
            }
            remove
            {
            lock (PreDrawEvent)
            {
            PreDrawEvent -= value;
            }
            }
            }
            }

            You do not typically need to provide your own custom event accessors. The accessors that are automatically
            generated by the compiler when you declare an event are sufficient for most scenarios.

            See Also
            Events

            get (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The get keyword defines an accessor method in a property or indexer that returns the property value or the
            indexer element. For more information, see Properties, Auto-Implemented Properties and Indexers.
            The following example defines both a get and a set accessor for a property named Seconds . It uses a private
            field named _seconds to back the property value.

            class TimePeriod
            {
            private double _seconds;
            public double Seconds
            {
            get { return _seconds; }
            set { _seconds = value; }
            }
            }

            Often, the get accessor consists of a single statement that returns a value, as it did in the previous example.
            Starting with C# 7.0, you can implement the get accessor as an expression-bodied member. The following
            example implements both the get and the set accessor as expression-bodied members.

            class TimePeriod
            {
            private double _seconds;
            public double Seconds
            {
            get => _seconds;
            set => _seconds = value;
            }
            }

            For simple cases in which a property's get and set accessors perform no other operation than setting or
            retrieving a value in a private backing field, you can take advantage of the C# compiler's support for autoimplemented properties. The following example implements Hours as an auto-implemented property.
            class TimePeriod2
            {
            public double Hours { get; set; }
            }

            C# Language Specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See Also

            C# Reference
            C# Programming Guide
            C# Keywords
            Properties

            global (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The global contextual keyword, when it comes before the :: operator, refers to the global namespace, which is the
            default namespace for any C# program and is otherwise unnamed. For more information, see How to: Use the
            Global Namespace Alias.

            Example
            The following example shows how to use the global contextual keyword to specify that the class TestApp is
            defined in the global namespace:
            class TestClass : global::TestApp { }

            See also
            Namespaces

            partial type (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            Partial type definitions allow for the definition of a class, struct, or interface to be split into multiple files.
            In File1.cs:
            namespace PC
            {
            partial class A
            {
            int num = 0;
            void MethodA() { }
            partial void MethodC();
            }
            }

            In File2.cs the declaration:
            namespace PC
            {
            partial class A
            {
            void MethodB() { }
            partial void MethodC() { }
            }
            }

            Remarks
            Splitting a class, struct or interface type over several files can be useful when you are working with large projects,
            or with automatically generated code such as that provided by the Windows Forms Designer. A partial type may
            contain a partial method. For more information, see Partial Classes and Methods.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            Modifiers
            Introduction to Generics

            partial method (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            A partial method has its signature defined in one part of a partial type, and its implementation defined in another
            part of the type. Partial methods enable class designers to provide method hooks, similar to event handlers, that
            developers may decide to implement or not. If the developer does not supply an implementation, the compiler
            removes the signature at compile time. The following conditions apply to partial methods:
            Signatures in both parts of the partial type must match.
            The method must return void.
            No access modifiers are allowed. Partial methods are implicitly private.
            The following example shows a partial method defined in two parts of a partial class:
            namespace PM
            {
            partial class A
            {
            partial void OnSomethingHappened(string s);
            }
            // This part can be in a separate file.
            partial class A
            {
            // Comment out this method and the program
            // will still compile.
            partial void OnSomethingHappened(String s)
            {
            Console.WriteLine("Something happened: {0}", s);
            }
            }
            }

            For more information, see Partial Classes and Methods.

            See also
            C# Reference
            partial type

            remove (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The remove contextual keyword is used to define a custom event accessor that is invoked when client code
            unsubscribes from your event. If you supply a custom remove accessor, you must also supply an add accessor.

            Example
            The following example shows an event with custom add and remove accessors. For the full example, see How to:
            Implement Interface Events.

            class Events : IDrawingObject
            {
            event EventHandler PreDrawEvent;
            event EventHandler IDrawingObject.OnDraw
            {
            add
            {
            lock (PreDrawEvent)
            {
            PreDrawEvent += value;
            }
            }
            remove
            {
            lock (PreDrawEvent)
            {
            PreDrawEvent -= value;
            }
            }
            }
            }

            You do not typically need to provide your own custom event accessors. The accessors that are automatically
            generated by the compiler when you declare an event are sufficient for most scenarios.

            See also
            Events

            set (C# Reference)
            1/9/2019 • 2 minutes to read • Edit Online

            The set keyword defines an accessor method in a property or indexer that assigns a value to the property or the
            indexer element. For more information and examples, see Properties, Auto-Implemented Properties, and Indexers.
            The following example defines both a get and a set accessor for a property named Seconds . It uses a private
            field named _seconds to back the property value.

            class TimePeriod
            {
            private double _seconds;
            public double Seconds
            {
            get { return _seconds; }
            set { _seconds = value; }
            }
            }

            Often, the set accessor consists of a single statement that assigns a value, as it did in the previous example.
            Starting with C# 7.0, you can implement the set accessor as an expression-bodied member. The following
            example implements both the get and the set accessors as expression-bodied members.

            class TimePeriod
            {
            private double _seconds;
            public double Seconds
            {
            get => _seconds;
            set => _seconds = value;
            }
            }

            For simple cases in which a property's get and set accessors perform no other operation than setting or
            retrieving a value in a private backing field, you can take advantage of the C# compiler's support for autoimplemented properties. The following example implements Hours as an auto-implemented property.
            class TimePeriod2
            {
            public double Hours { get; set; }
            }

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also

            C# Reference
            C# Programming Guide
            C# Keywords
            Properties

            when (C# Reference)
            1/11/2019 • 3 minutes to read • Edit Online

            You can use the when contextual keyword to specify a filter condition in two contexts:
            In the catch statement of a try/catch or try/catch/finally block.
            In the case label of a switch statement.

            when

            in a catch statement

            Starting with C# 6, when can be used in a catch statement to specify a condition that must be true for the handler
            for a specific exception to execute. Its syntax is:
            catch (ExceptionType [e]) when (expr)

            where expr is an expression that evaluates to a Boolean value. If it returns true , the exception handler executes; if
            false , it does not.
            The following example uses the when keyword to conditionally execute handlers for an HttpRequestException
            depending on the text of the exception message.
            using System;
            using System.Net.Http;
            using System.Threading.Tasks;
            class Program
            {
            static void Main()
            {
            Console.WriteLine(MakeRequest().Result);
            }
            public static async Task<string> MakeRequest()
            {
            var client = new System.Net.Http.HttpClient();
            var streamTask = client.GetStringAsync("https://localHost:10000");
            try {
            var responseText = await streamTask;
            return responseText;
            }
            catch (HttpRequestException e) when (e.Message.Contains("301")) {
            return "Site Moved";
            }
            catch (HttpRequestException e) when (e.Message.Contains("404")) {
            return "Page Not Found";
            }
            catch (HttpRequestException e) {
            return e.Message;
            }
            }
            }

            when

            in a switch statement

            Starting with C# 7.0, case labels no longer need be mutually exclusive, and the order in which case labels appear
            in a switch statement can determine which switch block executes. The when keyword can be used to specify a
            filter condition that causes its associated case label to be true only if the filter condition is also true. Its syntax is:
            case (expr) when (when-condition):

            where expr is a constant pattern or type pattern that is compared to the match expression, and when-condition is
            any Boolean expression.
            The following example uses the when keyword to test for Shape objects that have an area of zero, as well as to
            test for a variety of Shape objects that have an area greater than zero.
            using System;
            public abstract class Shape
            {
            public abstract double Area { get; }
            public abstract double Circumference { get; }
            }
            public class Rectangle : Shape
            {
            public Rectangle(double length, double width)
            {
            Length = length;
            Width = width;
            }
            public double Length { get; set; }
            public double Width { get; set; }
            public override double Area
            {
            get { return Math.Round(Length * Width,2); }
            }
            public override double Circumference
            {
            get { return (Length + Width) * 2; }
            }
            }
            public class Square : Rectangle
            {
            public Square(double side) : base(side, side)
            {
            Side = side;
            }
            public double Side { get; set; }
            }
            public class Example
            {
            public static void Main()
            {
            Shape sh = null;
            Shape[] shapes = { new Square(10), new Rectangle(5, 7),
            new Rectangle(10, 10), sh, new Square(0) };
            foreach (var shape in shapes)
            ShowShapeInfo(shape);
            }
            private static void ShowShapeInfo(Object obj)
            {

            {
            switch (obj)
            {
            case Shape shape when shape.Area == 0:
            Console.WriteLine($"The shape: {shape.GetType().Name} with no dimensions");
            break;
            case Square sq when sq.Area > 0:
            Console.WriteLine("Information about the square:");
            Console.WriteLine($" Length of a side: {sq.Side}");
            Console.WriteLine($" Area: {sq.Area}");
            break;
            case Rectangle r when r.Area > 0:
            Console.WriteLine("Information about the rectangle:");
            Console.WriteLine($" Dimensions: {r.Length} x {r.Width}");
            Console.WriteLine($" Area: {r.Area}");
            break;
            case Shape shape:
            Console.WriteLine($"A {shape.GetType().Name} shape");
            break;
            case null:
            Console.WriteLine($"The {nameof(obj)} variable is uninitialized.");
            break;
            default:
            Console.WriteLine($"The {nameof(obj)} variable does not represent a Shape.");
            break;
            }
            }
            }
            // The example displays the following output:
            //
            Information about the square:
            //
            Length of a side: 10
            //
            Area: 100
            //
            Information about the rectangle:
            //
            Dimensions: 5 x 7
            //
            Area: 35
            //
            Information about the rectangle:
            //
            Dimensions: 10 x 10
            //
            Area: 100
            //
            The obj variable is uninitialized.
            //
            The shape: Square with no dimensions

            See also
            switch statement
            try/catch statement
            try/catch/finally statement

            where (generic type constraint) (C# Reference)
            1/11/2019 • 3 minutes to read • Edit Online

            The where clause in a generic definition specifies constraints on the types that are used as arguments for type
            parameters in a generic type, method, delegate, or local function. Constraints can specify interfaces, base classes,
            or require a generic type to be a reference, value or unmanaged type. They declare capabilities that the type
            argument must possess.
            For example, you can declare a generic class, MyGenericClass , such that the type parameter T implements the
            IComparable<T> interface:
            public class AGenericClass<T> where T : IComparable<T> { }

            NOTE
            For more information on the where clause in a query expression, see where clause.

            The where clause can also include a base class constraint. The base class constraint states that a type to be used as
            a type argument for that generic type has the specified class as a base class (or is that base class) to be used as a
            type argument for that generic type. If the base class constraint is used, it must appear before any other constraints
            on that type parameter. Some types are disallowed as a base class constraint: Object, Array, and ValueType. Prior
            to C# 7.3, Enum, Delegate, and MulticastDelegate were also disallowed as base class constraints. The following
            example shows the types that can now be specified as a base class:
            public class UsingEnum<T> where T : System.Enum { }
            public class UsingDelegate<T> where T : System.Delegate { }
            public class Multicaster<T> where T : System.MulticastDelegate { }

            The where clause can specify that the type is a class or a struct . The struct constraint removes the need to
            specify a base class constraint of System.ValueType . The System.ValueType type may not be used as a base class
            constraint. The following example shows both the class and struct constraints:
            class MyClass<T, U>
            where T : class
            where U : struct
            { }

            The where clause may also include an unmanaged constraint. The unmanaged constraint limits the type parameter
            to types known as unmanaged types. An unmanaged type is a type that isn't a reference type and doesn't
            contain reference type fields at any level of nesting. The unmanaged constraint makes it easier to write low -level
            interop code in C#. This constraint enables reusable routines across all unmanaged types. The unmanaged
            constraint can't be combined with the class or struct constraint. The unmanaged constraint enforces that the
            type must be a struct :

            class UnManagedWrapper<T>
            where T : unmanaged
            { }

            The where clause may also include a constructor constraint, new() . That constraint makes it possible to create an
            instance of a type parameter using the new operator. The new () Constraint lets the compiler know that any type
            argument supplied must have an accessible parameterless--or default-- constructor. For example:
            public class MyGenericClass<T> where T : IComparable<T>, new()
            {
            // The following line is not possible without new() constraint:
            T item = new T();
            }

            The new() constraint appears last in the where clause. The new() constraint can't be combined with the struct
            or unmanaged constraints. All types satisfying those constraints must have an accessible parameterless constructor,
            making the new() constraint redundant.
            With multiple type parameters, use one where clause for each type parameter, for example:
            public interface IMyInterface { }
            namespace CodeExample
            {
            class Dictionary<TKey, TVal>
            where TKey : IComparable<TKey>
            where TVal : IMyInterface
            {
            public void Add(TKey key, TVal val) { }
            }
            }

            You can also attach constraints to type parameters of generic methods, as shown in the following example:
            public void MyMethod<T>(T t) where T : IMyInterface { }

            Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:
            delegate T MyDelegate<T>() where T : new();

            For information on generic delegates, see Generic Delegates.
            For details on the syntax and use of constraints, see Constraints on Type Parameters.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            Introduction to Generics

            new Constraint
            Constraints on Type Parameters

            value (C# Reference)
            12/19/2018 • 2 minutes to read • Edit Online

            The contextual keyword value is used in the set accessor in ordinary property declarations. It is similar to an
            input parameter on a method. The word value references the value that client code is attempting to assign to the
            property. In the following example, MyDerivedClass has a property called Name that uses the value parameter to
            assign a new string to the backing field name . From the point of view of client code, the operation is written as a
            simple assignment.
            class MyBaseClass
            {
            // virtual auto-implemented property. Overrides can only
            // provide specialized behavior if they implement get and set accessors.
            public virtual string Name { get; set; }
            // ordinary virtual property with backing field
            private int num;
            public virtual int Number
            {
            get { return num; }
            set { num = value; }
            }
            }
            class MyDerivedClass : MyBaseClass
            {
            private string name;
            // Override auto-implemented property with ordinary property
            // to provide specialized accessor behavior.
            public override string Name
            {
            get
            {
            return name;
            }
            set
            {
            if (value != String.Empty)
            {
            name = value;
            }
            else
            {
            name = "Unknown";
            }
            }
            }
            }

            For more information about the use of value , see Properties.

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            C# Keywords

            yield (C# Reference)
            1/11/2019 • 4 minutes to read • Edit Online

            When you use the yield contextual keyword in a statement, you indicate that the method, operator, or get
            accessor in which it appears is an iterator. Using yield to define an iterator removes the need for an explicit extra
            class (the class that holds the state for an enumeration, see IEnumerator<T> for an example) when you
            implement the IEnumerable and IEnumerator pattern for a custom collection type.
            The following example shows the two forms of the yield statement.
            yield return <expression>;
            yield break;

            Remarks
            You use a yield return statement to return each element one at a time.
            You consume an iterator method by using a foreach statement or LINQ query. Each iteration of the foreach loop
            calls the iterator method. When a yield return statement is reached in the iterator method, expression is
            returned, and the current location in code is retained. Execution is restarted from that location the next time that
            the iterator function is called.
            You can use a yield break statement to end the iteration.
            For more information about iterators, see Iterators.

            Iterator methods and get accessors
            The declaration of an iterator must meet the following requirements:
            The return type must be IEnumerable, IEnumerable<T>, IEnumerator, or IEnumerator<T>.
            The declaration can't have any in ref or out parameters.
            The yield type of an iterator that returns IEnumerable or IEnumerator is object . If the iterator returns
            IEnumerable<T> or IEnumerator<T>, there must be an implicit conversion from the type of the expression in the
            yield return statement to the generic type parameter .
            You can't include a yield return or yield break statement in methods that have the following characteristics:
            Anonymous methods. For more information, see Anonymous Methods.
            Methods that contain unsafe blocks. For more information, see unsafe.

            Exception handling
            A yield return statement can't be located in a try-catch block. A yield return statement can be located in the
            try block of a try-finally statement.
            A yield break statement can be located in a try block or a catch block but not a finally block.
            If the foreach body (outside of the iterator method) throws an exception, a finally block in the iterator method
            is executed.

            Technical implementation
            The following code returns an IEnumerable<string> from an iterator method and then iterates through its
            elements.
            IEnumerable<string> elements = MyIteratorMethod();
            foreach (string element in elements)
            {
            ...
            }

            The call to MyIteratorMethod doesn't execute the body of the method. Instead the call returns an
            IEnumerable<string> into the elements variable.
            On an iteration of the foreach loop, the MoveNext method is called for elements . This call executes the body of
            MyIteratorMethod until the next yield return statement is reached. The expression returned by the
            yield return statement determines not only the value of the element variable for consumption by the loop
            body but also the Current property of elements , which is an IEnumerable<string> .
            On each subsequent iteration of the foreach loop, the execution of the iterator body continues from where it left
            off, again stopping when it reaches a yield return statement. The foreach loop completes when the end of the
            iterator method or a yield break statement is reached.

            Example
            The following example has a yield return statement that's inside a for loop. Each iteration of the foreach
            statement body in the Main method creates a call to the Power iterator function. Each call to the iterator function
            proceeds to the next execution of the yield return statement, which occurs during the next iteration of the for
            loop.
            The return type of the iterator method is IEnumerable, which is an iterator interface type. When the iterator
            method is called, it returns an enumerable object that contains the powers of a number.
            public class PowersOf2
            {
            static void Main()
            {
            // Display powers of 2 up to the exponent of 8:
            foreach (int i in Power(2, 8))
            {
            Console.Write("{0} ", i);
            }
            }
            public static System.Collections.Generic.IEnumerable<int> Power(int number, int exponent)
            {
            int result = 1;
            for (int i = 0; i < exponent; i++)
            {
            result = result * number;
            yield return result;
            }
            }
            // Output: 2 4 8 16 32 64 128 256
            }

            Example
            The following example demonstrates a get accessor that is an iterator. In the example, each yield return
            statement returns an instance of a user-defined class.
            public static class GalaxyClass
            {
            public static void ShowGalaxies()
            {
            var theGalaxies = new Galaxies();
            foreach (Galaxy theGalaxy in theGalaxies.NextGalaxy)
            {
            Debug.WriteLine(theGalaxy.Name + " " + theGalaxy.MegaLightYears.ToString());
            }
            }
            public class Galaxies
            {
            public System.Collections.Generic.IEnumerable<Galaxy> NextGalaxy
            {
            get
            {
            yield return new Galaxy { Name = "Tadpole", MegaLightYears = 400 };
            yield return new Galaxy { Name = "Pinwheel", MegaLightYears = 25 };
            yield return new Galaxy { Name = "Milky Way", MegaLightYears = 0 };
            yield return new Galaxy { Name = "Andromeda", MegaLightYears = 3 };
            }
            }
            }
            public class Galaxy
            {
            public String Name { get; set; }
            public int MegaLightYears { get; set; }
            }
            }

            C# language specification
            For more information, see the C# Language Specification. The language specification is the definitive source for
            C# syntax and usage.

            See also
            C# Reference
            C# Programming Guide
            foreach, in
            Iterators

            Query keywords (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            This section contains the contextual keywords used in query expressions.

            In this section
            CLAUSE

            DESCRIPTION

            from

            Specifies a data source and a range variable (similar to an
            iteration variable).

            where

            Filters source elements based on one or more Boolean
            expressions separated by logical AND and OR operators ( &&
            or || ).

            select

            Specifies the type and shape that the elements in the
            returned sequence will have when the query is executed.

            group

            Groups query results according to a specified key value.

            into

            Provides an identifier that can serve as a reference to the
            results of a join, group or select clause.

            orderby

            Sorts query results in ascending or descending order based
            on the default comparer for the element type.

            join

            Joins two data sources based on an equality comparison
            between two specified matching criteria.

            let

            Introduces a range variable to store sub-expression results in
            a query expression.

            in

            Contextual keyword in a join clause.

            on

            Contextual keyword in a join clause.

            equals

            Contextual keyword in a join clause.

            by

            Contextual keyword in a group clause.

            ascending

            Contextual keyword in an orderby clause.

            descending

            Contextual keyword in an orderby clause.

            See also
            C# Keywords
            LINQ (Language-Integrated Query)
            LINQ Query Expressions

            Getting Started with LINQ in C#

            from clause (C# Reference)
            12/11/2018 • 5 minutes to read • Edit Online

            A query expression must begin with a from clause. Additionally, a query expression can contain sub-queries,
            which also begin with a from clause. The from clause specifies the following:
            The data source on which the query or sub-query will be run.
            A local range variable that represents each element in the source sequence.
            Both the range variable and the data source are strongly typed. The data source referenced in the from clause
            must have a type of IEnumerable, IEnumerable<T>, or a derived type such as IQueryable<T>.
            In the following example, numbers is the data source and num is the range variable. Note that both variables are
            strongly typed even though the var keyword is used.
            class LowNums
            {
            static void Main()
            {
            // A simple data source.
            int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
            // Create the query.
            // lowNums is an IEnumerable<int>
            var lowNums = from num in numbers
            where num < 5
            select num;
            // Execute the query.
            foreach (int i in lowNums)
            {
            Console.Write(i + " ");
            }
            }
            }
            // Output: 4 1 3 2 0

            The range variable
            The compiler infers the type of the range variable when the data source implements IEnumerable<T>. For
            example, if the source has a type of IEnumerable<Customer> , then the range variable is inferred to be Customer . The
            only time that you must specify the type explicitly is when the source is a non-generic IEnumerable type such as
            ArrayList. For more information, see How to: Query an ArrayList with LINQ.
            In the previous example num is inferred to be of type int . Because the range variable is strongly typed, you can
            call methods on it or use it in other operations. For example, instead of writing select num , you could write
            select num.ToString() to cause the query expression to return a sequence of strings instead of integers. Or you
            could write select num + 10 to cause the expression to return the sequence 14, 11, 13, 12, 10. For more
            information, see select clause.
            The range variable is like an iteration variable in a foreach statement except for one very important difference: a
            range variable never actually stores data from the source. It's just a syntactic convenience that enables the query
            to describe what will occur when the query is executed. For more information, see Introduction to LINQ Queries
            (C#).

            Compound from clauses
            In some cases, each element in the source sequence may itself be either a sequence or contain a sequence. For
            example, your data source may be an IEnumerable<Student> where each student object in the sequence contains a
            list of test scores. To access the inner list within each Student element, you can use compound from clauses. The
            technique is like using nested foreach statements. You can add where or orderby clauses to either from clause to
            filter the results. The following example shows a sequence of Student objects, each of which contains an inner
            List of integers representing test scores. To access the inner list, use a compound from clause. You can insert
            clauses between the two from clauses if necessary.

            class CompoundFrom
            {
            // The element type of the data source.
            public class Student
            {
            public string LastName { get; set; }
            public List<int> Scores {get; set;}
            }
            static void Main()
            {
            // Use a collection initializer to create the data source. Note that
            // each element in the list contains an inner sequence of scores.
            List<Student> students = new List<Student>
            {
            new Student {LastName="Omelchenko", Scores= new List<int> {97, 72, 81, 60}},
            new Student {LastName="O'Donnell", Scores= new List<int> {75, 84, 91, 39}},
            new Student {LastName="Mortensen", Scores= new List<int> {88, 94, 65, 85}},
            new Student {LastName="Garcia", Scores= new List<int> {97, 89, 85, 82}},
            new Student {LastName="Beebe", Scores= new List<int> {35, 72, 91, 70}}
            };
            // Use a compound from to access the inner sequence within each element.
            // Note the similarity to a nested foreach statement.
            var scoreQuery = from student in students
            from score in student.Scores
            where score > 90
            select new { Last = student.LastName, score };
            // Execute the queries.
            Console.WriteLine("scoreQuery:");
            // Rest the mouse pointer on scoreQuery in the following line to
            // see its type. The type is IEnumerable<'a>, where 'a is an
            // anonymous type defined as new {string Last, int score}. That is,
            // each instance of this anonymous type has two members, a string
            // (Last) and an int (score).
            foreach (var student in scoreQuery)
            {
            Console.WriteLine("{0} Score: {1}", student.Last, student.score);
            }
            // Keep the console window open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /*
            scoreQuery:
            Omelchenko Score: 97
            O'Donnell Score: 91
            Mortensen Score: 94
            Garcia Score: 97
            Beebe Score: 91
            */

            Using Multiple from Clauses to Perform Joins
            A compound from clause is used to access inner collections in a single data source. However, a query can also
            contain multiple from clauses that generate supplemental queries from independent data sources. This technique
            enables you to perform certain types of join operations that are not possible by using the join clause.
            The following example shows how two from clauses can be used to form a complete cross join of two data
            sources.

            class CompoundFrom2
            {
            static void Main()
            {
            char[] upperCase = { 'A', 'B', 'C' };
            char[] lowerCase = { 'x', 'y', 'z' };
            // The type of joinQuery1 is IEnumerable<'a>, where 'a
            // indicates an anonymous type. This anonymous type has two
            // members, upper and lower, both of type char.
            var joinQuery1 =
            from upper in upperCase
            from lower in lowerCase
            select new { upper, lower };
            // The type of joinQuery2 is IEnumerable<'a>, where 'a
            // indicates an anonymous type. This anonymous type has two
            // members, upper and lower, both of type char.
            var joinQuery2 =
            from lower in lowerCase
            where lower != 'x'
            from upper in upperCase
            select new { lower, upper };

            // Execute the queries.
            Console.WriteLine("Cross join:");
            // Rest the mouse pointer on joinQuery1 to verify its type.
            foreach (var pair in joinQuery1)
            {
            Console.WriteLine("{0} is matched to {1}", pair.upper, pair.lower);
            }
            Console.WriteLine("Filtered non-equijoin:");
            // Rest the mouse pointer over joinQuery2 to verify its type.
            foreach (var pair in joinQuery2)
            {
            Console.WriteLine("{0} is matched to {1}", pair.lower, pair.upper);
            }
            // Keep the console window open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /* Output:
            Cross join:
            A is matched to x
            A is matched to y
            A is matched to z
            B is matched to x
            B is matched to y
            B is matched to z
            C is matched to x
            C is matched to y
            C is matched to z
            Filtered non-equijoin:
            y is matched to A
            y is matched to B
            y is matched to C
            z is matched to A
            z is matched to B
            z is matched to C
            */

            For more information about join operations that use multiple from clauses, see Perform left outer joins.

            See also
            Query Keywords (LINQ )
            Language Integrated Query (LINQ )

            where clause (C# Reference)
            1/11/2019 • 3 minutes to read • Edit Online

            The where clause is used in a query expression to specify which elements from the data source will be returned in
            the query expression. It applies a Boolean condition (predicate) to each source element (referenced by the range
            variable) and returns those for which the specified condition is true. A single query expression may contain
            multiple where clauses and a single clause may contain multiple predicate subexpressions.

            Example
            In the following example, the where clause filters out all numbers except those that are less than five. If you
            remove the where clause, all numbers from the data source would be returned. The expression num < 5 is the
            predicate that is applied to each element.
            class WhereSample
            {
            static void Main()
            {
            // Simple data source. Arrays support IEnumerable<T>.
            int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
            // Simple query with one predicate in where clause.
            var queryLowNums =
            from num in numbers
            where num < 5
            select num;
            // Execute the query.
            foreach (var s in queryLowNums)
            {
            Console.Write(s.ToString() + " ");
            }
            }
            }
            //Output: 4 1 3 2 0

            Example
            Within a single where clause, you can specify as many predicates as necessary by using the && and || operators.
            In the following example, the query specifies two predicates in order to select only the even numbers that are less
            than five.

            class WhereSample2
            {
            static void Main()
            {
            // Data source.
            int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
            // Create the query with two predicates in where clause.
            var queryLowNums2 =
            from num in numbers
            where num < 5 && num % 2 == 0
            select num;
            // Execute the query
            foreach (var s in queryLowNums2)
            {
            Console.Write(s.ToString() + " ");
            }
            Console.WriteLine();
            // Create the query with two where clause.
            var queryLowNums3 =
            from num in numbers
            where num < 5
            where num % 2 == 0
            select num;
            // Execute the query
            foreach (var s in queryLowNums3)
            {
            Console.Write(s.ToString() + " ");
            }
            }
            }
            // Output:
            // 4 2 0
            // 4 2 0

            Example
            A where clause may contain one or more methods that return Boolean values. In the following example, the
            where clause uses a method to determine whether the current value of the range variable is even or odd.

            class WhereSample3
            {
            static void Main()
            {
            // Data source
            int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
            // Create the query with a method call in the where clause.
            // Note: This won't work in LINQ to SQL unless you have a
            // stored procedure that is mapped to a method by this name.
            var queryEvenNums =
            from num in numbers
            where IsEven(num)
            select num;
            // Execute the query.
            foreach (var s in queryEvenNums)
            {
            Console.Write(s.ToString() + " ");
            }
            }
            // Method may be instance method or static method.
            static bool IsEven(int i)
            {
            return i % 2 == 0;
            }
            }
            //Output: 4 8 6 2 0

            Remarks
            The where clause is a filtering mechanism. It can be positioned almost anywhere in a query expression, except it
            cannot be the first or last clause. A where clause may appear either before or after a group clause depending on
            whether you have to filter the source elements before or after they are grouped.
            If a specified predicate is not valid for the elements in the data source, a compile-time error will result. This is one
            benefit of the strong type-checking provided by LINQ.
            At compile time the where keyword is converted into a call to the Where Standard Query Operator method.

            See also
            Query Keywords (LINQ )
            from clause
            select clause
            Filtering Data
            LINQ Query Expressions
            Getting Started with LINQ in C#

            select clause (C# Reference)
            12/11/2018 • 6 minutes to read • Edit Online

            In a query expression, the select clause specifies the type of values that will be produced when the query is
            executed. The result is based on the evaluation of all the previous clauses and on any expressions in the select
            clause itself. A query expression must terminate with either a select clause or a group clause.
            The following example shows a simple select clause in a query expression.
            class SelectSample1
            {
            static void Main()
            {
            //Create the data source
            List<int> Scores = new List<int>() { 97, 92, 81, 60 };
            // Create the query.
            IEnumerable<int> queryHighScores =
            from score in Scores
            where score > 80
            select score;
            // Execute the query.
            foreach (int i in queryHighScores)
            {
            Console.Write(i + " ");
            }
            }
            }
            //Output: 97 92 81

            The type of the sequence produced by the select clause determines the type of the query variable
            queryHighScores . In the simplest case, the select clause just specifies the range variable. This causes the
            returned sequence to contain elements of the same type as the data source. For more information, see Type
            Relationships in LINQ Query Operations. However, the select clause also provides a powerful mechanism for
            transforming (or projecting) source data into new types. For more information, see Data Transformations with
            LINQ (C#).

            Example
            The following example shows all the different forms that a select clause may take. In each query, note the
            relationship between the select clause and the type of the query variable ( studentQuery1 , studentQuery2 , and
            so on).
            class SelectSample2
            {
            // Define some classes
            public class Student
            {
            public string First { get; set; }
            public string Last { get; set; }
            public int ID { get; set; }
            public List<int> Scores;
            public ContactInfo GetContactInfo(SelectSample2 app, int id)
            {
            ContactInfo cInfo =

            (from ci in app.contactList
            where ci.ID == id
            select ci)
            .FirstOrDefault();
            return cInfo;
            }
            public override string ToString()
            {
            return First + " " + Last + ":" + ID;
            }
            }
            public class ContactInfo
            {
            public int ID { get; set; }
            public string Email { get; set; }
            public string Phone { get; set; }
            public override string ToString() { return Email + "," + Phone; }
            }
            public class ScoreInfo
            {
            public double Average { get; set; }
            public int ID { get; set; }
            }
            // The primary data source
            List<Student> students = new List<Student>()
            {
            new Student {First="Svetlana", Last="Omelchenko", ID=111, Scores= new List<int>() {97, 92, 81,
            60}},
            new Student {First="Claire", Last="O'Donnell", ID=112, Scores= new List<int>() {75, 84, 91, 39}},
            new Student {First="Sven", Last="Mortensen", ID=113, Scores= new List<int>() {88, 94, 65, 91}},
            new Student {First="Cesar", Last="Garcia", ID=114, Scores= new List<int>() {97, 89, 85, 82}},
            };
            // Separate data source for contact info.
            List<ContactInfo> contactList = new List<ContactInfo>()
            {
            new ContactInfo {ID=111, Email="SvetlanO@Contoso.com", Phone="206-555-0108"},
            new ContactInfo {ID=112, Email="ClaireO@Contoso.com", Phone="206-555-0298"},
            new ContactInfo {ID=113, Email="SvenMort@Contoso.com", Phone="206-555-1130"},
            new ContactInfo {ID=114, Email="CesarGar@Contoso.com", Phone="206-555-0521"}
            };

            static void Main(string[] args)
            {
            SelectSample2 app = new SelectSample2();
            // Produce a filtered sequence of unmodified Students.
            IEnumerable<Student> studentQuery1 =
            from student in app.students
            where student.ID > 111
            select student;
            Console.WriteLine("Query1: select range_variable");
            foreach (Student s in studentQuery1)
            {
            Console.WriteLine(s.ToString());
            }
            // Produce a filtered sequence of elements that contain
            // only one property of each Student.
            IEnumerable<String> studentQuery2 =
            from student in app.students
            where student.ID > 111

            where student.ID > 111
            select student.Last;
            Console.WriteLine("\r\n studentQuery2: select range_variable.Property");
            foreach (string s in studentQuery2)
            {
            Console.WriteLine(s);
            }
            // Produce a filtered sequence of objects created by
            // a method call on each Student.
            IEnumerable<ContactInfo> studentQuery3 =
            from student in app.students
            where student.ID > 111
            select student.GetContactInfo(app, student.ID);
            Console.WriteLine("\r\n studentQuery3: select range_variable.Method");
            foreach (ContactInfo ci in studentQuery3)
            {
            Console.WriteLine(ci.ToString());
            }
            // Produce a filtered sequence of ints from
            // the internal array inside each Student.
            IEnumerable<int> studentQuery4 =
            from student in app.students
            where student.ID > 111
            select student.Scores[0];
            Console.WriteLine("\r\n studentQuery4: select range_variable[index]");
            foreach (int i in studentQuery4)
            {
            Console.WriteLine("First score = {0}", i);
            }
            // Produce a filtered sequence of doubles
            // that are the result of an expression.
            IEnumerable<double> studentQuery5 =
            from student in app.students
            where student.ID > 111
            select student.Scores[0] * 1.1;
            Console.WriteLine("\r\n studentQuery5: select expression");
            foreach (double d in studentQuery5)
            {
            Console.WriteLine("Adjusted first score = {0}", d);
            }
            // Produce a filtered sequence of doubles that are
            // the result of a method call.
            IEnumerable<double> studentQuery6 =
            from student in app.students
            where student.ID > 111
            select student.Scores.Average();
            Console.WriteLine("\r\n studentQuery6: select expression2");
            foreach (double d in studentQuery6)
            {
            Console.WriteLine("Average = {0}", d);
            }
            // Produce a filtered sequence of anonymous types
            // that contain only two properties from each Student.
            var studentQuery7 =
            from student in app.students
            where student.ID > 111
            select new { student.First, student.Last };
            Console.WriteLine("\r\n studentQuery7: select new anonymous type");
            foreach (var item in studentQuery7)

            foreach (var item in studentQuery7)
            {
            Console.WriteLine("{0}, {1}", item.Last, item.First);
            }
            // Produce a filtered sequence of named objects that contain
            // a method return value and a property from each Student.
            // Use named types if you need to pass the query variable
            // across a method boundary.
            IEnumerable<ScoreInfo> studentQuery8 =
            from student in app.students
            where student.ID > 111
            select new ScoreInfo
            {
            Average = student.Scores.Average(),
            ID = student.ID
            };
            Console.WriteLine("\r\n studentQuery8: select new named type");
            foreach (ScoreInfo si in studentQuery8)
            {
            Console.WriteLine("ID = {0}, Average = {1}", si.ID, si.Average);
            }
            // Produce a filtered sequence of students who appear on a contact list
            // and whose average is greater than 85.
            IEnumerable<ContactInfo> studentQuery9 =
            from student in app.students
            where student.Scores.Average() > 85
            join ci in app.contactList on student.ID equals ci.ID
            select ci;
            Console.WriteLine("\r\n studentQuery9: select result of join clause");
            foreach (ContactInfo ci in studentQuery9)
            {
            Console.WriteLine("ID = {0}, Email = {1}", ci.ID, ci.Email);
            }
            // Keep the console window open in debug mode
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /* Output
            Query1: select range_variable
            Claire O'Donnell:112
            Sven Mortensen:113
            Cesar Garcia:114
            studentQuery2: select range_variable.Property
            O'Donnell
            Mortensen
            Garcia
            studentQuery3: select range_variable.Method
            ClaireO@Contoso.com,206-555-0298
            SvenMort@Contoso.com,206-555-1130
            CesarGar@Contoso.com,206-555-0521
            studentQuery4: select range_variable[index]
            First score = 75
            First score = 88
            First score = 97
            studentQuery5: select expression
            Adjusted first score = 82.5
            Adjusted first score = 96.8
            Adjusted first score = 106.7
            studentQuery6: select expression2

            studentQuery6: select expression2
            Average = 72.25
            Average = 84.5
            Average = 88.25
            studentQuery7: select new anonymous type
            O'Donnell, Claire
            Mortensen, Sven
            Garcia, Cesar
            studentQuery8: select new named type
            ID = 112, Average = 72.25
            ID = 113, Average = 84.5
            ID = 114, Average = 88.25
            studentQuery9: select result of join clause
            ID = 114, Email = CesarGar@Contoso.com
            */

            As shown in studentQuery8 in the previous example, sometimes you might want the elements of the returned
            sequence to contain only a subset of the properties of the source elements. By keeping the returned sequence as
            small as possible you can reduce the memory requirements and increase the speed of the execution of the query.
            You can accomplish this by creating an anonymous type in the select clause and using an object initializer to
            initialize it with the appropriate properties from the source element. For an example of how to do this, see Object
            and Collection Initializers.

            Remarks
            At compile time, the select clause is translated to a method call to the Select standard query operator.

            See also
            C# Reference
            Query Keywords (LINQ )
            from clause
            partial (Method) (C# Reference)
            Anonymous Types
            LINQ Query Expressions
            Getting Started with LINQ in C#

            group clause (C# Reference)
            12/11/2018 • 8 minutes to read • Edit Online

            The group clause returns a sequence of IGrouping<TKey,TElement> objects that contain zero or more items
            that match the key value for the group. For example, you can group a sequence of strings according to the first
            letter in each string. In this case, the first letter is the key and has a type char, and is stored in the Key property
            of each IGrouping<TKey,TElement> object. The compiler infers the type of the key.
            You can end a query expression with a group clause, as shown in the following example:
            // Query variable is an IEnumerable<IGrouping<char, Student>>
            var studentQuery1 =
            from student in students
            group student by student.Last[0];

            If you want to perform additional query operations on each group, you can specify a temporary identifier by
            using the into contextual keyword. When you use into , you must continue with the query, and eventually end it
            with either a select statement or another group clause, as shown in the following excerpt:
            // Group students by the first letter of their last name
            // Query variable is an IEnumerable<IGrouping<char, Student>>
            var studentQuery2 =
            from student in students
            group student by student.Last[0] into g
            orderby g.Key
            select g;

            More complete examples of the use of group with and without into are provided in the Example section of this
            article.

            Enumerating the results of a group query
            Because the IGrouping<TKey,TElement> objects produced by a group query are essentially a list of lists, you
            must use a nested foreach loop to access the items in each group. The outer loop iterates over the group keys,
            and the inner loop iterates over each item in the group itself. A group may have a key but no elements. The
            following is the foreach loop that executes the query in the previous code examples:
            // Iterate group items with a nested foreach. This IGrouping encapsulates
            // a sequence of Student objects, and a Key of type char.
            // For convenience, var can also be used in the foreach statement.
            foreach (IGrouping<char, Student> studentGroup in studentQuery2)
            {
            Console.WriteLine(studentGroup.Key);
            // Explicit type for student could also be used here.
            foreach (var student in studentGroup)
            {
            Console.WriteLine(" {0}, {1}", student.Last, student.First);
            }
            }

            Key types

            Group keys can be any type, such as a string, a built-in numeric type, or a user-defined named type or
            anonymous type.
            Grouping by string
            The previous code examples used a char . A string key could easily have been specified instead, for example the
            complete last name:
            // Same as previous example except we use the entire last name as a key.
            // Query variable is an IEnumerable<IGrouping<string, Student>>
            var studentQuery3 =
            from student in students
            group student by student.Last;

            Grouping by bool
            The following example shows the use of a bool value for a key to divide the results into two groups. Note that the
            value is produced by a sub-expression in the group clause.

            class GroupSample1
            {
            // The element type of the data source.
            public class Student
            {
            public string First { get; set; }
            public string Last { get; set; }
            public int ID { get; set; }
            public List<int> Scores;
            }
            public static List<Student> GetStudents()
            {
            // Use a collection initializer to create the data source. Note that each element
            // in the list contains an inner sequence of scores.
            List<Student> students = new List<Student>
            {
            new Student {First="Svetlana", Last="Omelchenko", ID=111, Scores= new List<int> {97, 72, 81, 60}},
            new Student {First="Claire", Last="O'Donnell", ID=112, Scores= new List<int> {75, 84, 91, 39}},
            new Student {First="Sven", Last="Mortensen", ID=113, Scores= new List<int> {99, 89, 91, 95}},
            new Student {First="Cesar", Last="Garcia", ID=114, Scores= new List<int> {72, 81, 65, 84}},
            new Student {First="Debra", Last="Garcia", ID=115, Scores= new List<int> {97, 89, 85, 82}}
            };
            return students;
            }
            static void Main()
            {
            // Obtain the data source.
            List<Student> students = GetStudents();
            // Group by true or false.
            // Query variable is an IEnumerable<IGrouping<bool, Student>>
            var booleanGroupQuery =
            from student in students
            group student by student.Scores.Average() >= 80; //pass or fail!
            // Execute the query and access items in each group
            foreach (var studentGroup in booleanGroupQuery)
            {
            Console.WriteLine(studentGroup.Key == true ? "High averages" : "Low averages");
            foreach (var student in studentGroup)
            {
            Console.WriteLine(" {0}, {1}:{2}", student.Last, student.First, student.Scores.Average());
            }
            }
            // Keep the console window open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /* Output:
            Low averages
            Omelchenko, Svetlana:77.5
            O'Donnell, Claire:72.25
            Garcia, Cesar:75.5
            High averages
            Mortensen, Sven:93.5
            Garcia, Debra:88.25
            */

            Grouping by numeric range
            The next example uses an expression to create numeric group keys that represent a percentile range. Note the

            use of let as a convenient location to store a method call result, so that you don't have to call the method two
            times in the group clause. For more information about how to safely use methods in query expressions, see
            How to: Handle Exceptions in Query Expressions.
            class GroupSample2
            {
            // The element type of the data source.
            public class Student
            {
            public string First { get; set; }
            public string Last { get; set; }
            public int ID { get; set; }
            public List<int> Scores;
            }
            public static List<Student> GetStudents()
            {
            // Use a collection initializer to create the data source. Note that each element
            // in the list contains an inner sequence of scores.
            List<Student> students = new List<Student>
            {
            new Student {First="Svetlana", Last="Omelchenko", ID=111, Scores= new List<int> {97, 72, 81, 60}},
            new Student {First="Claire", Last="O'Donnell", ID=112, Scores= new List<int> {75, 84, 91, 39}},
            new Student {First="Sven", Last="Mortensen", ID=113, Scores= new List<int> {99, 89, 91, 95}},
            new Student {First="Cesar", Last="Garcia", ID=114, Scores= new List<int> {72, 81, 65, 84}},
            new Student {First="Debra", Last="Garcia", ID=115, Scores= new List<int> {97, 89, 85, 82}}
            };
            return students;
            }
            // This method groups students into percentile ranges based on their
            // grade average. The Average method returns a double, so to produce a whole
            // number it is necessary to cast to int before dividing by 10.
            static void Main()
            {
            // Obtain the data source.
            List<Student> students = GetStudents();
            // Write the query.
            var studentQuery =
            from student in students
            let avg = (int)student.Scores.Average()
            group student by (avg / 10) into g
            orderby g.Key
            select g;
            // Execute the query.
            foreach (var studentGroup in studentQuery)
            {
            int temp = studentGroup.Key * 10;
            Console.WriteLine("Students with an average between {0} and {1}", temp, temp + 10);
            foreach (var student in studentGroup)
            {
            Console.WriteLine(" {0}, {1}:{2}", student.Last, student.First, student.Scores.Average());
            }
            }
            // Keep the console window open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /* Output:
            Students with an average between 70 and 80
            Omelchenko, Svetlana:77.5

            O'Donnell, Claire:72.25
            Garcia, Cesar:75.5
            Students with an average between 80 and 90
            Garcia, Debra:88.25
            Students with an average between 90 and 100
            Mortensen, Sven:93.5
            */

            Grouping by composite keys
            Use a composite key when you want to group elements according to more than one key. You create a composite
            key by using an anonymous type or a named type to hold the key element. In the following example, assume that
            a class Person has been declared with members named surname and city . The group clause causes a
            separate group to be created for each set of persons with the same last name and the same city.
            group person by new {name = person.surname, city = person.city};

            Use a named type if you must pass the query variable to another method. Create a special class using autoimplemented properties for the keys, and then override the Equals and GetHashCode methods. You can also use
            a struct, in which case you do not strictly have to override those methods. For more information see How to:
            Implement a Lightweight Class with Auto-Implemented Properties and How to: Query for Duplicate Files in a
            Directory Tree. The latter article has a code example that demonstrates how to use a composite key with a named
            type.

            Example
            The following example shows the standard pattern for ordering source data into groups when no additional
            query logic is applied to the groups. This is called a grouping without a continuation. The elements in an array of
            strings are grouped according to their first letter. The result of the query is an IGrouping<TKey,TElement> type
            that contains a public Key property of type char and an IEnumerable<T> collection that contains each item in
            the grouping.
            The result of a group clause is a sequence of sequences. Therefore, to access the individual elements within each
            returned group, use a nested foreach loop inside the loop that iterates the group keys, as shown in the following
            example.

            class GroupExample1
            {
            static void Main()
            {
            // Create a data source.
            string[] words = { "blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese" };
            // Create the query.
            var wordGroups =
            from w in words
            group w by w[0];
            // Execute the query.
            foreach (var wordGroup in wordGroups)
            {
            Console.WriteLine("Words that start with the letter '{0}':", wordGroup.Key);
            foreach (var word in wordGroup)
            {
            Console.WriteLine(word);
            }
            }
            // Keep the console window open in debug mode
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /* Output:
            Words that start with the letter 'b':
            blueberry
            banana
            Words that start with the letter 'c':
            chimpanzee
            cheese
            Words that start with the letter 'a':
            abacus
            apple
            */

            Example
            This example shows how to perform additional logic on the groups after you have created them, by using a
            continuation with into . For more information, see into. The following example queries each group to select only
            those whose key value is a vowel.

            class GroupClauseExample2
            {
            static void Main()
            {
            // Create the data source.
            string[] words2 = { "blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese", "elephant",
            "umbrella", "anteater" };
            // Create the query.
            var wordGroups2 =
            from w in words2
            group w by w[0] into grps
            where (grps.Key == 'a' || grps.Key == 'e' || grps.Key == 'i'
            || grps.Key == 'o' || grps.Key == 'u')
            select grps;
            // Execute the query.
            foreach (var wordGroup in wordGroups2)
            {
            Console.WriteLine("Groups that start with a vowel: {0}", wordGroup.Key);
            foreach (var word in wordGroup)
            {
            Console.WriteLine(" {0}", word);
            }
            }
            // Keep the console window open in debug mode
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /* Output:
            Groups that start with a vowel: a
            abacus
            apple
            anteater
            Groups that start with a vowel: e
            elephant
            Groups that start with a vowel: u
            umbrella
            */

            Remarks
            At compile time, group clauses are translated into calls to the GroupBy method.

            See also
            IGrouping<TKey,TElement>
            GroupBy
            ThenBy
            ThenByDescending
            Query Keywords
            Language Integrated Query (LINQ )
            Create a nested group
            Group query results
            Perform a subquery on a grouping operation

            into (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The into contextual keyword can be used to create a temporary identifier to store the results of a group, join or
            select clause into a new identifier. This identifier can itself be a generator for additional query commands. When
            used in a group or select clause, the use of the new identifier is sometimes referred to as a continuation.

            Example
            The following example shows the use of the into keyword to enable a temporary identifier fruitGroup which
            has an inferred type of IGrouping . By using the identifier, you can invoke the Count method on each group and
            select only those groups that contain two or more words.
            class IntoSample1
            {
            static void Main()
            {
            // Create a data source.
            string[] words = { "apples", "blueberries", "oranges", "bananas", "apricots"};
            // Create the query.
            var wordGroups1 =
            from w in words
            group w by w[0] into fruitGroup
            where fruitGroup.Count() >= 2
            select new { FirstLetter = fruitGroup.Key, Words = fruitGroup.Count() };
            // Execute the query. Note that we only iterate over the groups,
            // not the items in each group
            foreach (var item in wordGroups1)
            {
            Console.WriteLine(" {0} has {1} elements.", item.FirstLetter, item.Words);
            }
            // Keep the console window open in debug mode
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /* Output:
            a has 2 elements.
            b has 2 elements.
            */

            The use of into in a group clause is only necessary when you want to perform additional query operations on
            each group. For more information, see group clause.
            For an example of the use of into in a join clause, see join clause.

            See also
            Query Keywords (LINQ )
            LINQ Query Expressions
            group clause

            orderby clause (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            In a query expression, the orderby clause causes the returned sequence or subsequence (group) to be sorted in
            either ascending or descending order. Multiple keys can be specified in order to perform one or more secondary
            sort operations. The sorting is performed by the default comparer for the type of the element. The default sort
            order is ascending. You can also specify a custom comparer. However, it is only available by using method-based
            syntax. For more information, see Sorting Data.

            Example
            In the following example, the first query sorts the words in alphabetical order starting from A, and second query
            sorts the same words in descending order. (The ascending keyword is the default sort value and can be omitted.)

            class OrderbySample1
            {
            static void Main()
            {
            // Create a delicious data source.
            string[] fruits = { "cherry", "apple", "blueberry" };
            // Query for ascending sort.
            IEnumerable<string> sortAscendingQuery =
            from fruit in fruits
            orderby fruit //"ascending" is default
            select fruit;
            // Query for descending sort.
            IEnumerable<string> sortDescendingQuery =
            from w in fruits
            orderby w descending
            select w;
            // Execute the query.
            Console.WriteLine("Ascending:");
            foreach (string s in sortAscendingQuery)
            {
            Console.WriteLine(s);
            }
            // Execute the query.
            Console.WriteLine(Environment.NewLine + "Descending:");
            foreach (string s in sortDescendingQuery)
            {
            Console.WriteLine(s);
            }
            // Keep the console window open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /* Output:
            Ascending:
            apple
            blueberry
            cherry
            Descending:
            cherry
            blueberry
            apple
            */

            Example
            The following example performs a primary sort on the students' last names, and then a secondary sort on their
            first names.
            class OrderbySample2
            {
            // The element type of the data source.
            public class Student
            {
            public string First { get; set; }
            public string Last { get; set; }
            public int ID { get; set; }
            }

            public static List<Student> GetStudents()
            {
            // Use a collection initializer to create the data source. Note that each element
            // in the list contains an inner sequence of scores.
            List<Student> students = new List<Student>
            {
            new Student {First="Svetlana", Last="Omelchenko", ID=111},
            new Student {First="Claire", Last="O'Donnell", ID=112},
            new Student {First="Sven", Last="Mortensen", ID=113},
            new Student {First="Cesar", Last="Garcia", ID=114},
            new Student {First="Debra", Last="Garcia", ID=115}
            };
            return students;
            }
            static void Main(string[] args)
            {
            // Create the data source.
            List<Student> students = GetStudents();
            // Create the query.
            IEnumerable<Student> sortedStudents =
            from student in students
            orderby student.Last ascending, student.First ascending
            select student;
            // Execute the query.
            Console.WriteLine("sortedStudents:");
            foreach (Student student in sortedStudents)
            Console.WriteLine(student.Last + " " + student.First);
            // Now create groups and sort the groups. The query first sorts the names
            // of all students so that they will be in alphabetical order after they are
            // grouped. The second orderby sorts the group keys in alpha order.
            var sortedGroups =
            from student in students
            orderby student.Last, student.First
            group student by student.Last[0] into newGroup
            orderby newGroup.Key
            select newGroup;
            // Execute the query.
            Console.WriteLine(Environment.NewLine + "sortedGroups:");
            foreach (var studentGroup in sortedGroups)
            {
            Console.WriteLine(studentGroup.Key);
            foreach (var student in studentGroup)
            {
            Console.WriteLine(" {0}, {1}", student.Last, student.First);
            }
            }
            // Keep the console window open in debug mode
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /* Output:
            sortedStudents:
            Garcia Cesar
            Garcia Debra
            Mortensen Sven
            O'Donnell Claire
            Omelchenko Svetlana
            sortedGroups:
            G
            Garcia, Cesar

            Garcia, Cesar
            Garcia, Debra
            M
            Mortensen, Sven
            O
            O'Donnell, Claire
            Omelchenko, Svetlana
            */

            Remarks
            At compile time, the orderby clause is translated to a call to the OrderBy method. Multiple keys in the orderby
            clause translate to ThenBy method calls.

            See also
            C# Reference
            Query Keywords (LINQ )
            Language Integrated Query (LINQ )
            group clause
            Getting Started with LINQ in C#

            join clause (C# Reference)
            12/11/2018 • 9 minutes to read • Edit Online

            The join clause is useful for associating elements from different source sequences that have no direct
            relationship in the object model. The only requirement is that the elements in each source share some value that
            can be compared for equality. For example, a food distributor might have a list of suppliers of a certain product,
            and a list of buyers. A join clause can be used, for example, to create a list of the suppliers and buyers of that
            product who are all in the same specified region.
            A join clause takes two source sequences as input. The elements in each sequence must either be or contain a
            property that can be compared to a corresponding property in the other sequence. The join clause compares
            the specified keys for equality by using the special equals keyword. All joins performed by the join clause are
            equijoins. The shape of the output of a join clause depends on the specific type of join you are performing. The
            following are three most common join types:
            Inner join
            Group join
            Left outer join

            Inner join
            The following example shows a simple inner equijoin. This query produces a flat sequence of "product name /
            category" pairs. The same category string will appear in multiple elements. If an element from categories has
            no matching products , that category will not appear in the results.
            var innerJoinQuery =
            from category in categories
            join prod in products on category.ID equals prod.CategoryID
            select new { ProductName = prod.Name, Category = category.Name }; //produces flat sequence

            For more information, see Perform inner joins.

            Group join
            A join clause with an into expression is called a group join.
            var innerGroupJoinQuery =
            from category in categories
            join prod in products on category.ID equals prod.CategoryID into prodGroup
            select new { CategoryName = category.Name, Products = prodGroup };

            A group join produces a hierarchical result sequence, which associates elements in the left source sequence with
            one or more matching elements in the right side source sequence. A group join has no equivalent in relational
            terms; it is essentially a sequence of object arrays.
            If no elements from the right source sequence are found to match an element in the left source, the join clause
            will produce an empty array for that item. Therefore, the group join is still basically an inner-equijoin except that
            the result sequence is organized into groups.
            If you just select the results of a group join, you can access the items, but you cannot identify the key that they

            match on. Therefore, it is generally more useful to select the results of the group join into a new type that also
            has the key name, as shown in the previous example.
            You can also, of course, use the result of a group join as the generator of another subquery:
            var innerGroupJoinQuery2 =
            from category in categories
            join prod in products on category.ID equals prod.CategoryID into prodGroup
            from prod2 in prodGroup
            where prod2.UnitPrice > 2.50M
            select prod2;

            For more information, see Perform grouped joins.

            Left outer join
            In a left outer join, all the elements in the left source sequence are returned, even if no matching elements are in
            the right sequence. To perform a left outer join in LINQ, use the DefaultIfEmpty method in combination with a
            group join to specify a default right-side element to produce if a left-side element has no matches. You can use
            null as the default value for any reference type, or you can specify a user -defined default type. In the following
            example, a user-defined default type is shown:
            var leftOuterJoinQuery =
            from category in categories
            join prod in products on category.ID equals prod.CategoryID into prodGroup
            from item in prodGroup.DefaultIfEmpty(new Product { Name = String.Empty, CategoryID = 0 })
            select new { CatName = category.Name, ProdName = item.Name };

            For more information, see Perform left outer joins.

            The equals operator
            A join clause performs an equijoin. In other words, you can only base matches on the equality of two keys.
            Other types of comparisons such as "greater than" or "not equals" are not supported. To make clear that all joins
            are equijoins, the join clause uses the equals keyword instead of the == operator. The equals keyword can
            only be used in a join clause and it differs from the == operator in one important way. With equals , the left
            key consumes the outer source sequence, and the right key consumes the inner source. The outer source is only
            in scope on the left side of equals and the inner source sequence is only in scope on the right side.

            Non-equijoins
            You can perform non-equijoins, cross joins, and other custom join operations by using multiple from clauses to
            introduce new sequences independently into a query. For more information, see Perform custom join operations.

            Joins on object collections vs. relational tables
            In a LINQ query expression, join operations are performed on object collections. Object collections cannot be
            "joined" in exactly the same way as two relational tables. In LINQ, explicit join clauses are only required when
            two source sequences are not tied by any relationship. When working with LINQ to SQL, foreign key tables are
            represented in the object model as properties of the primary table. For example, in the Northwind database, the
            Customer table has a foreign key relationship with the Orders table. When you map the tables to the object
            model, the Customer class has an Orders property that contains the collection of Orders associated with that
            Customer. In effect, the join has already been done for you.
            For more information about querying across related tables in the context of LINQ to SQL, see How to: Map

            Database Relationships.

            Composite keys
            You can test for equality of multiple values by using a composite key. For more information, see Join by using
            composite keys. Composite keys can be also used in a group clause.

            Example
            The following example compares the results of an inner join, a group join, and a left outer join on the same data
            sources by using the same matching keys. Some extra code is added to these examples to clarify the results in
            the console display.
            class JoinDemonstration
            {
                #region Data
            class Product
            {
            public string Name { get; set; }
            public int CategoryID { get; set; }
            }
            class Category
            {
            public string Name { get; set; }
            public int ID { get; set; }
            }
            // Specify the first data source.
            List<Category> categories = new List<Category>()
            {
            new Category(){Name="Beverages", ID=001},
            new Category(){ Name="Condiments", ID=002},
            new Category(){ Name="Vegetables", ID=003},
            new Category() { Name="Grains", ID=004},
            new Category() { Name="Fruit", ID=005}
            };
            // Specify the second data source.
            List<Product> products = new List<Product>()
            {
            new Product{Name="Cola", CategoryID=001},
            new Product{Name="Tea", CategoryID=001},
            new Product{Name="Mustard", CategoryID=002},
            new Product{Name="Pickles", CategoryID=002},
            new Product{Name="Carrots", CategoryID=003},
            new Product{Name="Bok Choy", CategoryID=003},
            new Product{Name="Peaches", CategoryID=005},
            new Product{Name="Melons", CategoryID=005},
            };
                #endregion

            static void Main(string[] args)
            {
            JoinDemonstration app = new JoinDemonstration();
            app.InnerJoin();
            app.GroupJoin();
            app.GroupInnerJoin();
            app.GroupJoin3();
            app.LeftOuterJoin();
            app.LeftOuterJoin2();

            // Keep the console window open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            void InnerJoin()
            {
            // Create the query that selects
            // a property from each element.
            var innerJoinQuery =
            from category in categories
            join prod in products on category.ID equals prod.CategoryID
            select new { Category = category.ID, Product = prod.Name };
            Console.WriteLine("InnerJoin:");
            // Execute the query. Access results
            // with a simple foreach statement.
            foreach (var item in innerJoinQuery)
            {
            Console.WriteLine("{0,-10}{1}", item.Product, item.Category);
            }
            Console.WriteLine("InnerJoin: {0} items in 1 group.", innerJoinQuery.Count());
            Console.WriteLine(System.Environment.NewLine);
            }
            void GroupJoin()
            {
            // This is a demonstration query to show the output
            // of a "raw" group join. A more typical group join
            // is shown in the GroupInnerJoin method.
            var groupJoinQuery =
            from category in categories
            join prod in products on category.ID equals prod.CategoryID into prodGroup
            select prodGroup;
            // Store the count of total items (for demonstration only).
            int totalItems = 0;
            Console.WriteLine("Simple GroupJoin:");
            // A nested foreach statement is required to access group items.
            foreach (var prodGrouping in groupJoinQuery)
            {
            Console.WriteLine("Group:");
            foreach (var item in prodGrouping)
            {
            totalItems++;
            Console.WriteLine(" {0,-10}{1}", item.Name, item.CategoryID);
            }
            }
            Console.WriteLine("Unshaped GroupJoin: {0} items in {1} unnamed groups", totalItems,
            groupJoinQuery.Count());
            Console.WriteLine(System.Environment.NewLine);
            }
            void GroupInnerJoin()
            {
            var groupJoinQuery2 =
            from category in categories
            orderby category.ID
            join prod in products on category.ID equals prod.CategoryID into prodGroup
            select new
            {
            Category = category.Name,
            Products = from prod2 in prodGroup
            orderby prod2.Name
            select prod2
            };

            };
            //Console.WriteLine("GroupInnerJoin:");
            int totalItems = 0;
            Console.WriteLine("GroupInnerJoin:");
            foreach (var productGroup in groupJoinQuery2)
            {
            Console.WriteLine(productGroup.Category);
            foreach (var prodItem in productGroup.Products)
            {
            totalItems++;
            Console.WriteLine(" {0,-10} {1}", prodItem.Name, prodItem.CategoryID);
            }
            }
            Console.WriteLine("GroupInnerJoin: {0} items in {1} named groups", totalItems,
            groupJoinQuery2.Count());
            Console.WriteLine(System.Environment.NewLine);
            }
            void GroupJoin3()
            {
            var groupJoinQuery3 =
            from category in categories
            join product in products on category.ID equals product.CategoryID into prodGroup
            from prod in prodGroup
            orderby prod.CategoryID
            select new { Category = prod.CategoryID, ProductName = prod.Name };
            //Console.WriteLine("GroupInnerJoin:");
            int totalItems = 0;
            Console.WriteLine("GroupJoin3:");
            foreach (var item in groupJoinQuery3)
            {
            totalItems++;
            Console.WriteLine(" {0}:{1}", item.ProductName, item.Category);
            }
            Console.WriteLine("GroupJoin3: {0} items in 1 group", totalItems, groupJoinQuery3.Count());
            Console.WriteLine(System.Environment.NewLine);
            }
            void LeftOuterJoin()
            {
            // Create the query.
            var leftOuterQuery =
            from category in categories
            join prod in products on category.ID equals prod.CategoryID into prodGroup
            select prodGroup.DefaultIfEmpty(new Product() { Name = "Nothing!", CategoryID = category.ID
            });
            // Store the count of total items (for demonstration only).
            int totalItems = 0;
            Console.WriteLine("Left Outer Join:");
            // A nested foreach statement is required to access group items
            foreach (var prodGrouping in leftOuterQuery)
            {
            Console.WriteLine("Group:", prodGrouping.Count());
            foreach (var item in prodGrouping)
            {
            totalItems++;
            Console.WriteLine(" {0,-10}{1}", item.Name, item.CategoryID);
            }
            }
            Console.WriteLine("LeftOuterJoin: {0} items in {1} groups", totalItems, leftOuterQuery.Count());
            Console.WriteLine(System.Environment.NewLine);

            Console.WriteLine(System.Environment.NewLine);
            }
            void LeftOuterJoin2()
            {
            // Create the query.
            var leftOuterQuery2 =
            from category in categories
            join prod in products on category.ID equals prod.CategoryID into prodGroup
            from item in prodGroup.DefaultIfEmpty()
            select new { Name = item == null ? "Nothing!" : item.Name, CategoryID = category.ID };
            Console.WriteLine("LeftOuterJoin2: {0} items in 1 group", leftOuterQuery2.Count());
            // Store the count of total items
            int totalItems = 0;
            Console.WriteLine("Left Outer Join 2:");
            // Groups have been flattened.
            foreach (var item in leftOuterQuery2)
            {
            totalItems++;
            Console.WriteLine("{0,-10}{1}", item.Name, item.CategoryID);
            }
            Console.WriteLine("LeftOuterJoin2: {0} items in 1 group", totalItems);
            }
            }
            /*Output:
            InnerJoin:
            Cola
            1
            Tea
            1
            Mustard 2
            Pickles 2
            Carrots 3
            Bok Choy 3
            Peaches 5
            Melons
            5
            InnerJoin: 8 items in 1 group.

            Unshaped GroupJoin:
            Group:
            Cola
            1
            Tea
            1
            Group:
            Mustard 2
            Pickles 2
            Group:
            Carrots 3
            Bok Choy 3
            Group:
            Group:
            Peaches 5
            Melons
            5
            Unshaped GroupJoin: 8 items in 5 unnamed groups

            GroupInnerJoin:
            Beverages
            Cola
            1
            Tea
            1
            Condiments
            Mustard
            2
            Pickles
            2
            Vegetables
            Bok Choy 3
            Carrots
            3
            Grains
            Fruit

            Fruit
            Melons
            5
            Peaches
            5
            GroupInnerJoin: 8 items in 5 named groups

            GroupJoin3:
            Cola:1
            Tea:1
            Mustard:2
            Pickles:2
            Carrots:3
            Bok Choy:3
            Peaches:5
            Melons:5
            GroupJoin3: 8 items in 1 group

            Left Outer Join:
            Group:
            Cola
            1
            Tea
            1
            Group:
            Mustard 2
            Pickles 2
            Group:
            Carrots 3
            Bok Choy 3
            Group:
            Nothing! 4
            Group:
            Peaches 5
            Melons
            5
            LeftOuterJoin: 9 items in 5 groups

            LeftOuterJoin2: 9 items in 1 group
            Left Outer Join 2:
            Cola
            1
            Tea
            1
            Mustard 2
            Pickles 2
            Carrots 3
            Bok Choy 3
            Nothing! 4
            Peaches 5
            Melons
            5
            LeftOuterJoin2: 9 items in 1 group
            Press any key to exit.
            */

            Remarks
            A join clause that is not followed by into is translated into a Join method call. A join clause that is followed
            by into is translated to a GroupJoin method call.

            See also
            Query Keywords (LINQ )
            Language Integrated Query (LINQ )
            Join Operations
            group clause
            Perform left outer joins

            Perform inner joins
            Perform grouped joins
            Order the results of a join clause
            Join by using composite keys
            Compatible database systems for Visual Studio

            let clause (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            In a query expression, it is sometimes useful to store the result of a sub-expression in order to use it in subsequent
            clauses. You can do this with the let keyword, which creates a new range variable and initializes it with the result
            of the expression you supply. Once initialized with a value, the range variable cannot be used to store another
            value. However, if the range variable holds a queryable type, it can be queried.

            Example
            In the following example let is used in two ways:
            1. To create an enumerable type that can itself be queried.
            2. To enable the query to call ToLower only one time on the range variable word . Without using let , you
            would have to call ToLower in each predicate in the where clause.

            class LetSample1
            {
            static void Main()
            {
            string[] strings =
            {
            "A penny saved is a penny earned.",
            "The early bird catches the worm.",
            "The pen is mightier than the sword."
            };
            // Split the sentence into an array of words
            // and select those whose first letter is a vowel.
            var earlyBirdQuery =
            from sentence in strings
            let words = sentence.Split(' ')
            from word in words
            let w = word.ToLower()
            where w[0] == 'a' || w[0] == 'e'
            || w[0] == 'i' || w[0] == 'o'
            || w[0] == 'u'
            select word;
            // Execute the query.
            foreach (var v in earlyBirdQuery)
            {
            Console.WriteLine("\"{0}\" starts with a vowel", v);
            }
            // Keep the console window open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
            }
            }
            /* Output:
            "A" starts with a vowel
            "is" starts with a vowel
            "a" starts with a vowel
            "earned." starts with a vowel
            "early" starts with a vowel
            "is" starts with a vowel
            */

            See also
            C# Reference
            Query Keywords (LINQ )
            Language Integrated Query (LINQ )
            Getting Started with LINQ in C#
            Handle exceptions in query expressions

            ascending (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The ascending contextual keyword is used in the orderby clause in query expressions to specify that the sort
            order is from smallest to largest. Because ascending is the default sort order, you do not have to specify it.

            Example
            The following example shows the use of ascending in an orderby clause.
            IEnumerable<string> sortAscendingQuery =
            from vegetable in vegetables
            orderby vegetable ascending
            select vegetable;

            See Also
            C# Reference
            LINQ Query Expressions
            descending

            descending (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The descending contextual keyword is used in the orderby clause in query expressions to specify that the sort
            order is from largest to smallest.

            Example
            The following example shows the use of descending in an orderby clause.
            IEnumerable<string> sortDescendingQuery =
            from vegetable in vegetables
            orderby vegetable descending
            select vegetable;

            See also
            C# Reference
            LINQ Query Expressions
            ascending

            on (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The on contextual keyword is used in the join clause of a query expression to specify the join condition.

            Example
            The following example shows the use of on in a join clause.
            var innerJoinQuery =
            from category in categories
            join prod in products on category.ID equals prod.CategoryID
            select new { ProductName = prod.Name, Category = category.Name };

            See also
            C# Reference
            Language Integrated Query (LINQ )

            equals (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The equals contextual keyword is used in a join clause in a query expression to compare the elements of two
            sequences. For more information, see join clause.

            Example
            The following example shows the use of the equals keyword in a join clause.
            var innerJoinQuery =
            from category in categories
            join prod in products on category.ID equals prod.CategoryID
            select new { ProductName = prod.Name, Category = category.Name };

            See also
            Language Integrated Query (LINQ )

            by (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The by contextual keyword is used in the group clause in a query expression to specify how the returned items
            should be grouped. For more information, see group clause.

            Example
            The following example shows the use of the by contextual keyword in a group clause to specify that the students
            should be grouped according to the first letter of the last name of each student.
            var query = from student in students
            group student by student.LastName[0];

            See also
            LINQ Query Expressions

            in (C# Reference)
            12/11/2018 • 2 minutes to read • Edit Online

            The in keyword is used in four contexts:
            generic type parameters in generic interfaces and delegates.
            As a parameter modifier, which lets you pass an argument to a method by reference rather than by value.
            foreach statements.
            from clauses in LINQ query expressions.
            join clauses in LINQ query expressions.

            See Also
            C# Keywords
            C# Reference

            
--
~/Dropbox/rsc/Doks/csharp3.cheatsh.pdf  @
            C# Basics Cheat Sheet (1 of 4)
            begincodingnow.com

            Introduction to C#

            The C# language was developed by
            Microsoft for the .NET framework.
            C# is a completely-rewritten
            language based on C Language and
            C++ Language. It is a
            general-purpose, object-oriented,
            type-safe platform-neutral language
            that works with the .NET Framework.

            Visual Studio (VS)

            Visual Studio Community 2017 is a
            free download from Microsoft. To
            create a new project, go to File >
            New > Project in Visual Studio.
            From there select the Visual C#
            template type in the left frame.
            Then select the Console App
            template in the right frame. At the
            bottom of the window configure the
            name and location of the project.
            Click OK and the project wizard
            will create your project.

            C# Hello World (at the Console)
            using System;
            namespace ConsoleApp1
            {
              class Program
              {
                static void Main(string[] args)
                {
                  Console.WriteLine("Hello World");
                  /* this comment in C# is ignored by compiler */
                  /* a multi-line comment
                     that is ignored by the compiler*/
                }
              }
            }

            c-f5 will run the program without
            the debug mode. T@The reason why
            you do not want to choose the Start
            Debugging command (f5) here is
            because the console window will
            then close as soon as the program
            has finished executing, unless you
            use Console.ReadKey(); at the end.
            There are several methods and
            properties of console. You can
            change colors and put a Title on
            the console. Add this to the Main()
            to use your namespace, which may be
            your solution and project name
            also.

            Type myType = typeof(Program);
            Console.Title = myType.Namespace;
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WindowWidth = 180;
              // max might be 213 (180 is very wide)

            A Few Code Snippets in VS
            Code Snippet
              Description
            --
            cw
              Console.WriteLine()
            prop
              public int MyProperty { get; set; }
            Constructor
              ctor
            f12
              Go to Definition
            c-k_c/c-k_u
              Comment & un-comment a selected
              code block

            ReSharper is a plug-in for Visual
            Studio that adds many code
            navigation and editing features. It
            finds compiler errors, runtime
            errors, redundancies, and code
            smells right as you type,
            suggesting intelligent corrections
            for them.

            Common Language Runtime (CLR)

            A core component of the .NET
            Framework is the CLR, which sits on
            top of the operating system and
            manages program execution. You use
            the .NET tools (VS, compiler,
            debugger, ASP and WCF) to produce
            compiled code that uses the Base
            Class Library (BCL) that are all
            used by the CLR.

            The compiler for a .NET language
            takes a source code (C# code and
            others) file and produces an output
            file called an assembly (EXE or
            DLL), which isn't native machine
            code but contains an intermediate
            language called the Common
            Intermediate Language (CIL), and
            metadata. The program's CIL isn't
            compiled to native machine code
            until it's called to run.

            At run time, the CLR checks
            security, allocates space in memory
            and sends the assembly's executable
            code to its just-in-time (JIT)
            compiler, which compiles portions
            of it to native (machine) code.

            Once the CIL is compiled to native
            code, the CLR manages it as it
            runs, performing such tasks as
            releasing orphaned memory, checking
            array bounds, checking parameter
            types, and managing exceptions.
            Compilation to native code occurs
            at run time. In summary, the steps
            are: C# code > assembly (exe or dll)
            & BCL > CLR & JIT compiler > machine
            code > operating system > machine.

            Variable Declaration and Assignment

            In C#, a variable must be declared
            (created) before it can be used. To
            declare a variable, you start with
            the data type you want it to hold
            followed by a variable name. A
            value is assigned to the variable
            by using the equals sign, which is
            the assignment operator (=). T@The
            variable then becomes defined or
            initialized.

            Data Types

            A primitive is a C# built-in type.
            A string is not a primitive type
            but it is a built-in type.

            Primitive
              Bytes
              Suffix
              Range
              Sys Type

            bool
              1

              True or False
              Boolean
            char
              2

              Unicode
              Char
            byte
              1

              0 to 255
              Byte
            sbyte
              1

              -128 to 127
              SByte
            short
              2

              -32,768 to 32,767
              Int16
            int
              4

              -2^31 to 2^31 - 1
              Int32
            long
              8
              L
              –2^63 to 2^63 - 1
              Int64
            ushort
              2

              0 to 2^16 - 1
              UInt16
            uint
              4
              U
              0 to 2^32 - 1
              UInt32
            ulong
              8
              UL
              0 to 2^64 - 1
              UInt64
            float
              4
              F
              +-1.5 x 10^-45 to +-3.4 x 10^38
              Single
            double
              8
              D
              +-5.0 x 10 -324 to +-1.7 x 10308
              Double
            decimal
              16
              M
              +-1.0 x 10 -28 to +-7.9 x 1028
              Decimal

            The numeric suffixes listed in the
            preceding table explicitly define
            the type of a literal. By default,
            the compiler infers a numeric
            literal to be either of type double
            or an integral type:
            - If the literal contains a decimal
              point or the exponential symbol
              (E), it is a double.
            - Otherwise, the literal's type is
              the first type in this list that
              can fit the literal's value: int,
              uint, long, and ulong.

              - Integral Signed (sbyte, short,
                int, long)
              - Integral Unsigned (byte,
                ushort, uint, ulong)
              - Real (float, double, decimal)

            Console.WriteLine(2.6.GetType()); // System.Double
            Console.WriteLine(3.GetType());   // System.Int32

            Type
              Default Value
              Reference/Value

            All numbers
              0
              Value Type

            Boolean
              False
              Value Type

            String
              null
              Reference Type

            Char
              '\0'
              Value Type

            Struct

              Value Type

            Enum
              E(0)
              Value Type

            Nullable
              null
              Value Type

            Class
              null
              Reference Type

            Interface

              Reference Type

            Array

              Reference Type

            Delegate

              Reference Type

            Reference Types & Value Types

            C# types can be divided into value
            types and reference types. Value
            types comprise most built-in types
            (specifically, all numeric types,
            the char type, and the bool type)
            as well as custom struct and enum
            types. There are two types of value
            types: structs and enumerations.
            Reference types comprise all class,
            array, delegate, and interface
            types. Value types and reference
            types are handled differently in
            memory. T@Value types are stored on
            the stack. T@Reference types have a
            reference (memory pointer) stored
            on the stack and the object itself
            is stored on the heap. With
            reference types, multiple variables
            can reference the same object, and
            object changes made through one
            variable will affect other
            variables that reference the same
            object. With value types, each
            variable will store its own value
            and operations on one will not
            affect another.

            Strings

            TT@A string is a built-in
            non-primitive reference type that
            is an immutable sequence of Unicode
            characters. A string literal is
            specified between double quotes.
            The + operator concatenates two
            strings.

            T@T@T@A string preceded with
            the $ character is called an
            interpolated string which can
            include expressions inside braces
            {1:} that can be formatted by
            appending a colon and a format
            string.
            string s = $"255 in hex is {byte.MaxValue:X2}";
            HM@Interpolated strings must
            complete on a single line, unless
            you also specify the verbatim
            string operator. T@T@Note that the
            $ operator must come before @ as
            shown here:
            int x = 2;
            string s = $@"this spans {x}
            lines in code but 1 on the console.";

            Another example:
            string s = $@"this spans {x}
            lines in code and 2 lines on the console.";
              // at left side of editor

            T@T@string does not support < and >
            operators for comparisons. You must
            instead use string's CompareTo
            method, which returns a positive
            number, a negative number, or zero.

            Char

            C#'s char type (aliasing the
            System.Char type) represents a
            Unicode character and occupies two
            bytes. A char literal is specified
            inside single quotes.

            char MyChar = 'A';
            char[] MyChars = { 'A', 'B', 'C' };
            Console.WriteLine(MyChar);
            T@foreach (char ch in MyChars) { Console.Write(ch); }

            Escape Sequences

            Escape sequences work with chars
            and strings, except for verbatim
            strings, which are proceeded by the
            @ symbol.
            Console.WriteLine("Hello\nWorld");  // on two lines
            Console.WriteLine("Hello\u000AWorld");  // on two lines
            char newLine = '\n';
            Console.WriteLine("Hi" + newLine + "World"); // on two lines

            The \u (or \x) escape sequence lets
            you specify any Unicode character
            via its four-digit hexadecimal code.

            Char
              Meaning
              Value

            \'
              Single quote
              0x0027
            \"
              Double quote
              0x0022
            \\
              Backslash
              0x005C
            \0
              Null
              0x0000
            \a
              Alert
              0x0007
            \b
              Backspace
              0x0008
            \f
              Form feed
              0x000C
            \n
              New line
              0x000A
            \r
              Carriage return
              0x000D
            \t
              Horizontal tab
              0x0009
            \v
              Vertical tab
              0x000B

            Verbatim string literals. A
            verbatim string literal is prefixed
            with @ and does not support escape
            sequences.
            string myPath = @"C:\temp\";
            string myPath = "C:\\temp\\";

            Constants

            A local constant is much like a
            local variable, except that once it
            is initialized, its value can't be
            changed.
            N@The keyword const is not a
            modifier but part of the core
            declaration and it must be placed
            immediately before the type.

            A constant is a static field whose
            value can never change. A constant
            is evaluated statically at compile
            time and the compiler literally
            substitutes its value whenever used
            (rather like a macro in C++). A
            constant can be any of the built-in
            numeric types, bool, char, string,
            or an enum type.
            const int myNumber = 3;

            Expressions

            An expression essentially denotes a
            value. The simplest kinds of
            expressions are constants (such as
            45) and variables (such as myInt).
            Expressions can be transformed and
            combined with operators. An
            operator takes one or more input
            operands to output a new
            expression.

            Operators

            Operators are used to operate on
            values and can be classed as unary,
            binary, or ternary, depending on
            the number of operands they work on
            (one, two, or three). They can be
            grouped into five types:
            arithmetic, assignment, comparison,
            logical and bitwise operators.
            The arithmetic operators include
            the four basic arithmetic
            operations, as well as the modulus
            operator (%) which is used to
            obtain the division remainder.
            The second group is the assignment
            operators. Most importantly, the
            assignment operator (=) itself,
            which assigns a value to a
            variable.
            The comparison operators compare
            two values and return either true
            or false. The logical operators are
            often used together with the
            comparison operators. Logical and
            (&&) evaluates to true if both the
            left and right side are true, and
            logical or (||) evaluates to true
            if either the left or right side is
            true. The logical not (!)
            operator is used for inverting a
            Boolean result.
            The bitwise operators can
            manipulate individual bits inside
            an integer.
            A few examples of Operators.

            Symbol
              Name
              Example
              Overloadable?

            .
              Member access
              x.y
              No
            ()
              Function call
              x()
              No
            []
              Array/index
              a[x]
              Via indexer
            ++
              Post-increment
              x++
              Yes
            --
              Post-decrement
              x--
              Yes
            new
              Create instance
              new Foo()
              No
            ?.  T@T@
              Null-conditional
              x?.y
              No
            !
              Not
              !x
              Yes
            ++
              Pre-increment
              ++x
              Yes
            --
              Pre-decrement
              --x
              Yes
            ()
              Cast
              (int)x
              No
            ==
              Equals
              x == y
              Yes
            !=
              Not equals
              x != y
              Yes
            &
              Logical And
              x&y
              Yes
            |
              Logical Or
              x|y
              Yes
            &&
              Conditional And
              x && y
              Via &
            ||
              Conditional Or
              x || y
              Via|
            ? :
              Ternary
              isTrue ? then this : elseThis
              No
            =
              Assign
              x = 23
              No
            *=
              Multiply by self (and / + -)
              x *= 3
              Via *
            =>
              Lambda
              x => x + 3
              No

            Note: The && and || operators are
            conditional versions of the & and |
            operators. T@The operation x && y
            corresponds to the operation x & y,
            except that y is evaluated only if
            x is not false. The right-hand
            operand is evaluated conditionally
            depending on the value of the
            left-hand operand. x && y is
            equivalent to x ? y : false

            T@T@T@The ?? operator is the null
            coalescing operator. If the operand
            is non-null, give it to me;
            otherwise, give me a default value.

            T@T@HM@The using Directive

            To access a class from another
            namespace, you need to specify its
            fully qualified name, however the
            fully qualified name can be
            shortened by including the
            namespace with a using directive.

            It is mandatory to place using
            directives before all other members
            in the code file. In Visual Studio,
            the editor will grey out any using
            statements that are not required.

            T@T@N@StringBuilder

            System.Text.StringBuilder
            There are three Constructors

            StringBuilder sb = new StringBuilder();
            StringBuilder sb = new StringBuilder(myString);
            StringBuilder sb = new StringBuilder(myString,capacity);

            Capacity is initial size (in
            characters) of buffer.

            The string class is immutable,
            meaning once you create a string
            object you cannot change its
            content. T@T@t@If you have a lot of
            string manipulations to do, and you
            need to modify it, use
            StringBuilder. Note that you cannot
            search your string. You do not have
            the following: IndexOf(),
            StartsWith(), LastIndexOf(),
            Contains() and so on. Instead you
            have methods for manipulating
            strings such as Append(), Insert(),
            Remove(), Clear() and Replace().
            StringBuilder needs using System.Text.
            TT@You can chain these
            methods together because each of
            these methods return a
            StringBuilder object.

            T@T@T@T@static void Main(string[] args)
            {
              var sbuild = new System.Text.StringBuilder("");
              sbuild.AppendLine("Title")
                  .Append('=', 5)
                  .Replace('=', '-')
                  .Insert(0, new string('-', 5))
                  .Remove(0, 4);
              Console.WriteLine(sbuild);
            }

            Arrays

            An array is a fixed number of
            elements of the same type. An array
            uses square brackets after the
            element type. Square brackets also
            index the array, starting at zero,
            not 1.

            static void Main(string[] args)
            {
              int[] numArray = { 7, 2, 3 };
              int[] numArray2 = new int[3]; // default value is 0
              // below is 3 rows and 2 columns
              int[,] numArray3 = { { 1, 2 }, { 3, 4 }, { 5, 6 } };
              char[] vowels = new char[] { 'a', 'e', 'i', 'o', 'u' };
              char[] vowels2 = { 'a', 'e', 'i', 'o', 'u' };
                // =simplified
              Array.Sort(numArray);
              foreach (int n in numArray) {
                Console.Write(n);
              } // 237
              Console.WriteLine("First element is: " + numArray[0]); // 2
            }

            NN@An array itself is always a
            reference type object, regardless
            of element type. N@For integer
            types the default is zero and for
            reference types the default is
            null.
            For Boolean the default is False.

            int[] a = null;
            // this is legal since arrays themselves are ref types

            N@Rectangular & Jagged Arrays

            With rectangular arrays we use one
            set of square brackets with the
            number of elements separated by a
            comma. Jagged arrays are arrays of
            arrays, and they can have irregular
            dimensions. We use 2 sets of square
            brackets for jagged arrays.

            TUT@static void Main(string[] args)
            {
              // a jagged array with 3 rows
              string[][] a = new string[3][];
              a[0] = new string[1]; a[0][0] = "00";
              a[1] = new string[3]; a[1][0] = "10"; a[1][1] = "11";
                                                    a[1][2] = "12";
              a[2] = new string[2]; a[2][0] = "20"; a[2][1] = "21";
              foreach (string[] b in a)
              {
                foreach (string c in b)
                {
                  Console.Write(c + " ");
                }
              }
              Console.WriteLine("initialize them");
              string[][] e = { new string[] { "00" },
                               new string[] { "10", "11", "12" },
                               new string[] { "20", "21" } };

              foreach (string[] f in e)
              {
                foreach (string g in f)
                {
                  Console.Write(g + " ");
                }
              }
            }

            DateTime

            T@N@DateTime is a struct and is
            therefore a value type.

            var dateTime = new DateTime(2000, 1, 1);
            var now = DateTime.Now; // gets the current date & time
            var today = DateTime.Today; // gets the current date (no time)
            var utcnow = DateTime.UtcNow;
            Console.WriteLine($"The current hour is: {now.Hour}");
            Console.WriteLine($"The current minute is: {now.Minute}");
            Console.WriteLine($"The current second is: {now.Second}");
            var tomorrow = now.AddDays(1);
            var yesterday = now.AddDays(-1);
            // AddDays, AddHours, AddMinutes, AddMonths, AddYears etc.
            Console.WriteLine($"Tomorrow (yyyy-mm-dd): {tomorrow}");
            Console.WriteLine(now.ToLongDateString());
            Console.WriteLine(now.ToShortDateString());
            Console.WriteLine(now.ToLongTimeString());
            Console.WriteLine(now.ToShortTimeString());
            Console.WriteLine(now.ToString()); // shows date and time
            Console.WriteLine(now.ToString("yyyy-MM-dd")); // format specifier
            Console.WriteLine(now.ToString("yyyy-MMMM-dd")); // format specifier
            Console.WriteLine(now.ToString("dddd yyyy-MMMM- dd"));
            Console.WriteLine(now.ToString("yyyy-MM-dd HH:mm:ss"));
            T@Console.WriteLine(String.Format("today: {0:D}", now));
            Console.WriteLine(String.Format("today: {0:F}", now));
            // D F d f g G M m Y y t T s u U

            TimeSpan

            // Creating TimeSpan object - there are 3 ways.
            var timeSpan = new TimeSpan(2, 1, 45); // hours minutes second
            // Creating TimeSpan object - there are 3 ways.
            var timeSpan = new TimeSpan(2, 1, 45); // hours minutes seconds
            var timeSpan1 = new TimeSpan(3, 0, 0); // 3 hours
            // second way:
            // easier to know it is one hour with FromHours()
            var timeSpan2 = TimeSpan.FromHours(1);
            // third way:
            var now = DateTime.Now;
            var end = DateTime.Now.AddMinutes(2);
            var duration = end - now;
            Console.WriteLine("Duration: " + duration);
            // above result is: Duration: 00:02:00.00199797
            var negativeduration = now - end;
            Console.WriteLine("\"Negative Duration\": " + duration); // positive number

            TimeSpan trueEnd = now.AddMinutes(2) - now; // subtract to get TimeSpan object
            Console.WriteLine("True Duration: " + trueEnd);
            // above output: True Duration: 00:02:00

            // Properties
            // timeSpan is two hours, one minutes and 45 seconds
            Console.WriteLine("Minutes: " + timeSpan.Minutes);
            Console.WriteLine("Total Minutes: " + timeSpan.TotalMinutes);
            Console.WriteLine("Total Days: " + timeSpan.TotalDays);

            // Add Method of TimeSpan
            // Add 3 min to our original TimeSpan 2 hours 1 minutes 45 seconds
            Console.WriteLine("Add 3 min: " + timeSpan.Add(TimeSpan.FromMinutes(3)
            ));
            Console.WriteLine("Add 4 min: " + timeSpan.Add(new TimeSpan(0,4,0)));
            // ToString method
            Console.WriteLine("ToString: " + timeSpan.ToString());
            // don't need ToString here:
            Console.WriteLine("ToString not needed: " + timeSpan);
            // Parse method
            Console.WriteLine("Parse: " + TimeSpan.Parse("01:02:03"));

            Formatting Numerics

            Numbers fall into two categories:
            integral and floating point.

            Format Specifier
              Pattern
              Value
              Description

            C or c
              {0:C2}, 2781.29
              $2781.29
              Currency
            D or d
              {0:D5}, 78
              00078
              Must be integer
            E or e
              {0:E2}, 2781.29
              2.78+E003
              Must be floating point
            F or f
              {0:F2}, 2781.29
              2781.29
              Fixed point
            G or g
              {0:G5}, 2781.29
              2781.2
              General
            N or n
              {0:N1}, 2781.29
              2,781.29
              Inserts commas
            P or p
              {0:P3}, 4516.9
              45.16%
              Converts to percent
            R or r
              {0:R}, 2.89351
              2.89315
              Retains all decimal places (round-trip)
            X or x
              {0,9:X4}, 17
              0011
              Converts to Hex

            Console.WriteLine("Value: {0:C}.", 447); // $447.00
            int myInt = 447;
            Console.WriteLine($"Value: {myInt:C}"); // $ is interpolation $447.00

            The optional alignment specifier
            represents the minimum width of the
            field in terms of characters. It is
            separated from the index with a
            comma. It consists of a positive or
            negative integer. T@T@The sign
            represents either right (positive)
            or left (negative) alignment.

            Console.WriteLine("Value: {0, 10:C}", myInt); // + right align
            Console.WriteLine("Value: {0, -10:C}", myInt); // - left align
            Value:    $447.00
            Value: $447.00

            Console.WriteLine($"Value: {myInt, 10:C}"); // interpolation
            Value:    $447.00

            Console.WriteLine("Percent: {0:P2}",0.126293); // 12.63 rounds
            Console.WriteLine("{0:E2}", 12.6375); //2 decimal places 1.26E+001

            Enumerated Type

            N@It can be defined using the enum
            keyword directly inside a
            namespace, class, or structure.

            T@T@public enum Score
            {
              Touchdown = 6, FieldGoal = 3, Conversion = 1, Safety = 2,
            }
            class Program
            {
              static void Main(string[] args)
              {
                Console.WriteLine(Score.Touchdown); // output: Touchdown
                T@int myInt = (int)Score.FieldGoal;
                Console.WriteLine(myInt); // output: 3
                TT@Score myScore = (Score)6;
                Console.WriteLine(myScore); // output: Touchdown
                string teamscore = "Conversion";
                T@Enum.TryParse(teamscore, out Score myVar);
                Console.WriteLine(myVar); // output: Conversion
                Console.WriteLine((int)myVar); // output: 1
              }
            }

            Enumerations could just be a list
            of words. For example you could
            have a list of the days of the
            week: Monday, Tuesday and so on,
            without any values. T@T@T@You can
            use IsDefined() and typeof().

            if(Enum.IsDefined(typeof(Score), "Safety") ...


            The Object Class

            In .NET, everything is an object
            and the base of everything is the
            Object class. T@T@N@The available
            methods of an object are: Equals,
            GetHashCode, GetType and ToString.

            T@T@N@Struct

            You can define a custom value type
            with the struct keyword. A struct
            is a value type. T@Fields cannot
            have an initializer and cannot
            inherit from a class or be
            inherited. The explicit constructor
            must have a parameter.

            struct Customer
            {
              public string firstName;
              public string lastName;
              public string middleName;
              public int birthYear;
              //public string Name() => firstName + " " + middleName + " " + lastName;
              public string Name() => firstName + " " +
                  (String.IsNullOrWhiteSpace(middleName) ? "" :
                     middleName + " ") + lastName;
              // Name() accesses firstName & lastName; uses lambda and ternary
              public string NameFunct()
              {
                string midN = String.IsNullOrWhiteSpace(middleName) ?
                        "" : middleName + " ";
                return firstName + " " + midN + lastName;
              }
            }
            class Program
            {
              static void Main(string[] args)
              {
                T@Customer myCustomer;
                myCustomer.firstName = "Sam";
                myCustomer.lastName = "Smith";
                myCustomer.middleName = "   "; // note the spaces
                myCustomer.birthYear = 1960;
                Console.WriteLine($"{myCustomer.Name()} was born in {myCustomer.birthYear}.");
              Console.WriteLine($"{myCustomer.NameFunct()} was born in {myCustomer.birthYear}.");
                // Output: Sam Smith was born in 1960.
                // Output: Sam Smith was born in 1960.
              }
            }

            Conversions

            C# can convert between instances of
            compatible types. N@A conversion
            always creates a new value from an
            existing one. Conversions can be
            either implicit or explicit:
            implicit conversions happen
            automatically, whereas explicit
            conversions require a cast.
            T@T@n@One useful use of a
            conversion is when you are getting
            input from the user in a Console
            program, using Convert().

            Console.WriteLine("Enter your number: ");
            double number = Convert.ToDouble(Console.ReadLine());

            Here are some examples below using
            implicit and explicit conversions.

            int x = 12345; // int is a 32-bit integer
            long y = x; // implicit conversion to 64-bit long
            short z = (short)x; // cast - explicit conversion to 16-bit int
            Console.WriteLine(z);
            byte b = (byte)x; // data loss !!
            Console.WriteLine(b); // 57
            // 12345 = 0011 0000 0011 1001
            // 57 =              0011 1001
            T@T@int myInt = 1_000_000; // C# 7 allows underscores
            T@T@Console.WriteLine(2.6.GetType()); // System.Double
            Console.WriteLine(3.GetType()); // System.Int32

            Conversions from integral types to
            real types are implicit, whereas
            the reverse must be explicit.
            Converting from a floating-point to
            an integral type truncates any
            fractional portion; T@T@to perform
            rounding conversions, use the
            static System.Convert class.

            float f = 128.67F;
            int d = Convert.ToInt32(f); // rounds
            // System.Int32 d is 129
            Console.WriteLine(d.GetType() + " d is " + d);

            The Regex Class

            The class is
            System.Text.RegularExpressions.Regex

            Pattern
              Description
              Example

            +
              Matches one or more
              ab+c matches abc, abbc
            *
              Matches zero or more
              ab*c matches ac, abbc
            ?
              Matches zero or one
              ab?c matches ac, abc
            \d
              Any digit from 0 to 9
              \d\d matches 14, 98, 03
            [0-9]
              Any digit from 0 to 9
              [0-9] matches 3, 8, 1, 0, 2
            \d{3}
              Any 3 digits from 0-9
              \d{3} matches 123, 420
            [0-9]{3}
              Any 3 digits from 0-9
              [0-9]{3} matches 123, 420

            Comparison Operators

            The comparison operators compare
            two values and return true or
            false. They specify conditions that
            evaluate to true or false (like a
            predicate):
            == != > < >= <=

            Conditional Statements

            Syntax
              Example

            if (condition) {
              // statements
            } else {
              // statements
            }

            if (product == "H1")
              price = 134.00M; // M decimal
            else if (product == "H2")
              price = 516.00M;
            else price = 100.00M;


            q ? a : b,
            if condition q is true, a is evaluated,
            else b is evaluated.

            price = (product == "A1") ? 34 : 42;
            // ternary operator  ? :


            switch (expression)
            { case expression:
              // statements
                break / goto / return() case ...
              default:
              // statements
                break / goto / return()
            }
            // expression may be integer,
            string, or enum

            switch (product)
            {
              case "P1": price = 15; break;
              case "P2": price = 16; break;
              default: price = 10M; break;
            }

            Loops

            Syntax
              Example

            while (condition)
            { body }

            var i = 1;
            var total = 0;
            while (i <= 4)
            {
              // 1 + 2 + 3 + 4 = 10
              total = total + i;
              i++;
            }


            do { body }
            while (condition);

            do
            {
              // 1 + 2 + 3 + 4 + 5 = 15
              total = total + i;
              i++;
            }
            while (i <= 4);


            for (initializer;
              termination condition;
              iteration;)
            { // statements }

            for (var i = 1; i < list.Count; i++)
            {
              if (list[i] < min)
                  min = list[i];
            }


            foreach (type identifier in collection)
            { // statements }

            int[] nums = new int[] { 2, 5, 4 };
            foreach (int num in nums)
            {
              Console.WriteLine(num);
            }

            Lists

            Lists are covered in more detail in
            the Lists of Objects section in the
            Advanced section, but are here now
            due to their importance.

            T@T@var numbers = new List<int>() {1,2,3,4};
            numbers.Add(1);
            numbers.AddRange(new int [3] {5,6,7});
            foreach (var num in numbers) Console.Write(num + " ");

            File IO

            using System;
            using System.IO; // add this
            namespace FileManipulation
            {
              class Program
              {// File (static) and FileInfo (instance)
                static void Main(string[] args)
                {
                  var filenamewithpath = @"D:\myfile.txt"; // verbatim @
                  using (File.Create(filenamewithpath))
                  // without using you get Unhandled Exception
                  // true will over-write existing file
                  File.Copy(filenamewithpath, @"D:\myfile_2.txt", true);
                  File.Copy(filenamewithpath, @"D:\myfile_3.txt", true);
                  File.Delete(@"D:\myfile_3.txt");
                  if(File.Exists(@"D:\myfile_2.txt"))
                  {
                    Console.WriteLine("File " + @"D:\myfile_2.txt" + " exists.");
                  }
                  string filecontent = File.ReadAllText(filenamewithpath);
                  var fileInfo = new FileInfo(filenamewithpath);
                  fileInfo.CopyTo(@"D:\myfile_4.txt", true);
                  var fileInfo4 = new FileInfo(@"D:\myfile_4.txt");
                  if (fileInfo4.Exists) // Exists is a property
                  {
                    fileInfo4.Delete(); // takes no paramters
                  }
                  else
                  {
                    Console.WriteLine("Cannot delete file "
                        + @"D:\myfile_4.txt" + " because it does not exist.");
                  }
                  // FileInfo does not have a ReadAllText method
                  // need to call openread which returns a file string but
                  // that is a little bit complex.
                  Console.WriteLine("Press any key to continue...");
                }
              }
            }

            T@T@N@Use File for occasional usage
            and FileInfo for many operations
            because each time you use File the
            OS does security checks and that
            can slow down your app; T@with
            FileInfo you need to create an
            instance of it. Both are easy to
            use. StreamReader and StreamWriter
            are available. You can encode in
            ASCII, Unicode, BigEndianUnicode,
            UTF-8, UTF-7, UTF-32 and Default.
            Different computers can use
            different encodings as the default,
            but UTF-8 is supported on all the
            operating systems (Windows, Linux,
            and Max OS X) on which .NET Core
            applications run..

            var filenamewithpath = @"D:\temp\A_ascii.txt";
            File.WriteAllText(filenamewithpath, "A", Encoding.ASCII);

            Directory IO

            using System;
            using System.IO; // add this
            namespace Directories
            {
              class Program
              {
                static void Main(string[] args)
                {
                  Directory.CreateDirectory(@"D:\temp\folder1");
                  File.Create(@"D:\temp\folder1\mytext.txt");
                  File.Create(@"D:\temp\folder1\mytext2.txt");

                  string[] files = Directory.GetFiles(@"D:\temp\folder1", "*.*",
                      SearchOption.AllDirectories); // or TopDirectoryOnly

                  foreach (var file in files) {Console.WriteLine(file);}
                  var directories = Directory.GetDirectories(@"D:\temp","*.*",
                      SearchOption.AllDirectories);
                  foreach (var dir in directories)
                  {
                    Console.WriteLine(dir);
                  }
                  var directoryInfo = new DirectoryInfo(@"D:\temp\folder1");
                  var ct = directoryInfo.CreationTime;
                  Console.WriteLine("Creation date and time: " + ct);
                }
              }
            }

            Debugging

            T@To debug your code you first decide
            where in your code you suspect a
            problem and create a breakpoint by
            putting the cursor on that line and
            pressing f9. Press f5 to run the
            program in debug mode. You can use
            multiple breakpoints if you want.
            We can either use f10 to step over
            or perhaps f11 to step into. Place
            your cursor over a variable and you
            should be able to see the data
            inside. If all looks good, go ahead
            and press f10 or perhaps f11. If
            you have another breakpoint, you
            can press f5 to run to the next
            breakpoint. Also, you can move the
            current position of execution
            backwards by dragging the yellow
            arrow at the left. When you are
            done you can press s-f11 to step
            out. You can end the debugging with
            s-f5. You can run it without the
            debugger with c-f5. You can manage
            all your breakpoints with the
            Breakpoints window. Debug
            > Windows > Breakpoints.

            T@T@N@It's a good idea to always
            check that the methods you write
            receive meaningful data. For
            example, if you expect a list of
            something, check that the list is
            not null. Users may not enter
            values you expect. It's important
            to think of these Edge Cases, which
            are uncommon scenarios, which is
            the opposite of the Happy Path.

            NuGet Package Manager

            NuGet is the package manager for
            .NET. The NuGet client tools
            provide the ability to produce and
            consume packages. The NuGet Gallery
            is the central package repository
            used by all package authors and
            consumers.. Packages are installed
            into a Visual Studio project using
            the Package Manager UI or the
            Package Manager Console. N@One
            interesting package is the
            HtmlAgilityPack that allows you to
            parse HTML, but there are lots of
            them.

            Your Own Library (Assembly)

            T@To create a class library using
            Visual Studio 2017 Community, in
            the menu select File > New >
            Project > Installed > Visual C# >
            .NET Standard > Class Library(.NET
            Standard) and give it a name and
            location and press OK. Write your
            library code. Switch to Release
            from Build. Press cs-b to build the
            DLL. T@Note the location of the DLL
            (bin\Release\netstandard2.0).
            T@Within the project that uses the
            library, you need to give the
            compiler a reference to your
            assembly by giving its name and
            location. Select Solution Explorer
            > Right-click the References folder
            > Add Reference. Select the Browse
            tab, browse to the DLL file
            mentioned above. Click the OK
            button. N@T@For convenience you can
            now add a using statement at the
            top of your program. You should now
            have access to your library code.
            Nice!

            Object-Oriented Programming (OOP)

            Object-oriented programming (OOP)
            is a programming paradigm that
            employs objects to encapsulate
            code. Objects consist of types and
            are called classes. A class is just
            a template for an object which is
            an instance of the class, which
            occupies memory. N@When we say that a
            class is instantiated, we mean that
            an object in memory has been
            created. Classes contain data and
            executable code. Everything in C#
            and .NET is an object. T@In the menu
            View > Object Browser.

            Programming Principles

            DRY is an acronym for Don't Repeat
            Yourself. In OOP, encapsulation is
            used to refer to one of two related
            but distinct notions, and sometimes
            to the combination thereof: (1) A
            language mechanism for restricting
            direct access to some of the
            object's components. (2) A language
            construct that facilitates the
            bundling of data with the methods
            (or other functions) operating on
            that data. NN@In OOP, the open/closed
            principle states that software
            entities (classes, modules,
            functions, etc.) should be open for
            extension, but closed for
            modification.

            Simple Class Declaration

            The simplest class declaration is:
            class Foo { }

            [ public | protected | internal | private ]
            [ abstract | sealed | static ]
            class class_name [:class/interfaces inherited from ]

            T@T@A class is a data structure
            that can store data and execute
            code. N@It contains data members and
            function members. The members can
            be any combination of nine possible
            member types. A local variable is a
            variable declared inside a function
            member. On the Internet are the
            StyleCop Rules documenting the
            ordering of members in classes.
            N@Note: Whenever you have a class,
            such as our Customer, and inside
            that class you have a List of
            objects of any type, you should
            always initialize that list to an
            empty list.

            Static

            Static classes are meant to be
            consumed without instantiating
            them. TT@Static classes can be used to
            group members that are to be
            available throughout the program.
            TN@A static class must have all
            members marked as static as well as
            the class itself. T@The class can
            have a static constructor, but it
            cannot have an instance
            constructor. Static classes are
            implicitly sealed, meaning you
            cannot inherit from a static class.
            TT@A non-static instantiable class can
            have static members which exist and
            are accessible even if there are no
            instances of the class. TN@A static
            field is shared by all the
            instances of the class, and all the
            instances access the same memory
            location when they access the
            static field. T@Static methods exist.
            Static function members cannot
            access instance members, but can
            access other static members. T@Static
            members, like instance members, can
            also be accessed from outside the
            class using dot-syntax notation.
            tT@Another option to access the
            member doesn't use any prefix at
            all, if you have included a using
            static declaration for the specific
            class to which that member belongs:

            Using static System.Console;


            Abstract Classes

            A class declared as abstract can
            never be instantiated. T@Instead,
            only its concrete subclasses can be
            instantiated. Abstract classes can
            define abstract members which are
            like N@virtual members, except they
            don't provide a default
            implementation. TT@That implementation
            must be provided by the subclass,
            unless that subclass is also
            declared abstract.

            Sealed Classes

            T@A sealed class cannot be used as
            the base class for any other class.
            You use the sealed keyword to
            protect your class from the prying
            methods of a subclass. N@Static
            classes are implicitly sealed.

            Instance Constructors

            N@For classes, the C# compiler
            automatically generates a
            parameterless public constructor if
            and only if you do not define any
            constructors. However, as soon as
            you define at least one
            constructor, the parameterless
            constructor is no longer
            automatically generated, so you may
            need to write it yourself.

            Instance constructors execute when
            the object is first instantiated.
            When an object is destroyed the
            destructor is called. Memory is
            freed up at this time.
            T@T@Constructors are called with
            the new keyword.

            T@Constructors can be static. A
            static constructor executes once
            per type, rather than once per
            instance. A type can define only
            one static constructor, NN@and it
            must be parameterless and have the
            same name as the type.

            public class Customer
            {
              public string Name; // in real world these are private
              public int Id;  // in real world these are private
              public Customer() { } // constructor (same name as class)
              public Customer(int id) // constructor
              {
                this.Id = id; // set Id property
              }
              public Customer(int id, string name) // constructor
              {
                this.Id = id; // 'this' references current object Customer
                this.Name = name; // here we set Name property
              }
            }
            class Program
            {
              static void Main(string[] args)
              {
                // ERROR: not contain constructor that takes zero arguments
                // unless we create OUR OWN parameterless constructor (we did)
                var customer = new Customer();
                customer.Id = 7;
                customer.Name = "John";
                Console.WriteLine(customer.Id);
                Console.WriteLine(customer.Name);
              }
            }

            Fields

            N@A field is a variable that belongs
            to a class. It can be of any type,
            either predefined or user-defined.
            A field initializer is part of the
            field declaration and consists of
            an equal sign followed by an
            expression that evaluates to a
            value. The initialization value
            must be determinable at compile
            time. If no initializer is used,
            the compiler sets the value of a
            field to a default value,
            determined by the type of the
            field. The default value for each
            type is 0 and is false for bool.
            n@The default for reference types is
            null.

            class Order
            {
              public int Id;
            }
            class Customer
            {
              public int Id;
              public string Name;
              public readonly List<Order> Orders = new List<Order>();
              // Note: no parameterless constructor for Customer
              public Customer(int id)
              {
                // a constructor
                this.Id = id; // the keyword this is redundant
              }
              public Customer(int id, string name) : this(id)
              {
                // a constructor
                this.Name = name; // the keyword this is redundant
              }
              public void DoSomething() { } // just an example method
            }
            class Program
            {
              static void Main(string[] args)
              {
                var customer = new Customer(3, "Bob");
                customer.Orders.Add(new Order());
                customer.Orders.Add(new Order() { Id = 7 });
                Console.WriteLine("Customer Id: " + customer.Id + " Name: "
                    + customer.Name);
                Console.WriteLine("Num orders: " + customer.Orders.Count);
                foreach (var ord in customer.Orders) { Console.WriteLine("Order Id: " + ord.Id); }
              }
            }

            Here is the Console output of he
            above program. Notice that the
            first order Id below is zero
            because zero is the default.

            Customer Id: 3 Name: Bob
            Number of orders: 2
            Order Id: 0
            Order Id: 7

            T@T@HM@Generally, you would use
            private fields with public
            properties to provide
            encapsulation.

            Methods

            TT@A method is a named block of code
            that is a function member of a
            class. You can execute the code
            from somewhere else in the program
            by using the method's name,
            N@provided you have access to it.
            Below is the simplest way to write
            a method inside a class.

            class NotAnything { void DoNothingMethod() { } }

            You can also pass data into a
            method and receive data back as
            output. A block is a sequence of
            statements between curly braces.
            n@It may contain local variables
            (usually for local computations),
            flow-of-control statements, method
            invocations, nested blocks or other
            methods known as local functions.

            [access modifier]
            [static|virtual|override|new|sealed|abstract]
            method name (parameter list) { body }

            TT@C# allows for optional parameters
            which you can either include or
            omit when invoking the method. To
            specify that, you must include a
            default value for that parameter in
            the method declaration. T@Value types
            require the default value to be
            determinable at compile time, and
            reference types only if the default
            value is null. TT@The declaration
            order must be all required (if any)
            - all optional (if any) - all
            params (if any).

            Access Modifier
              Description

            public
              Fully accessible. n@This is the
              implicit accessibility for
              members of an enum or interface.
            private
              Accessible only within the
              containing type. T@This is the
              default accessibility for members
              of a class or struct. Perhaps you
              have a method that is
              implementation detail that
              calculates something.
            protected
              Accessible only within the
              containing type or subclasses
              (derived classes).
              TT@May be a sign of bad design.
            internal
              N@Accessible only from the same
              assembly. We create a separate
              class library and use internal.
              How? Rightclick Solution > Add >
              New Project > Class Library
              (DLL). We'll need to add a
              Reference (Project, Add
              Reference) and add using
              statement.
            protected internal
              Not used normally! Accessible
              only from the same assembly or
              any derived classes. The union of
              protected and internal.

            T@T@virtual
              method can be overridden in
              subclass.
            override
              overrides virtual method in base
              class.
            new
              hides non-virtual method in base
              class.
            sealed
              prevents derived class from
              inheriting.
            T@abstract
              must be implemented by subclass.

            Below is an example of a method
            called MyMethod (()

            public class MyClass
            {
              public int MyMethod (int integer, string text)
              {
                return 0;
              }
            }

            T@T@Properties

            TT@T@A property is declared like a
            field, but with a get/set block
            added.
            T@Properties look like fields from
            the outside, but internally they
            contain logic, like methods do.
            n@You can set the values of a
            public field and a public property,
            no problem. Note that -= means
            subtract from self.

            class Program
            {
              static void Main(string[] args)
              {
                Item it = new Item();
                it.FieldPrice = 24.67M;
                it.PropertyPrice = 45.21M;
                Console.WriteLine(it.FieldPrice + " " + it.PropertyPrice);
                it.FieldPrice -= 1.00M;
                it.PropertyPrice -= 1.00M;
                Console.WriteLine(it.FieldPrice + " " + it.PropertyPrice);
              }
            }
            public class Item
            {
              public decimal FieldPrice;
              T@T@T@public decimal PropertyPrice { get; set; }
            }

            Here is a public property Amount
            with its backing field, that can be
            simplified with auto implemented
            property with { get; set; }.

            TT@private decimal _amount; // backing field
            public decimal Amount // public property
            {
              get { return _amount; }
              set { _amount = value; } // notice the keyword value
            }

            The get and set denote property
            accessors. The set method could
            throw an exception if value was
            outside a valid range of values.


            Object Initialization Syntax

            C# 3.0 (.NET 3.5) introduced Object
            Initializer Syntax, a new way to
            initialize an object of a class or
            collection. T@Object initializers
            allow you to assign values to the
            fields or properties at the time of
            creating an object without invoking
            a constructor.

            class Program
            {
              public class Person
              {
                public int id { get; set; }
                public string FirstName { get; set; }
                public string LastName { get; set; }
                public DateTime BirthDate { get; set; }
              }
              static void Main(string[] args)
              { // don't need to initialize all fields
                var p = new Person {FirstName = "J", LastName = "Smith"};
                Console.WriteLine("Last name is {0}", p.LastName);
                // OUTPUT: Last name is Smith
              }
            }

            If the class has a constructor that
            initializes a field, the field in
            the object initializer syntax wins.
            Below, the last name is Smith.

            public class Person
            {
              public int id { get; set; }
              public string FirstName { get; set; }
              public string LastName { get; set; }
              public DateTime BirthDate { get; set; }
              public Person() // constructor
                  { LastName = "Johnson"; }
            }
            static void Main(string[] args)
            { // don't need to initialize all fields
              var p = new Person {FirstName = "J", LastName = "Smith"};
              Console.WriteLine("Last name is {0}", p.LastName);
              // OUTPUT: Last name is Smith
            }


            Indexers

            Indexers provide a natural syntax
            for accessing elements in a class
            or struct that encapsulate a list
            or dictionary of values.
            Indexers are like properties but
            are accessed via an index argument
            rather than a property name. The
            string class has an indexer that
            lets you access each of its char
            values via an int Index.

            string s = "hello";
            Console.WriteLine(s[0]);  // 'h' zero-based
            Console.WriteLine(s[1]);  // 'e'
            Console.WriteLine(s[99]); // IndexOutOfRangeException
            Console.WriteLine(s[-1]); // IndexOutOfRangeException

            The index argument(s) can be of any
            type(s), unlike arrays. T@T@You can
            call indexers null-conditionally by
            inserting a question mark before
            the square bracket as shown below.

            string str = null;
            Console.WriteLine(str?[0]); // Writes nothing; no error.
            Console.WriteLine(str[0]);  // NullReferenceException

            To write an indexer, define a
            property called this, specifying
            the arguments in square brackets.

            class Sentence
            {
              string[] words = "The quick brown fox".Split(); //field
              public Sentence() { } // default constructor
              public Sentence(string str) // constructor
                  { words = str.Split(); }
              public int Length // property
                  { get { return words.Length; } }
              public string this[int wordNum] // indexer
              {
                get { return words[wordNum]; }
                set { words[wordNum] = value; }
              }
            }
            static void Main(string[] args)
            {
              string s = "hello world";
              Console.WriteLine(s[0]); // 'h' zero-based
              Console.WriteLine(s[5]); // ' '
              string str = null;
              Console.WriteLine(str?[0]); // Writes nothing; no error.
              // Console.WriteLine(str[0]); // NullReferenceException
              Sentence sen = new Sentence();
              Console.WriteLine(sen[1]); // quick
              sen[3] = "wildebeest"; // replace the 4th word
              Console.WriteLine(sen[3]); // wildebeest
              for (int i=0;i<sen.Length;i++) { Console.Write(sen[i] + "|"); }
              // now use our constructor to use our sentence
              Sentence sent = new Sentence("The sleeping black cat");
              Console.WriteLine(sent[1]); // sleeping
            }

            You have your own class Customer
            with fields FirstName and LastName.
            Instantiate it as Cust1. Get the
            first name and last name with
            Cust1.FirstName and Cust1.LastName.
            Indexers allow you to do the same
            with Cust1[0] and Cust1[1]
            respectively. An indexer is a pair
            of get and set accessors inside the
            code block of ReturnType this [
            Type param1, ... ]. The set and get
            blocks use switch.

            Inheritance

            Inheritance is a type of
            relationship ("Is-A") between
            classes that allows one class to
            inherit members from the other
            (code reuse). A horse "is an"
            animal. Inheritance allows for
            polymorphic behaviour. In UML, the
            Animal is at the top with the Horse
            under it with an arrow pointing up
            to Animal. Another example of
            inheritance is where a Saving Bank
            Account and Chequing Bank Account
            inherit from a Bank Account.

            public class BaseClass
            {
              public int Amount { get; set; }
              public BaseClass() { Console.WriteLine("Base constr"); }
              public void BaseDo() { Console.WriteLine("Base's BaseDo."); }
              public virtual void Do() { Console.WriteLine("Base's Do"); }
            }
            public class SubClass : BaseClass
            {
              public SubClass() { Console.WriteLine("Sub constr"); }
              public override void Do() { Console.WriteLine("Sub's Do");}
            }
            class Program
            {
              static void Main(string[] args)
              {
                var bas = new BaseClass();
                var sub = new SubClass();
                sub.Amount = 1; // Amount inherited from Base
                sub.Do(); // Sub's Do
              }
            }
            ----
            Output:
            Base constr
            Base constr
            Sub constr
            Sub's Do

            Constructor Inheritance

            When you instantiate a sub class,
            base class constructors are always
            executed first, then sub class
            constructors, as you can see in
            lines 2 and 3 from the output. Base
            class constructors are not
            inherited.

            Composition (aka Containment)

            Composition is a type of
            relationship ("has-a") between two
            classes that allows one class to
            contain another. Inheritance is
            another type of relationship. Both
            methods give us code re-use. In our
            example, both the car and truck
            have an engine and the engine needs
            to send a message to the console.
            t@We use a private field in the
            composite class (car and truck) to
            achieve this. T@You use a member
            field to hold an object instance.
            Generally, inheritance results in a
            more tightly-coupled relationship
            than composition and many
            developers prefer composition, but
            it depends on your project. Two
            things to remember:
            private field and constructor.

            using System;
            namespace CompositionGeneral
            {
              class Car
              {
                private readonly Engine _engine;
                public Car(Engine engine) // constructor
                {
                  _engine = engine;
                }
                public void DriveCar()
                {
                  float speed = 0.0F;
                  _engine.EngineStatus("car starting engine");
                  speed = 50.0F;

                  _engine.EngineStatus($"speed of {speed} Km/hr");
                  _engine.EngineStatus("car engine off");
                }
              }
              class Truck
              {
                private readonly Engine _engine;
                public Truck(Engine engine) // constructor
                {
                  _engine = engine;
                }
                public void DriveTruck() { //...
                }
              }
              class Engine // the car and truck "Have An" engine
              {
                public void EngineStatus(string message)
                {
                  Console.WriteLine("Engine status: " + message);
                }
              }
              class Program
              {
                static void Main(string[] args)
                {
                  var e = new Engine();
                  var sedan = new Car(e);
                  sedan.DriveCar();
                  var pickup = new Truck(new Engine());
                  pickup.DriveTruck();
                }
              }
            }

            Instead of having the car and truck
            contain a concrete class, like
            Engine, what if we used an
            interface, like IEngine instead?
            Please see the section on
            Interfaces & Extensibility for an
            example of this.

            Composition vs Inheritance

            Designing classes needs to be done
            carefully. N@Be careful with
            designing your inheritance because
            it can result in large hierarchies
            that become fragile (difficult to
            modify due to tight coupling).

            T@T@You can always refactor
            inheritance into composition. A
            horse and a fish are both animals,
            but they are quite different. Both
            eat and sleep (Animal class) but
            horses walk and fish swim. You
            could use composition and create a
            CanWalk and CanSwim class. The
            horse "has-a" CanWalk class. This
            is fine even though "has-a" may not
            make sense or sound correct in the
            real world. You don't want to put a
            Walk() method in your Animal class
            unless you are certain all of your
            animals now and in the future can
            walk. If you have that, using
            inheritance, you may need a
            sub-class of Animal called mammal,
            and re-compile and re-deploy your
            code. T@Also, with composition we
            get an extra benefit that's not
            possible with inheritance:
            Interfaces.
            N@N@We can replace our Animal class
            with an interface IAnimal. This is
            dependency injection and is covered
            later in the topic called
            Interfaces & Extensibility.

            Method Overriding & Polymorphism

            Method overriding is changing the
            implementation of an inherited
            method that came from the base
            class.
            T@T@Use the virtual keyword in the
            method of the base class and
            override in the derived class.

            Virtual is just the opportunity to
            override. You don't have to
            override it.
            What is polymorphism? Poly means
            many and morph means form. Let's
            use an example with classes called
            BaseClass, ChildRed and ChildBlue.

            class MyBaseClass
            {
              public int CommonProperty { get; set; }
              public virtual void WriteMessage() { }
            }
            T@T@class ChildRed : MyBaseClass
            {
              public new int CommonProperty { get; set; }
              public override void WriteMessage()
              {
                CommonProperty = 46;
                Console.WriteLine("Red " + CommonProperty);
              }
            }
            class ChildGreen : MyBaseClass
            {
              public override void WriteMessage()
              {
                Console.WriteLine("Green " + CommonProperty);
              }
            }
            class Display
            {
              public void WriteMyMessages(List<MyBaseClass> baseclasses)
              {
                foreach (var bc in baseclasses)
                {
                  bc.WriteMessage();
                }
              }
            }

            When we call WriteMessage() above
            we have polymorphic behavior. We
            have a list of different colors,
            but the implementation is different
            for each colour. Red and Green
            overrode the base class's method.
            Notice that the list is a list of
            the base class MyBaseClass.

            class Program
            {
              static void Main(string[] args)
              {
                var baseclasses = new List<MyBaseClass>();
                baseclasses.Add(new ChildRed() { CommonProperty = 1 });
                baseclasses.Add(new ChildGreen() { CommonProperty = 3 });
                var display = new Display();
                display.WriteMyMessages(baseclasses);
              }
            }

            HM@You can assign a variable that
            is of a derived type to a variable
            of one of the base types. No
            casting is required for this. T@You
            can then call methods of the base
            class through this variable. This
            results in the implementation of
            the method in the derived class
            being called. N@You can cast a base
            type variable into a derived class
            variable and call the method of the
            derived class.

            Interfaces

            An interface is like a class, but
            it provides a specification rather
            than an implementation for its
            members. It's a "contract".
            Interface members are all
            implicitly abstract. T@N@A class
            (or struct) can implement multiple
            interfaces. In contrast, a class
            can inherit from only a single
            class, and a struct cannot inherit
            at all (N@aside from deriving from
            System.ValueType). The interface's
            members will be implemented by the
            classes and structs that implement
            the interface.
            T@T@N@By convention,
            interface names start with the
            capital letter "I".

            interface IInfo
            {
              string GetName();
              string GetAge();
            }
            class CA : IInfo
            {
              // declare that CA implements the interface IInfo
              public string Name;
              public int Age;
              // implement two interface methods of IInfo:
              public string GetName() { return Name; }
              public string GetAge() { return Age.ToString(); }
            }
            class CB : IInfo
            {
              // declare that CB implements the interface
              public string First;
              public string Last;
              public double PersonsAge;
              public string GetName() { return First + " " + Last; }
              public string GetAge() { return PersonsAge.ToString(); }
            }
            class Program
            {
              // pass objects as references to the interface
              static void PrintInfo(IInfo item)
              {
                Console.WriteLine("Name: {0} Age: {1}", item.GetName() ,
                    item.GetAge() );
              }
              static void Main()
              {
                // instantiate using object initialization syntax
                CA a = new CA() { Name = "John Doe", Age = 35 };
                CB b = new CB() { First = "Jane", Last = "Smith",
                                           PersonsAge = 44.0 };
                // references to the objects are automatically
                // converted to references
                // to the interfaces they implement (in the code below)
                PrintInfo(a);
                PrintInfo(b);

                Type myType = typeof(Program);
                Console.Title = myType.Namespace;
              }
            }
            ----
            Output:
            Name: John Doe Age: 35
            Name: Jane Smith Age: 44

            Interfaces & Extensibility

            We create a constructor and inject
            a dependency. This is called
            dependency injection, T@T@N@which
            means that in the constructor we
            are specifying the dependencies of
            our class. The FileProcessor is not
            directly dependent on the
            ConsoleLogger. It doesn't care who
            implements ILogger. T@T@It could be
            a DatabaseLogger that does it.

            // FilesProcessor is dependent on an interface.
            public interface ILogger
            {
              void LogError(string message); // method
              void LogInfo(string message); // method
            }
            public class ConsoleLogger : ILogger
            { // ConsoleLogger implements ILogger
              public void LogError(string message)
              {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine(message);
                Console.ForegroundColor = ConsoleColor.White;
              }
              public void LogInfo(string message)
              {
                Console.ForegroundColor = ConsoleColor.Green;
                Console.WriteLine(message);
                Console.ForegroundColor = ConsoleColor.White;
              }
            }
            public class FilesProcessor
            {
              private readonly ILogger _logger;
              public FilesProcessor(ILogger logger) // constructor
              {
                _logger = logger;
              }
              public void Process()
              {
                try
                { // we might employ the using keyword in the real world
                  _logger.LogInfo($"Migrating started at {DateTime.Now}");
                  _logger.LogInfo($"In middle of doing stuff...");
                  int zero = 0;
                  int myError = 1 / zero;
                  _logger.LogInfo($"Migrating ended at {DateTime.Now}");
                }
                catch
                {
                  _logger.LogError($"Opps! Error");
                }
              }
            }
            class Program
            {
              static void Main(string[] args)
              {
                // Our logger to sends to console
                var filesProcessor = new FilesProcessor(new ConsoleLogger());
                filesProcessor.Process();
                Console.WriteLine("done program.");
              }
            }
            ----
            Output:
            Migrating started at 2019-02-07 10:05:43 AM
            In middle of doing stuff...
            Opps! Error
            done program.

            T@T@T@N@We can extend it. We can
            create more loggers other than
            ConsoleLogger, such as
            DatabaseLogger, FileLogger,
            EmailLogger SMSLogger and so on,
            and all we need to do is change the
            Main().

            Interfaces & Testability

            T@I@Using interfaces help with unit
            testing. This example builds on
            many topics in this cheat sheet.
            We'll use the N@Microsoft Test
            Runner. You get a new journal entry
            and then post it passing the entry
            to the Post() method of the
            JournalPoster class. Posting the
            entry requires the services of the
            checker. I@In order to make testing
            work, we need to use an interface
            for the checker.

            class Program
            {
              static void Main(string[] args)
              {
                var jp = new JournalPoster(new DrEqualsCrChecker());
                var je = new JournalEntry { DebitAmount = 120.50f,
                                            CreditAmount = -120.50f };
                jp.Post(je);
                Console.WriteLine("Posted? " + je.IsPosted);
                Console.WriteLine("Date posted: " +
                    je.Posting.PostingDate.ToString("yyyy-MM-dd"));
                Console.WriteLine("Debit amount: {0:C}", je.DebitAmount);
                Console.WriteLine("Credit amount: {0:C}", je.CreditAmount);
                Console.WriteLine("JE Balance: {0:C}", je.Posting.Balance);
              }
            }
            ----
            Output:
            Posted? True
            Date posted: 2019-02-07
            Debit amount: $120.50
            Credit amount: -$120.50
            JE Balance: $0.00

            public class JournalEntry
            {
              // in the reaal world there is more than this
              public Posting Posting { get; set; }
              public float DebitAmount = 0f;
              public float CreditAmount = 0f;
              public DateTime DatePosted { get; set; }
              public bool IsPosted
              {
                get { return Posting != null; }
              }
            }
            public class Posting
            {
              public float Balance { get; set; } // zero if Dr = Cr
              public DateTime PostingDate { get; set; }
            }
            public class JournalPoster
            { // this class does not even know about DrEqualsCrChecker
              private readonly IDrEqualsCrChecker _checker;
              public JournalPoster(IDrEqualsCrChecker checker)
                  { _checker = checker; }
              public void Post(JournalEntry je)
              {
                if (je.IsPosted)
                  throw new InvalidOperationException("Opps. Already posted!");
                je.Posting = new Posting
                {
                  Balance = _checker.CalcBalance(je),
                  PostingDate = DateTime.Today.AddDays(1)
                };
              }
            }
            public interface IDrEqualsCrChecker
                { float CalcBalance(JournalEntry je); }
            public class DrEqualsCrChecker : IDrEqualsCrChecker
            {
              public float CalcBalance(JournalEntry je)
              {
                var balance = je.DebitAmount + je.CreditAmount;
                return balance;
              }
            }

            Here is our test. T@T@n@We need to
            test the JournalPoster's Post
            method. We need to isolate it so we
            can write code to test our code. Go
            to the Solution Explorer >
            Right-Click Solution > Add >
            Project > Visual C# > Test > Unit
            Test Project > T@T@Name it after
            the Project and append .UnitTests
            to the name > OK. You get the
            following by default. We'll change
            that.

            [TestClass]
            public class UnitTest1
            {
              [TestMethod]
              public void TestMethod1()
              {
              }
            }

            Since we want to test the
            JournalPoster(), rename UnitTest1
            to JournalPosterTests. Rename
            TestMethod1 following the naming
            convention of
            methodname_condition_expectation.
            We need to add a Reference to our
            Project in our UnitTest project. In
            the unit test project, Right-Click
            References > Add Reference >
            Projects > click the check box of
            the project. We need to create a
            Fake debit equals credit checker.
            Why? We don't want to pass the
            original one to the JournalPoster.
            We need to pass a fake one that
            must always be working because our
            testing is focussing on the
            JournalPoster, not the checker.

            [TestClass]
            public class JournalPosterTests
            {
              // need to add a Reference to our project
              [TestMethod]
              [ExpectedException(typeof(InvalidOperationException))]
              public void JournalPoster_JEIsAlreadyPosted_ThrowsAnException()
              { // naming convention: methodname_condition_expection
                var JournalPoster = new JournalPoster(new FakeDrEqualsCrChecker());
                var je = new JournalEntry { Posting = new Posting() };
                JournalPoster.Post(je);
              }
              [TestMethod]
              public void JournalPoster_JEIsNotPosted_ShouldSetPostedPropertyOfJournalEntry()
              {
                var JournalPoster = new JournalPoster(new FakeDrEqualsCrChecker());
                var je = new JournalEntry();
                JournalPoster.Post(je);
                Assert.IsTrue(je.IsPosted);
                Assert.AreEqual(1, je.Posting.Balance);
                Assert.AreEqual(DateTime.Today.AddDays(1), je.Posting.PostingDate);
              }
            }
            public class FakeDrEqualsCrChecker : IDrEqualsCrChecker
            { // methods defined in an interface must be public
              public float CalcBalance(JournalEntry je)
                  { return 1; } // simple and it will works
            }

            Generics

            C# has two separate mechanisms for
            writing code that is reusable
            across different types: inheritance
            and generics. T@T@n@Whereas
            inheritance expresses re-usability
            with a base type, generics express
            reusability with a "template" that
            contains "placeholder" types.

            using System;
            using System.Collections.Generic;
            namespace Generics
            {
              public class Customer
              {
                public int Id { get; set; }
                public string Name { get; set; }
              }
              class Program
              {
                static void Main(string[] args)
                {
                  List<Customer> myCustomers = new List<Customer>(); //empty
                  myCustomers.Add(new Customer() { Id = 1, Name = "Jack" });
                  myCustomers.Add(new Customer() { Id = 2, Name = "Jill" });
                  foreach (Customer cust in myCustomers) {
                            Console.WriteLine(cust.Name); }
                }
              }
            }

            Lists of Objects

            Lists were covered briefly in the
            Basics section of this cheat sheet
            series, but the example was only a
            list of integers. Here was have a
            list of our own objects based on
            our own class: Customer.

            class Customer
            {
              public int Id = 0;
              public string Name = "";
              public string Status { get; set; }
            }
            class Repository
            {
              private static List<Customer> privatecust = new List<Customer>();
              public static IEnumerable<Customer> Customers {
                get { return privatecust; }
              }
              public static void AddCustomers(Customer customer) {
                privatecust.Add(customer);
              }
              public static int NumberOfCustomers {
                get { return privatecust.Count; }
              }
            }
            class Program
            {
              static void Main(string[] args)
              {
                var cust1 = new Customer { Id = 1, Name = "Joe",
                  Status = "Active" };
                var cust2 = new Customer { Id = 1, Name = "Sally",
                  Status = "Active" };
                Repository.AddCustomers(cust1);
                Repository.AddCustomers(cust2);
                foreach (Customer cust in Repository.Customers)
                { Console.WriteLine($"Name: {cust.Name} Id: {cust.Id} " +
                    $"Status: {cust.Status}"); }
                Console.WriteLine($"Number of customers: " +
                    $"{Repository.NumberOfCustomers}");
              }
            }

            Here is another example of a list
            of objects, without the Repository.

            class Program
            {
              public class Customer
              { // mix fields with a property just for demonstration
                public int Id = 0;
                public string Name = "";
                public string Status { get; set; }

              }
              static void Main(string[] args)
              {
                var customers = new List<Customer>
                { // using object initialization syntax here
                  new Customer { Id = 4, Name = "Jack", Status = "Active"},
                  new Customer { Name = "Sally", Status = "Active"}
                };
                customers.Add(new Customer { Name = "Sam" });
                foreach (Customer cust in customers)
                        { Console.WriteLine(cust.Id + " " + cust.Name +
                                                      " " + cust.Status); }
              }
            }

            Delegates

            T@T@A delegate is an object that
            "holds" one or more methods. T@T@A
            delegate is a reference to a
            function or ordered list of
            functions with a specific
            signature. You can "execute" a
            delegate and it will execute the
            method or methods that it
            "contains" (points to). A delegate
            is a user-defined reference type,
            like a class. T@You can create your
            own delegate or use the generic
            ones: Func<> and Action<>. First,
            we'll create our own.

            class Program
            {
              delegate int Multiplier(int x); // type declaration
              static void Main()
              {
                Multiplier t = Cube; // Create delegate instance
                // by assigning a method to a delegate variable.
                int result = t(2); // Invoke delegate: t(3)
                Console.WriteLine(result); // 8
              }
              static int Cube(int x) => x * x * x;
            }

            Here is second example.

            using System;
            namespace ReturnValues
            {
              // Illustrated C# 7 Fifth Edition page 361
              delegate int MyDel(); // Declare delegate with return value.
              class MyClass
              {
                private int IntValue = 5;
                public int Add2() { IntValue += 2; return IntValue; }
                public int Add3() { IntValue += 3; return IntValue; }
              }
              class Program
              {
                static void Main()
                {
                  MyClass mc = new MyClass();
                  MyDel mDel = mc.Add2; // Create initialize delegate.
                  mDel += mc.Add3; // Add a method.
                  mDel += mc.Add2; // Add a method.
                  Console.WriteLine($"Value: { mDel() }"); // output 12
                }
              }
            }

            TUT@Here is a more realistic
            example of delegates. Here we
            create a multicast delegate. The
            consumer of our code is the method
            Main(). We have an object that we
            need to "process" with several
            methods in order, and we also want
            the code to be extensible so the
            consumer can add their own methods
            in Main() to the list of our
            methods.

            class MyClass
            {
              public string MyString { get; set; }
              public int MyInt { get; set; }

              public static MyClass MyClassDoMethod()
              {
                return new MyClass(); // we don't use these
              }
            }

            Our code has 3 methods that act
            upon the above class. They are:
            AddOne(), DoubleIt() and
            AppendString().

            class MyClassMethods
            {
              public void AddOne(MyClass mc)
              { // here we do something with the object mc
                mc.MyInt = mc.MyInt + 1;
                Console.WriteLine("AddOne: " + mc.MyString + " " + mc.MyInt);
              }
              public void DoubleIt(MyClass mc)
              {
                mc.MyInt = mc.MyInt * 2;
                Console.WriteLine("DoubleIt:" + mc.MyString + " " + mc.MyInt);
              }
              public void AppendString(MyClass mc)
              {
                mc.MyString = mc.MyString + " appending string now ";
                Console.WriteLine("AppendString: " + mc.MyString + " "
                    + mc.MyInt);
              }
            }
            class MyClassProcessor
            {
              public int MyAmount { get; set; }
              public delegate void MyClassMethodHandler(MyClass myclass);
              public void Process(MyClassMethodHandler methodHandler)
              { // methodHandler is a delegate
                // instantiate with object initialization syntax
                var myclass = new MyClass { MyString = "In Process method ",
                      MyInt = 1 };
                methodHandler(myclass);
                // we do not define the methods we want to run here because
                // we are going to let the consumer define that.
              }
            }
            class Program
            {
              static void Main(string[] args)
              {
                var myclassprocessor = new MyClassProcessor();
                var myclassmethods = new MyClassMethods();
                MyClassProcessor.MyClassMethodHandler
                    methodHandler = myclassmethods.AddOne;
                // MyClassMethodHandler is a delegate (multicast)
                // methodHandler is pointer to a group of functions (delegate)
                methodHandler += myclassmethods.DoubleIt;
                methodHandler += FromConsumerMinusThree;
                methodHandler += myclassmethods.AppendString;

                // Process() takes a delegate
                myclassprocessor.Process(methodHandler);
              }
              static void FromConsumerMinusThree(MyClass myC)
              {
                myC.MyInt = myC.MyInt - 3;
                Console.WriteLine("FromConsumerMinusThree: " + myC.MyString +
                    myC.MyInt);
              }
            }

            Output:
            ----
            AddOne: inside Process method 2
            DoubleIt: inside Process method 4
            FromConsumerMinusThree: inside Process method 1
            AppendString: inside Process method appending string now   1

            Func<> and Action<>

            T@N@n@In .NET we have 2 delegates
            that are generic: Action<> and
            Func<>. Each also come in a
            non-generic form. Modifying the
            above program requires us to use
            Action<> and introducing a new
            processor (we'll call it
            MyClassGenericProcessor) and
            removing our custom delegate in
            there and adding Action<>. Also in
            the Main() program we need to
            change the first line and the third
            line of code.

            class MyClassGenericProcessor
            {
              public int MyAmount { get; set; }
              // public delegate void MyClassMethodHandler(MyClass myclass);

              public void Process(Action<MyClass> methodHandler)
              {
                // methodHandler is a delegate
                // instantiate with object initialization syntax
                var myclass = new MyClass { MyString = "in Process method ",
                      MyInt = 1 };
                methodHandler(myclass);
                // we do not define the methods we want to run here because
                // we are going to let the consumer define that.
              }
            }

            Below is a partial listing of our
            Main() program showing the changes.

            var myclassprocessor = new MyClassGenericProcessor(); // generics
            var myclassmethods = new MyClassMethods();
            Action<MyClass> methodHandler = myclassmethods.AddOne;

            Anonymous Types

            T@T@t@An anonymous type is a simple
            class created on the fly to store a
            set of values. To create an
            anonymous type, you use the new
            keyword followed by an object
            initializer {}, specifying the
            properties and values the type will
            contain. Anonymous types are used
            in LINQ queries.

            static void Main(string[] args)
            {
              var person = new { Name = "Bob", Number = 32 };
              Console.WriteLine($"Name: {person.Name} " +
                  $"Number: {person.Number}");
              // output: Name: Bob Number: 32
            }

            Here is another example.

            class Program
            {
              static void Main(string[] args)
              {
                var person = new
                {
                  Name = "John",
                  Age = 29,
                  Major = "Computers"
                };
                Console.WriteLine($"{ person.Name }, Age { person.Age }, "
                    + $"Major: {person.Major}");
                // the code below produces the same results
                string Major = "Computers";
                var guy = new { Age = 29, Other.Name, Major };
                Console.WriteLine($"{guy.Name }, Age {guy.Age }, "
                    + $"Major: {guy.Major}");
                // John, Age 29, Major: Computers
              }
            }
            class Other
            {
              // Name is a static field of class Other
              static public string Name = "John";
            }

            Lambda

            T@A lambda expression is an unnamed
            method written in place of a
            delegate instance. T@A lambda
            expression is an anonymous method
            that has no access modifier, no
            name and no return statement. We
            have code below that we can
            re-factor using a lambda
            expression.
            The => is read as "goes to".

            class Program
            {
              delegate int MyDel(int InParameter); // custom delegate

              static void Main(string[] args)
              {
                MyDel AddTwo = x => x + 2;
                Func<int, int> AddThree = number => number + 3;
                Console.WriteLine(AddOne(0));
                Console.WriteLine(AddTwo(0));
                Console.WriteLine(AddThree(0));
              }
              static int AddOne(int number)
              {
                return number + 1;
              }
            }

            Here is another example.

            static void Main(string[] args)
            {
              Console.WriteLine(Square(3)); // 9
              Func<int, int> squareDel = Square;
              Console.WriteLine(squareDel(3)); // 9
              Func<int, int> squareLambda = m => m * m;
              Console.WriteLine(squareLambda(3)); // 9
              Func<int, int, long> multiplyTwoInts = (m, n) => m * n;
              Console.WriteLine(multiplyTwoInts(3,4)); // 12
            }
            static int Square(int number)
            {
              return number * number;
            }

            Here is another example that is
            more realistic. Here we have a list
            of Products. We also have a
            repository of products. We use
            object initialization syntax to
            initialize the list with a series
            of products. T@T@FindAll() takes a
            predicate. A predicate is something
            that evaluates to true or false.

            class Product
            {
              public string Title { get; set; }
              public int Price { get; set; }
            }
            class ProductRepository
            {
              public List<Product> GetProducts()
              {
                return new List<Book>
                  {
                    new Product () { Title ="product 1", Price = 5},
                    new Product () { Title = "product 2", Price = 6 },
                    new Product () { Title = "product 3", Price = 17 }
                  };
              }
            }
            class Program
            {
              static void Main(string[] args)
              {
                var products = new ProductRepository().GetProducts();
                List<Product> cheapProducts = products.FindAll(b =>
                      b.Price < 10);
                foreach (var product in cheapProducts)
                {
                  Console.WriteLine(product.Title + " $" + product.Price);
                }
              }
            }

            n@You can use a lambda expression
            when argument requires a delegate.

            Events

            T@- 1. define a delegate (define
              signature) or use EventHandler<>
            - 2. define an event based on that
              delegate (ItemProcessed in this
              case)
            - 3. raise the event
            Here is an example program that
            uses events.

            public class Item
            {
              public string Name { get; set; }
            }
            public class ItemEventArgs : EventArgs
            {
              public Item Item { get; set; }
            }
            public class ItemProcessor
            {
              // public delegate void ItemProcessedEventHandler(object source,
              //                                 ItemEventArgs args);
              public event EventHandler<ItemEventArgs> ItemProcessed;

              public void ProcessItem(Item item)
              {
                Console.WriteLine("Processing Item...");
                Thread.Sleep(1500); // delay 1.5 seconds
                OnItemProcessed(item);
              }
              protected virtual void OnItemProcessed(Item item)
              {
                ItemProcessed?.Invoke(this, new ItemEventArgs() { Item = item });

                // if (ItemProcessed != null)
                // ItemProcessed(this, new ItemEventArgs() { Item = item });
              }
            }
            public class SubscriberOne
            {
              public void OnItemProcessed(object source, ItemEventArgs args)
              { // maybe send an email
                Console.WriteLine("SubscriberOne: " + args.Item.Name);
              }
            }
            class SubscriberTwo
            {
              public void OnItemProcessed(object source, ItemEventArgs args)
              { // maybe send SMS (text message)
                Console.WriteLine("SubscriberTwo: " + args.Item.Name);
              }
            }

            Here is the main program.

            class Program
            {
              static void Main(string[] args)
              {
                var item = new Item() { Name = "Item 1 name" };
                var itemProcessor = new ItemProcessor(); // publisher
                var subscriberOne = new SubscriberOne(); // subscriber
                var subscriberTwo = new SubscriberTwo(); // subscriber
                Console.WriteLine("Beginning program EventsExample...");
                // itemProcessed is a list of pointers to methods
                itemProcessor.ItemProcessed += subscriberOne.OnItemProcessed;
                itemProcessor.ItemProcessed += subscriberTwo.OnItemProcessed;

                itemProcessor.ProcessItem(item);
              }
            }

            Attributes

            T@T@N@n@Attributes allow you to add
            metadata to a program's assembly.
            N@Attribute names use Pascal casing
            and end with the suffix Attribute.
            An attribute section consists of
            square brackets enclosing an
            attribute name and sometimes a
            parameter list. A construct with an
            attribute applied to it is said to
            be decorated, or adorned, with the
            attribute. n@Use the [Obsolete]
            attribute to mark the old method as
            obsolete and to display a helpful
            warning message when the code is
            compiled.

            Preprocessor Directives

            T@T@C# includes a set of
            preprocessor directives that are
            mainly used for conditional
            compilation. The directives #region
            and #endregion delimit a section of
            code that can be expanded or
            collapsed using the outlining
            feature of Visual Studio and can be
            nested within each other.

            Extension Methods

            T@T@T@N@Extension methods allow an
            existing type to be extended with
            new methods, without altering the
            definition of the original type. An
            extension method is a static method
            of a static class, where the this
            modifier is applied to the first
            parameter. The type of the first
            parameter will be the type that is
            extended. Extension methods, like
            instance methods, provide a way to
            chain functions.

            public static class MyStringExtensions
            {
              public static string Shorten(this String str, int numberOfWords)
              {
                if (numberOfWords < 0) throw new
                      ArgumentOutOfRangeException("must contain words");
                if (numberOfWords == 0) return "";
                string[] words = str.Split(' ');
                if (words.Length <= numberOfWords) return str;
                return string.Join(" ", words.Take(numberOfWords)) + "...";
              }
            }
            class Program
            {
              static void Main(string[] args)
              {
                string senten = "A very very long sentence...";
                Console.WriteLine("Number of chars: " + senten.Length);
                var shortededSentence = senten.Shorten(10);
                var s2 = shortededSentence.ToUpper();
                var s3 = s2.PadRight(60);
                Console.WriteLine("[" + s3 + "]");
              }
            }

            LINQ

            LINQ stands for Language Integrated
            Query and is pronounced "link."
            LINQ is an extension of the .NET
            Framework and allows you to query
            collections of data in a manner
            like using SQL to query databases.
            T@T@With LINQ you can query data
            from databases (LINQ to Entities),
            collections of objects in memory
            (LINQ to Objects), XML documents
            (LINQ to XML), and ADO.NET data
            sets (LINQ to Data Sets).

            using System;
            using System.Collections.Generic;
            using System.Linq;
            namespace LINQint
            {
              class Program
              {
                static void Main(string[] args)
                {
                  int[] numbers = { 6, 47, 15, 68, 23 }; // Data source
                  IEnumerable<int> bigNums = // Define & store the query.
                        from n in numbers
                        where n > 30
                        orderby n descending
                        select n;
                  foreach (var x in bigNums) // Execute the query.
                    Console.Write($"{ x }, "); // output: 68, 47
                }
              }
            }

            Now let's use a more realistic
            example. First we'll show the code
            without LINQ, then with LINQ. We
            have a class of our objects called
            Product and we have a
            ProductRepository.

            class Product
            {
              public string Name { get; set; }
              public float Price { get; set; }
            }
            class ProductRepository
            {

              public IEnumerable<Product> GetProducts() // method
              {
                return new List<Product>
                {
                  new Product() {Name = "P one", Price = 5},
                  new Product() {Name = "P two", Price = 9.99f},
                  new Product() {Name = "P three", Price = 12},
                };
              }
            }
            class Program
            {
              static void Main(string[] args)
              {
                var products = new ProductRepository().GetProducts();
                var pricyProducts = new List<Product>();
                // ------without LINQ---------------------------foreach (var product in products)
                {
                  if (product.Price > 10)
                    pricyProducts.Add(product);
                }
                // ------without LINQ----------------------------foreach (var product in pricyProducts)
                Console.WriteLine("{0} {1:C}",product.Name, product.Price);
              }
            }

            When you type product followed by
            the dot, Intelisense gives you a
            few methods and a long list of
            extension methods. One extension
            method is Where<>. T@T@Where is
            asking for a delegate.
            Func<Product,bool> predicate. It
            points to a method that gets a
            Product and returns a bool based on
            the predicate. Whenever we see
            Func<> as a delegate we can use a
            Lambda expression such as p =>
            p.Price > 10. Here is the code with
            LINQ.

            // -----with LINQ------------------------------------------
            var pricyProducts2 = products.Where(p => p.Price > 10);
            // -----with LINQ-------------------------------------------

            The LINQ extension methods can be
            chained. When we use Select in this
            case we get back a list of strings,
            not products.

            // -----LINQ-----------------------------------------
            var pricyProducts2 = products.Where(p => p.Price > 8)
                  .OrderBy(p => p.Name)
                  .Select(p => p.Name); // string
            // -----LINQ-----------------------------------------
            foreach (var product in pricyProducts2)
                Console.WriteLine(product);

            There are several LINQ extension
            methods beyond Where(). A few are
            listed in the C# comments below. If
            you only want one Product you can
            use Single() or SingleOrDefault().
            Single() will throw an error
            InvalidOperationException if it
            can't find a match. The OrDefault
            will return null if it can't find a
            match, which is probably better.

            var product = products.Single(p => p.Name == "P two");
            var product2 = products.SingleOrDefault(p => p.Name == "P unknown");
            Console.WriteLine(product.Name); // P two
            Console.WriteLine(product2 == null); // output: True
            var product3 = products.First();
            Console.WriteLine(product3.Name); // P one
            // FirstOrDefault() Last() LastOrDefult()
            // Skip(2).Take(3) will skip the first 2 and take the next 3
            // Count() Max() Min() Sum() Average()
            // Average(p => p.Price)

            Nullable Types

            Reference types can represent a
            non-existent value with a null
            reference. Normally value types
            cannot be null, however to
            represent null in a value type, you
            must use a special construct called
            a n@nullable type which is denoted
            with a value type immediately
            followed by the ? symbol.
            T@T@N@An important use case for
            nullable types is when you have a
            database with a column like
            MiddleName or BirthDate which may
            have a null value.

            static void Main(string[] args)
            {
              // DateTime is a value type - cannot be null, but...
              System.Nullable<DateTime> d = null;
              DateTime? dt = null;
              Console.WriteLine("GetValueOrDefault: " + dt.GetValueOrDefault());
              Console.WriteLine("HasValue: " + dt.HasValue); // property
              // below line causes InvalidOperationException when null
              // Console.WriteLine("Value: " + dt.Value); // property
              Console.WriteLine(dt);

              // output: 0001-01-01 12:00:00 AM
              // output: False
              // output:
            }

            What about conversions and the
            N@null-coalescing operator?

            // Conversions
            DateTime? date = new DateTime(2019, 1, 1);
            // DateTime date2 = date; compiler says cannot convert
            DateTime date2 = date.GetValueOrDefault();
            Console.WriteLine("date2: " + date2);
            DateTime? date3 = date2;
            Console.WriteLine(date3.GetValueOrDefault());

            // Null Coales Operator: ??
            DateTime? date4 = null;
            DateTime date5;
            // if date has a value use that, otherwise use today
            if (date4 != null)
              date5 = date4.GetValueOrDefault();
            else
              date5 = DateTime.Today;
            // null
            date5 = date4 ?? DateTime.Today;
              // same as if block above

            T@T@When working with nullable
            types, GetValueOrDefault() is the
            preferred way of doing things.

            Dynamics

            Programming languages are either
            static or dynamic. C# and Java are
            static, but Ruby, JavaScript and
            Python are dynamic. With static
            languages the types are resolved at
            compile time, not at run time. The
            CLR (.NET's virtual machine) takes
            compiled code (verified by the
            compiler) which is in Intermediate
            language (IL) and converts that to
            machine code at runtime. Runtime
            checking is performed by the CLR.

            N@n@Runtime type checking is
            possible because each object on the
            heap internally stores a little
            type token. T@N@N@You can retrieve
            this token by calling the GetType
            method of object (reflection).
            N@N@With C# dynamics and the
            keyword dynamic, we don't need to
            use reflection. Much cleaner code
            results. When converting from
            dynamic to static types, if the
            runtime type of the dynamic object
            can be implicitly converted to the
            target type we don't need to cast
            it.

            dynamic name = "Bob";
            name = 19; // this works because name is dynamic!
            name++;
            Console.WriteLine(name); // 20
            dynamic a = 4, b = 5;
            var c = a + b; // c becomes dynamic
            Console.WriteLine(c); // 9
            int i = 7;
            dynamic d = i;
            long l = d;
            Console.WriteLine(l); //

            Asynchronous

            In the synchronous model the
            program executes line by line,
            T@T@N@but in the asynchronous model
            (e.g. media players, web browsers),
            responsiveness is improved. In .NET
            4.5 (in 2012) Microsoft introduced
            a new asynchronous model,
            N@N@t@instead of multi-threading
            and callbacks. It uses async and
            await keywords. In our example we
            have a WPF program that has 2
            blocking operations (downloading
            and writing). You can only use the
            await operator inside an async
            method. Async affects only what
            happens inside the method and has
            no effect on a method's signature
            or public metadata.

            using System.IO;
            using System.Net;
            using System.Threading.Tasks;
            using System.Windows;
            namespace AysnchronousProgramming
            {
              public partial class MainWindow : Window
              {
                public MainWindow()
                {
                  InitializeComponent();
                }
                private async void Button_Click(object sender,
                      RoutedEventArgs e)
                {
                  await DownloadHtmlAsync("http://begincodingnow.com");
                }
                public async Task DownloadHtmlAsync(string url)
                { // decorate method async, use Task, and only by convention
                  // put "Async" at end of the method name.
                  var webClient = new WebClient();
                  // use TaskAsync not Async, and await is a compiler marker
                  var html = await webClient.DownloadStringTaskAsync(url);
                  using (var streamWriter = new
                        StreamWriter(@"c:\temp\result.html"))
                  { // use the Async one: WriteAsync and add await
                    await streamWriter.WriteAsync(html);
                  }
                  MessageBox.Show("Finished downloading","Asynch Example");
                }
                public void DownloadHtml(string url)
                { // NOT asynchronous! - just shown here for comparison
                  var webClient = new WebClient();
                  var html = webClient.DownloadString(url);

                  using (var streamWriter = new
                      StreamWriter(@"c:\temp\result.html"))
                  {
                    streamWriter.Write(html);
                  }
                }
              }
            }

            Now we will modify our program. The
            message box "Waiting..." executes
            immediately. We can execute other
            code here. Another message box
            executes after the blocking
            operation completes.

            private async void Button_Click(object sender, RoutedEventArgs e)
            {
              //await DownloadHtmlAsync("http://begincodingnow.com");
              // Note: if we use await we must use async in method definition.
              // var html = await GetHtmlAsync("http://begincodingnow.com");
              var getHtmlTask = GetHtmlAsync("http://begincodingnow.com");
              // executes immediately
              MessageBox.Show("Waiting for task to complete...");
              var html = await getHtmlTask;
              // executes after html is downloaded
              MessageBox.Show(html.Substring(0, 500));
            }
            public async Task<string> GetHtmlAsync(string url)
            {
              var webClient = new WebClient();
              return await webClient.DownloadStringTaskAsync(url);
            }

            Exception Handling

            We write exception handling code to
            avoid those Unhandled Exception
            messages when the program crashes.
            We can use a Try Catch block.
            T@T@N@The four keywords of
            exception handling are: try, catch,
            finally and throw. The first code
            example crashes with an unhandled
            exception. In the second example we
            handle the exception.

            public class Calculator
            {
              public int Divide(int numerator, int denominator)
              {
                return numerator / denominator;
              }
            }
            class Program
            {
              static void Main(string[] args)
              {
                var calc = new Calculator();
                // Unhandled Exception: System.DivideByZeroException:
                // Attempted to divide by zero. CRASHES !!
                var result = calc.Divide(89, 0);
              }
            }

            Let's refactor our Main() method to
            use a try catch block.

            static void Main(string[] args)
            {
              try
              {
                var calc = new Calculator();
                var result = calc.Divide(89, 0);
              }
              catch (Exception ex)
              {
                Console.WriteLine("Unexpected error!"); // f9, f5
              }
            }

            To implement multiple catch blocks
            set a break point (with f9) and run
            it in debug mode (f5). Place your
            cursor on "ex" and click the small
            right-arrow icon in the pop-up to
            bring up more details. Properties
            have the wrench icon. Look at
            Message, Source (the DLL or
            assembly), StackTrace (sequence of
            method calls in the reverse order -
            click the magnifier icon),
            TarketSite (method where exception
            happened) and the others.

            static void Main(string[] args)
            {
              try
              {
                var calc = new Calculator();
                var result = calc.Divide(89, 0);
              }
              catch (Exception ex)
              {
                Console.WriteLine("Unexpected error! " +
                    ex.Message); // f9, f5
                // Unexpected error! Attempted to divide by zero.
              }
            }

            Multiple catch blocks example
            below.

            static void Main(string[] args)
            {
              try
              {
                var calc = new Calculator();
                var result = calc.Divide(89, 0);
                // type DivideByZeroException and f12
                // for Object Browser to see inheritance
                // hierarchy & click parent (bottom right)
              }
              catch (DivideByZeroException ex)
              {
                Console.WriteLine("Cannot divide by zero. " + ex.Message);
              }
              catch (ArithmeticException ex)
              {
                Console.WriteLine("Arithmetic exception. " + ex.Message);
              }
              catch (Exception ex)
              {
                Console.WriteLine("Unexpected error! " +
                    ex.Message); // f9, f5
                // Unexpected error! Attempted to divide by zero.
              }
              finally // unmanaged resources are not handled by CLR
              { } // we need to .Dispose() of those here, unless we employ
            // the using statement.
            }
            class Program
            { // we need using System.IO;
              static void Main(string[] args)
              {
                try
                { // using creates finally block in background
                  using (var strmRdr = new StreamReader(@"c:\not.txt")) ;
                }
                catch (Exception ex)
                {
                  Console.WriteLine("Unexpected error!");
                }
              }
            }

            T@T@N@One of the new features in C#
            6 was exception filters, which are
            not covered here. They give you
            more control over your catch blocks
            and further tailor how you handle
            specific exceptions.

            Recursion

            Recursion happens when a method or
            function calls itself. N@We must
            write a condition that checks that
            the termination condition is
            satisfied. Below is a program that
            tells you how many times a number
            is evenly divisible by a divisor.

            public static int CountDivisions(double number, double divisor)
            {
              int count = 0;
              if (number > 0 && number % divisor == 0)
              {
                count++;
                number /= divisor;
                return count += CountDivisions(number, divisor);
              }
              return count;
            }
            static void Main(string[] args)
            {
              Console.WriteLine("Enter your number: ");
              double number = Convert.ToDouble(Console.ReadLine());
              Console.WriteLine("Enter your divisor: ");
              double divisor = Convert.ToDouble(Console.ReadLine());
              int count = CountDivisions(number, divisor);
              Console.WriteLine($"Total number of divisions: {count}");
              Console.ReadKey();
            }
~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/ciss.txt  #=HAS FUNCT/METHODS-LIST
            1 Att komma igång 5 ----
            1.1 Vad är C# och .NET? 5
            1.2 Traditionell kompilering, länkning och exekvering 8
            1.3 Kompilering och exekvering av C#-program 12
            1.4 De första programmen 13
            1.5 En introduktion till Visual C# 19
            1.6 Att läsa indata 28
            1.7 Användning av numeriska variabler 30
            1.8 if-satsen 32
            1.9 Användning av dialogrutor 36
            1.10 while-satsen 41
            1.11 for-satsen 44
            1.12 Nästlade repetitionssatser 47
            1.13 Ett grafiskt program 48
              1.13.1 Utan användning av Visual C# 49
              1.13.2 Med användning av Visual C# 53
            1.14 Övningsuppgifter 57
            2 Klasser och typer 59 ----
            2.1 Objektorientering 59
            2.2 Klassdeklarationer 62
            2.3 Variabeldeklarationer 63
            2.4 Enkla typer 65
              2.4.1 Numeriska typer och uttryck 66
              2.4.2 Typen bool 70
              2.4.3 Typen char 71
            2.5 Referenstyper 74
            2.6 Tilldelning 76
            2.7 Metoder 78
              2.7.1 Deklarationer av metoder 81
              2.7.2 Anrop av metoder 83
            2.8 Exempel - Visning av klockslag 85
              2.8.1 Utan användning av Visual C# 85
              2.8.2 Med användning av Visual C# 89
            2.9 Standardklassen String 92
            2.10 Konstruktorer - initieringar av objekt 95
            2.11 Överlagrade metoder 99
            2.12 Standardklassen Random 100
            2.13 Struct-typer 102
            2.14 Egenskaper (properties) 106
            2.15 Objektinitierare och anonyma typer 113
            2.16 Övningsuppgifter 115
            3 Mer om klasser och typer 117 ----
            3.1 Namnrymder 117
              3.1.1 Deklaration av namnrymder 117
              3.1.2 Sub-namnrymder 119
              3.1.3 using-direktiv 120
            3.2 Inkapsling och synlighet 122
              3.2.1 Deklarationers placering 123
              3.2.2 Synlighet för medlemmar i namnrymder 123
              3.2.3 Synlighet för medlemmar i klasser 124
              3.2.4 Synlighet för medlemmar i structer 126
              3.2.5 Synlighet för lokala variabler och konstanter 126
            3.3 Statiska medlemmar 126
              3.3.1 Statiska variabler 126
              3.3.2 Statiska konstruktorer 129
              3.3.3 Statiska metoder 129
              3.3.4 Statiska egenskaper (properties) 130
              3.3.5 Konstanter130
              3.3.6 Statiska klasser 132
            3.4 readonly och const 133
            3.5 Standardklassen Math 134
            3.6 Parameteröverföring 135
            3.7 Referensen this 140
            3.8 Tilläggsmetoder 142
            3.9 Uppräkningstyper 143
            3.10 Övningsuppgifter 149
            4 Objektorienterad programutveckling 151 ----
            4.1 Objektorienterad analys 151
            4.2 Objektorienterad design 157
            4.3 Objektorienterad programmering 157
            4.4 Algoritmer 160
            4.5 Relationer i C# 163
              4.5.1 Har-relation (komposition) 163
              4.5.2 Känner-till-relation 164
              4.5.3 Simulerad har-relation 166
              4.5.4 Är-relation (arv) 168
            4.6 Övningsuppgifter 171
            5 Fält, listor och delegater 173 ----
            5.1 Fält, grunderna 173
            5.2 Sökning och sortering 180
            5.3 Fält med komponenter av struct-typ 183
            5.4 Fält med referenser 184
            5.5 Fält som parametrar 189
            5.6 Parameterfält - params 192
            5.7 Parametrar till Main 193
            5.8 Listor 196
            5.9 Multipla relationer 204
            5.10 lndexerare 205
            5.11 Flerdimensionella fält 207
            5.12 Fält av fält 210
            5.13 Delegater 212
            5.14 Övningsupp gifter 21 8
            6 Läsning och skrivning 221 ----
            6.1 Nationella inställningar 221
            6.2 Redigering av utskrifter 222
            6.3 Avkodning av indata 227
              6.3.1 Uppdelning av text 227
              6.3.2 Felkontroll 230
            6.4 Textfiler 231
            6.5 Datum och tider - klassen DateTime 234
            6.6 Övningsuppgifter 237
            7 Arv 239 ----
            7.1 Deklaration av subklasser 239
            7.2 Referenser och subklasser 243
            7.3 Dolda medlemmar 245
            7.4 Virtuella metoder 248
            7.5 Egenskaper (properties) vid arv 251
            7.6 Konstruktorer vid arv 252
            7.7 Destruktorer 255
            7.8 Objektsamlingar 255
            7.9 Abstrakta klasser 258
            7.10 Gränssnitt - interface 261
            7.11 Jämförbara objekt 268
              7.11.1 Gränssnittet IComparable och metoden CompareTo 268
              7.11.2 Extern jämförare 270
            7.12 Ett objektorienterat exempel 273
            7.13 Övningsuppgifter 280
            8 Exceptionella händelser 283 ----
            8.1 Automatiskt genererade exceptionella händelser 284
            8.2 throw - satsen 287
            8.3 Att fånga exceptionella händelser 289
            8.4 Övningsuppgifter 294
            9 Grafiska användargränssnitt 295 ----
            9.1 En översikt 295
            9.2 Klassen Control, gemensamma egenskaper 301
            9.3 Demonstrationsexempel, klassen Label 306
              9.3.1 Utan användning av Visual C# 307
              9.3.2 Med användning av Visual C# 309
            9.4 Kommandofönstret 312
            9.5 Att förankra och docka komponenter 313
            9.6 Händelser och klassen Button 316
            9.7 CheckBox och RadioButton 325
            9.8 Panel och GroupBox 328
            9.9 TextBox 331
              9.9.1 Inläsning av enkel text 331
              9.9.2 Inläsning av numeriska data 334
              9.9.3 Textboxar med flera rader 338
            9.10 Dialogrutor med textboxar 339
              9.101 Dialogrutor med flera textboxar 340
              9.102 Klassen InputBox 346
            9.11 Fildialogrutor och klassen RichTextBox 351
            9.12 WebBrowser 355
            9.13 ListBox 358
            9.14 ComboBox 364
            9.15 ProgressBar 367
            9.16 TrackBar 368
            9.17 TableLayoutPanel 371
            9.18 Övningsuppgifter 376
            10 Konstruktion av egna grafiska komponenter 379 ----
            10.1 Sätta samman flera standardkomponenter 379
            10.2 Användning av egna klasser i andra projekt 383
              10.2.1 Konstruktion av egen komponent 383
              10.2.2 Användning av egen komponent 384
            10.3 Utökning av standardklasser 385
            10.4 Grafik 389
              10.4.1 Pennor 392
              10.4.2 Penslar 393
              10.4.3 Linjer 393
              10.4.4 Rektanglar 394
              10.4.5 Cirklar och ellipser 394
              10.4.6 Polygoner och sammansatta linjer 395
              10.4.7 Bågar och segment 395
              10.4.8 Texter 396
              10.4.9 Transformationer 397
            10.4.10 Kurvor 398
            10.4.11 Bilder 400
            10.5 Grafik och händelser 402
              10.5.1 Mus och tangentbord - ett ritprogram 402
              10.5.2 Timer - rörliga figurer 407
            10.6 Övningsuppgifter 413
            11 Mer om användargränssnitt 415 ----
            11.1 Verktygsfält 415
            11.2 Verktygskomponenter 418
            11.3 Menyer 425
              11.3.1 Menyrader, menyer och menyalternativ 426
              11.3.2 Submenyer 430
              11.3.3 Popup-menyer 431
              11.3.4 Kortkommandon till menyer 434
            11.4 Mer om klassen Form 435
            11.5 Interna fönster 440
            11.6 Exempel - en texteditor 446
            11.7 Ljud 451
              11.7.1 SoundPlayer 451
              11.7.2 Windows Media Player 453
            11.8 Övningsuppgifter 455
            12 Strömmar och filer 457 ----
            12.1 Klassen Stream 457
            12.2 Strömmar med text 460
              12.2.1 Kodning 460
              12.2.2 Klassen StreamWriter 461
              12.2.3 Klassen StreamReader 462
              12.2.4 Klassen Console 463
            12.3 Strömmar med binära data 464
            12.4 Lagring av hela objekt 467
            12.5 Direktaecessfiler 470
            12.6 Hantering av filer och mappar 477
            12.7 Övningsuppgifter 480
            13 Generiska konstruktioner och containerklasser 483 ----
            13.1 Generiska konstruktioner 483
              13.1.1 Generiska typer 483
              13.1.2 Statiska medlemmar 487
              13.1.3 Restriktioner for typparametrar 487
              13.1.4 Generiska metoder 490
            13.2 Samlingar- gemensamma egenskaper 495
            13.3 Listor 495
              13.3.1 Listor i allmänhet 495
              13.3.2 Klassen List 496
              13.3.3 Klassen LinkedList 496
              13.3.4 Klassen Stack 499
              13.3.5 Klassen Queue 499
            13.4 Mängder - klassen HashSet 500
            13.5 Avbildningstabeller 506
            13.6 Övningsuppgifter 513
            14 Lite av varje 515 ----
            14.1 Fler satser 515
              14.1.1 do-satsen 515
              14.1.2 switch-satsen 516
              14.1.3 break-satsen 518
              14.1.4 continue-satsen 518
              14.1.5 goto-satsen 519
            14.2 Fler operatorer 519
              14.2.1 Bit-operatorer och binär lagring av heltal 519
              14.2.2 Operatorerna & och | 523
              14.2.3 Villkorsoperatorn 523
              14.2.4 Operatorn ?? 524
            14.3 Egendeflnierade operatorer 524
              14.3.1 Typomvandlingsoperatorer 530
            14.4 Nullable types 532
            14.5 Rekursion 533
            14.6 Trådar 537
              14.6.1 Aktiva objekt 537
              14.6.2 Klassen. Thread 538
              14.6.3 Synkronisering av trådar 542
            14.7 Övningsuppgifter 549
            Appendix A Reserverade ord och operatorer 551
            Appendix B LATIN_l-koder 553
~/Empire/Doks/Comp/PROGR/prograb.pdf  #p109 ++
~/Empire/Doks/Comp/PROGR/prograb.txt

~/Empire/Doks/Comp/lang/clangs/csharp/cscb_2022.txt  @
~/Empire/Doks/Comp/lang/clangs/csharp/cs7-netcore-cb.txt  @
[+.NET-LINKS FOR STD-LIBRARIES  =IN CPPDLANG-SCRIPT[!!]]
+Check Derek Banas C#

~/Empire/Doks/Comp/lang/clangs/csharp/learn-intro/csharplearn-2020.txt  @
gvim -p ~/Empire/rsc/code/cs/Program.cs ~/Dropbox/rsc/Doks/phone/Comp/lang/clangs/ciss.txt ~/Dropbox/rsc/Doks/phone/Comp/PROGR/prograb.txt ~/Empire/Doks/Comp/lang/clangs/csharp/Ref/CSDOCS-TOC.txt ~/Empire/Doks/Comp/lang/clangs/csharp/Ref/CSDOCS.txt ~/Empire/Doks/Comp/lang/clangs/csharp/funct/functional-cs.txt
~/Empire/Doks/Comp/lang/clangs/csharp/cs-classdesign-handb.txt  @
~/Empire/Doks/Comp/lang/clangs/csharp/cs-datastructsalgos.txt  @
~/Empire/Doks/Comp/lang/clangs/csharp/cs-despatts_2018.txt  @
~/Empire/Doks/Comp/lang/clangs/csharp/csh-becomegoodprogr.txt  @
~/Empire/Doks/Comp/lang/clangs/csharp/effective-cs-with-scottm_2017.txt  @
~/Empire/Doks/Comp/lang/clangs/csharp/notes4pros-csharp_2.txt  @
~  @
 --
~/Empire/Doks/Comp/lang/clangs/csharp/learn-intro/csh-learn7days.txt
~/Empire/Doks/Comp/lang/clangs/csharp/learn-intro/cshlearn.txt
~/Empire/Doks/Comp/lang/clangs/csharp/learn-intro/csh-learninoneday.txt
~/Empire/Doks/Comp/lang/clangs/csharp/cs-analystoprogram.txt  @
--
~/Empire/Doks/Comp/lang/clangs/csharp/cs8-qsyntaxref.txt
~/Empire/Doks/Comp/lang/clangs/csharp/cs10-pockref.txt
    ~/Empire/Doks/Comp/lang/clangs/csharp/cs7-netcore-cb.txt
--
~/Empire/Doks/Comp/lang/clangs/csharp/notes4pros-dotnet.txt
--
--
~/Empire/Doks/Comp/lang/clangs/csharp/csharptips-2014.txt
~/Empire/Doks/Comp/lang/clangs/csharp/dotnet-perform.txt  @


 typ
Variable
  get =läsas
  set =tilldelas
Function1  Method (=vad man brukar kalla en function.... när den ligger inbakad i ett Object)
  Skriv ut 1 + var2
  Göra lite annat
Class
  Constructor
Object o = new ClassO()


addera vs konkatenera (???????)
1 2 --> 3
1 2 --> 12

int var2;  // reservera en plats i minnet för en int, och namnet på den platsen är 'var2'

var2 = 5

1 + var2


Function1()

  Function1()

Rad1
Rad2
Rad3


- Question: I've used Vim a fair
  bit in the past, but now I'm
  using JetBrains Rider (and also
  Visual Studio at least a bit) at
  work. One thing that tends to
  screw up my workflow (a fair bit
  actually) is that whenever I 'Go
  to implementation' and any of the
  related functionalities (i.e. Go
  to interface, Go to usages, etc),
  at least Rider, but I think also
  Visual Studio - at least as a
  matter of default - wants to open
  up all the files I'm visiting
  along the way, which quickly
  clutters up the file-list
  enormously. I suspect there has
  to be some setting in Rider where
  one can turn off this behavior?

You're absolutely right, this is a
very common frustration for
developers transitioning from Vim's
more minimalist approach to modern
IDEs like Rider and Visual Studio.
They tend to aggressively open
files, cluttering the tab bar and
making it difficult to navigate.

Rider Settings to Address This:

Rider provides a few key settings
to control this behavior:

- "Preview Tab" (or "Preview in Single Tab"):

This is the most crucial setting.
It allows you to preview files in a
single tab instead of opening a new
tab for each.

How to Enable:  ____

- Go to Settings/Preferences ->
  Editor -> Tabs.
- Check the box for Enable preview
  tab.
- You can also configure if
  double-clicking a file should
  open it permanently.

- "Scroll Tabs If Possible":

This setting helps with the tab
clutter by allowing the tab bar to
scroll horizontally instead of
shrinking the tabs.

How to Enable:

- Go to Settings/Preferences ->
  Editor -> Tabs.
- Check the box for Scroll tabs if
  possible.

- "Close Unmodified Files":

Rider has an option to
automatically close unmodified
files after a certain period of
inactivity.

How to Enable:

- Go to Settings/Preferences ->
  Editor -> Tabs.
- Check the box for Close
  unmodified files after.
- Set the inactivity time.

- "Navigation History":

While not directly preventing tab
clutter, Rider's navigation history
(Ctrl+Alt+Left/Right) is very
helpful for quickly jumping back
and forth between locations.

Use this to quickly go back to the
code you were working on.

- "Find Usages" Settings:

Rider's "Find Usages" has settings
that can help control how results
are displayed.

- Right click on the find usages
  results window, and explore the
  different settings.

Visual Studio Settings (Similar Concepts):

Visual Studio has similar concepts,
though the exact wording might
differ:

- "Preview Tab" (or "Preview Selected Files"):

Visual Studio also has a preview
tab feature.

Click the "Preview Selected Files"
button in the Solution Explorer
toolbar.

- "Navigation History":

Visual Studio's navigation history
(Ctrl+-/Ctrl+Shift+-) works
similarly to Rider's.

- "Find All References" Settings:

Visual studio also has settings to
configure the results window for
find all references.

Workflow Recommendations:

- Embrace Preview Tabs: This is the
  most effective way to address the
  tab clutter issue.
- Use Navigation History: Get
  comfortable with the navigation
  history shortcuts.
- Close Tabs Regularly: Don't be
  afraid to close tabs that you're
  no longer using.
- Utilize "Find Usages" Settings:
  Customize the Find Usages window
  to suit your needs.
- Use Bookmarks: Bookmarks
  (Ctrl+Shift+Number) can be
  helpful for marking important
  locations.

____
TODO: TEST GLOBAL MARKS = WORKS

By adjusting these settings and
adopting these workflow practices,
you can significantly reduce tab
clutter and improve your navigation
experience in Rider and Visual
Studio.


- Great. And, on the other hand,
  Vim is (in another and very good
  respect) not a very minimalist
  editor, in that it has a separate
  buffer-list, and a separate
  args-list (as well as quicklist
  (or something similar) and
  location-list. Being used to and
  using those different features to
  good effect can make even Rider
  seem quite primitive. Is there
  functionality in Rider that
  emulates or can replace at least
  parts of the functionality of
  those features in Vim=

You've hit on a core difference in
philosophy between Vim and modern
IDEs like Rider. Vim's buffer,
argument, quickfix, and location
lists provide a level of
fine-grained control that, at
first, seems absent in IDEs.
However, Rider does offer features
that can emulate or replace much of
that functionality, albeit in a
different way.

Let's break down each Vim feature
and its Rider equivalent:

- 1. Vim Buffers vs. Rider Tabs and Navigation:

- Vim Buffers: Vim's buffers are
  independent entities that hold
  file content. You can have many
  buffers open without them being
  visible in the window.
- Rider Tabs: Rider uses tabs to
  represent open files. As
  discussed earlier, you can
  control tab behavior with
  preview-tabs and scrolling.
- Rider Navigation: Rider's
  navigation-features are powerful
  replacements for Vim's
  buffer-management:

- "Recent Files" (Ctrl+E): Quickly
  switch between recently opened
  files.
- "Recent Locations"
  (Ctrl+Shift+E): Jump to recently
  edited locations.
- "Go to File" (Ctrl+Shift+N):
  Search for files by name.
- "Go to Symbol"  ____
  (Ctrl+Alt+Shift+N): Search for
  symbols (classes, methods, etc.).
- "Navigation History"
  (Ctrl+Alt+Left/Right): Navigate
  backward and forward in your
  editing history.
- "Bookmarks" (Ctrl+Shift+Number):
  Quickly navigate to specific
  parts of code.

Rider Solution Explorer: The
solution explorer also provides a
good overview of all the files in
your project.

- 2. Vim Argument List vs. Rider
  Solution Explorer and Scopes:

Vim Argument List: The argument
list allows you to specify a list
of files to work with, often using
wildcards.

- Rider Solution Explorer: The
  solution explorer effectively
  replaces the argument list by
  providing a hierarchical view of
  your project files.

____
- Rider Scopes: Rider's scopes
  allow you to define custom sets
  of files for searching,
  refactoring, and other
  operations. This is a more
  powerful and flexible version of
  Vim's argument list.

  - You can define scopes based on
    file paths, patterns, or other
    criteria.
  - Scopes are used in "Find
    Usages," "Refactor This," and
    other features.

Search Everywhere: Rider's "Search
Everywhere" (Double Shift) with
file filters can also be used to
search in a set of files that match
a specific pattern.

- 3. Vim Quickfix/Location Lists
  vs. Rider "Find Usages," "Find in
  Files," and "Problems" Tool
  Windows:

Vim Quickfix/Location Lists: These
lists store the results of commands
like grep, compiler errors, and
search results.

____
- Rider "Find Usages" (Alt+F7):
  This provides a powerful way to
  find all usages of a symbol. The
  results are displayed in a tool
  window that you can navigate.
- Rider "Find in Files"
  (Ctrl+Shift+F): This allows you
  to search for text in your
  project files. The results are
  displayed in a similar tool
  window.
- Rider "Problems" Tool Window:
  This window displays compiler
  errors, warnings, and other
  issues.
  - It's a more integrated and
    user-friendly version of Vim's
    quickfix list.

Rider "Search Everywhere" (Double
Shift): This can also be used to
search for text and symbols across
your project.

Emulation Strategies:

- Keyboard Shortcuts: Learn and use
  Rider's keyboard shortcuts
  extensively. This will
  significantly improve your
  navigation speed.
- Tool Windows: Get comfortable
  with Rider's tool windows
  (Solution Explorer, Find Usages,
  Problems, etc.). These are
  essential for navigating and
  managing your code.
- Scopes: Explore and use Rider's
  scopes to define custom file
  sets.
- Search Everywhere: Use "Search
  Everywhere" to quickly find
  files, symbols, and text.
- Live Templates: Rider's live
  templates can be used to generate
  code snippets, similar to Vim's
  abbreviations and mappings.

Key Differences:

Integrated vs. Separate: Rider's functionality is more integrated into the IDE, while Vim's features are more separate and command-line driven.
GUI vs. Text-Based: Rider is a GUI-based IDE, while Vim is a text-based editor.

While Rider doesn't perfectly
replicate Vim's buffer and list
management, it provides powerful
and flexible alternatives that can
significantly improve your
workflow. By embracing Rider's
features and adapting your
workflow, you can leverage the
power of a modern IDE while
maintaining the efficiency you're
accustomed to in Vim.

