set foldmethod=indent foldlevel=2
vim: fdm=indent:fdl=2:

~/Dropbox/rsc/Doks/Comp/xml-w3schools.txt
                evince -p 1 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML documents form a tree structure that starts at "the
            root" and branches to "the leaves".

            An Example XML Document
            XML documents use a self-describing and simple syntax:

            <?xml version="1.0" encoding="UTF-8"?>
            <note>
              <to>Tove</to>
              <from>Jani</from>
              <heading>Reminder</heading>
              <body>Don't forget me this weekend!</body>
            </note>

            The first line is the XML declaration. It defines the XML
            version (1.0).
            The next line describes the root element of the document
            (like saying: "this document is a note"):

            <note>

            The next 4 lines describe 4 child elements of the root (to,
            from, heading, and body):

            Ending-tag

                evince -p 2 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <to>Tove</to>
            <from>Jani</from>
            <heading>Reminder</heading>
            <body>Don't forget me this weekend!</body>

            And finally the last line defines the end of the root element:

            </note>

            You can assume, from this example, that the XML document
            contains a note to Tove from Jani.

            Don't you agree that XML is pretty self-descriptive?


            XML Documents Form a Tree Structure

            XML documents must contain a root element. This element
            is "the parent" of all other elements.

            The elements in an XML document form a document tree.
            The tree starts at the root and branches to the lowest level
            of the tree.

            All elements can have sub elements (child elements):
            ___pickout

            <root>
              <child>
                <subchild>.....</subchild>
              </child>
            </root>

            The terms parent, child, and sibling are used to describe the
            relationships between elements. Parent elements have
            children. Children on the same level are called siblings
            (brothers or sisters).

            All elements can have text content and attributes
            (just like in HTML).

                evince -p 3 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example:


            The image above represents one book in the XML below:

            <bookstore>
              <book category="COOKING">
                <title lang="en">Everyday Italian</title>
                <author>Giada De Laurentiis</author>
                <year>2005</year>
                <price>30.00</price>
              </book>
              <book category="CHILDREN">
                <title lang="en">Harry Potter</title>
                <author>J K. Rowling</author>
                <year>2005</year>
                <price>29.99</price>
              </book>
              <book category="WEB">
                <title lang="en">Learning XML</title>
                <author>Erik T. Ray</author>
                <year>2003</year>
                <price>39.95</price>
              </book>
            </bookstore>

            The root element in the example is <bookstore>. All <book>
            elements in the document are contained within <bookstore>.

            The <book> element has 4 children: <title>,< author>,
            <year>, <price>.

                evince -p 8 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Syntax Rules

            The syntax rules of XML are very simple and logical. The
            rules are easy to learn, and easy to use.

            All XML Elements Must Have a Closing Tag

            In HTML, some elements do not have to have a closing tag:

              <p>This is a paragraph.
              <br>

            In XML, it is illegal to omit the closing tag. All elements
            must have a closing tag:

              <p>This is a paragraph.</p>
              <br />

            Note: You might have noticed from the previous example
            that the XML declaration did not have a closing tag. This is
            not an error. The declaration is not a part of the XML
            document itself, and it has no closing tag.

                evince -p 9 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Tags are Case Sensitive

            XML tags are case sensitive. The tag <Letter> is different
            from the tag <letter>.

            Opening and closing tags must be written with the same case:

            <Message>This is incorrect</message>
            <message>This is correct</message>

            Note: "Opening and closing tags" are often referred to as
            "Start and end tags". Use whatever you prefer. It is exactly
            the same thing.


            XML Elements Must be Properly Nested

            In HTML, you might see improperly nested elements:

              <b><i>This text is bold and italic</b></i>

            In XML, all elements must be properly nested within each other:

              <b><i>This text is bold and italic</i></b>

            In the example above, "Properly nested" simply means that
            since the <i> element is opened inside the <b> element, it
            must contain one element that is the parent
            of all other elements. This element is called the root element.

                evince -p 10 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <root>
              <child>
                <subchild>.....</subchild>
              </child>
            </root>


            XML Attribute Values Must be Quoted

            XML elements can have attributes in name/value pairs just
            like in HTML.

            In XML, the attribute values must always be quoted.

            INCORRECT:

            <note date=12/11/2007>
              <to>Tove</to>
              <from>Jani</from>
            </note>

            CORRECT:

            <note date="12/11/2007">
              <to>Tove</to>
              <from>Jani</from>
            </note>

            The error in the first document is that the date attribute in
            the note element is not quoted.


            Entity References

            Some characters have a special meaning in XML.
            If you place a character like "<" inside an XML element, it
            will generate an error because the parser interprets it as the
            start of a new element.

            This will generate an XML error:

                evince -p 11 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <message>if salary < 1000 then</message>

            To avoid this error, replace the "<" character
            with an entity reference:

            <message>if salary &lt; 1000 then</message>

            There are 5 pre-defined entity references in XML:

            &lt;
            <               #strictly illegal
            less than

            &gt;
            >
            greater than

            &amp;
            &               #strictly illegal
            ampersand

            &apos;
            '
            apostrophe

            &quot;
            "
            quotation mark

            Note: Only the characters "<" and "&" are strictly illegal in
            XML. The greater than character is legal, but it is a good
            habit to replace it.


            Comments in XML

            The syntax for writing comments in XML is similar to that of HTML.

            <!-- This is a comment -->

            White-space is Preserved in XML
            XML does not truncate multiple white-spaces in a document
            (while HTML truncates multiple white-spaces to one single
            white-space):

            -----------------
            XML:
            Hello       Tove

            HTML:
            Hello Tove

                evince -p 12 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Stores New Line as LF

            Windows applications store a new line as: carriage return
            and line feed (CR+LF).

            Unix and Mac OSX uses LF.
              Old Mac systems uses CR.

            XML stores a new line as LF.


            Well Formed XML

            XML documents that conform to the syntax rules above are
            said to be "Well Formed" XML documents.

                evince -p 17 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Elements

            An XML document contains XML Elements.


            What is an XML Element?

            An XML element is everything from (including) the element's
            start tag to (including) the element's end tag.

            An element can contain:

            - other elements
            - text
            - attributes
             - a mix of all of the above...

                evince -p 18 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <bookstore> 
              <book category="CHILDREN">
                <title>Harry Potter</title>
                <author>J K. Rowling</author>
                <year>2005</year>
                <price>29.99</price>
              </book>
              <book category="WEB">
                <title>Learning XML</title>
                <author>Erik T. Ray</author>
                <year>2003</year>
                <price>39.95</price>
              </book>
            </bookstore>

            In the example above, <bookstore> and <book> have
            element contents, because they contain other elements.
            <book> also has an attribute (category="CHILDREN").
            <title>, <author>, <year>, and <price> have text content
            because they contain text.

            Empty XML Elements

            An element with no content is said to be empty.
            In XML, you can indicate an empty element like this:

            <element></element>

            or you can use an empty tag, like this (this sort of element
            syntax is called self-closing):

            <element />

            The two forms above produce identical results in an XML parser.

            Note: Empty elements do not have any content, but they
            can have attributes!

                evince -p 19 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Naming Rules

            - Element names are case-sensitive
            - Element names must start with a letter or underscore
            - Element names cannot start with the letters xml (or
              XML, or Xml, etc)
            - Element names can contain letters, digits, hyphens,
              underscores, and periods
            - Element names cannot contain spaces

            Any name can be used, no words are reserved (except xml).

            Best Naming Practices

            Create descriptive names, like this: <person>, <firstname>,
            <lastname>.

            Create short and simple names, like this: <book_title> not
            like this: <the_title_of_the_book>.

            Avoid "-". If you name something "first-name", some
            software may think you want to subtract "name" from "first".

            Avoid ".". If you name something "first.name", some
            software may think that "name" is a property of the object
            "first".

            Avoid ":". Colons are reserved for namespaces (more later).
            Non-English letters like éòá are perfectly legal in XML, but
            watch out for problems if your software doesn't support them.


            Naming Styles

            There are no naming styles defined for XML elements. But
            here are some commonly used:


            Style   Example     Description

            Lower case 
            <firstname>
            All letters lower case

            Upper case
            <FIRSTNAME>
            All letters upper case

                evince -p 20 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Underscore
            <first_name>
            Underscore separates words

            Pascal case
            <FirstName>
            Uppercase first letter in each word

            Camel case
            <firstName>
            Uppercase first letter in each word except the first


            If you choose a naming style, it is good to be consistent!
            XML documents often have a corresponding database. A
            good practice is to use the naming rules of your database for
            the elements in the XML documents.


            XML Elements are Extensible

            XML elements can be extended to carry more information.
            Look at the following XML example:

            <note>
              <to>Tove</to>
              <from>Jani</from>
              <body>Don't forget me this weekend!</body>
            </note>

            Let's imagine that we created an application that extracted
            the <to>, <from>, and <body> elements from the XML
            document to produce this output:

            MESSAGE
            To: Tove
            From: Jani

            Don't forget me this weekend!

            Imagine that the author of the XML document added some
            extra information to it:

            <note>
              <date>2008-01-10</date>
              <to>Tove</to>
              <from>Jani</from>

                evince -p 21 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

              <heading>Reminder</heading>
              <body>Don't forget me this weekend!</body>
            </note>

            Should the application break or crash?

            No. The application should still be able to find the <to>,
            <from>, and <body> elements in the XML document and
            produce the same output.

            One of the beauties of XML, is that it can be extended
            without breaking applications.

                evince -p 26 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Attributes

            XML elements can have attributes, just like HTML.
            Attributes provide additional information about an element.


            XML Attributes

            In HTML, attributes provide additional information about
            elements:

            <img src="computer.gif">
            <a href="demo.asp">

            Attributes often provide information that is not a part of the
            data. In the example below, the file type is irrelevant to the
            data, but can be important to the software that wants to
            manipulate the element:

            <file type="gif">computer.gif</file>

                evince -p 27 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Attributes Must be Quoted

            Attribute values must always be quoted. Either single or
            double quotes can be used. For a person's gender, the
            person element can be written like this:

            <person gender="female">

            or like this:

            <person gender='female'>

            If the attribute value itself contains double quotes you can
            use single quotes, like in this example:

            <gangster name='George "Shotgun" Ziegler'>

            or you can use character entities:

            <gangster name="George &quot;Shotgun&quot; Ziegler">


            XML Elements vs. Attributes

            Take a look at these examples:

            <person gender="female">
              <firstname>Anna</firstname>
              <lastname>Smith</lastname>
            </person>

            <person>
              <gender>female</gender>
              <firstname>Anna</firstname>
              <lastname>Smith</lastname>
            </person>

            In the first example gender is an attribute. In the last,
            gender is an element. Both examples provide the same
            information.

                evince -p 28 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            There are no rules about when to use attributes or when to
            use elements. Attributes are handy in HTML. In XML my
            advice is to avoid them. Use elements instead.


            My Favorite Way

            The following three XML documents contain exactly the same
            information:

            A date attribute is used in the first example:

            <note date="2008-01-10">
              <to>Tove</to>
              <from>Jani</from>
              <heading>Reminder</heading>
              <body>Don't forget me this weekend!</body>
            </note>

            A date element is used in the second example:

            <note>
              <date>2008-01-10</date>
              <to>Tove</to>
              <from>Jani</from>
              <heading>Reminder</heading>
              <body>Don't forget me this weekend!</body>
            </note>

            An expanded date element is used in the third:
            (THIS IS MY FAVORITE):

            <note>
              <date>
                <year>2008</year>
                <month>01</month>
                <day>10</day>
              </date>
              <to>Tove</to>
              <from>Jani</from>
              <heading>Reminder</heading>
              <body>Don't forget me this weekend!</body>
            </note>

                evince -p 29 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Avoid XML Attributes?

            Some of the problems with using attributes are:
            - attributes cannot contain multiple values (elements can)
            - attributes cannot contain tree structures (elements can)
            - attributes are not easily expandable (for future changes)

            Attributes are difficult to read and maintain. Use elements
            for data. Use attributes for information that is not relevant to
            the data.

            Don't end up like this:

            <note day="10" month="01" year="2008"
            to="Tove" from="Jani" heading="Reminder"
            body="Don't forget me this weekend!">
            </note>


            XML Attributes for Metadata

            Sometimes ID references are assigned to elements. These
            IDs can be used to identify XML elements in much the same
            way as the id attribute in HTML. This example demonstrates this:

            <messages>
              <note id="501">
                <to>Tove</to>
                <from>Jani</from>
                <heading>Reminder</heading>
                <body>Don't forget me this weekend!</body>
              </note>
              <note id="502">
                <to>Jani</to>
                <from>Tove</from>
                <heading>Re: Reminder</heading>
                <body>I will not</body>
              </note>
            </messages>

            The id attributes above are for identifying the different notes.

                evince -p 30 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            It is not a part of the note itself.

            What I'm trying to say here is that metadata (data about
            data) should be stored as attributes, and the data itself
            should be stored as elements.

                evince -p 34 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Namespaces

            XML Namespaces provide a method to avoid element
            name conflicts.


            Name Conflicts

            In XML, element names are defined by the developer. This
            often results in a conflict when trying to mix XML documents
            from different XML applications.

            This XML carries HTML table information:

            <table>
              <tr>
                <td>Apples</td>
                <td>Bananas</td>
              </tr>
            </table>

            This XML carries information about a table (a piece of
            furniture):

            <table>
              <name>African Coffee Table</name>
              <width>80</width>
              <length>120</length>
            </table>

                evince -p 35 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            If these XML fragments were added together, there would be
            a name conflict. Both contain a <table> element, but the
            elements have different content and meaning.

            A user or an XML application will not know how to handle
            these differences.


            Solving the Name Conflict Using a Prefix

            Name conflicts in XML can easily be avoided using a name prefix.

            This XML carries information about an HTML table, and a
            piece of furniture:

            <h:table>
              <h:tr>
                <h:td>Apples</h:td>
                <h:td>Bananas</h:td>
              </h:tr>
            </h:table>

            <f:table>
              <f:name>African Coffee Table</f:name>
              <f:width>80</f:width>
              <f:length>120</f:length>
            </f:table>

            In the example above, there will be no conflict because the
            two <table> elements have different names.


            XML Namespaces - The xmlns Attribute

            When using prefixes in XML, a so-called namespace for the
            prefix must be defined.

            The namespace is defined by the xmlns attribute in the
            start tag of an element.

            The namespace declaration has the following syntax.

                evince -p 36 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <root>

            <h:table xmlns:h="http://www.w3.org/TR/html4/">
              <h:tr>
                <h:td>Apples</h:td>
                <h:td>Bananas</h:td>
              </h:tr>
            </h:table>

            <f:table xmlns:f="http://www.w3schools.com/furniture">
              <f:name>African Coffee Table</f:name>
              <f:width>80</f:width>
              <f:length>120</f:length>
            </f:table>

            </root>

            In the example above, the xmlns attribute in the <table>
            tag give the h: and f: prefixes a qualified namespace.
            When a namespace is defined for an element, all child
            elements with the same prefix are associated with the same
            namespace.

            Namespaces can be declared in the elements where they are
            used or in the XML root element:

            <root xmlns:h="http://www.w3.org/TR/html4/"
            xmlns:f="http://www.w3schools.com/furniture">

            <h:table>
              <h:tr>
                <h:td>Apples</h:td>
                <h:td>Bananas</h:td>
              </h:tr>
            </h:table>

            <f:table>
              <f:name>African Coffee Table</f:name>
              <f:width>80</f:width>
              <f:length>120</f:length>
            </f:table>

            </root>

                evince -p 37 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Note: The namespace URI is not used by the parser to look
            up information.

            The purpose is to give the namespace a unique name.
            However, often companies use the namespace as a pointer to
            a web page containing namespace information.


            Uniform Resource Identifier (URI)

            A Uniform Resource Identifier (URI) is a string of
            characters which identifies an Internet Resource.
            The most common URI is the Uniform Resource Locator
            (URL) which identifies an Internet domain address. Another,
            not so common type of URI is the Universal Resource
            Name (URN).

            In our examples we will only use URLs.


            Default Namespaces

            Defining a default namespace for an element saves us from
            using prefixes in all the child elements. It has the following
            syntax:

            xmlns="namespaceURI"

            This XML carries HTML table information:

            <table xmlns="http://www.w3.org/TR/html4/">
              <tr>
                <td>Apples</td>
                <td>Bananas</td>
              </tr>
            </table>

            This XML carries information about a piece of furniture:

            <table xmlns="http://www.w3schools.com/furniture">
              <name>African Coffee Table</name>
              <width>80</width>
              <length>120</length>
            </table>

                evince -p 38 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Namespaces in Real Use

            XSLT is an XML language that can be used to transform XML
            documents into other formats, like HTML.
            In the XSLT document below, you can see that most of the
            tags are HTML tags.

            The tags that are not HTML tags have the prefix xsl,
            identified by the namespace
            xmlns:xsl="http://www.w3.org/1999/XSL/Transform":

            <?xml version="1.0" encoding="UTF-8"?>
            <xsl:stylesheet version="1.0"xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
            <html>
            <body>
              <h2>My CD Collection</h2>
              <table border="1">
                <tr>
                  <th style="text-align:left">Title</th>
                  <th style="text-align:left">Artist</th>
                </tr>
                <xsl:for-each select="catalog/cd">
                <tr>
                  <td><xsl:value-of select="title"/></td>
                  <td><xsl:value-of select="artist"/></td>
                </tr>
                </xsl:for-each>
              </table>
            </body>
            </html>
            </xsl:template>

            </xsl:stylesheet>

            If you want to learn more about XSLT, please read our XSLT
            Tutorial (/xsl/default.asp).

                evince -p 43 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Encoding

            XML documents can contain international characters, like
            Norwegian æøå, or French êèé.

            To avoid errors, you should specify the encoding used, or
            save your XML files as UTF-8.


            Character Encoding

            Character encoding defines a unique binary code for each
            different character used in a document.

            In computer terms, character encoding are also called
            character set, character map, code set, and code page.


            The Unicode Consortium

            The Unicode Consortium develops the Unicode Standard.
            Their goal is to replace the existing character sets with its
            standard Unicode Transformation Format (UTF).

            The Unicode Standard has become a success and is
            implemented in HTML, XML, Java, JavaScript, E-mail, ASP,
            PHP, etc. The Unicode standard is also supported in many
            operating systems and all modern browsers.

                evince -p 44 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The Unicode Consortium cooperates with the leading
            standards development organizations, like ISO, W3C, and ECMA.


            The Unicode Character Sets

            Unicode can be implemented by different character sets. The
            most commonly used encodings are UTF-8 and UTF-16.

            UTF-8 uses 1 byte (8-bits) to represent basic Latin
            characters, and two, three, or four bytes for the rest.

            UTF-16 uses 2 bytes (16 bits) for most characters, and four
            bytes for the rest.


            UTF-8 = The Web Standard

            UTF-8 is the standard character encoding on the web.
            UTF-8 is the default character encoding for HTML5, CSS,
            JavaScript, PHP, SQL, and XML.


            XML Encoding

            The first line in an XML document is called the prolog:

            <?xml version="1.0"?>

            The prolog is optional. Normally it contains the XML
            version number.

            It can also contain information about the encoding used in
            the document. This prolog specifies UTF-8 encoding:

            <?xml version="1.0" encoding="UTF-8"?>

            The XML standard states that all XML software must
            understand both UTF-8 and UTF-16.

            UTF-8 is the default for documents without encoding information.

                evince -p 45 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            In addition, most XML software systems understand
            encodings like ISO-8859-1, Windows-1252, and ASCII.

            XML Errors

            Most often, XML documents are created on one computer,
            uploaded to a server on a second computer, and displayed by
            a browser on a third computer.

            If the encoding is not correctly interpreted by all the three
            computers, the browser might display meaningless text, or
            you might get an error message.

            For high quality XML documents, UTF-8 encoding is the best
            to use. UTF-8 covers international characters, and it is also
            the default, if no encoding is declared.


            Conclusion

            - When you write an XML document:
            - Use an XML editor that supports encoding
            - Make sure you know what encoding the editor uses
            - Describe the encoding in the encoding attribute
            - UTF-8 is the safest encoding to use
            - UTF-8 is the web standard

                evince -p 50 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Viewing XML Files

            Raw XML files can be viewed in all major browsers.

            Don't expect XML files to be displayed as HTML pages.

            Viewing XML Files

            <?xml version="1.0" encoding="UTF-8"?>
            - <note>
                <to>Tove</to>
                <from>Jani</from>
                <heading>Reminder</heading>
                <body>Don't forget me this weekend!</body>
              </note>

            Look at the XML file above in your browser: note.xml (note.xml)

            Notice that an XML document will be displayed with
            color-coded root and child elements. A plus (+) or minus
            sign (-) to the left of the elements can be clicked to expand
            or collapse the element structure. To view the raw XML
            source (without the + and - signs), select "View Page
            Source" or "View Source" from the browser menu.

                evince -p 51 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Note: In Safari, only the element text will be displayed. To
            view the raw XML, you must right click the page and select
            "View Source".

            Viewing an Invalid XML File

            If an erroneous XML file is opened, some browsers report the
            error, and some only display it incorrectly.

            Try to open the following XML file in Chrome, IE, Firefox,
            Opera, and Safari: note_error.xml (note_error.xml).


            Other XML Examples

            Viewing some XML documents will help you get the XML
            feeling:

            An XML CD catalog (cd_catalog.xml)
            This is a CD collection, stored as XML.

            An XML plant catalog (plant_catalog.xml)
            This is a plant catalog from a plant shop, stored as XML.

            An XML breakfast menu (simple.xml)
            This is a breakfast food menu from a restaurant, stored as XML.


            Why Does XML Display Like This?

            XML documents do not carry information about how to
            display the data.

            Since XML tags are "invented" by the author of the XML
            document, browsers do not know if a tag like <table>
            describes an HTML table or a dining table.

            Without any information about how to display the data, most
            browsers will just display the XML document as it is.

            In the next chapters, we will see how CSS, XSLT, and
            JavaScript can be used to format XML data in different ways.

                evince -p 56 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Displaying XML with CSS

            With CSS (Cascading Style Sheets) you can add display
            information to an XML document.


            Displaying XML Files with CSS?

            Below is an example of how to use CSS to format an XML
            document.

            We will use the following XML file: The CD catalog
            (cd_catalog.xml)
            with the following stylesheet: The CSS file (cd_catalog.txt)

            RESULT: The CD catalog formatted with the CSS file
            (cd_catalog_with_css.xml)

            Below is a fraction of the XML file. The second line links the
            XML file to the CSS file:

            <?xml version="1.0" encoding="UTF-8"?>
            <?xml-stylesheet type="text/css" href="cd_catalog.css"?>
            <CATALOG>
              <CD>
                <TITLE>Empire Burlesque</TITLE>
                <ARTIST>Bob Dylan</ARTIST>
                <COUNTRY>USA</COUNTRY>
                <COMPANY>Columbia</COMPANY>
                <PRICE>10.90</PRICE>

                evince -p 57 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

                <YEAR>1985</YEAR>
              </CD>
              <CD>
                <TITLE>Hide your heart</TITLE>
                <ARTIST>Bonnie Tyler</ARTIST>
                <COUNTRY>UK</COUNTRY>
                <COMPANY>CBS Records</COMPANY>
                <PRICE>9.90</PRICE>
                <YEAR>1988</YEAR>
              </CD>
            .
            .
            .
            </CATALOG>

            Formatting XML with CSS is not the most common method.
            W3C recommends using XSLT instead.

                evince -p 62 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Document Types

            An XML document with correct syntax is called "Well
            Formed".

            A "Valid" XML document must also conform to a
            document type definition.


            Well Formed XML Documents

            An XML document with correct syntax is "Well Formed".

            The syntax rules were described in the previous chapters:

            - XML documents must have a root element
            - XML elements must have a closing tag
            - XML tags are case sensitive
            - XML elements must be properly nested
            - XML attribute values must be quoted

            <?xml version="1.0" encoding="UTF-8"?>
            <note>
            <to>Tove</to>
            <from>Jani</from>
            <heading>Reminder</heading>
            <body>Don't forget me this weekend!</body>
            </note>

                evince -p 63 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            An XML Validator

            To help you check the syntax of your XML files, we have
            created an XML validator (xml_validator.asp) to syntax-check
            your XML.

            Valid XML Documents

            A "valid" XML document is not the same as a "well formed"
            XML document.

            A "valid" XML document must be well formed. In addition it
            must conform to a document type definition.

            Rules that defines the legal elements and attributes for XML
            documents are called Document Type Definitions (DTD) or
            XML Schemas.

            There are two different document type definitions that can
            be used with XML:

            - DTD - The original Document Type Definition
            - XML Schema - An XML-based alternative to DTD


            When to Use a DTD/Schema?

            With a DTD, independent groups of people can agree to use
            a standard DTD for interchanging data.

            Your application can use a standard DTD to verify that the
            data you receive from the outside world is valid.

            You can also use a DTD to verify your own data.


            When to NOT to Use a DTD/Schema?

            XML does not require a DTD/Schema.

            When you are experimenting with XML, or when you are
            working with small XML files, creating DTDs may be a waste
            of time.

            If you develop applications, wait until the specification is
            stable before you add a document definition. Otherwise, your
            software might stop working because of validation errors.

                evince -p 68 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Validator

            Use our XML validator to syntax-check your XML.


            XML Errors Will Stop You

            Errors in XML documents will stop your XML applications.

            The W3C XML specification states that a program should stop
            processing an XML document if it finds an error. The reason is
            that XML software should be small, fast, and compatible.

            HTML browsers will display HTML documents with errors (like
            missing end tags).

            With XML, errors are not allowed.


            Syntax-Check Your XML

            To help you syntax-check your XML, we have created an XML
            validator.

            Paste your XML into the text area below, and syntax-check it
            by clicking the "Validate" button.

                evince -p 69 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <?xml version="1.0" encoding="UTF-8"?>
            <note>
            <to>Tove</to>
            <from>Jani</from>
            <heading>Reminder</heading>
            <body>Don't forget me this weekend!</body>
            </note>


            Syntax-Check an XML File

            You can syntax-check an XML file by typing the URL of the file
            into the input field below, and then click the "Validate" button:

            Filename:
            http://www.w3schools.com/xml/note_error.xml
            Validate

            If you get "Access Denied" or "Network Error", it is
            because your browser does not allow file access across domains.

            The file "note_error.xml" demonstrates your browsers error
            handling. If you want to see an error-free message, substitute
            the "note_error.xml" with "cd_catalog.xml".

                evince -p 74 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DTD

            An XML document with correct syntax is called
            "Well Formed".

            An XML document validated against a DTD is
            "Well Formed" and "Valid".


            Valid XML Documents

            A "Valid" XML document is a "Well Formed" XML document,
            which also conforms to the rules of a DTD:

            <?xml version="1.0" encoding="UTF-8"?>
            <!DOCTYPE note SYSTEM "Note.dtd">
            <note>
            <to>Tove</to>
            <from>Jani</from>
            <heading>Reminder</heading>
            <body>Don't forget me this weekend!</body>
            </note>

            The DOCTYPE declaration, in the example above, is a
            reference to an external DTD file. The content of the file is
            shown in the paragraph below.

                evince -p 75 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DTD

            The purpose of a DTD is to define the structure of an XML
            document. It defines the structure with a list of legal
            elements:

            <!DOCTYPE note
            [
            <!ELEMENT note (to,from,heading,body)>
            <!ELEMENT to (#PCDATA)>
            <!ELEMENT from (#PCDATA)>
            <!ELEMENT heading (#PCDATA)>
            <!ELEMENT body (#PCDATA)>
            ]>


            The DTD above is interpreted like this:

            - !DOCTYPE note defines that the root element of the
              document is note
            - !ELEMENT note defines that the note element must
              contain four elements: "to, from, heading, body"
            - !ELEMENT to defines the to element to be of type "#PCDATA"
            - !ELEMENT from defines the from element to be of type "#PCDATA"
            - !ELEMENT heading defines the heading element to be of
              type "#PCDATA"
            - !ELEMENT body defines the body element to be of type "#PCDATA"

            Note:
#PCDATA means parse-able text data.


            Using DTD for Entity Declaration

            A doctype declaration can also be used to define special
            characters and character strings, used in the document:

                evince -p 76 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example
            <?xml version="1.0" encoding="UTF-8"?>
            <!DOCTYPE note [
            <!ENTITY nbsp "&#xA0;">
            <!ENTITY writer "Writer: Donald Duck.">
            <!ENTITY copyright "Copyright: W3Schools.">
            ]>

            <note>
            <to>Tove</to>
            <from>Jani</from>
            <heading>Reminder</heading>
            <body>Don't forget me this weekend!</body>
            <footer>&writer;&nbsp;&copyright;</footer>
            </note>

            An entity has three parts: an ampersand (&), an
            entity name, and a semicolon (;).


            Why Use a DTD?

            With a DTD, independent groups of people can agree on a
            standard for interchanging data.

            With a DTD, you can verify that the data you receive from
            the outside world is valid.

            If you want to study DTD, please read our DTD Tutorial
            (/dtd/default.asp).

                evince -p 81 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            DTD Tutorial

            A Document Type Definition (DTD) defines
            the structure and the legal elements and
            attributes of an XML document.

            A DTD can be declared inside an XML
            document or in an external file.


            What You Should Already Know

            Before you continue you should have a basic understanding
            of the following:

            - HTML
            - XML

            If you want to study these subjects first, find the tutorials on
            our Home page (/default.asp).


            Why Use a DTD?

            With a DTD, independent groups of people can agree to use
            a standard DTD for interchanging data.

            Your application can use a standard DTD to verify that the
            data you receive from the outside world is valid.

                evince -p 82 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            You can also use a DTD to verify your own data.


            Internal DTD Declaration

            If the DTD is declared inside the XML file, it must be wrapped
            inside the <!DOCTYPE> definition:

            XML document with an internal DTD

            <?xml version="1.0"?>
            <!DOCTYPE note [
            <!ELEMENT note (to,from,heading,body)>
            <!ELEMENT to (#PCDATA)>
            <!ELEMENT from (#PCDATA)>
            <!ELEMENT heading (#PCDATA)>
            <!ELEMENT body (#PCDATA)>
            ]>
            <note>
            <to>Tove</to>
            <from>Jani</from>
            <heading>Reminder</heading>
            <body>Don't forget me this weekend</body>
            </note>

              View XML file » (note_in_dtd.xml)

            In the XML file, select "view source" to view the DTD.


            The DTD above is interpreted like this:
            - !DOCTYPE note defines that the root element of this
              document is note
            - !ELEMENT note defines that the note element must
              contain four elements: "to,from,heading,body"
            - !ELEMENT to defines the to element to be of type
              "#PCDATA"
            - !ELEMENT from defines the from element to be of
              type "#PCDATA"
            - !ELEMENT heading defines the heading element to be
              of type "#PCDATA"
            - !ELEMENT body defines the body element to be of
              type "#PCDATA"

                evince -p 83 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            External DTD Declaration

            If the DTD is declared in an external file, the <!DOCTYPE>
            definition must contain a reference to the DTD file:

            XML document with a reference to an external DTD

            <?xml version="1.0"?>
            <!DOCTYPE note SYSTEM "note.dtd">
            <note>
              <to>Tove</to>
              <from>Jani</from>
              <heading>Reminder</heading>
              <body>Don't forget me this weekend!</body>
            </note>

              View XML file » (note_ex_dtd.xml)


            And here is the file "note.dtd", which contains the DTD:

            <!ELEMENT note (to,from,heading,body)>
            <!ELEMENT to (#PCDATA)>
            <!ELEMENT from (#PCDATA)>
            <!ELEMENT heading (#PCDATA)>
            <!ELEMENT body (#PCDATA)>

                evince -p 88 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            DTD - XML Building Blocks

            The main building blocks of both XML and HTML
            documents are elements.


            The Building Blocks of XML Documents

            Seen from a DTD point of view, all XML documents are made
            up by the following building blocks:

            - Elements
            - Attributes
            - Entities
            - PCDATA
            - CDATA


            Elements

            Elements are the main building blocks of both XML and
            HTML documents.

            Examples of HTML elements are "body" and "table".
            Examples of XML elements could be "note" and "message".
            Elements can contain text, other elements, or be empty.
            Examples of empty HTML elements are "hr", "br" and "img".

                evince -p 89 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Examples:

            <body>some text</body>

            <message>some text</message>


            Attributes

            Attributes provide extra information about elements.

            Attributes are always placed inside the opening tag of an
            element. Attributes always come in name/value pairs. The
            following "img" element has additional information about a
            source file:

            <img src="computer.gif" />

            The name of the element is "img". The name of the attribute
            is "src". The value of the attribute is "computer.gif". Since
            the element itself is empty it is closed by a " /".


            Entities

            Some characters have a special meaning in XML, like the less
            than sign (<) that defines the start of an XML tag.

            Most of you know the HTML entity: "&nbsp;". This
            "no-breaking-space" entity is used in HTML to insert an extra
            space in a document. Entities are expanded when a
            document is parsed by an XML parser.

            The following entities are predefined in XML:


            Entity References   Character

            &lt;        <
            &gt;        >
            &amp;       &
            &quot;      "
            &apos;      '

                evince -p 90 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            PCDATA

            PCDATA means parsed character data.

            Think of character data as the text found between the start
            tag and the end tag of an XML element.

            PCDATA is text that WILL be parsed by a parser. The
            text will be examined by the parser for entities and markup.

            Tags inside the text will be treated as markup and entities
            will be expanded.

            However, parsed character data should not contain any &, <,
            or > characters; these need to be represented by the &amp;
            &lt; and &gt; entities, respectively.


            CDATA

            CDATA means character data.

            CDATA is text that will NOT be parsed by a parser. Tags
            inside the text will NOT be treated as markup and entities
            will not be expanded.

                evince -p 95 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            DTD - Elements

            In a DTD, elements are declared with an ELEMENT
            declaration.


            Declaring Elements

            In a DTD, XML elements are declared with the following syntax:

            <!ELEMENT element-name category>

            or

            <!ELEMENT element-name (element-content)>


            Empty Elements

            Empty elements are declared with the category keyword EMPTY:

            <!ELEMENT element-name EMPTY>

            Example:
            <!ELEMENT br EMPTY>

            XML example:
            <br />

                evince -p 96 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Elements with Parsed Character Data

            Elements with only parsed character data are declared with
#PCDATA inside parentheses:

            <!ELEMENT element-name (#PCDATA)>

            Example:
            <!ELEMENT from (#PCDATA)>


            Elements with any Contents

            Elements declared with the category keyword ANY, can
            contain any combination of parsable data:

            <!ELEMENT element-name ANY>

            Example:
            <!ELEMENT note ANY>


            Elements with Children (sequences)

            Elements with one or more children are declared with the
            name of the children elements inside parentheses:

            <!ELEMENT element-name (child1)>

            or
            <!ELEMENT element-name (child1,child2,...)>

                evince -p 97 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example:
            <!ELEMENT note (to,from,heading,body)>

            When children are declared in a sequence separated by
            commas, the children must appear in the same sequence in
            the document. In a full declaration, the children must also be
            declared, and the children can also have children. The full
            declaration of the "note" element is:

            <!ELEMENT note (to,from,heading,body)>
            <!ELEMENT to (#PCDATA)>
            <!ELEMENT from (#PCDATA)>
            <!ELEMENT heading (#PCDATA)>
            <!ELEMENT body (#PCDATA)>


            Declaring Only One Occurrence of an Element

            <!ELEMENT element-name (child-name)>

            Example:
            <!ELEMENT note (message)>

            The example above declares that the child element
            "message" must occur once, and only once inside the "note"
            element.


            Declaring Minimum One Occurrence of an Element

            <!ELEMENT element-name (child-name+)>

            Example:
            <!ELEMENT note (message+)>

            The + sign in the example above declares that the child
            element "message" must occur one or more times inside the
            "note" element.

                evince -p 98 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Declaring Zero or More Occurrences of an Element

            <!ELEMENT element-name (child-name*)>

            Example:
            <!ELEMENT note (message*)>

            The * sign in the example above declares that the child
            element "message" can occur zero or more times inside the
            "note" element.


            Declaring Zero or One Occurrences of an Element

            <!ELEMENT element-name (child-name?)>

            Example:
            <!ELEMENT note (message?)>

            The ? sign in the example above declares that the child
            element "message" can occur zero or one time inside the
            "note" element.


            Declaring either/or Content

            <!ELEMENT note (to,from,header,(message|body))>

            The example above declares that the "note" element must
            contain a "to" element, a "from" element, a "header"
            element, and either a "message" or a "body" element.

                evince -p 99 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Declaring Mixed Content

            <!ELEMENT note (#PCDATA|to|from|header|message)*>

            The example above declares that the "note" element can
            contain zero or more occurrences of parsed character data,
            "to", "from", "header", or "message" elements.

                evince -p 103 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            DTD - Attributes

            In a DTD, attributes are declared with an ATTLIST
            declaration.


            Declaring Attributes

            An attribute declaration has the following syntax:


            <!ATTLIST element-name attribute-name
            attribute-type attribute-value>

            DTD example:
            <!ATTLIST payment type CDATA "check">

            XML example:
            <payment type="check" />


            The attribute-type can be one of the following:

            Type    Description

            CDATA
            The value is character data

            (en1|en2|..)
            The value must be one from an enumerated list

                evince -p 104 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            ID
            The value is a unique id

            IDREF
            The value is the id of another element

            IDREFS
            The value is a list of other ids

            NMTOKEN
            The value is a valid XML name

            NMTOKENS
            The value is a list of valid XML names

            ENTITY
            The value is an entity

            ENTITIES
            The value is a list of entities

            NOTATION
            The value is a name of a notation xml:

            The value is a predefined xml value


            The attribute-value can be one of the following:

            Value   Explanation

            value
            The default value of the attribute

#REQUIRED
            The attribute is required

#IMPLIED
            The attribute is optional value

#FIXED value
            The attribute value is fixed


            A Default Attribute Value

            DTD:
            <!ELEMENT square EMPTY>
            <!ATTLIST square width CDATA "0">

            Valid XML:
            <square width="100" />

            In the example above, the "square" element is defined to be
            an empty element with a "width" attribute of type CDATA. If
            no width is specified, it has a default value of 0.

                evince -p 105 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

#REQUIRED

            Syntax

            <!ATTLIST element-name attribute-name attribute-type #REQUIRED>


            Example

            DTD:
            <!ATTLIST person number CDATA #REQUIRED>

            Valid XML:
            <person number="5677" />

            Invalid XML:
            <person />

            Use the #REQUIRED keyword if you don't have an option for
            a default value, but still want to force the attribute to be
            present.


#IMPLIED

            Syntax

            <!ATTLIST element-name attribute-name
            attribute-type #IMPLIED>

            Example

            DTD:
            <!ATTLIST contact fax CDATA #IMPLIED>

            Valid XML:
            <contact fax="555-667788" />

            Valid XML:
            <contact />

                evince -p 106 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Use the #IMPLIED keyword if you don't want to force the
            author to include an attribute, and you don't have an option
            for a default value.


#FIXED

            Syntax

            <!ATTLIST element-name attribute-name
            attribute-type #FIXED "value">


            Example

            DTD:
            <!ATTLIST sender company CDATA #FIXED "Microsoft">

            Valid XML:
            <sender company="Microsoft" />

            Invalid XML:
            <sender company="W3Schools" />

            Use the #FIXED keyword when you want an attribute to
            have a fixed value without allowing the author to change it.
            If an author includes another value, the XML parser will
            return an error.


            Enumerated Attribute Values

            Syntax

            <!ATTLIST element-name attribute-name
            (en1|en2|..) default-value>

                evince -p 107 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example

            DTD:
            <!ATTLIST payment type (check|cash) "cash">

            XML example:
            <payment type="check" />

            or

            <payment type="cash" />

            Use enumerated attribute values when you want the
            attribute value to be one of a fixed set of legal values.

                evince -p 112 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Elements vs. Attributes

            In XML, there are no rules about when to use attributes,
            and when to use child elements.


            Use of Elements vs. Attributes

            Data can be stored in child elements or in attributes.

            Take a look at these examples:

            <person sex="female">
              <firstname>Anna</firstname>
              <lastname>Smith</lastname>
            </person>

            <person>
              <sex>female</sex>
              <firstname>Anna</firstname>
              <lastname>Smith</lastname>
            </person>

            In the first example sex is an attribute. In the last, sex is a
            child element. Both examples provide the same information.

                evince -p 113 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            There are no rules about when to use attributes, and when
            to use child elements. My experience is that attributes are
            handy in HTML, but in XML you should try to avoid them. Use
            child elements if the information feels like data.


            My Favorite Way

            I like to store data in child elements.

            The following three XML documents contain exactly the same
            information:

            A date attribute is used in the first example:

            <note date="12/11/2002">
              <to>Tove</to>
              <from>Jani</from>
              <heading>Reminder</heading>
              <body>Don't forget me this weekend!</body>
            </note>

            A date element is used in the second example:

            <note>
              <date>12/11/2002</date>
              <to>Tove</to>
              <from>Jani</from>
              <heading>Reminder</heading>
              <body>Don't forget me this weekend!</body>
            </note>

            An expanded date element is used in the third: (THIS IS MY
            FAVORITE):

            <note>
              <date>
                <day>12</day>
                <month>11</month>
                <year>2002</year>
              </date>
              <to>Tove</to>
              <from>Jani</from>
              <heading>Reminder</heading>
              <body>Don't forget me this weekend!</body>
            </note>

                evince -p 114 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Avoid using attributes?

            Should you avoid using attributes?

            Some of the problems with attributes are:

            - attributes cannot contain multiple values (child elements can)
            - attributes are not easily expandable (for future changes)
            - attributes cannot describe structures (child elements can)
            - attributes are more difficult to manipulate by program code
            - attribute values are not easy to test against a DTD

            If you use attributes as containers for data, you end up with
            documents that are difficult to read and maintain. Try to use
            elements to describe data. Use attributes only to provide
            information that is not relevant to the data.

            Don't end up like this (this is not how XML should be used):

            <note day="12" month="11" year="2002"
            to="Tove" from="Jani" heading="Reminder"
            body="Don't forget me this weekend!">
            </note>


            An Exception to my Attribute Rule

            Rules always have exceptions.

            My rule about attributes has one exception:

            Sometimes I assign ID references to elements. These ID
            references can be used to access XML elements in much the
            same way as the NAME or ID attributes in HTML. This
            example demonstrates this:

            <messages>
            <note id="p501">
              <to>Tove</to>

                evince -p 115 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

              <from>Jani</from>
              <heading>Reminder</heading> 
              <body>Don't forget me this weekend!</body>
            </note>

            <note id="p502">
              <to>Jani</to>
              <from>Tove</from>
              <heading>Re: Reminder</heading>
              <body>I will not!</body>
            </note>
            </messages>

            The ID in these examples is just a counter, or a unique
            identifier, to identify the different notes in the XML file, and
            not a part of the note data.

            What I am trying to say here is that metadata (data about
            data) should be stored as attributes, and that data itself
            should be stored as elements.

                evince -p 120 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            DTD - Entities

            Entities are used to define shortcuts to special
            characters.

            Entities can be declared internal or external.


            An Internal Entity Declaration

            Syntax

            <!ENTITY entity-name "entity-value">

            Example

            DTD Example:
            <!ENTITY writer "Donald Duck.">
            <!ENTITY copyright "Copyright W3Schools.">

            XML example:
            <author>&writer;&copyright;</author>

            Note: An entity has three parts: an ampersand (&), an
            entity name, and a semicolon (;).

                evince -p 121 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            An External Entity Declaration

            Syntax

            <!ENTITY entity-name SYSTEM "URI/URL">

            Example

            DTD Example:
            <!ENTITY writer SYSTEM "http://www.w3schools.com/entities.dtd">
            <!ENTITY copyright SYSTEM "http://www.w3schools.com/entities.dtd">

            XML example:
            <author>&writer;&copyright;</author>

                evince -p 126 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            DTD Validation

            With Internet Explorer you can validate your XML against
            a DTD.


            Validating With the XML Parser

            If you try to open an XML document, the XML Parser might
            generate an error. By accessing the parseError object, you
            can retrieve the error code, the error text, or even the line
            that caused the error.

            Note: The load() method is used for files, while the
            loadXML() method is used for strings.

            Example

            var xmlDoc = new
            ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.async="false";
            xmlDoc.validateOnParse="true";
            xmlDoc.load("note_dtd_error.xml");

            document.write("<br />Error Code: ");
            document.write(xmlDoc.parseError.errorCode);
            document.write("<br />Error Reason: ");
            document.write(xmlDoc.parseError.reason);
            document.write("<br />Error Line: ");
            document.write(xmlDoc.parseError.line);

                evince -p 127 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

              Look at the XML file (note_dtd_error.xml)


            Turn Validation Off

            Validation can be turned off by setting the XML parser's
            validateOnParse="false".

            Example
            var xmlDoc = new
            ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.async="false";
            xmlDoc.validateOnParse="false";
            xmlDoc.load("note_dtd_error.xml");

            document.write("<br />Error Code: ");
            document.write(xmlDoc.parseError.errorCode);
            document.write("<br />Error Reason: ");
            document.write(xmlDoc.parseError.reason);
            document.write("<br />Error Line: ");
            document.write(xmlDoc.parseError.line);


            A General XML Validator

            To help you check your xml files, you can syntax-check any
            XML file (/dom/dom_validate.asp) here.


            The parseError Object

            You can read more about the parseError object in our XML
            DOM tutorial (/dom/default.asp).

                evince -p 132 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            DTD Examples

            TV Schedule DTD

            By David Moisan. Copied from http://www.davidmoisan.org/
            (http://www.davidmoisan.org/)

            <!DOCTYPE TVSCHEDULE [

            <!ELEMENT TVSCHEDULE (CHANNEL+)>
            <!ELEMENT CHANNEL (BANNER,DAY+)>
            <!ELEMENT BANNER (#PCDATA)>
            <!ELEMENT DAY (DATE,(HOLIDAY|PROGRAMSLOT+)+)>
            <!ELEMENT HOLIDAY (#PCDATA)>
            <!ELEMENT DATE (#PCDATA)>
            <!ELEMENT PROGRAMSLOT (TIME,TITLE,DESCRIPTION?)>
            <!ELEMENT TIME (#PCDATA)>
            <!ELEMENT TITLE (#PCDATA)>
            <!ELEMENT DESCRIPTION (#PCDATA)>

            <!ATTLIST TVSCHEDULE NAME CDATA #REQUIRED>
            <!ATTLIST CHANNEL CHAN CDATA #REQUIRED>
            <!ATTLIST PROGRAMSLOT VTR CDATA #IMPLIED>
            <!ATTLIST TITLE RATING CDATA #IMPLIED>
            <!ATTLIST TITLE LANGUAGE CDATA #IMPLIED>
            ]>

                evince -p 133 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Newspaper Article DTD

            Copied from http://www.vervet.com/
            (http://www.vervet.com/)

            <!DOCTYPE NEWSPAPER [
            <!ELEMENT NEWSPAPER (ARTICLE+)>
            <!ELEMENT ARTICLE
            (HEADLINE,BYLINE,LEAD,BODY,NOTES)>
            <!ELEMENT HEADLINE (#PCDATA)>
            <!ELEMENT BYLINE (#PCDATA)>
            <!ELEMENT LEAD (#PCDATA)>
            <!ELEMENT BODY (#PCDATA)>
            <!ELEMENT NOTES (#PCDATA)>
            <!ATTLIST ARTICLE AUTHOR CDATA #REQUIRED>
            <!ATTLIST ARTICLE EDITOR CDATA #IMPLIED>
            <!ATTLIST ARTICLE DATE CDATA #IMPLIED>
            <!ATTLIST ARTICLE EDITION CDATA #IMPLIED>

            <!ENTITY NEWSPAPER "Vervet Logic Times">
            <!ENTITY PUBLISHER "Vervet Logic Press">
            <!ENTITY COPYRIGHT "Copyright 1998 Vervet Logic Press">
            ]>


            Product Catalog DTD

            Copied from http://www.vervet.com/
            (http://www.vervet.com/)

            <!DOCTYPE CATALOG [

            <!ENTITY AUTHOR "John Doe">
            <!ENTITY COMPANY "JD Power Tools, Inc.">
            <!ENTITY EMAIL "jd@jd-tools.com">

            <!ELEMENT CATALOG (PRODUCT+)>

            <!ELEMENT PRODUCT
            (SPECIFICATIONS+,OPTIONS?,PRICE+,NOTES?)>
            <!ATTLIST PRODUCT
            NAME CDATA #IMPLIED
            CATEGORY (HandTool|Table|Shop-Professional)
            "HandTool"
            PARTNUM CDATA #IMPLIED

                evince -p 134 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            PLANT (Pittsburgh|Milwaukee|Chicago) "Chicago"
            INVENTORY (InStock|Backordered|Discontinued)
            "InStock">
            <!ELEMENT SPECIFICATIONS (#PCDATA)>
            <!ATTLIST SPECIFICATIONS
            WEIGHT CDATA #IMPLIED
            POWER CDATA #IMPLIED>

            <!ELEMENT OPTIONS (#PCDATA)>
            <!ATTLIST OPTIONS
            FINISH (Metal|Polished|Matte) "Matte"
            ADAPTER (Included|Optional|NotApplicable)
            "Included"
            CASE (HardShell|Soft|NotApplicable) "HardShell">

            <!ELEMENT PRICE (#PCDATA)>
            <!ATTLIST PRICE
            MSRP CDATA #IMPLIED
            WHOLESALE CDATA #IMPLIED
            STREET CDATA #IMPLIED
            SHIPPING CDATA #IMPLIED>

            <!ELEMENT NOTES (#PCDATA)>

            ]>

                evince -p 139 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Schema

            An XML Schema describes the structure of an XML
            document, just like a DTD.

            An XML document with correct syntax is called "Well Formed".

            An XML document validated against an XML Schema is
            both "Well Formed" and "Valid".


            XML Schema

            XML Schema is an XML-based alternative to DTD:

            <xs:element name="note">

            <xs:complexType>
              <xs:sequence>
                <xs:element name="to" type="xs:string"/>
                <xs:element name="from" type="xs:string"/>
                <xs:element name="heading" type="xs:string"/>
                <xs:element name="body" type="xs:string"/>
              </xs:sequence>
            </xs:complexType>

            </xs:element>

            The Schema above is interpreted like this:

                evince -p 140 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            - <xs:element name="note"> defines the element called "note"
            - <xs:complexType> the "note" element is a complex type
            - <xs:sequence> the complex type is a sequence of elements
            - <xs:element name="to" type="xs:string"> the element
              "to" is of type string (text)
            - <xs:element name="from" type="xs:string"> the
              element "from" is of type string
            - <xs:element name="heading" type="xs:string"> the
              element "heading" is of type string
            - <xs:element name="body" type="xs:string"> the
              element "body" is of type string

            Everything is wrapped in "Well Formed" XML.

            XML Schemas are More Powerful than DTD

            - XML Schemas are written in XML
            - XML Schemas are extensible to additions
            - XML Schemas support data types
            - XML Schemas support namespaces


            Why Use an XML Schema?

            With XML Schema, your XML files can carry a description of
            its own format.

            With XML Schema, independent groups of people can agree
            on a standard for interchanging data.

            With XML Schema, you can verify data.

                evince -p 141 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Schemas Support Data Types

            One of the greatest strength of XML Schemas is the support
            for data types:

            It is easier to:
            - describe document content
            - define restrictions on data
            - validate the correctness of data
            - convert data between different data types


            XML Schemas use XML Syntax

            Another great strength about XML Schemas is that they are
            written in XML:

            - You don't have to learn a new language
            - You can use your XML editor to edit your Schema files
            - You can use your XML parser to parse your Schema files
            - You can manipulate your Schemas with the XML DOM
            - You can transform your Schemas with XSLT

            If you want to study XML Schema, please read our XML
            Schema Tutorial (/schema/default.asp).

                evince -p 146 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Schema Tutorial

            An XML Schema describes the structure of
            an XML document.

            In this tutorial you will learn how to create
            XML Schemas and how to use XML
            Schemas in your application.

            XML Schema Example

            <?xml version="1.0"?>
            <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">

            <xs:element name="note">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="to" type="xs:string"/>
                  <xs:element name="from" type="xs:string"/>
                  <xs:element name="heading" type="xs:string"/>
                  <xs:element name="body" type="xs:string"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>

            </xs:schema>

                evince -p 147 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            What You Should Already Know

            Before you continue you should have a basic understanding
            of the following:

            - HTML
            - XML
            - A basic understanding of DTD

            If you want to study these subjects first, find the tutorials on
            our Home page (/default.asp).


            What is an XML Schema?

            The purpose of an XML Schema is to define the legal building
            blocks of an XML document, just like a DTD.

            An XML Schema:

            - defines elements that can appear in a document
            - defines attributes that can appear in a document
            - defines which elements are child elements
            - defines the order of child elements
            - defines the number of child elements
            - defines whether an element is empty or can include text
            - defines data types for elements and attributes
            - defines default and fixed values for elements and attributes

            XML Schema is a W3C Recommendation
            XML Schema became a W3C Recommendation 02. May 2001.

                evince -p 152 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Why Use XML Schemas?

            XML Schemas is an XML-based alternative to DTD.

            XML Schemas are much more powerful than DTDs.

            The XML Schema language is also referred to as XML
            Schema Definition (XSD).


            XML Schemas Support Data Types

            One of the greatest strength of XML Schemas is the support
            for data types.

            With support for data types, it is easier to: 
            - describe allowable document content
            - validate the correctness of data
            - work with data from a database
            - define data facets (restrictions on data)
            - define data patterns (data formats)
            - convert data between different data types

                evince -p 153 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Schemas use XML Syntax

            Another great strength about XML Schemas is that they are
            written in XML.

            Some benefits of that XML Schemas are written in XML:

            - You don't have to learn a new language
            - You can use your XML editor to edit your Schema files
            - You can use your XML parser to parse your Schema files
            - You can manipulate your Schema with the XML DOM
            - You can transform your Schema with XSLT


            XML Schemas Secure Data Communication

            When sending data from a sender to a receiver, it is essential
            that both parts have the same "expectations" about the content.

            With XML Schemas, the sender can describe the data in a
            way that the receiver will understand.

            A date like: "03-11-2004" will, in some countries, be
            interpreted as 3.November and in other countries as
            11.March.

            However, an XML element with a data type like this:

            <date type="date">2004-03-11</date>

            ensures a mutual understanding of the content, because the
            XML data type "date" requires the format "YYYY-MM-DD".


            XML Schemas are Extensible

            XML Schemas are extensible, because they are written in XML.

            With an extensible Schema definition you can:
            - Reuse your Schema in other Schemas
            - Create your own data types derived from the standard types
            - Reference multiple schemas in the same document

                evince -p 154 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Well-Formed is not Enough

            A well-formed XML document is a document that conforms to
            the XML syntax rules, like:

            - it must begin with the XML declaration
            - it must have one unique root element
            - start-tags must have matching end-tags
            - elements are case sensitive
            - all elements must be closed
            - all elements must be properly nested
            - all attribute values must be quoted
            - entities must be used for special characters

            Even if documents are well-formed they can still contain
            errors, and those errors can have serious consequences.
            Think of the following situation: you order 5 gross of laser
            printers, instead of 5 laser printers. With XML Schemas,
            most of these errors can be caught by your validating software.

                evince -p 159 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD How To?

            XML documents can have a reference to a DTD or to an XML Schema.


            A Simple XML Document

            Look at this simple XML document called "note.xml":

            <?xml version="1.0"?>
            <note>
              <to>Tove</to>
              <from>Jani</from>
              <heading>Reminder</heading>
              <body>Don't forget me this weekend!</body>
            </note>


            A DTD File

            The following example is a DTD file called "note.dtd" that
            defines the elements of the XML document above ("note.xml"):

            <!ELEMENT note (to, from, heading, body)>
            <!ELEMENT to (#PCDATA)>
            <!ELEMENT from (#PCDATA)>
            <!ELEMENT heading (#PCDATA)>
            <!ELEMENT body (#PCDATA)>

                evince -p 160 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The first line defines the note element to have four child
            elements: "to, from, heading, body".

            Line 2-5 defines the to, from, heading, body elements to be
            of type "#PCDATA".


            An XML Schema

            The following example is an XML Schema file called
            "note.xsd" that defines the elements of the XML document
            above ("note.xml"):

            <?xml version="1.0"?>
            <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
            targetNamespace="http://www.w3schools.com"
            xmlns="http://www.w3schools.com"
            elementFormDefault="qualified">

            <xs:element name="note">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="to" type="xs:string"/>
                  <xs:element name="from" type="xs:string"/>
                  <xs:element name="heading" type="xs:string"/>
                  <xs:element name="body" type="xs:string"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>

            </xs:schema>

            The note element is a complex type because it contains
            other elements. The other elements (to, from, heading,
            body) are simple types because they do not contain other
            elements. You will learn more about simple and complex
            types in the following chapters.

                evince -p 161 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            A Reference to a DTD

            This XML document has a reference to a DTD:

            <?xml version="1.0"?>
            <!DOCTYPE note SYSTEM
            "http://www.w3schools.com/dtd/note.dtd">

            <note>
              <to>Tove</to>
              <from>Jani</from>
              <heading>Reminder</heading>
              <body>Don't forget me this weekend!</body>
            </note>


            A Reference to an XML Schema

            This XML document has a reference to an XML Schema:

            <?xml version="1.0"?>

            <note
            xmlns="http://www.w3schools.com"
            xmlns:xsi="http://www.w3.org/2001/XMLSchemainstance"
            xsi:schemaLocation="http://www.w3schools.com
                ___HM
            note.xsd">
              <to>Tove</to>
              <from>Jani</from>
              <heading>Reminder</heading>
              <body>Don't forget me this weekend!</body>
            </note>

                evince -p 166 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD - The <schema> Element

            The <schema> element is the root element of every XML Schema.


            The <schema> Element

            The <schema> element is the root element of every XML Schema:

            <?xml version="1.0"?>

            <xs:schema>
            ...
            ...
            </xs:schema>

            The <schema> element may contain some attributes. A
            schema declaration often looks something like this:

            <?xml version="1.0"?>

            <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
            targetNamespace="http://www.w3schools.com"
            xmlns="http://www.w3schools.com"
            elementFormDefault="qualified">
            ...
            ...
            </xs:schema>

                evince -p 167 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The following fragment:

            xmlns:xs="http://www.w3.org/2001/XMLSchema"

            indicates that the elements and data types used in the
            schema come from the "http://www.w3.org
            /2001/XMLSchema" namespace. It also specifies that the
            elements and data types that come from the
            "http://www.w3.org/2001/XMLSchema" namespace should
            be prefixed with xs:


            This fragment:

            targetNamespace="http://www.w3schools.com"

            indicates that the elements defined by this schema (note, to,
            from, heading, body.) come from the
            "http://www.w3schools.com" namespace.


            This fragment:

            xmlns="http://www.w3schools.com"

            indicates that the default namespace is
            "http://www.w3schools.com".


            This fragment:

            elementFormDefault="qualified"

            indicates that any elements used by the XML instance
            document which were declared in this schema must be
            namespace qualified.

                evince -p 168 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Referencing a Schema in an XML Document

            This XML document has a reference to an XML Schema:

            <?xml version="1.0"?>

            <note xmlns="http://www.w3schools.com"
            xmlns:xsi="http://www.w3.org/2001/XMLSchemainstance"
            xsi:schemaLocation="http://www.w3schools.com
            note.xsd">

            <to>Tove</to>
            <from>Jani</from>
            <heading>Reminder</heading>
            <body>Don't forget me this weekend!</body>
            </note>


            The following fragment:

            xmlns="http://www.w3schools.com"

            specifies the default namespace declaration. This declaration
            tells the schema-validator that all the elements used in this
            XML document are declared in the
            "http://www.w3schools.com" namespace.

            Once you have the XML Schema Instance namespace available:

            xmlns:xsi="http://www.w3.org/2001/XMLSchemainstance"

            you can use the schemaLocation attribute. This attribute has
            two values, separated by a space. The first value is the
            namespace to use. The second value is the location of the
            XML schema to use for that namespace:

            xsi:schemaLocation="http://www.w3schools.com note.xsd"

                evince -p 173 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD Simple Elements

            XML Schemas define the elements of your XML files.

            A simple element is an XML element that contains only
            text. It cannot contain any other elements or attributes.


            What is a Simple Element?

            A simple element is an XML element that can contain only
            text. It cannot contain any other elements or attributes.
            However, the "only text" restriction is quite misleading. The
            text can be of many different types. It can be one of the
            types included in the XML Schema definition (boolean, string,
            date, etc.), or it can be a custom type that you can define
            yourself.

            You can also add restrictions (facets) to a data type in order
            to limit its content, or you can require the data to match a
            specific pattern.

                evince -p 174 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Defining a Simple Element

            The syntax for defining a simple element is:

            <xs:element name="xxx" type="yyy"/>

            where xxx is the name of the element and yyy is the data
            type of the element.

            XML Schema has a lot of built-in data types. The most
            common types are:

            - xs:string
            - xs:decimal
            - xs:integer
            - xs:boolean
            - xs:date
            - xs:time


            Example

            Here are some XML elements:

            <lastname>Refsnes</lastname>
            <age>36</age>
            <dateborn>1970-03-27</dateborn>

            And here are the corresponding simple element definitions:

            <xs:element name="lastname" type="xs:string"/>
            <xs:element name="age" type="xs:integer"/>
            <xs:element name="dateborn" type="xs:date"/>


            Default and Fixed Values for Simple Elements

            Simple elements may have a default value OR
            a fixed value specified.

            A default value is automatically assigned to the element
            when no other value is specified.

            In the following example the default value is "red":

                evince -p 175 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:element name="color" type="xs:string" default="red"/>

            A fixed value is also automatically assigned to the element,
            and you cannot specify another value.

            In the following example the fixed value is "red":
            <xs:element name="color" type="xs:string"
            fixed="red"/>

                evince -p 180 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD Attributes

            All attributes are declared as simple types.


            What is an Attribute?

            Simple elements cannot have attributes. If an element has
            attributes, it is considered to be of a complex type. But the
            attribute itself is always declared as a simple type.


            How to Define an Attribute?

            The syntax for defining an attribute is:

            <xs:attribute name="xxx" type="yyy"/>

            where xxx is the name of the attribute and yyy specifies the
            data type of the attribute.

            XML Schema has a lot of built-in data types. The most
            common types are:

            - xs:string
            - xs:decimal
            - xs:integer
            - xs:boolean
            - xs:date
            - xs:time

                evince -p 181 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example

            Here is an XML element with an attribute:

            <lastname lang="EN">Smith</lastname>

            And here is the corresponding attribute definition:

            <xs:attribute name="lang" type="xs:string"/>


            Default and Fixed Values for Attributes

            Attributes may have a default value OR a fixed value specified.

            A default value is automatically assigned to the attribute
            when no other value is specified.

            In the following example the default value is "EN":

            <xs:attribute name="lang" type="xs:string" default="EN"/>

            A fixed value is also automatically assigned to the attribute,
            and you cannot specify another value.

            In the following example the fixed value is "EN":

            <xs:attribute name="lang" type="xs:string" fixed="EN"/>


            Optional and Required Attributes

            Attributes are optional by default. To specify that the
            attribute is required, use the "use" attribute:

                evince -p 182 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:attribute name="lang" type="xs:string" use="required"/>


            Restrictions on Content

            When an XML element or attribute has a data type defined, it
            puts restrictions on the element's or attribute's content.

            If an XML element is of type "xs:date" and contains a string
            like "Hello World", the element will not validate.

            With XML Schemas, you can also add your own restrictions
            to your XML elements and attributes. These restrictions are
            called facets. You can read more about facets in the next
            chapter.

                evince -p 187 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD Restrictions/Facets

            Restrictions are used to define acceptable values for XML
            elements or attributes. Restrictions on XML elements are
            called facets.


            Restrictions on Values

            The following example defines an element called "age" with a

            Complex Types

            restriction. The value of age cannot be lower than 0 or
            greater than 120:

            <xs:element name="age">
              <xs:simpleType>
                <xs:restriction base="xs:integer">
                  <xs:minInclusive value="0"/>
                  <xs:maxInclusive value="120"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>


            Restrictions on a Set of Values

            To limit the content of an XML element to a set of acceptable
            values, we would use the enumeration constraint.

                evince -p 188 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The example below defines an element called "car" with a
            restriction. The only acceptable values are: Audi, Golf, BMW:

            <xs:element name="car"
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="Audi"/>
                  <xs:enumeration value="Golf"/>
                  <xs:enumeration value="BMW"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>

            The example above could also have been written like this:

            <xs:element name="car" type="carType"/>

            <xs:simpleType name="carType">
              <xs:restriction base="xs:string">
                <xs:enumeration value="Audi"/>
                <xs:enumeration value="Golf"/>
                <xs:enumeration value="BMW"/>
              </xs:restriction>
            </xs:simpleType>

            Note: In this case the type "carType" can be used by other
            elements because it is not a part of the "car" element.


            Restrictions on a Series of Values

            To limit the content of an XML element to define a series of
            numbers or letters that can be used, we would use the
            pattern constraint.

            The example below defines an element called "letter" with a
            restriction. The only acceptable value is ONE of the
            LOWERCASE letters from a to z:

            <xs:element name="letter">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:pattern value="[a-z]"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>

                evince -p 189 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The next example defines an element called "initials" with a
            restriction. The only acceptable value is THREE of the
            UPPERCASE letters from a to z:

            <xs:element name="initials">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:pattern value="[A-Z][A-Z][A-Z]"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>

            The next example also defines an element called "initials"
            with a restriction. The only acceptable value is THREE of the
            LOWERCASE OR UPPERCASE letters from a to z:

            <xs:element name="initials">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:pattern value="[a-zA-Z][a-zAZ][a-zA-Z]"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>

            The next example defines an element called "choice" with a
            restriction. The only acceptable value is ONE of the following
            letters: x, y, OR z:

            <xs:element name="choice">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:pattern value="[xyz]"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>

            The next example defines an element called "prodid" with a
            restriction. The only acceptable value is FIVE digits in a
            sequence, and each digit must be in a range from 0 to 9:

                evince -p 190 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:element name="prodid">
              <xs:simpleType>
                <xs:restriction base="xs:integer">
                  <xs:pattern value="[0-9][0-9][0-9][0-9][0-9]"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>


            Other Restrictions on a Series of Values

            The example below defines an element called "letter" with a
            restriction. The acceptable value is zero or more occurrences
            of lowercase letters from a to z:

            <xs:element name="letter">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:pattern value="([a-z])*"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>

            The next example also defines an element called "letter" with
            a restriction. The acceptable value is one or more pairs of
            letters, each pair consisting of a lower case letter followed by
            an upper case letter. For example, "sToP" will be validated by
            this pattern, but not "Stop" or "STOP" or "stop":

            <xs:element name="letter">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:pattern value="([a-z][A-Z])+"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>

            The next example defines an element called "gender" with a
            restriction. The only acceptable value is male OR female:

            <xs:element name="gender">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:pattern value="male|female"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>

                evince -p 191 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The next example defines an element called "password" with
            a restriction. There must be exactly eight characters in a row
            and those characters must be lowercase or uppercase letters
            from a to z, or a number from 0 to 9:

            <xs:element name="password">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:pattern value="[a-zA-Z0-9]{8}"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>


            Restrictions on Whitespace Characters

            To specify how whitespace characters should be handled, we
            would use the whiteSpace constraint.

            This example defines an element called "address" with a
            restriction. The whiteSpace constraint is set to "preserve",
            which means that the XML processor WILL NOT remove any
            white space characters:

            <xs:element name="address">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:whiteSpace value="preserve"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>

            This example also defines an element called "address" with a
            restriction. The whiteSpace constraint is set to "replace",
            which means that the XML processor WILL REPLACE all white
            space characters (line feeds, tabs, spaces, and carriage
            returns) with spaces:

                evince -p 192 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:element name="address">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:whiteSpace value="replace"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>

            This example also defines an element called "address" with a
            restriction. The whiteSpace constraint is set to "collapse",
            which means that the XML processor WILL REMOVE all white
            space characters (line feeds, tabs, spaces, carriage returns
            are replaced with spaces, leading and trailing spaces are
            removed, and multiple spaces are reduced to a single space):

            <xs:element name="address">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:whiteSpace value="collapse"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>


            Restrictions on Length

            To limit the length of a value in an element, we would use
            the length, maxLength, and minLength constraints.
            This example defines an element called "password" with a
            restriction. The value must be exactly eight characters:

            <xs:element name="password">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:length value="8"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>

            This example defines another element called "password" with
            a restriction. The value must be minimum five characters
            and maximum eight characters:

                evince -p 193 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:element name="password">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:minLength value="5"/>
                  <xs:maxLength value="8"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>


            Restrictions for Datatypes

            Constraint      Description

            enumeration
             --
            Defines a list of acceptable values

            fractionDigits
             --
            Specifies the maximum number of decimal
            places allowed. Must be equal to or greater
            than zero

            length
             --
            Specifies the exact number of characters or
            list items allowed. Must be equal to or
            greater than zero

            maxExclusive
             --
            Specifies the upper bounds for numeric
            values (the value must be less than this value)

            maxInclusive
             --
            Specifies the upper bounds for numeric
            values (the value must be less than or
            equal to this value)

            maxLength
             --
            Specifies the maximum number of
            characters or list items allowed. Must be
            equal to or greater than zero

            minExclusive
             --
            Specifies the lower bounds for numeric
            values (the value must be greater than this value)

                evince -p 194 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            minInclusive
             --
            Specifies the lower bounds for numeric
            values (the value must be greater than or
            equal to this value)

            minLength
             --
            Specifies the minimum number of
            characters or list items allowed. Must be
            equal to or greater than zero

            pattern
             --
            Defines the exact sequence of characters
            that are acceptable

            totalDigits
             --
            Specifies the exact number of digits
            allowed. Must be greater than zero

            whiteSpace
             --
            Specifies how white space (line feeds, tabs,
            spaces, and carriage returns) is handled

                evince -p 199 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD Complex Elements

            A complex element contains other elements and/or
            attributes.


            What is a Complex Element?

            A complex element is an XML element that contains other
            elements and/or attributes.

            There are four kinds of complex elements:

            - empty elements
            - elements that contain only other elements
            - elements that contain only text
            - elements that contain both other elements and text

            Note: Each of these elements may contain attributes as well!

            Examples of Complex Elements

            A complex XML element, "product", which is empty:
            <product pid="1345"/>


            A complex XML element, "employee", which contains only
            other elements:

                evince -p 200 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <employee>
              <firstname>John</firstname>
              <lastname>Smith</lastname>
            </employee>

            A complex XML element, "food", which contains only text:

            <food type="dessert">Ice cream</food>

            A complex XML element, "description", which contains both

            <description>
            It happened on <date
            lang="norwegian">03.03.99</date> ....
            </description>


            How to Define a Complex Element

            Look at this complex XML element, "employee", which
            contains only other elements:

            <employee>
              <firstname>John</firstname>
              <lastname>Smith</lastname>
            </employee>

            We can define a complex element in an XML Schema two
            different ways:

            1. The "employee" element can be declared directly by
            naming the element, like this:

            <xs:element name="employee">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="firstname" type="xs:string"/>
                  <xs:element name="lastname" type="xs:string"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>

                evince -p 201 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            If you use the method described above, only the "employee"
            element can use the specified complex type. Note that the
            child elements, "firstname" and "lastname", are surrounded
            by the <sequence> indicator. This means that the child
            elements must appear in the same order as they are
            declared. You will learn more about indicators in the XSD
            Indicators chapter.

            2. The "employee" element can have a type attribute that
            refers to the name of the complex type to use:

            <xs:element name="employee" type="personinfo"/>

            <xs:complexType name="personinfo">
              <xs:sequence>
                <xs:element name="firstname" type="xs:string"/>
                <xs:element name="lastname" type="xs:string"/>
              </xs:sequence>
            </xs:complexType>

            If you use the method described above, several elements
            can refer to the same complex type, like this:

            <xs:element name="employee" type="personinfo"/>
            <xs:element name="student" type="personinfo"/>
            <xs:element name="member" type="personinfo"/>

            <xs:complexType name="personinfo">
              <xs:sequence>
                <xs:element name="firstname" type="xs:string"/>
                <xs:element name="lastname" type="xs:string"/>
              </xs:sequence>
            </xs:complexType>

            You can also base a complex element on an existing complex
            element and add some elements, like this:

                evince -p 202 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:element name="employee" type="fullpersoninfo"/>

            <xs:complexType name="personinfo">
              <xs:sequence>
                <xs:element name="firstname" type="xs:string"/>
                <xs:element name="lastname" type="xs:string"/>
              </xs:sequence>
            </xs:complexType>

            <xs:complexType name="fullpersoninfo">
              <xs:complexContent>
                <xs:extension base="personinfo">
                  <xs:sequence>
                    <xs:element name="address" type="xs:string"/>
                    <xs:element name="city" type="xs:string"/>
                    <xs:element name="country" type="xs:string"/>
                  </xs:sequence>
                </xs:extension>
              </xs:complexContent>
            </xs:complexType>

                evince -p 207 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD Empty Elements

            An empty complex element cannot have contents, only
            attributes.


            Complex Empty Elements

            An empty XML element:

            <product prodid="1345" />

            The "product" element above has no content at all. To define
            a type with no content, we must define a type that allows
            elements in its content, but we do not actually declare any
            elements, like this:

            <xs:element name="product">
              <xs:complexType>
                <xs:complexContent>
                  <xs:restriction base="xs:integer">
                    <xs:attribute name="prodid" type="xs:positiveInteger"/>
                  </xs:restriction>
                </xs:complexContent>
              </xs:complexType>
            </xs:element>

                evince -p 208 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            In the example above, we define a complex type with a
            complex content. The complexContent element signals that
            we intend to restrict or extend the content model of a
            complex type, and the restriction of integer declares one
            attribute but does not introduce any element content.

            However, it is possible to declare the "product" element more
            compactly, like this:


            <xs:element name="product">
              <xs:complexType>
                <xs:attribute name="prodid" type="xs:positiveInteger"/>
              </xs:complexType>
            </xs:element>

            Or you can give the complexType element a name, and let
            the "product" element have a type attribute that refers to
            the name of the complexType (if you use this method,
            several elements can refer to the same complex type):

            <xs:element name="product" type="prodtype"/>

            <xs:complexType name="prodtype">
              <xs:attribute name="prodid" type="xs:positiveInteger"/>
            </xs:complexType>

                evince -p 213 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD Elements Only

            An "elements-only" complex type contains an element
            that contains only other elements.


            Complex Types Containing Elements Only

            An XML element, "person", that contains only other elements:

            <person>
              <firstname>John</firstname>
              <lastname>Smith</lastname>
            </person>

            You can define the "person" element in a schema, like this:

                evince -p 214 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:element name="person">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="firstname" type="xs:string"/>
                  <xs:element name="lastname" type="xs:string"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>

            Notice the <xs:sequence> tag. It means that the elements
            defined ("firstname" and "lastname") must appear in that
            order inside a "person" element.

            Or you can give the complexType element a name, and let
            the "person" element have a type attribute that refers to the
            name of the complexType (if you use this method, several
            elements can refer to the same complex type):

            <xs:element name="person" type="persontype"/>

            <xs:complexType name="persontype">
              <xs:sequence>
                <xs:element name="firstname" type="xs:string"/>
                <xs:element name="lastname" type="xs:string"/>
              </xs:sequence>
            </xs:complexType>

                evince -p 219 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD Text-Only Elements

            A complex text-only element can contain text and
            attributes.


            Complex Text-Only Elements

            This type contains only simple content (text and attributes),
            therefore we add a simpleContent element around the
            content. When using simple content, you must define an
            extension OR a restriction within the simpleContent element,
            like this:

            <xs:element name="somename">
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="basetype">
                    ....
                    ....
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>

            OR

                evince -p 220 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:element name="somename">
              <xs:complexType>
                <xs:simpleContent>
                  <xs:restriction base="basetype">
                    ....
                    ....
                  </xs:restriction>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>

            Tip: Use the extension/restriction element to expand or to
            limit the base simple type for the element.

            Here is an example of an XML element, "shoesize", that
            contains text-only:

            <shoesize country="france">35</shoesize>

            The following example declares a complexType, "shoesize".
            The content is defined as an integer value, and the
            "shoesize" element also contains an attribute named "country":

            <xs:element name="shoesize">
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:integer">
                    <xs:attribute name="country" type="xs:string" />
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>

            We could also give the complexType element a name, and let
            the "shoesize" element have a type attribute that refers to
            the name of the complexType (if you use this method,
            several elements can refer to the same complex type):

            <xs:element name="shoesize" type="shoetype"/>

            <xs:complexType name="shoetype">
              <xs:simpleContent>
                <xs:extension base="xs:integer">
                  <xs:attribute name="country" type="xs:string" />
                </xs:extension>
              </xs:simpleContent>
            </xs:complexType>

                evince -p 225 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD Mixed Content

            A mixed complex type element can contain attributes,
            elements, and text.


            Complex Types with Mixed Content

            An XML element, "letter", that contains both text and other elements:

            <letter>
              Dear Mr.<name>John Smith</name>.
              Your order <orderid>1032</orderid>
              will be shipped on
            <shipdate>2001-07-13</shipdate>.
            </letter>

            The following schema declares the "letter" element:

            <xs:element name="letter">
              <xs:complexType mixed="true">
                <xs:sequence>
                  <xs:element name="name" type="xs:string"/>
                  <xs:element name="orderid" type="xs:positiveInteger"/>
                  <xs:element name="shipdate" type="xs:date"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>

                evince -p 226 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Note: To enable character data to appear between the child-
            elements of "letter", the mixed attribute must be set to
            "true". The <xs:sequence> tag means that the elements
            defined (name, orderid and shipdate) must appear in that
            order inside a "letter" element.

            We could also give the complexType element a name, and let
            the "letter" element have a type attribute that refers to the
            name of the complexType (if you use this method, several
            elements can refer to the same complex type):

            <xs:element name="letter" type="lettertype"/>

            <xs:complexType name="lettertype" mixed="true">
              <xs:sequence>
                <xs:element name="name" type="xs:string"/>
                <xs:element name="orderid" type="xs:positiveInteger"/>
                <xs:element name="shipdate" type="xs:date"/>
              </xs:sequence>
            </xs:complexType>

                evince -p 231 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD Indicators

            We can control HOW elements are to be used in
            documents with indicators.


            Indicators

            There are seven indicators:

            Order indicators:
            - All
            - Choice
            - Sequence

            Occurrence indicators:
            - maxOccurs
            - minOccurs

            Group indicators:
            - Group name
            - attributeGroup name


            Order Indicators

            Order indicators are used to define the order of the elements.

                evince -p 232 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            All Indicator

            The <all> indicator specifies that the child elements can
            appear in any order, and that each child element must occur
            only once:

            <xs:element name="person">
              <xs:complexType>
                <xs:all>
                  <xs:element name="firstname" type="xs:string"/>
                  <xs:element name="lastname" type="xs:string"/>
                </xs:all>
              </xs:complexType>
            </xs:element>

            Note: When using the <all> indicator you can set the
            <minOccurs> indicator to 0 or 1 and the <maxOccurs>
            indicator can only be set to 1 (the <minOccurs> and
            <maxOccurs> are described later).


            Choice Indicator

            The <choice> indicator specifies that either one child
            element or another can occur:

            <xs:element name="person">
              <xs:complexType>
                <xs:choice>
                  <xs:element name="employee" type="employee"/>
                  <xs:element name="member" type="member"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>


            Sequence Indicator

            The <sequence> indicator specifies that the child elements
            must appear in a specific order:

                evince -p 233 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:element name="person">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="firstname" type="xs:string"/>
                  <xs:element name="lastname" type="xs:string"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>


            Occurrence Indicators

            Occurrence indicators are used to define how often an
            element can occur.

            Note: For all "Order" and "Group" indicators (any, all, choice,
            sequence, group name, and group reference) the default
            value for maxOccurs and minOccurs is 1.


            maxOccurs Indicator

            The <maxOccurs> indicator specifies the maximum number
            of times an element can occur:

            <xs:element name="person">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="full_name" type="xs:string"/>
                  <xs:element name="child_name" type="xs:string" maxOccurs="10"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>

            The example above indicates that the "child_name" element
            can occur a minimum of one time (the default value for
            minOccurs is 1) and a maximum of ten times in the "person" element.


            minOccurs Indicator

            The <minOccurs> indicator specifies the minimum number
            of times an element can occur:

                evince -p 234 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:element name="person">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="full_name" type="xs:string"/>
                  <xs:element name="child_name" type="xs:string" maxOccurs="10" minOccurs="0"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>

            The example above indicates that the "child_name" element
            can occur a minimum of zero times and a maximum of ten
            times in the "person" element.

            Tip: To allow an element to appear an unlimited number of
            times, use the maxOccurs="unbounded" statement:

            A working example:

            An XML file called "Myfamily.xml":

            <?xml version="1.0" encoding="UTF-8"?>
            <persons xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:noNamespaceSchemaLocation="family.xsd">

            <person>
              <full_name>Hege Refsnes</full_name>
              <child_name>Cecilie</child_name>
            </person>

            <person>
              <full_name>Tove Refsnes</full_name>
              <child_name>Hege</child_name>
              <child_name>Stale</child_name>
              <child_name>Jim</child_name>
              <child_name>Borge</child_name>
            </person>

            <person>
              <full_name>Stale Refsnes</full_name>
            </person>

            </persons>
             
                evince -p 235 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The XML file above contains a root element named
            "persons". Inside this root element we have defined three
            "person" elements. Each "person" element must contain a
            "full_name" element and it can contain up to five
            "child_name" elements.

            Here is the schema file "family.xsd":

            <?xml version="1.0" encoding="UTF-8"?>
            <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
            elementFormDefault="qualified">

            <xs:element name="persons">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="person" maxOccurs="unbounded">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element name="full_name" type="xs:string"/>
                        <xs:element name="child_name" type="xs:string"
                            minOccurs="0" maxOccurs="5"/>
                      </xs:sequence>
                    </xs:complexType>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>

            </xs:schema>


            Group Indicators

            Group indicators are used to define related sets of elements.

            Element Groups

            Element groups are defined with the group declaration, like this:

                evince -p 236 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:group name="groupname">
            ...
            </xs:group>

            You must define an all, choice, or sequence element inside
            the group declaration. The following example defines a group
            named "persongroup", that defines a group of elements that
            must occur in an exact sequence:

            <xs:group name="persongroup">
              <xs:sequence>
                <xs:element name="firstname" type="xs:string"/>
                <xs:element name="lastname" type="xs:string"/>
                <xs:element name="birthday" type="xs:date"/>
              </xs:sequence>
            </xs:group>

            After you have defined a group, you can reference it in
            another definition, like this:

            <xs:group name="persongroup">
              <xs:sequence>
                <xs:element name="firstname" type="xs:string"/>
                <xs:element name="lastname" type="xs:string"/>
                <xs:element name="birthday" type="xs:date"/>
              </xs:sequence>
            </xs:group>

            <xs:element name="person" type="personinfo"/>
              <xs:complexType name="personinfo">
                <xs:sequence>
                <xs:group ref="persongroup"/>
                <xs:element name="country" type="xs:string"/>
              </xs:sequence>
            </xs:complexType>


            Attribute Groups

            Attribute groups are defined with the attributeGroup
            declaration, like this:

                evince -p 237 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:attributeGroup name="groupname">
            ...
            </xs:attributeGroup>

            The following example defines an attribute group named
            "personattrgroup":

            <xs:attributeGroup name="personattrgroup">
              <xs:attribute name="firstname" type="xs:string"/>
              <xs:attribute name="lastname" type="xs:string"/>
              <xs:attribute name="birthday" type="xs:date"/>
            </xs:attributeGroup>

            After you have defined an attribute group, you can reference
            it in another definition, like this:

            <xs:attributeGroup name="personattrgroup">
              <xs:attribute name="firstname" type="xs:string"/>
              <xs:attribute name="lastname" type="xs:string"/>
              <xs:attribute name="birthday" type="xs:date"/>
            </xs:attributeGroup>

            <xs:element name="person">
              <xs:complexType>
                <xs:attributeGroup ref="personattrgroup"/>
              </xs:complexType>
            </xs:element>

                evince -p 242 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD The <any> Element

            The <any> element enables us to extend the XML
            document with elements not specified by the schema!


            The <any> Element

            The <any> element enables us to extend the XML document
            with elements not specified by the schema.

            The following example is a fragment from an XML schema
            called "family.xsd". It shows a declaration for the "person"
            element. By using the <any> element we can extend (after
            <lastname>) the content of "person" with any element:

            <xs:element name="person">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="firstname" type="xs:string"/>
                  <xs:element name="lastname" type="xs:string"/>
                  <xs:any minOccurs="0"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>

                evince -p 243 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Now we want to extend the "person" element with a
            "children" element. In this case we can do so, even if the
            author of the schema above never declared any "children" element.

            Look at this schema file, called "children.xsd":

            <?xml version="1.0" encoding="UTF-8"?>
            <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                targetNamespace="http://www.w3schools.com"
                xmlns="http://www.w3schools.com"
            elementFormDefault="qualified">

            <xs:element name="children">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="childname" type="xs:string"
                      maxOccurs="unbounded"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>

            </xs:schema>

            The XML file below (called "Myfamily.xml"), uses components
            from two different schemas; "family.xsd" and "children.xsd":

            <?xml version="1.0" encoding="UTF-8"?>

            <persons xmlns="http://www.microsoft.com"
            xmlns:xsi="http://www.w3.org/2001/XMLSchemainstance"
            xsi:schemaLocation="http://www.microsoft.com
            family.xsd
            http://www.w3schools.com children.xsd">

            <person>
              <firstname>Hege</firstname>
              <lastname>Refsnes</lastname>
              <children>
                <childname>Cecilie</childname>
              </children>
            </person>

            <person>
              <firstname>Stale</firstname>
              <lastname>Refsnes</lastname>
            </person>

            </persons>

                evince -p 244 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The XML file above is valid because the schema "family.xsd"
            allows us to extend the "person" element with an optional
            element after the "lastname" element.

            The <any> and <anyAttribute> elements are used to make
            EXTENSIBLE documents! They allow documents to contain
            additional elements that are not declared in the main XML schema.

                evince -p 249 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD The <anyAttribute>

            The <anyAttribute> element enables us to extend the
            XML document with attributes not specified by the schema!


            The <anyAttribute> Element

            The <anyAttribute> element enables us to extend the XML
            document with attributes not specified by the schema.

            The following example is a fragment from an XML schema
            called "family.xsd". It shows a declaration for the "person"
            element. By using the <anyAttribute> element we can add
            any number of attributes to the "person" element:

            <xs:element name="person">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="firstname" type="xs:string"/>
                  <xs:element name="lastname" type="xs:string"/>
                </xs:sequence>
                <xs:anyAttribute/>
              </xs:complexType>
            </xs:element>

                evince -p 250 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Now we want to extend the "person" element with a
            "gender" attribute. In this case we can do so, even if the
            author of the schema above never declared any "gender" attribute.

            Look at this schema file, called "attribute.xsd":

            <?xml version="1.0" encoding="UTF-8"?>
            <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                targetNamespace="http://www.w3schools.com"
                xmlns="http://www.w3schools.com"
                elementFormDefault="qualified">

            <xs:attribute name="gender">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:pattern value="male|female"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>

            </xs:schema>

            The XML file below (called "Myfamily.xml"), uses components
            from two different schemas; "family.xsd" and "attribute.xsd":

            <?xml version="1.0" encoding="UTF-8"?>

            <persons xmlns="http://www.microsoft.com"
            xmlns:xsi="http://www.w3.org/2001/XMLSchemainstance"
            xsi:SchemaLocation="http://www.microsoft.com
            family.xsd
            http://www.w3schools.com attribute.xsd">

            <person gender="female">
              <firstname>Hege</firstname>
              <lastname>Refsnes</lastname>
            </person>

            <person gender="male">
              <firstname>Stale</firstname>
              <lastname>Refsnes</lastname>
            </person>

            </persons>

                evince -p 251 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The XML file above is valid because the schema "family.xsd"
            allows us to add an attribute to the "person" element.

            The <any> and <anyAttribute> elements are used to make
            EXTENSIBLE documents! They allow documents to contain
            additional elements that are not declared in the main XML schema.

                evince -p 255 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD Element Substitution

            With XML Schemas, one element can substitute another element.

            Element Substitution

            Let's say that we have users from two different countries:
            England and Norway. We would like the ability to let the user
            choose whether he or she would like to use the Norwegian
            element names or the English element names in the XML document.

            To solve this problem, we could define a substitutionGroup
            in the XML schema. First, we declare a head element and
            then we declare the other elements which state that they are
            substitutable for the head element.

            <xs:element name="name" type="xs:string"/>
            <xs:element name="navn"
            substitutionGroup="name"/>

            In the example above, the "name" element is the head
            element and the "navn" element is substitutable for "name".

            Look at this fragment of an XML schema:

                evince -p 256 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:element name="name" type="xs:string"/>
            <xs:element name="navn"
            substitutionGroup="name"/>

            <xs:complexType name="custinfo">
              <xs:sequence>
                <xs:element ref="name"/>
              </xs:sequence>
            </xs:complexType>

            <xs:element name="customer" type="custinfo"/>
            <xs:element name="kunde"
            substitutionGroup="customer"/>

            A valid XML document (according to the schema above)
            could look like this:

            <customer>
              <name>John Smith</name>
            </customer>

            or like this:

            <kunde>
              <navn>John Smith</navn>
            </kunde>


            Blocking Element Substitution

            To prevent other elements from substituting with a specified
            element, use the block attribute:

            <xs:element name="name" type="xs:string"
            block="substitution"/>

            Look at this fragment of an XML schema:

            <xs:element name="name" type="xs:string" block="substitution"/>
            <xs:element name="navn" substitutionGroup="name"/>

            <xs:complexType name="custinfo">
              <xs:sequence>
              <xs:element ref="name"/>
              </xs:sequence>
            </xs:complexType>

                evince -p 257 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:element name="customer" type="custinfo" block="substitution"/>
            <xs:element name="kunde" substitutionGroup="customer"/>

            A valid XML document (according to the schema above)
            looks like this:

            <customer>
              <name>John Smith</name>
            </customer>

            BUT THIS IS NO LONGER VALID:

            <kunde>
              <navn>John Smith</navn>
            </kunde>


            Using substitutionGroup

            The type of the substitutable elements must be the same as,
            or derived from, the type of the head element. If the type of
            the substitutable element is the same as the type of the
            head element you will not have to specify the type of the
            substitutable element.

            Note that all elements in the substitutionGroup (the head
            element and the substitutable elements) must be declared as
            global elements, otherwise it will not work!


            What are Global Elements?

            Global elements are elements that are immediate children of
            the "schema" element! Local elements are elements nested
            within other elements.

                evince -p 262 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            An XSD Example

            This chapter will demonstrate how to write an XML
            Schema. You will also learn that a schema can be written
            in different ways.

            An XML Document

            Let's have a look at this XML document called
            "shiporder.xml":

            <?xml version="1.0" encoding="UTF-8"?>

            <shiporder orderid="889923"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:noNamespaceSchemaLocation="shiporder.xsd">
              <orderperson>John Smith</orderperson>
              <shipto>
                <name>Ola Nordmann</name>
                <address>Langgt 23</address>
                <city>4000 Stavanger</city>
                <country>Norway</country>
              </shipto>
              <item>
                <title>Empire Burlesque</title>
                <note>Special Edition</note>
                <quantity>1</quantity>
                <price>10.90</price>
              </item>
              <item>
                <title>Hide your heart</title>
                <quantity>1</quantity>
                <price>9.90</price>
              </item>
            </shiporder>

                evince -p 263 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The XML document above consists of a root element,
            "shiporder", that contains a required attribute called
            "orderid". The "shiporder" element contains three different
            child elements: "orderperson", "shipto" and "item". The
            "item" element appears twice, and it contains a "title", an
            optional "note" element, a "quantity", and a "price" element.

            The line above: xmlns:xsi="http://www.w3.org
            /2001/XMLSchema-instance" tells the XML parser that this
            document should be validated against a schema. The line:
            xsi:noNamespaceSchemaLocation="shiporder.xsd" specifies
            WHERE the schema resides (here it is in the same folder as
            "shiporder.xml").


            Create an XML Schema

            Now we want to create a schema for the XML document above.

            We start by opening a new file that we will call
            "shiporder.xsd". To create the schema we could simply follow
            the structure in the XML document and define each element
            as we find it. We will start with the standard XML declaration
            followed by the xs:schema element that defines a schema:

            <?xml version="1.0" encoding="UTF-8" ?>
            <xs:schema xmlns:xs="http://www.w3.org
            /2001/XMLSchema">
            ...
            </xs:schema>

            In the schema above we use the standard namespace (xs),
            and the URI associated with this namespace is the Schema
            language definition, which has the standard value of
            http://www.w3.org/2001/XMLSchema.

                evince -p 264 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Next, we have to define the "shiporder" element. This
            element has an attribute and it contains other elements,
            therefore we consider it as a complex type. The child
            elements of the "shiporder" element is surrounded by a
            xs:sequence element that defines an ordered sequence of
            sub elements:

            <xs:element name="shiporder">
              <xs:complexType>
                <xs:sequence>
                  ...
                </xs:sequence>
              </xs:complexType>
            </xs:element>

            Then we have to define the "orderperson" element as a
            simple type (because it does not contain any attributes or
            other elements). The type (xs:string) is prefixed with the
            namespace prefix associated with XML Schema that indicates
            a predefined schema data type:

            <xs:element name="orderperson" type="xs:string"/>

            Next, we have to define two elements that are of the
            complex type: "shipto" and "item". We start by defining the
            "shipto" element:

            <xs:element name="shipto">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="name" type="xs:string"/>
                  <xs:element name="address" type="xs:string"/>
                  <xs:element name="city" type="xs:string"/>
                  <xs:element name="country" type="xs:string"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>

            With schemas we can define the number of possible
            occurrences for an element with the maxOccurs and
            minOccurs attributes. maxOccurs specifies the maximum
            number of occurrences for an element and minOccurs
            specifies the minimum number of occurrences for an
            element. The default value for both maxOccurs and
            minOccurs is 1!

                evince -p 265 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Now we can define the "item" element. This element can
            appear multiple times inside a "shiporder" element. This is
            specified by setting the maxOccurs attribute of the "item"
            element to "unbounded" which means that there can be as
            many occurrences of the "item" element as the author
            wishes. Notice that the "note" element is optional. We have
            specified this by setting the minOccurs attribute to zero:

            <xs:element name="item" maxOccurs="unbounded">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="title" type="xs:string"/>
                  <xs:element name="note" type="xs:string" minOccurs="0"/>
                  <xs:element name="quantity" type="xs:positiveInteger"/>
                  <xs:element name="price" type="xs:decimal"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>

            We can now declare the attribute of the "shiporder" element.
            Since this is a required attribute we specify use="required".

            Note: The attribute declarations must always come last:

            <xs:attribute name="orderid" type="xs:string" use="required"/>

            Here is the complete listing of the schema file called
            "shiporder.xsd":

            <?xml version="1.0" encoding="UTF-8" ?>
            <xs:schema xmlns:xs="http://www.w3.org
            /2001/XMLSchema">

            <xs:element name="shiporder">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="orderperson" type="xs:string"/>

                evince -p 266 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

                  <xs:element name="shipto">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element name="name" type="xs:string"/>
                        <xs:element name="address" type="xs:string"/>
                        <xs:element name="city" type="xs:string"/>
                        <xs:element name="country" type="xs:string"/>
                      </xs:sequence>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="item" maxOccurs="unbounded">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element name="title" type="xs:string"/>
                        <xs:element name="note" type="xs:string" minOccurs="0"/>
                        <xs:element name="quantity" type="xs:positiveInteger"/>
                        <xs:element name="price" type="xs:decimal"/>
                      </xs:sequence>
                    </xs:complexType>
                  </xs:element>
                </xs:sequence>
                <xs:attribute name="orderid" type="xs:string" use="required"/>
              </xs:complexType>
            </xs:element>

            </xs:schema>


            Divide the Schema

            The previous design method is very simple, but can be
            difficult to read and maintain when documents are complex.

            The next design method is based on defining all elements
            and attributes first, and then referring to them using the ref attribute.

            Here is the new design of the schema file ("shiporder.xsd"):

                evince -p 267 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <?xml version="1.0" encoding="UTF-8"?>
            <xs:schema xmlns:xs="http://www.w3.org
            /2001/XMLSchema">

            <!-- definition of simple elements -->
            <xs:element name="orderperson" type="xs:string"/>
            <xs:element name="name" type="xs:string"/>
            <xs:element name="address" type="xs:string"/>
            <xs:element name="city" type="xs:string"/>
            <xs:element name="country" type="xs:string"/>
            <xs:element name="title" type="xs:string"/>
            <xs:element name="note" type="xs:string"/>
            <xs:element name="quantity" type="xs:positiveInteger"/>
            <xs:element name="price" type="xs:decimal"/>

            <!-- definition of attributes -->
            <xs:attribute name="orderid" type="xs:string"/>

            <!-- definition of complex elements -->
            <xs:element name="shipto">
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="name"/>
                  <xs:element ref="address"/>
                  <xs:element ref="city"/>
                  <xs:element ref="country"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>

            <xs:element name="item">
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="title"/>
                  <xs:element ref="note" minOccurs="0"/>
                  <xs:element ref="quantity"/>
                  <xs:element ref="price"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>

            <xs:element name="shiporder">
              <xs:complexType>
                <xs:sequence>
                  <xs:element ref="orderperson"/>
                  <xs:element ref="shipto"/>
                  <xs:element ref="item" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute ref="orderid" use="required"/>
              </xs:complexType>
            </xs:element>

            </xs:schema>

                evince -p 268 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Using Named Types

            The third design method defines classes or types, that
            enables us to reuse element definitions. This is done by
            naming the simpleTypes and complexTypes elements, and
            then point to them through the type attribute of the element.

            Here is the third design of the schema file ("shiporder.xsd"):

            <?xml version="1.0" encoding="UTF-8" ?>
            <xs:schema xmlns:xs="http://www.w3.org
            /2001/XMLSchema">

            <xs:simpleType name="stringtype">
              <xs:restriction base="xs:string"/>
            </xs:simpleType>

            <xs:simpleType name="inttype">
              <xs:restriction base="xs:positiveInteger"/>
            </xs:simpleType>

            <xs:simpleType name="dectype">
              <xs:restriction base="xs:decimal"/>
            </xs:simpleType>

            <xs:simpleType name="orderidtype">
              <xs:restriction base="xs:string">
                <xs:pattern value="[0-9]{6}"/>
              </xs:restriction>
            </xs:simpleType>

            <xs:complexType name="shiptotype">
              <xs:sequence>
                <xs:element name="name" type="stringtype"/>
                <xs:element name="address" type="stringtype"/>
                <xs:element name="city" type="stringtype"/>
                <xs:element name="country" type="stringtype"/>
              </xs:sequence>
            </xs:complexType>

                evince -p 269 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <xs:complexType name="itemtype">
              <xs:sequence>
                <xs:element name="title" type="stringtype"/>
                <xs:element name="note" type="stringtype" minOccurs="0"/>
                <xs:element name="quantity" type="inttype"/>
                <xs:element name="price" type="dectype"/>
              </xs:sequence>
            </xs:complexType>

            <xs:complexType name="shipordertype">
              <xs:sequence>
                <xs:element name="orderperson" type="stringtype"/>
                <xs:element name="shipto" type="shiptotype"/>
                <xs:element name="item" maxOccurs="unbounded" type="itemtype"/>
              </xs:sequence>
              <xs:attribute name="orderid" type="orderidtype" use="required"/>
            </xs:complexType>

            <xs:element name="shiporder" type="shipordertype"/>

            </xs:schema>

            The restriction element indicates that the datatype is derived
            from a W3C XML Schema namespace datatype. So, the
            following fragment means that the value of the element or
            attribute must be a string value:

            <xs:restriction base="xs:string">

            The restriction element is more often used to apply
            restrictions to elements. Look at the following lines from the
            schema above:

            <xs:simpleType name="orderidtype">
              <xs:restriction base="xs:string">
                <xs:pattern value="[0-9]{6}"/>
              </xs:restriction>
            </xs:simpleType>

            This indicates that the value of the element or attribute must
            be a string, it must be exactly six characters in a row, and
            those characters must be a number from 0 to 9.

                evince -p 274 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD String Data Types

            String data types are used for values that contains
            character strings.


            String Data Type

            The string data type can contain characters, line feeds,
            carriage returns, and tab characters.

            Complex Types

            The following is an example of a string declaration in a schema:

            <xs:element name="customer" type="xs:string"/>

            An element in your document might look like this:

            <customer>John Smith</customer>

            Or it might look like this:

            <customer>      John Smith      </customer>

            Note: The XML processor will not modify the value if you use
            the string data type.

                evince -p 275 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            NormalizedString Data Type

            The normalizedString data type is derived from the String
            data type.

            The normalizedString data type also contains characters, but
            the XML processor will remove line feeds, carriage returns,
            and tab characters.

            The following is an example of a normalizedString
            declaration in a schema:

            <xs:element name="customer" type="xs:normalizedString"/>

            An element in your document might look like this:
            <customer>John Smith</customer>

            Or it might look like this:

            <customer>      John Smith      </customer>

            Note: In the example above the XML processor will replace
            the tabs with spaces.


            Token Data Type

            The token data type is also derived from the String data type.

            The token data type also contains characters, but the XML
            processor will remove line feeds, carriage returns, tabs,
            leading and trailing spaces, and multiple spaces.

            The following is an example of a token declaration in a schema:

            <xs:element name="customer" type="xs:token"/>

            An element in your document might look like this:

                evince -p 276 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <customer>John Smith</customer>

            Or it might look like this:

            <customer>      John Smith      </customer>

            Note: In the example above the XML processor will remove
            the tabs.


            String Data Types

            Note that all of the data types below derive from the String
            data type (except for string itself)!

            Name        Description

            ENTITIES

            ENTITY

            ID
             --
            A string that represents the ID attribute
            in XML (only used with schema attributes)

            IDREF
             --
            A string that represents the IDREF
            attribute in XML (only used with
            schema attributes)

            IDREFS

            language
             --
            A string that contains a valid language id

            Name
             --
            A string that contains a valid XML name

            NCName

            NMTOKEN
             --
            A string that represents the NMTOKEN
            attribute in XML (only used with
            schema attributes)

                evince -p 277 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            NMTOKENS

            normalizedString
             --
            A string that does not contain line
            feeds, carriage returns, or tabs

            QName

            string
             --
            A string

            token
             --
            A string that does not contain line
            feeds, carriage returns, tabs, leading or
            trailing spaces, or multiple spaces


            Restrictions on String Data Types

            Restrictions that can be used with String data types:

            - enumeration
            - length
            - maxLength
            - minLength
            - pattern (NMTOKENS, IDREFS, and ENTITIES cannot use this constraint)
            - whiteSpace

                evince -p 282 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD Date and Time Data

            Date and time data types are used for values that
            contain date and time.


            Date Data Type

            The date data type is used to specify a date.
            The date is specified in the following form "YYYY-MM-DD" where:

            - YYYY indicates the year
            - MM indicates the month
            - DD indicates the day

            Note: All components are required!

            The following is an example of a date declaration in a schema:

            <xs:element name="start" type="xs:date"/>

            An element in your document might look like this:

            <start>2002-09-24</start>

                evince -p 283 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Time Zones

            To specify a time zone, you can either enter a date in UTC
            time by adding a "Z" behind the date - like this:

            <start>2002-09-24Z</start>

            or you can specify an offset from the UTC time by adding a
            positive or negative time behind the date - like this:

            <start>2002-09-24-06:00</start>

            or

            <start>2002-09-24+06:00</start>


            Time Data Type

            The time data type is used to specify a time.

            The time is specified in the following form "hh:mm:ss" where:

            - hh indicates the hour
            - mm indicates the minute
            - ss indicates the second

            Note: All components are required!

            The following is an example of a time declaration in a schema:

            <xs:element name="start" type="xs:time"/>

            An element in your document might look like this:

            <start>09:00:00</start>

            Or it might look like this:

            <start>09:30:10.5</start>

                evince -p 284 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Time Zones

            To specify a time zone, you can either enter a time in UTC
            time by adding a "Z" behind the time - like this:

            <start>09:30:10Z</start>

            or you can specify an offset from the UTC time by adding a
            positive or negative time behind the time - like this:

            <start>09:30:10-06:00</start>

            or

            <start>09:30:10+06:00</start>


            DateTime Data Type

            The dateTime data type is used to specify a date and a time.

            The dateTime is specified in the following form
            "YYYYMM-DDThh:mm:ss" where:

            - YYYY indicates the year
            - MM indicates the month
            - DD indicates the day
            - T indicates the start of the required time section
            - hh indicates the hour
            - mm indicates the minute
            - ss indicates the second

            Note: All components are required!

            The following is an example of a dateTime declaration in a schema:

            <xs:element name="startdate" type="xs:dateTime"/>

            An element in your document might look like this:

            <startdate>2002-05-30T09:00:00</startdate>

                evince -p 285 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Or it might look like this:

            <startdate>2002-05-30T09:30:10.5</startdate>


            Time Zones

            To specify a time zone, you can either enter a dateTime in
            UTC time by adding a "Z" behind the time - like this:

            <startdate>2002-05-30T09:30:10Z</startdate>

            or you can specify an offset from the UTC time by adding a
            positive or negative time behind the time - like this:

            <startdate>2002-05-30T09:30:10-06:00</startdate>

            or

            <startdate>2002-05-30T09:30:10+06:00</startdate>


            Duration Data Type

            The duration data type is used to specify a time interval.

            The time interval is specified in the following form
            "PnYnMnDTnHnMnS" where:

            - P indicates the period (required)
            - nY indicates the number of years
            - nM indicates the number of months
            - nD indicates the number of days
            - T indicates the start of a time section (required if you
                are going to specify hours, minutes, or seconds)
            - nH indicates the number of hours
            - nM indicates the number of minutes
            - nS indicates the number of seconds

            The following is an example of a duration declaration in a schema:

            <xs:element name="period" type="xs:duration"/>

                evince -p 286 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            An element in your document might look like this:

            <period>P5Y</period>

            The example above indicates a period of five years.

            Or it might look like this:

            <period>P5Y2M10D</period>

            The example above indicates a period of five years, two
            months, and 10 days.

            Or it might look like this:

            <period>P5Y2M10DT15H</period>

            The example above indicates a period of five years, two
            months, 10 days, and 15 hours.

            Or it might look like this:

            <period>PT15H</period>

            The example above indicates a period of 15 hours.


            Negative Duration
            To specify a negative duration, enter a minus sign before the P:

            <period>-P10D</period>

            The example above indicates a period of minus 10 days.


                evince -p 287 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Date and Time Data Types

            Name    Description

            date
             --
            Defines a date value

            dateTime
             --
            Defines a date and time value

            duration
             --
            Defines a time interval

            gDay
             --
            Defines a part of a date - the day (DD)

            gMonth
             --
            Defines a part of a date - the month (MM)

            gMonthDay
             --
            Defines a part of a date - the month and day (MM-DD)

            gYear
             --
            Defines a part of a date - the year (YYYY)

            gYearMonth
             --
            Defines a part of a date - the year and
            month (YYYY-MM)

            time
             --
            Defines a time value


            Restrictions on Date Data Types

            Restrictions that can be used with Date data types:
            - enumeration
            - maxExclusive
            - maxInclusive
            - minExclusive
            - minInclusive
            - pattern
            - whiteSpace

                evince -p 292 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD Numeric Data Types

            Decimal data types are used for numeric values.


            Decimal Data Type

            The decimal data type is used to specify a numeric value.

            Complex Types

            The following is an example of a decimal declaration in a schema:

            <xs:element name="prize" type="xs:decimal"/>

            An element in your document might look like this:

            <prize>999.50</prize>

            Or it might look like this:

            <prize>+999.5450</prize>

            Or it might look like this:

            <prize>-999.5230</prize>

            Or it might look like this:

                evince -p 293 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <prize>0</prize>

            Or it might look like this:

            <prize>14</prize>

            Note: The maximum number of decimal digits you can
            specify is 18.


            Integer Data Type

            The integer data type is used to specify a numeric value
            without a fractional component.

            The following is an example of an integer declaration in a schema:

            <xs:element name="prize" type="xs:integer"/>

            An element in your document might look like this:

            <prize>999</prize>

            Or it might look like this:

            <prize>+999</prize>

            Or it might look like this:

            <prize>-999</prize>

            Or it might look like this:

            <prize>0</prize>

                evince -p 294 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Numeric Data Types

            Note that all of the data types below derive from the Decimal
            data type (except for decimal itself)!

            Name    Description

            byte
             --
            A signed 8-bit integer

            decimal
             --
            A decimal value

            int
             --
            A signed 32-bit integer

            integer
             --
            An integer value

            long
             --
            A signed 64-bit integer

            negativeInteger
             --
            An integer containing only negative
            values (..,-2,-1)

            nonNegativeInteger
             --
            An integer containing only
            non-negative values (0,1,2,..)

            nonPositiveInteger
             --
            An integer containing only
            non-positive values (..,-2,-1,0)

            positiveInteger
             --
            An integer containing only positive
            values (1,2,..)

            short
             --
            A signed 16-bit integer

            unsignedLong
             --
            An unsigned 64-bit integer

            unsignedInt
             --
            An unsigned 32-bit integer

            unsignedShort
             --
            An unsigned 16-bit integer

            unsignedByte
             --
            An unsigned 8-bit integer

                evince -p 295 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Restrictions on Numeric Data Types

            Restrictions that can be used with Numeric data types:

            - enumeration
            - fractionDigits
            - maxExclusive
            - maxInclusive
            - minExclusive
            - minInclusive
            - pattern
            - totalDigits
            - whiteSpace

                evince -p 299 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSD Miscellaneous Data Types

            Other miscellaneous data types are boolean,
            base64Binary, hexBinary, float, double, anyURI, QName,
            and NOTATION.


            Boolean Data Type

            The boolean data type is used to specify a true or false value.

            The following is an example of a boolean declaration in a schema:

            <xs:attribute name="disabled" type="xs:boolean"/>

            An element in your document might look like this:

            <prize disabled="true">999</prize>

            Note: Legal values for boolean are true, false, 1 (which
            indicates true), and 0 (which indicates false).

                evince -p 300 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Binary Data Types

            Binary data types are used to express binary-formatted data.

            We have two binary data types:

            - base64Binary (Base64-encoded binary data)
            - hexBinary (hexadecimal-encoded binary data)

            The following is an example of a hexBinary declaration in a schema:

            <xs:element name="blobsrc" type="xs:hexBinary"/>


            AnyURI Data Type

            The anyURI data type is used to specify a URI.

            The following is an example of an anyURI declaration in a schema:

            <xs:attribute name="src" type="xs:anyURI"/>

            An element in your document might look like this:

            <pic src="http://www.w3schools.com/images/smiley.gif" />

            Note: If a URI has spaces, replace them with %20.


            Miscellaneous Data Types

            Name    Description

            anyURI
            base64Binary
            boolean
            double
            float
            hexBinary
            NOTATION
            QName

                evince -p 301 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Restrictions on Miscellaneous

            Restrictions that can be used with the other data types:

            - enumeration (a Boolean data type cannot use this constraint)
            - length (a Boolean data type cannot use this constraint)
            - maxLength (a Boolean data type cannot use this constraint)
            - minLength (a Boolean data type cannot use this constraint)
            - pattern
            - whiteSpace

                evince -p 306 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Schema Reference

            Element     Explanation

            all (el_all.asp)
             --
            Specifies that the child
            elements can appear in any
            order. Each child element can
            occur 0 or 1 time

            annotation (el_annotation.asp)
             --
            Specifies the top-level element
            for schema comments

            any (el_any.asp)
             --
            Enables the author to extend
            the XML document with
            elements not specified by the schema

            anyAttribute (el_anyattribute.asp)
             --
            Enables the author to extend
            the XML document with
            attributes not specified by the
            schema

                evince -p 307 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            appinfo (el_appinfo.asp)
             --
            Specifies information to be used
            by the application (must go
            inside annotation)

            attribute (el_attribute.asp)
             --
            Defines an attribute

            attributeGroup (el_attributegroup.asp)
             --
            Defines an attribute group to be
            used in complex type definitions

            choice (el_choice.asp)
             --
            Allows only one of the elements
            contained in the <choice>
            declaration to be present within
            the containing element

            complexContent (el_complextype.asp)
             --
            Defines extensions or
            restrictions on a complex type
            that contains mixed content or
            elements only

            complexType (el_complextype.asp)
             --
            Defines a complex type element

            documentation (el_documentation.asp)
             --
            Defines text comments in a
            schema (must go inside
            annotation)

            element (el_element.asp)
             --
            Defines an element

            extension (el_extension.asp)
             --
            Extends an existing simpleType
            or complexType element

            field (el_field.asp)
             --
            Specifies an XPath expression
            that specifies the value used to
            define an identity constraint

            group (el_group.asp)
             --
            Defines a group of elements to
            be used in complex type definitions

                evince -p 308 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            import (el_import.asp)
             --
            Adds multiple schemas with
            different target namespace to a
            document

            include (el_include.asp)
             --
            Adds multiple schemas with the
            same target namespace to a document

            key (el_key.asp)
             --
            Specifies an attribute or
            element value as a key (unique,
            non-nullable, and always
            present) within the containing
            element in an instance document

            keyref (el_keyref.asp)
             --
            Specifies that an attribute or
            element value correspond to
            those of the specified key or
            unique element

            list (el_list.asp)
             --
            Defines a simple type element
            as a list of values

            notation (el_notation.asp)
             --
            Describes the format of
            non-XML data within an XML document

            redefine (el_redefine.asp)
             --
            Redefines simple and complex
            types, groups, and attribute
            groups from an external schema

            restriction (el_restriction.asp)
             --
            Defines restrictions on a
            simpleType, simpleContent, or a
            complexContent

            schema (el_schema.asp)
             --
            Defines the root element of a schema

            selector (el_selector.asp)
             --
            Specifies an XPath expression
            that selects a set of elements
            for an identity constraint

                evince -p 309 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            sequence (el_sequence.asp)

            Specifies that the child
            elements must appear in a
            sequence. Each child element
            can occur from 0 to any number
            of times

            simpleContent (el_simpleContent.asp)
             --
            Contains extensions or
            restrictions on a text-only
            complex type or on a simple
            type as content and contains no elements

            simpleType (el_simpletype.asp)
             --
            Defines a simple type and
            specifies the constraints and
            information about the values of
            attributes or text-only elements

            union (el_union.asp)
             --
            Defines a simple type as a
            collection (union) of values
            from specified simple data types

            unique (el_unique.asp)
             --
            Defines that an element or an
            attribute value must be unique
            within the scope


            XSD Restrictions/Facets for Datatypes

            Look at XSD Restrictions! (schema_facets.asp)

            Constraint      Description

            enumeration
             --
            Defines a list of acceptable values

            fractionDigits
             --
            Specifies the maximum number of decimal
            places allowed. Must be equal to or greater
            than zero

                evince -p 310 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            length
             --
            Specifies the exact number
            of characters or
            list items allowed. Must be equal to or
            greater than zero

            maxExclusive
             --
            Specifies the upper bounds for numeric
            values (the value must be less than this value)

            maxInclusive
             --
            Specifies the upper bounds for numeric
            values (the value must be less than or
            equal to this value)

            maxLength
             --
            Specifies the maximum number of
            characters or list items allowed. Must be
            equal to or greater than zero

            minExclusive
             --
            Specifies the lower bounds for numeric
            values (the value must be greater than this value)

            minInclusive
             --
            Specifies the lower bounds for numeric
            values (the value must be greater than or
            equal to this value)

            minLength
             --
            Specifies the minimum number of
            characters or list items allowed. Must be
            equal to or greater than zero

            pattern
             --
            Defines the exact sequence of characters
            that are acceptable

            totalDigits
             --
            Specifies the maximum number of digits
            allowed. Must be greater than zero

            whiteSpace
             --
            Specifies how white space (line feeds, tabs,
            spaces, and carriage returns) is handled

                evince -p 315 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The XMLHttpRequest Object

            The XMLHttpRequest object is used to exchange data with a
            server behind the scenes.

            The XMLHttpRequest object is a developer's dream, because
            you can:

            - Update a web page without reloading the page
            - Request data from a server after the page has loaded
            - Receive data from a server after the page has loaded
            - Send data to a server in the background

            To learn more about the XMLHttpRequest object, study our XML
            DOM tutorial (/dom/default.asp).


            XMLHttpRequest Example

            When you type a character in the input field below, an
            XMLHttpRequest is sent to the server - and name suggestions
            are returned (from a file on the server):

            Example

            Start typing a name in the input field below:
            First name:

                evince -p 316 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Suggestions:


            Create an XMLHttpRequest Object

            All modern browsers (IE7+, Firefox, Chrome, Safari, and
            Opera) have a built-in XMLHttpRequest object.

            Syntax for creating an XMLHttpRequest object:

            xmlhttp=new XMLHttpRequest();

            In the next chapter, we will use the XMLHttpRequest object to
            retrieve XML information from a server.

                evince -p 320 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Parser

            All modern browsers have a built-in XML parser.

            An XML parser converts an XML document into an XML
            DOM object - which  can then be manipulated with
            JavaScript.


            Parse an XML Document

            The following code fragment parses an XML document into an
            XML DOM object:

            xmlhttp=new XMLHttpRequest();
            xmlhttp.open("GET","books.xml",false);
            xmlhttp.send();
            xmlDoc=xmlhttp.responseXML;


            Parse an XML String

            The following code fragment parses an XML string into an XML
            DOM object:

            txt="<bookstore><book>";
            txt=txt+"<title>Everyday Italian</title>";
            txt=txt+"<author>Giada De Laurentiis</author>";
            txt=txt+"<year>2005</year>";
            txt=txt+"</book></bookstore>";

                evince -p 321 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            if (window.DOMParser)
              {
              parser=new DOMParser();
              xmlDoc=parser.parseFromString(txt,"text/xml");
              }
            else // Internet Explorer
              {
              xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
              xmlDoc.async=false;
              xmlDoc.loadXML(txt);
              }

            Note: Internet Explorer uses the loadXML() method to parse
            an XML string, while other browsers use the DOMParser object.


            Access Across Domains

            For security reasons, modern browsers do not allow access
            across domains.

            This means, that both the web page and the XML file it tries to
            load, must be located on the same server.


            The XML DOM

            In the next chapter you will learn how to access and retrieve
            data from the XML DOM object.

                evince -p 324 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM

            A DOM (Document Object Model) defines a standard way
            for accessing and manipulating documents.


            The XML DOM

            The XML DOM defines a standard way for accessing and
            manipulating XML documents.

            The XML DOM views an XML document as a tree-structure.

            All elements can be accessed through the DOM tree. Their
            content (text and attributes) can be modified or deleted, and
            new elements can be created. The elements, their text, and
            their attributes are all known as nodes.

            You can learn more about the XML DOM in our XML DOM
            tutorial (/dom/default.asp).


            The HTML DOM

            The HTML DOM defines a standard way for accessing and
            manipulating HTML documents.

            All HTML elements can be accessed through the HTML DOM.
            You can learn more about the HTML DOM in our JavaScript
            tutorial (/js/default.asp).

                evince -p 325 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Load an XML File - Cross-browser Example

            The following example parses an XML document ("note.xml
            (note.xml)") into an XML DOM object and then extracts some
            info from it with a JavaScript:

            Example

            <html>
              <body>
                <h1>W3Schools Internal Note</h1>
                <div>
                  <b>To:</b> <span id="to"></span><br />
                  <b>From:</b> <span id="from"></span><br />
                  <b>Message:</b> <span id="message"></span>
                </div>

                <script>
                  if (window.XMLHttpRequest)
                    {// code for IE7+, Firefox, Chrome, Opera, Safari
                    xmlhttp=new XMLHttpRequest();
                    }
                  else
                    {// code for IE6, IE5
                    xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
                    }
                  xmlhttp.open("GET","note.xml",false);
                  xmlhttp.send();
                  xmlDoc=xmlhttp.responseXML;

                  document.getElementById("to").innerHTML=
                  xmlDoc.getElementsByTagName("to")
                  [0].childNodes[0].nodeValue;
                  document.getElementById("from").innerHTML=
                  xmlDoc.getElementsByTagName("from")
                  [0].childNodes[0].nodeValue;
                  document.getElementById("message").innerHTML=
                  xmlDoc.getElementsByTagName("body")
                  [0].childNodes[0].nodeValue;
                </script>

              </body>
            </html>

                evince -p 326 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Important Note!

            To extract the text "Tove" from the <to> element in the XML
            file above ("note.xml"), the syntax is:

            getElementsByTagName("to")
            [0].childNodes[0].nodeValue

            Notice that even if the XML file contains only ONE <to>
            element you still have to specify the array index [0]. This is
            because the getElementsByTagName() method returns an array.


            Load an XML String - Crossbrowser Example

            The following example parses an XML string into an XML
            DOM object and then extracts some info from it with a JavaScript:

            Example

            <html>
            <body>
            <h1>W3Schools Internal Note</h1>
            <div>
            <b>To:</b> <span id="to"></span><br />
            <b>From:</b> <span id="from"></span><br />
            <b>Message:</b> <span id="message"></span>
            </div>

            <script>
            txt="<note>";
            txt=txt+"<to>Tove</to>";
            txt=txt+"<from>Jani</from>";
            txt=txt+"<heading>Reminder</heading>";
            txt=txt+"<body>Don't forget me this weekend!

                evince -p 327 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            </body>";
            txt=txt+"</note>";

            if (window.DOMParser)
              {
              parser=new DOMParser();
              xmlDoc=parser.parseFromString(txt,"text/xml");
              }
            else // Internet Explorer
              {
              xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
              xmlDoc.async=false;
              xmlDoc.loadXML(txt);
              }

            document.getElementById("to").innerHTML=
            xmlDoc.getElementsByTagName("to")
            [0].childNodes[0].nodeValue;
            document.getElementById("from").innerHTML=
            xmlDoc.getElementsByTagName("from")
            [0].childNodes[0].nodeValue;
            document.getElementById("message").innerHTML=
            xmlDoc.getElementsByTagName("body")
            [0].childNodes[0].nodeValue;
            </script>
            </body>
            </html>

                evince -p 333 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML in HTML

            Display XML Data in an HTML Table

            In the following example, we open an XML file called
            "cd_catalog.xml (cd_catalog.xml)".

            We then loop through each <CD> element, and display the
            values of the <ARTIST> and the <TITLE> elements in an HTML table:

            Example

            <html>
            <head>
            <style>
            table, th, td {
              border: 1px solid black;
              border-collapse:collapse;
            }
            th, td {
              padding: 5px;
            }
            </style>
            </head>
            <body>

            <script>
            if (window.XMLHttpRequest)
              {// code for IE7+, Firefox, Chrome, Opera, Safari
              xmlhttp=new XMLHttpRequest();
              }

                evince -p 334 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            else
              {// code for IE6, IE5
              xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
              }
            xmlhttp.open("GET","cd_catalog.xml",false);
            xmlhttp.send();
            xmlDoc=xmlhttp.responseXML;

            document.write("<table><tr><th>Artist</th>
            <th>Title</th></tr>");
            var x=xmlDoc.getElementsByTagName("CD");
            for (i=0;i<x.length;i++)
              {
              document.write("<tr><td>");

              document.write(x[i].getElementsByTagName("ARTIST")
              [0].childNodes[0].nodeValue);
              document.write("</td><td>");
              document.write(x[i].getElementsByTagName("TITLE")
              [0].childNodes[0].nodeValue);
              document.write("</td></tr>");
              }
            document.write("</table>");
            </script>

            </body>
            </html>


            For more information about using JavaScript and the XML DOM,
            visit our XML DOM tutorial. (/dom/default.asp)

                evince -p 338 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Tutorial

            The XML DOM defines a standard for
            accessing and manipulating XML documents.

            The DOM presents an XML document as a
            tree-structure.

            Knowing the XML DOM is a must for
            anyone working with XML.

              XML DOM Tree Example


                evince -p 339 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            What You Should Already Know

            Before you continue you should have a basic understanding
            of the following:

            - HTML
            - XML
            - JavaScript

            If you want to study these subjects first, find the tutorials on
            our Home page (/default.asp).


            What is the DOM?

            The DOM is a W3C (World Wide Web Consortium) standard.
            The DOM defines a standard for accessing documents like
            XML and HTML:

              "The W3C Document Object Model (DOM) is a platform and
              language-neutral interface that allows programs and scripts
              to dynamically access and update the content, structure, and
              style of a document."

            The DOM is separated into 3 different parts / levels:

            - Core DOM - standard model for any structured document
            - XML DOM - standard model for XML documents
            - HTML DOM - standard model for HTML documents

            The DOM defines the objects and properties of all
            document elements, and the methods (interface) to access them.


            What is the HTML DOM?

            The HTML DOM defines the objects and properties of all
            HTML elements, and the methods (interface) to access them.

            If you want to study the HTML DOM, find the HTML DOM
            tutorial on our Home page (/default.asp).

                evince -p 340 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            What is the XML DOM?

            The XML DOM is:

            - A standard object model for XML
            - A standard programming interface for XML
            - Platform- and language-independent
            - A W3C standard

            The XML DOM defines the objects and properties of all
            XML elements, and the methods (interface) to access them.

            In other words: The XML DOM is a standard for how to
            get, change, add, or delete XML elements.

              XML Exam - Get Your Diploma!
              (/cert/default.asp)

              W3Schools'
              Online
              Certification

              The perfect solution for professionals who need to balance
              work, family, and career building.

              More than 10 000 certificates already issued!

              Get Your Certificate » (/cert/default.asp)

                evince -p 345 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Nodes

            In the DOM, everything in an XML document is a node.


            DOM Nodes

            According to the DOM, everything in an XML document is a node.

            The DOM says:
            - The entire document is a document node
            - Every XML element is an element node
            - The text in the XML elements are text nodes
            - Every attribute is an attribute node
            - Comments are comment nodes


            DOM Example

            Look at the following XML file (books.xml (books.xml)):

            <?xml version="1.0" encoding="UTF-8"?>
            <bookstore>
              <book category="cooking">
                <title lang="en">Everyday Italian</title>
                <author>Giada De Laurentiis</author>
                <year>2005</year>

                evince -p 346 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

                <price>30.00</price>
              </book>
              <book category="children">
                <title lang="en">Harry Potter</title>
                <author>J K. Rowling</author>
                <year>2005</year>
                <price>29.99</price>
              </book>
              <book category="web">
                <title lang="en">XQuery Kick Start</title>
                <author>James McGovern</author>
                <author>Per Bothner</author>
                <author>Kurt Cagle</author>
                <author>James Linn</author>
                <author>Vaidyanathan Nagarajan</author>
                <year>2003</year>
                <price>49.99</price>
              </book>
              <book category="web" cover="paperback">
                <title lang="en">Learning XML</title>
                <author>Erik T. Ray</author>
                <year>2003</year>
                <price>39.95</price>
              </book>
            </bookstore>

            The root node in the XML above is named <bookstore>. All
            other nodes in the document are contained within <bookstore>.

            The root node <bookstore> holds four <book> nodes.

            The first <book> node holds four nodes: <title>, <author>,
            <year>, and <price>, which contains one text node each,
            "Everyday Italian", "Giada De Laurentiis", "2005", and "30.00".


            Text is Always Stored in Text Nodes

            A common error in DOM processing is to expect an element
            node to contain text.

            However, the text of an element node is stored in a text node.

                evince -p 347 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            In this example: <year>2005</year>, the element node
            <year>, holds a text node with the value "2005".

            "2005" is not the value of the <year> element!

                evince -p 351 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Node Tree

            The XML DOM views an XML document as a node-tree.
            All the nodes in the tree have a relationship to each other.


            The XML DOM Node Tree

            The XML DOM views an XML document as a tree-structure.
            The tree structure is called a node-tree.

            All nodes can be accessed through the tree. Their contents
            can be modified or deleted, and new elements can be created.

            The node tree shows the set of nodes, and the connections
            between them. The tree starts at the root node and branches
            out to the text nodes at the lowest level of the tree:


            The image above represents the XML file books.xml
            (books.xml).

                evince -p 352 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Node Parents, Children, and Siblings

            The nodes in the node tree have a hierarchical relationship to
            each other.

            The terms parent, child, and sibling are used to describe the
            relationships. Parent nodes have children. Children on the
            same level are called siblings (brothers or sisters).

            - In a node tree, the top node is called the root
            - Every node, except the root, has exactly one parent node
            - A node can have any number of children
            - A leaf is a node with no children
            - Siblings are nodes with the same parent

            The following image illustrates a part of the node tree and
            the relationship between the nodes:


                evince -p 353 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Because the XML data is structured in a tree form, it can be
            traversed without knowing the exact structure of the tree
            and without knowing the type of data contained within.

            You will learn more about traversing the node tree in a later
            chapter of this tutorial.


            First Child - Last Child

            Look at the following XML fragment:

            <bookstore>
              <book category="cooking">
                <title lang="en">Everyday Italian</title>
                <author>Giada De Laurentiis</author>
                <year>2005</year>
                <price>30.00</price>
              </book>
            </bookstore>

            In the XML above, the <title> element is the first child of the
            <book> element, and the <price> element is the last child
            of the <book> element.

            Furthermore, the <book> element is the parent node of the
            <title>, <author>, <year>, and <price> elements.

                evince -p 358 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Parser

            All major browsers have a built-in XML parser to read
            and manipulate XML.

            The XML parser converts XML into an XML DOM object
            that can be accessed with JavaScript.


            XML Parser

            The XML DOM contains methods to traverse XML trees,
            access, insert, and delete nodes.

            However, before an XML document can be accessed and
            manipulated, it must be loaded into an XML DOM object.

            An XML parser reads XML, and converts it into an XML DOM
            object that can be accessed with JavaScript.

            Most browsers have a built-in XML parser.


            Load an XML Document
            The following JavaScript fragment loads an XML document
            ("books.xml (books.xml)"):

                evince -p 359 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            if (window.XMLHttpRequest)
              {
              xhttp=new XMLHttpRequest();
              }
            else // code for IE5 and IE6
              {
              xhttp=new ActiveXObject("Microsoft.XMLHTTP");
              }
            xhttp.open("GET","books.xml",false);
            xhttp.send();
            xmlDoc=xhttp.responseXML;


            Code explained:
            - Create an XMLHttpRequest object
            - Use the open() and send() methods of the
            - XMLHttpRequest object to send a request to a server
            - Get the response data as XML data


            Load an XML String

            The following code loads and parses an XML string:

            Example

            if (window.DOMParser)
              {
              parser=new DOMParser();
              xmlDoc=parser.parseFromString(text,"text/xml");
              }
            else // code for IE
              {
              xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
              xmlDoc.async=false;
              xmlDoc.loadXML(text);
              }

            Note: Internet Explorer uses the loadXML() method to parse
            an XML string, while other browsers use the DOMParser object.

                evince -p 360 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Access Across Domains

            For security reasons, modern browsers do not allow access
            across domains.

            This means, that both the web page and the XML file it tries
            to load, must be located on the same server.

            The examples on W3Schools all open XML files located on the
            W3Schools domain.

            If you want to use the example above on one of your web
            pages, the XML files you load must be located on your own server.

                evince -p 365 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Load Functions

            The code for loading XML documents can be stored in a function.


            The loadXMLDoc() Function

            To make the code from the previous page simpler to
            maintain (and check for older browsers), it should be written
            as a function:


            function loadXMLDoc(filename)
            {
            if (window.XMLHttpRequest)
              {
              xhttp=new XMLHttpRequest();
              }
            else // code for IE5 and IE6
              {
              xhttp=new ActiveXObject("Microsoft.XMLHTTP");
              Manipulate
              }
            xhttp.open("GET",filename,false);
            Nodes
            xhttp.send();
            return xhttp.responseXML;
            }

            The function above can be stored in the <head> section of
            an HTML page, and called from a script in the page.

                evince -p 366 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Note:
            The function described above, is used in all XML
            document examples in this tutorial!


            An External JavaScript for loadXMLDoc()

            To make the code above even easier to maintain, and to
            make sure the same code is used in all pages, we store the
            function in an external file.

            The file is called "loadxmldoc.js", and will be loaded in the
            head section of an HTML page. Then, the loadXMLDoc()
            function can be called from a script in the page.

            The following example uses the loadXMLDoc() function to
            load books.xml (books.xml):

            Example

            <html>
            <head>
            <script src="loadxmldoc.js">
            </script>
            </head>
            <body>

            <script>
            var xmlDoc=loadXMLDoc("books.xml");

            code goes here.....

            </script>

            </body>
            </html>

            How to get the data from the XML file, will be explained in
            the next chapters.

                evince -p 367 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The loadXMLString() Function

            To make the code from the previous page simpler to
            maintain (and check for older browsers), it should be written
            as a function:

            function loadXMLString(txt)
            {
            if (window.DOMParser)
              {
              parser=new DOMParser();
              xmlDoc=parser.parseFromString(txt,"text/xml");
              }
            else // code for IE
              {
              xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
              xmlDoc.async=false;
              xmlDoc.loadXML(txt);
              }
            return xmlDoc;
            }

            The function above can be stored in the <head> section of
            an HTML page, and called from a script in the page.

            Note:
            The function described above, is used in all XML
            string examples in this tutorial!


            An External JavaScript for loadXMLString()

            We have stored the loadXMLString() function in a file called
            "loadxmlstring.js".

            Example

            <html>
            <head>
            <script src="loadxmlstring.js"></script>
            </head>
            <body>
            <script>
            text="<bookstore>"
            text=text+"<book>";

                evince -p 368 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            text=text+"<title>Everyday Italian</title>";
            text=text+"<author>Giada De Laurentiis</author>";
            text=text+"<year>2005</year>";
            text=text+"</book>";
            text=text+"</bookstore>";

            var xmlDoc=loadXMLString(text);

            code goes here.....

            </script>
            </body>
            </html>

                evince -p 373 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM - Properties and Methods

            Properties and methods define the programming interface
            to the XML DOM.


            Programming Interface

            The DOM models XML as a set of node objects. The nodes can
            be accessed with JavaScript or other programming languages.
            In this tutorial we use JavaScript.

            The programming interface to the DOM is defined by a set
            standard properties and methods.

            Properties are often referred to as something that is (i.e.
            nodename is "book").

            Methods are often referred to as something that is done (i.e.
            delete "book").


            XML DOM Properties

            These are some typical DOM properties:
            x.nodeName - the name of x
            x.nodeValue - the value of x
            x.parentNode - the parent node of x

                evince -p 374 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            x.childNodes - the child nodes of x
            x.attributes - the attributes nodes of x

            Note: In the list above, x is a node object.


            XML DOM Methods

            - x.getElementsByTagName(name) - get all elements with a
                specified tag name
            - x.appendChild(node) - insert a child node to x
            - x.removeChild(node) - remove a child node from x

            Note: In the list above, x is a node object.


            Example

            The JavaScript code to get the text from the first <title>
            element in books.xml:

            txt=xmlDoc.getElementsByTagName("title")[0].childNodes[0].nodeValue

            After the execution of the statement, txt will hold the value
            "Everyday Italian"

            Explained:

            - xmlDoc - the XML DOM object created by the parser.
            - getElementsByTagName("title")[0] - the first <title> element
            - childNodes[0] - the first child of the <title> element (the text node)
            - nodeValue - the value of the node (the text itself)

                evince -p 379 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM - Accessing Nodes

            With the DOM, you can access every node in an XML document.


            Try it Yourself - Examples

            The examples below use the XML file books.xml (books.xml).

            A function, loadXMLDoc() (dom_loadxmldoc.asp), in an
            external JavaScript is used to load the XML file.

            Access a node using its index number in a node list

            This example uses the getElementsByTagName() method to
            get the third <title> element in "books.xml"

            Loop through nodes using the length property
            (tryit.asp?filename=try_dom_list_loop)

            This example uses the length property to loop through all
            <title> elements in "books.xml"

            See the node type of an element (tryit.asp?filename=try_dom_root)

            This example uses the nodeType property to get node type of
            the root element in "books.xml".

                evince -p 380 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Loop through element nodes

            This example uses the nodeType property to only process
            element nodes in "books.xml".

            Loop through element nodes using node relationships
            (tryit.asp?filename=try_dom_navigate)

            This example uses the nodeType property and the
            nextSibling property to process element nodes in
            "books.xml".


            Accessing Nodes

            You can access a node in three ways:
            1. By using the getElementsByTagName() method
            2. By looping through (traversing) the nodes tree.
            3. By navigating the node tree, using the node relationships.


            The getElementsByTagName() Method

            getElementsByTagName() returns all elements with a
            specified tag name.

            Syntax

            node.getElementsByTagName("tagname");

            Example

            The following example returns all <title> elements under the
            x element:

            x.getElementsByTagName("title");

            Note that the example above only returns <title> elements
            under the x node. To return all <title> elements in the XML
            document use:

            xmlDoc.getElementsByTagName("title");

            where xmlDoc is the document itself (document node).

                evince -p 381 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            DOM Node List

            The getElementsByTagName() method returns a node list. A
            node list is an array of nodes.

            The following code loads "books.xml (books.xml)" into
            xmlDoc using loadXMLDoc() (dom_loadxmldoc.asp) and
            stores a list of <title> nodes (a node list) in the variable x:

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName("title");

            The <title> elements in x can be accessed by index number.
            To access the third <title> you can write:

            y=x[2];

            Note: The index starts at 0.

            You will learn more about node lists in a later chapter of this tutorial.


            DOM Node List Length

            The length property defines the length of a node list (the
            number of nodes).

            You can loop through a node list by using the length property:

            Example

            var xmlDoc=loadXMLDoc("books.xml");
            var x=xmlDoc.getElementsByTagName("title");

                evince -p 382 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            for (i=0;i<x.length;i++)
              {
              document.write(x[i].childNodes[0].nodeValue);
              document.write("<br>");
              }

            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Get all <title> element nodes
            3. For each title element, output the value of its text node


            Node Types

            The documentElement property of the XML document is the root node.

            The nodeName property of a node is the name of the node.

            The nodeType property of a node is the type of the node.

            You will learn more about the node properties in the next
            chapter of this tutorial.

            Try it yourself (tryit.asp?filename=try_dom_root)


            Traversing Nodes

            The following code loops through the child nodes, that are
            also element nodes, of the root node:

            Example

            var xmlDoc=loadXMLDoc("books.xml");
            var x=xmlDoc.documentElement.childNodes;

            for (i=0;i<x.length;i++)
              {
              // Process only element nodes (type 1)
              if (x[i].nodeType==1)
                {
                document.write(x[i].nodeName);
                document.write("<br>");
                }
              }

                evince -p 383 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Get the child nodes of the root element
            3. For each child node, check the node type of the node. If
                the node type is "1" it is an element node
            4. Output the name of the node if it is an element node


            Navigating Node Relationships

            The following code navigates the node tree using the node
            relationships:

            Example

            var xmlDoc=loadXMLDoc("books.xml");
            var x=xmlDoc.getElementsByTagName("book")[0].childNodes;
            var y=xmlDoc.getElementsByTagName("book")[0].firstChild;

            for (i=0;i<x.length;i++)
              {
              // Process only element nodes (type 1)
              if (y.nodeType==1)
                {
                document.write(y.nodeName + "<br>");
                }
              y=y.nextSibling;
              }

                evince -p 384 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)

            2. Get the child nodes of the first book element
            3. Set the "y" variable to be the first child node of the first book element
            4. For each child node (starting with the first child node "y"):
            5. Check the node type. If the node type is "1" it is an element node
            6. Output the name of the node if it is an element node
            7. Set the "y" variable to be the next sibling node, and run
                through the loop again

                evince -p 389 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Node Information

            The nodeName, nodeValue, and nodeType properties
            contain information about nodes.


            Try it Yourself - Examples

            A function, loadXMLDoc() (dom_loadxmldoc.asp), in an
            external JavaScript is used to load the XML file.

            Get the node name of an element node
            (tryit.asp?filename=try_dom_nodename3)

            This example uses the nodeName property to get the node
            name of the root element in "books.xml".

            Get the text from a text node
            (tryit.asp?filename=try_dom_getelement)

            This example uses the nodeValue property to get the text of
            the first <title> element in "books.xml".

            Change the text in a text node
            (tryit.asp?filename=try_dom_changeelement)

            This example uses the nodeValue property to change the
            text of the first <title> element in "books.xml".

            Get the node name and type of an element node

                evince -p 390 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            This example uses the nodeName and nodeType property to
            get node name and type of the root element in "books.xml".


            Node Properties

            In the XML DOM, each node is an object.

            Objects have methods and properties, that can be accessed
            and manipulated by JavaScript.

            Three important node properties are:

            - nodeName
            - nodeValue
            - nodeType


            The nodeName Property

            The nodeName property specifies the name of a node.

            - nodeName is read-only
            - nodeName of an element node is the same as the tag name
            - nodeName of an attribute node is the attribute name
            - nodeName of a text node is always #text
            - nodeName of the document node is always #document


            The nodeValue Property

            The nodeValue property specifies the value of a node.

            - nodeValue for element nodes is undefined
            - nodeValue for text nodes is the text itself
            - nodeValue for attribute nodes is the attribute value

                evince -p 391 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Get the Value of an Element
            The following code retrieves the text node value of the first
            <title> element:

            Example

            var xmlDoc=loadXMLDoc("books.xml");
            var x=xmlDoc.getElementsByTagName("title")[0].childNodes[0];
            var txt=x.nodeValue;

            Result: txt = "Everyday Italian"


            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Get text node of the first <title> element node
            3. Set the txt variable to be the value of the text node


            Change the Value of an Element

            The following code changes the text node value of the first
            <title> element:

            Example

            var xmlDoc=loadXMLDoc("books.xml");
            var x=xmlDoc.getElementsByTagName("title")[0].childNodes[0];
            x.nodeValue="Easy Cooking";


            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Get text node of the first <title> element node
            3. Change the value of the text node to "Easy Cooking"

                evince -p 392 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The nodeType Property

            The nodeType property specifies the type of node.
            nodeType is read only.

            The most important node types are:

            Node type       NodeType

            Element
             --
            1

            Attribute
             --
            2

            Text
             --
            3

            Comment
             --
            8

            Document
             --
            9

            Try it yourself. (tryit.asp?filename=try_dom_root)

                evince -p 397 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Node List

            A list of nodes is returned by the
            getElementsByTagName() method and the childNodes property.


            Try it Yourself - Examples

            The examples below use the XML file books.xml (books.xml).
            A function, loadXMLDoc() (dom_loadxmldoc.asp), in an
            external JavaScript is used to load the XML file.

            Get the text from the first <title> element

            This example uses the getElementsByTagName() method to
            get the text from the first <title> element in "books.xml".

            Loop through nodes using the length property
            (tryit.asp?filename=try_dom_nodelist_length)

            This example uses node list and the length property to loop
            through all <title> elements in "books.xml"

            Get the attribute of an element
            (tryit.asp?filename=try_dom_attributes)

            This example uses a attribute list to get attribute from the
            first <book> element in "books.xml".

                evince -p 398 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            DOM Node List

            When using properties or methods like childNodes or
            getElementsByTagName(), a node list object is returned.

            A node list object represents a list of nodes, in the same
            order as in the XML.

            Nodes in the node list are accessed with index numbers
            starting from 0.

            The following image represents a node list of the <title>
            elements in "books.xml (books.xml)":


            The following code fragment loads "books.xml (books.xml)"
            into xmlDoc using loadXMLDoc() (dom_loadxmldoc.asp) and
            returns a node list of title elements in "books.xml":

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName("title");

            After the execution of the statement above, x is a node
            list object.

                evince -p 399 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The following code fragment returns the text from the first
            <title> element in the node list (x):

            Example

            var txt=x[0].childNodes[0].nodeValue;

            After the execution of the statement above, txt = "Everyday Italian".


            Node List Length

            A node list object keeps itself up-to-date. If an element is
            deleted or added, the list is automatically updated.

            The length property of a node list is the number of nodes in
            the list.

            The following code fragment loads "books.xml (books.xml)"
            into xmlDoc using loadXMLDoc() (dom_loadxmldoc.asp) and
            returns the number of <title> elements in "books.xml":

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName('title').length;

            After the execution of the statement above, x = 4.

            The length of the node list can be used to loop through all
            the elements in the list.

            The following code fragment uses the length property to loop
            through the list of <title> elements:

            Example

            var xmlDoc=loadXMLDoc("books.xml");

            //the x variable will hold a node list
            var x=xmlDoc.getElementsByTagName('title');

                evince -p 400 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            for (i=0;i<x.length;i++)
              {
              document.write(x[i].childNodes[0].nodeValue);
              document.write("<br>");
              }

            Output:

            Everyday Italian
            Harry Potter
            XQuery Kick Start
            Learning XML


            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Set the x variable to hold a node list of all title elements
            3. Output the value from the text node of all <title> elements


            DOM Attribute List (Named Node Map)

            The attributes property of an element node returns a list of
            attribute nodes.

            This is called a named node map, and is similar to a node
            list, except for some differences in methods and properties.

            A attribute list keeps itself up-to-date. If an attribute is
            deleted or added, the list is automatically updated.

            The following code fragment loads "books.xml (books.xml)"
            into xmlDoc using loadXMLDoc() (dom_loadxmldoc.asp) and
            returns a list of attribute nodes from the first <book>
            element in "books.xml":

            var xmlDoc=loadXMLDoc("books.xml");

            var x=xmlDoc.getElementsByTagName('book')[0].attributes;

                evince -p 401 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            After the execution of the code above, x.length = is the
            number of attributes and x.getNamedItem() can be used to
            return an attribute node.

            The following code fragment displays the value of the
            "category" attribute, and the number of attributes, of a book:

            Example

            var xmlDoc=loadXMLDoc("books.xml");
            var x=xmlDoc.getElementsByTagName("book")[0].attributes;

            document.write(x.getNamedItem("category").nodeValue);
            document.write("<br>" + x.length);

            Output:

            cooking
            1


            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Set the x variable to hold a list of all attributes of the
                first <book> element
            3. Output the value from the "category" attribute
            4. Output the length of the attribute list

                evince -p 406 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Traverse Node Tree

            Traversing means looping through or traveling across the
            node tree.


            Traversing the Node Tree

            Often you want to loop an XML document, for example: when
            you want to extract the value of each element.

            This is called "Traversing the node tree"

            The example below loops through all child nodes of <book>,
            and displays their names and values:

            Example

            <html>
            <head>
            <script src="loadxmlstring.js"></script>
            </head>
            <body>
            <script>
            var text="<book>";
            text=text+"<title>Everyday Italian</title>";
            text=text+"<author>Giada De Laurentiis</author>";
            text=text+"<year>2005</year>";
            text=text+"</book>";

                evince -p 407 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            var xmlDoc=loadXMLString(text);

            // documentElement always represents the root node
            var x=xmlDoc.documentElement.childNodes;

            for (i=0;i<x.length;i++)
              {
              document.write(x[i].nodeName);
              document.write(": ");
              document.write(x[i].childNodes[0].nodeValue);
              document.write("<br>");
              }
            </script>
            </body>
            </html>

            Output:

            title: Everyday Italian
            author: Giada De Laurentiis
            year: 2005


            Example explained:

            1. loadXMLString() (dom_loadxmldoc.asp) loads the XML
                string into xmlDoc
            2. Get the child nodes of the root element
            3. For each child node, output the node name and the node
                value of the text node

                evince -p 412 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Browser Differences

            Browser Differences in DOM Parsing

            All modern browsers support the W3C DOM specification.
            However, there are some differences between browsers. One
            important difference is:

            - The way they handle white-spaces and new lines


            DOM - White Spaces and New Lines

            XML often contains new line, or white space characters, between
            nodes. This is often the case when the document is edited by a
            simple editor like Notepad.

            The following example (edited by Notepad) contains CR/LF (new
            line) between each line and two spaces in front of each child node:

            <book>
              <title>Everyday Italian</title>
              <author>Giada De Laurentiis</author>
              <year>2005</year>
              <price>30.00</price>
            </book>

            Internet Explorer 9 and earlier do NOT treat empty white-spaces,
            or new lines as text nodes, while other browsers do.

                evince -p 413 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The following example will output the number of child nodes the
            root element (of books.xml (books.xml)) has. IE9 and earlier will
            output 4 child nodes, while IE10 and later versions, and other
            browsers will output 9 child nodes:

            Example

            var xmlDoc=loadXMLDoc("books.xml");

            var x=xmlDoc.documentElement.childNodes;
            document.write("Number of child nodes: " + x.length);

                evince -p 417 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM - Navigating Nodes

            Nodes can be navigated using node relationships.


            Navigating DOM Nodes

            Accessing nodes in the node tree via the relationship between
            nodes, is often called "navigating nodes".

            In the XML DOM, node relationships are defined as properties
            to the nodes:

            - parentNode
            - childNodes
            - firstChild
            - lastChild
            - nextSibling
            - previousSibling

            The following image illustrates a part of the node tree and the
            relationship between nodes in books.xml (books.xml):


                evince -p 418 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &


            DOM - Parent Node

            All nodes have exactly one parent node. The following code
            navigates to the parent node of <book>:

            Example

            var xmlDoc=loadXMLDoc("books.xml");
            var x=xmlDoc.getElementsByTagName("book")[0];
            document.write(x.parentNode.nodeName);


            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc()
            2. Get the first <book> element
            3. Output the node name of the parent node of "x"


            Avoid Empty Text Nodes

            Firefox, and some other browsers, will treat empty whites-
            paces or new lines as text nodes, Internet Explorer will not.

            This causes a problem when using the properties: firstChild,
            lastChild, nextSibling, previousSibling.

            To avoid navigating to empty text nodes (spaces and new-line
            characters between element nodes), we use a function that
            checks the node type:

                evince -p 419 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            function get_nextSibling(n)
              {
              y=n.nextSibling;
              while (y.nodeType!=1)
                {
                y=y.nextSibling;
                }
              return y;
              }

            The function above allows you to use get_nextSibling(node)
            instead of the property node.nextSibling.

            Code explained:

            Element nodes are type 1. If the sibling node is not an
            element node, it moves to the next nodes until an element
            node is found. This way, the result will be the same in both
            Internet Explorer and Firefox.


            Get the First Child Element

            The following code displays the first element node of the
            first <book>:

            Example

            <html>
            <head>
            <script src="loadxmldoc.js">
            </script>
            <script>
            //check if the first node is an element node
            function get_firstChild(n)
            {
            y=n.firstChild;
            while (y.nodeType!=1)
              {
              y=y.nextSibling;
              }
            return y;
            }
            </script>
            </head>

                evince -p 420 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <body>
            <script>
            var xmlDoc=loadXMLDoc("books.xml");
            var x=get_firstChild(xmlDoc.getElementsByTagName("book")[0]);
            document.write(x.nodeName);
            </script>
            </body>
            </html>

            Output:

            title


            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Use the get_firstChild function on the first <book>
                element node to get the first child node that is an
                element node
            3. Output the node name of first child node that is an
                element node


            More Examples

            lastChild() (tryit.asp?filename=try_dom_nav_lastchild)
            This example uses the lastChild() method and a custom
            function to get the last child node of a node

            nextSibling() (tryit.asp?filename=try_dom_nav_nextsibling)
            This example uses the nextSibling() method and a custom
            function to get the next sibling node of a node

            previousSibling() (tryit.asp?filename=try_dom_nav_prevsibling)
            This example uses the previousSibling() method and a custom
            function to get the previous sibling node of a node

                evince -p 425 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Get Node Values

            The nodeValue property is used to get the text value of a node.

            The getAttribute() method returns the value of an attribute.


            Get the Value of an Element

            In the DOM, everything is a node. Element nodes do not have a
            text value.

            The text of an element node is stored in a child node. This node is
            called a text node.

            The way to get the text of an element is to get the value of the
            child node (text node).


            Get an Element Value

            The getElementsByTagName() method returns a node list
            containing all elements with the specified tag name in the same
            order as they appear in the source document.

            The following code loads "books.xml (books.xml)" into xmlDoc
            using loadXMLDoc() (dom_loadxmldoc.asp) and retrieves the first
            <title> element:

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName("title")[0];

                evince -p 426 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The childNodes property returns a list of child nodes. The <title>
            element has only one child node. It is a text node.

            The following code retrieves the text node of the <title> element:

            x=xmlDoc.getElementsByTagName("title")[0];
            y=x.childNodes[0];

            The nodeValue property returns the text value of the text node:

            Example

            x=xmlDoc.getElementsByTagName("title")[0];
            y=x.childNodes[0];
            txt=y.nodeValue;

            Result: txt = "Everyday Italian"

            Loop through all <title> elements: Try it yourself
            (tryit.asp?filename=try_dom_getelementsbytagname1)


            Get the Value of an Attribute


            In the DOM, attributes are nodes. Unlike element nodes, attribute
            nodes have text values.

            The way to get the value of an attribute, is to get its text value.

            This can be done using the getAttribute() method or using the
            nodeValue property of the attribute node.


            Get an Attribute Value - getAttribute()

            The getAttribute() method returns an attribute value.

            The following code retrieves the text value of the "lang" attribute of
            the first <title> element:

            Example

            xmlDoc=loadXMLDoc("books.xml");

            txt=xmlDoc.getElementsByTagName("title")
            [0].getAttribute("lang");

                evince -p 427 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Result: txt = "en"

            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Set the txt variable to be the value of the "lang" attribute of
                the first title element node

            Loop through all <book> elements and get their "category"
            attributes: Try it yourself
            (tryit.asp?filename=try_dom_getattribute1)


            Get an Attribute Value getAttributeNode()

            The getAttributeNode() method returns an attribute node.

            The following code retrieves the text value of the "lang" attribute of
            the first <title> element:


            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName("title")
            [0].getAttributeNode("lang");
            txt=x.nodeValue;

            Result: txt = "en"

            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Get the "lang" attribute node of the first <title> element node
            3. Set the txt variable to be the value of the attribute

            Loop through all <book> elements and get their "category"
            attributes: Try it yourself
            (tryit.asp?filename=try_dom_getattributenode2)

                evince -p 431 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Change Node Values

            The nodeValue property is used to change a node value.

            The setAttribute() method is used to change an attribute value.


            Try it Yourself - Examples

            The examples below use the XML file books.xml (books.xml).

            A function, loadXMLDoc() (dom_loadxmldoc.asp), in an external
            JavaScript is used to load the XML file.

            Change an elements text node
            (tryit.asp?filename=try_dom_change_nodevalue)

            This example uses the nodeValue property to change the text
            node of the first <title> element in "books.xml".

            Change an attributes value using setAttribute
            (tryit.asp?filename=try_dom_setattribute1)

            This example uses the setAttribute() method to change the
            value of the "category" attribute of the first <book>.

            Change an attributes value using nodeValue

            This example use the nodeValue property to change the value
            of the "category" attribute of the first <book>.

                evince -p 432 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Change the Value of an Element

            In the DOM, everything is a node. Element nodes do not have a
            text value.

            The text of an element node is stored in a child node. This node
            is called a text node.

            The way to change the text of an element, is to change the
            value of the child node (text node).


            Change the Value of a Text Node

            The nodeValue property can be used to change the value of a
            text node.

            The following code changes the text node value of the first
            <title> element:


            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName("title")[0].childNodes[0];
            x.nodeValue="Easy Cooking";


            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Get the text node of the first <title> element
            3. Change the node value of the text node to "Easy Cooking"

            Loop through and change the text node of all <title> elements:

            Try it yourself
            (tryit.asp?filename=try_dom_change_nodevalue2)


            Change the Value of an Attribute

            In the DOM, attributes are nodes. Unlike element nodes,
            attribute nodes have text values.

                evince -p 433 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The way to change the value of an attribute, is to change its
            text value.

            This can be done using the setAttribute() method or using the
            nodeValue property of the attribute node.


            Change an Attribute Using setAttribute()

            The setAttribute() method changes the value of an existing
            attribute, or creates a new attribute.

            The following code changes the category attribute of the
            <book> element:

            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName('book');
            x[0].setAttribute("category","food");


            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Get the first <book> element
            3. Change the "category" attribute value to "food"

            Loop through all <title> elements and add a new attribute: Try
            it yourself (tryit.asp?filename=try_dom_setattribute2)

            Note: If the attribute does not exist, a new attribute is created
            (with the name and value specified).


            Change an Attribute Using nodeValue

            The nodeValue property can be used to change the value of a
            attribute node:

                evince -p 434 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName("book")[0]
            y=x.getAttributeNode("category");
            y.nodeValue="food";

            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Get the "category" attribute of the first <book> element
            3. Change the attribute node value to "food"

                evince -p 439 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Remove Nodes

            The removeChild() method removes a specified node.
            The removeAttribute() method removes a specified
            attribute.


            Try it Yourself - Examples

            The examples below use the XML file books.xml (books.xml).

            A function, loadXMLDoc() (dom_loadxmldoc.asp), in an
            external JavaScript is used to load the XML file.

            Remove an element node

            This example uses removeChild() to remove the first <book>

            Remove the current element node
            (tryit.asp?filename=try_dom_removecurrent)

            This example uses parentNode and removeChild() to remove
            the current <book> element.

            Remove a text node
            (tryit.asp?filename=try_dom_removetextnode)

            This example uses removeChild() to remove the text node
            from the first <title> element.

                evince -p 440 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Clear the text of a text node

            This example uses the nodeValue() property to clear the text
            node of the first <title> element.

            Remove an attribute by name
            (tryit.asp?filename=try_dom_removeattribute)

            This example uses removeAttribute() to remove the
            "category" attribute from the first <book> element.

            Remove attributes by object
            (tryit.asp?filename=try_dom_removeattributenode)

            This example uses removeAttributeNode() to remove all
            attributes from all <book> elements.


            Remove an Element Node

            The removeChild() method removes a specified node.
            When a node is removed, all its child nodes are also removed.

            The following code fragment will remove the first <book>
            element from the loaded xml:

            Example

            xmlDoc=loadXMLDoc("books.xml");

            y=xmlDoc.getElementsByTagName("book")[0];

            xmlDoc.documentElement.removeChild(y);


            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Set the variable y to be the element node to remove
            3. Remove the element node by using the removeChild()
                method from the parent node

                evince -p 441 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Remove Myself - Remove the Current Node

            The removeChild() method is the only way to remove a
            specified node.

            When you have navigated to the node you want to remove, it
            is possible to remove that node using the parentNode
            property and the removeChild() method:

            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName("book")[0];

            x.parentNode.removeChild(x);


            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Set the variable y to be the element node to remove
            3. Remove the element node by using the parentNode
                property and the removeChild() method


            Remove a Text Node

            The removeChild() method can also be used to remove a
            text node:

            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName("title")[0];

            y=x.childNodes[0];
            x.removeChild(y);

                evince -p 442 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Set the variable x to be the first title element node
            3. Set the variable y to be the text node to remove
            4. Remove the element node by using the removeChild()
                method from the parent node

            It is not very common to use removeChild() just to remove
            the text from a node. The nodeValue property can be used
            instead. See next paragraph.


            Clear a Text Node

            The nodeValue property can be used to change or clear the
            value of a text node:

            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName("title")
            [0].childNodes[0];
            x.nodeValue="";


            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Set the variable x to be the text node of the first title element
            3. Use the nodeValue property to clear the text from the
                text node

            Loop through and change the text node of all <title>
            elements: Try it yourself
            (tryit.asp?filename=try_dom_remove_nodevalue2)

                evince -p 443 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Remove an Attribute Node by Name

            The removeAttribute(name) method is used to remove an
            attribute node by its name.

            Example: removeAttribute('category')

            The following code fragment removes the "category"
            attribute in the first <book> element:

            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName("book");
            x[0].removeAttribute("category");

            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Use getElementsByTagName() to get book nodes
            3. Remove the "category" attribute form the first book
                element node

            Loop through and remove the "category" attribute of all
            <book> elements: Try it yourself
            (tryit.asp?filename=try_dom_removeattribute2)


            Remove Attribute Nodes by Object

            The removeAttributeNode(node) method is used to remove
            an attribute node, using the node object as parameter.

            Example: removeAttributeNode(x)

            The following code fragment removes all the attributes of all
            <book> elements:

                evince -p 444 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName("book");

            for (i=0;i<x.length;i++)
            {
            while (x[i].attributes.length>0)
              {
              attnode=x[i].attributes[0];
              old_att=x[i].removeAttributeNode(attnode);
              }
            }

            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Use getElementsByTagName() to get all book nodes
            3. For each book element check if there are any attributes
            4. While there are attributes in a book element, remove
                the attribute

                evince -p 449 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Replace Nodes

            The replaceChild() method replaces a specified node.

            The nodeValue property replaces text in a text node.


            Try it Yourself - Examples

            The examples below use the XML file books.xml (books.xml).

            A function, loadXMLDoc() (dom_loadxmldoc.asp), in an
            external JavaScript is used to load the XML file.

            Replace an element node

            This example uses replaceChild() to replace the first <book> node.

            Replace data in a text node
            (tryit.asp?filename=try_dom_replacedata2)

            This example uses the nodeValue property to replace data in
            a text node.


            Replace an Element Node

            The replaceChild() method is used to replace a node.

            The following code fragment replaces the first <book> element:

                evince -p 450 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.documentElement;

            //create a book element, title element and a text node
            newNode=xmlDoc.createElement("book");
            newTitle=xmlDoc.createElement("title");
            newText=xmlDoc.createTextNode("A Notebook");

            //add the text node to the title node,
            newTitle.appendChild(newText);
            //add the title node to the book node
            newNode.appendChild(newTitle);

            y=xmlDoc.getElementsByTagName("book")[0]
            //replace the first book node with the new node
            x.replaceChild(newNode,y);


            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Create a new element node <book>
            3. Create a new element node <title>
            4. Create a new text node with the text "A Notebook"
            5. Append the new text node to the new element node <title>
            6. Append the new element node <title> to the new
                element node <book>
            7. Replace the first <book> element node with the new
                <book> element node


            Replace Data In a Text Node

            The replaceData() method is used to replace data in a text node.

                evince -p 451 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The replaceData() method has three parameters:

            - offset - Where to begin replacing characters. Offset
                value starts at zero
            - length - How many characters to replace
            - string - The string to insert


            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName("title")
            [0].childNodes[0];

            x.replaceData(0,8,"Easy");


            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Get the text node of the first <title> element node
            3. Use the replaceData method to replace the eight first
                characters from the text node with "Easy"


            Use the nodeValue Property Instead

            It is easier to replace the data in a text node using the
            nodeValue property.

            The following code fragment will replace the text node value
            in the first <title> element with "Easy Italian":

            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName("title")
            [0].childNodes[0];

            x.nodeValue="Easy Italian";

                evince -p 452 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Get the text node of the first <title> element node
            3. Use the nodeValue property to change the text of the
                text node

            You can read more about changing node values in the
            Change Node chapter (dom_nodes_set.asp).

                evince -p 457 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Create Nodes




            Create an element node
            (tryit.asp?filename=try_dom_createelement1)

            This example uses createElement() to create a new element
            node, and appendChild() to add it to a node.

            Create an attribute node using createAttribute
            (tryit.asp?filename=try_dom_createattribute)

            This example uses createAttribute() to create a new attribute
            node, and setAttributeNode() to insert it to an element.

            Create an attribute node using setAttribute
            (tryit.asp?filename=try_dom_createattribute3)

            This example uses setAttribute() to create a new attribute for
            an element.

            Create a text node
            (tryit.asp?filename=try_dom_createelement1)

            This example uses createTextNode() to create a new text
            node, and appendChild() to add it to an element.

            Create a CDATA section node
            (tryit.asp?filename=try_dom_createcdatasection1)

                evince -p 458 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            This example uses createCDATAsection() to create a CDATA
            section node, and appendChild() to add it to an element.

            Create a comment node

            This example uses createComment() to create a comment
            node, and appendChild() to add it to an element.


            Create a New Element Node

            The createElement() method creates a new element node:

            Example

            xmlDoc=loadXMLDoc("books.xml");

            newel=xmlDoc.createElement("edition");

            x=xmlDoc.getElementsByTagName("book")[0];
            x.appendChild(newel);


            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Create a new element node <edition>
            3. Append the element node to the first <book> element

            Loop through and add an element to all <book> elements:
            Try it yourself (tryit.asp?filename=try_dom_createelement)


            Create a New Attribute Node

            The createAttribute() is used to create a new attribute node:

            Example

            xmlDoc=loadXMLDoc("books.xml");

            newatt=xmlDoc.createAttribute("edition");
            newatt.nodeValue="first";

                evince -p 459 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            x=xmlDoc.getElementsByTagName("title");
            x[0].setAttributeNode(newatt);


            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Create a new attribute node "edition"
            3. Set the value of the attribute node to "first"
            4. Add the new attribute node to the first <title> element

            Loop through all <title> elements and add a new attribute
            node: Try it yourself
            (tryit.asp?filename=try_dom_createattribute2)

            Note: If the attribute already exists, it is replaced by the new one.


            Create an Attribute Using setAttribute()

            Since the setAttribute() method creates a new attribute if the
            attribute does not exist, it can be used to create a new
            attribute.

            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName('book');
            x[0].setAttribute("edition","first");

            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Set (create) the attribute "edition" with the value "first"
                for the first <book> element

                evince -p 460 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Loop through all <title> elements and add a new attribute:
            Try it yourself (tryit.asp?filename=try_dom_createattribute4)


            Create a Text Node

            The createTextNode() method creates a new text node:

            Example

            xmlDoc=loadXMLDoc("books.xml");

            newel=xmlDoc.createElement("edition");
            newtext=xmlDoc.createTextNode("first");
            newel.appendChild(newtext);

            x=xmlDoc.getElementsByTagName("book")[0];
            x.appendChild(newel);


            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Create a new element node <edition>
            3. Create a new text node with the text "first"
            4. Append the new text node to the element node
            5. Append the new element node to the first <book> element

            Add an element node, with a text node, to all <book>
            elements: Try it yourself
            (tryit.asp?filename=try_dom_createelement)


            Create a CDATA Section Node

            The createCDATASection() method creates a new CDATA
            section node.


            Example

            xmlDoc=loadXMLDoc("books.xml");

                evince -p 461 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            newCDATA=xmlDoc.createCDATASection("Special Offer & Book Sale");

            x=xmlDoc.getElementsByTagName("book")[0];
            x.appendChild(newCDATA);


            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Create a new CDATA section node
            3. Append the new CDATA node to the first <book> element

            Loop through, and add a CDATA section, to all <book>
            elements: Try it yourself
            (tryit.asp?filename=try_dom_createcdatasection)


            Create a Comment Node

            The createComment() method creates a new comment node.

            Example

            xmlDoc=loadXMLDoc("books.xml");

            newComment=xmlDoc.createComment("Revised March 2008");

            x=xmlDoc.getElementsByTagName("book")[0];
            x.appendChild(newComment);


            Example explained:
            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Create a new comment node
            3. Append the new comment node to the first <book> element

                evince -p 462 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Loop through, and add a comment node, to all <book>
            elements: Try it yourself
            (tryit.asp?filename=try_dom_createcomment)

                evince -p 466 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Add Nodes







                evince -p 467 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Add a Node - appendChild()

            The appendChild() method adds a child node to an existing node.

            The new node is added (appended) after any existing child nodes.

            Note: Use insertBefore() if the position of the node is important.

            The following code fragment creates an element (<edition>),
            and adds it after the last child of the first <book> element:

            Example

            xmlDoc=loadXMLDoc("books.xml");

            newel=xmlDoc.createElement("edition");

            x=xmlDoc.getElementsByTagName("book")[0];
            x.appendChild(newel);


            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Create a new node <edition>
            3. Append the node to the first <book> element

            Loop through and append an element to all <book>
            elements:Try it yourself
            (tryit.asp?filename=try_dom_createelement)


            Insert a Node - insertBefore()

            The insertBefore() method is used to insert a node before a
            specified child node.

            This method is useful when the position of the added node is
            important:

                evince -p 468 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example

            xmlDoc=loadXMLDoc("books.xml");

            newNode=xmlDoc.createElement("book");

            x=xmlDoc.documentElement;
            y=xmlDoc.getElementsByTagName("book")[3];

            x.insertBefore(newNode,y);


            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Create a new element node <book>
            3. Insert the new node in front of the last <book> element node

            If the second parameter of insertBefore() is null, the new
            node will be added after the last existing child node.

            x.insertBefore(newNode,null) and
            x.appendChild(newNode) will both append a new child
            node to x.


            Add a New Attribute

            There is no method called addAtribute().

            The setAttribute() method creates a new attribute if the
            attribute does not exist:

            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName('book');
            x[0].setAttribute("edition","first");

                evince -p 469 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
            loadXMLDoc() (dom_loadxmldoc.asp)

            2. Set (create) the attribute "edition" with the value "first"
            for the first <book> element

            Note: If the attribute already exists, the setAttribute()
            method will overwrite the existing value.


            Add Text to a Text Node insertData()

            The insertData() method inserts data into an existing text node.

            The insertData() method has two parameters:

            - offset - Where to begin inserting characters (starts at zero)
            - string - The string to insert

            The following code fragment will add "Easy" to the text node
            of the first <title> element of the loaded XML:

            Example

            xmlDoc=loadXMLDoc("books.xml");

            x=xmlDoc.getElementsByTagName("title")[0].childNodes[0];

            x.insertData(0,"Easy ");

                evince -p 473 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML DOM Clone Nodes

            Try it Yourself - Examples

            The examples below use the XML file books.xml (books.xml).

            A function, loadXMLDoc() (dom_loadxmldoc.asp), in an
            external JavaScript is used to load the XML file.

            Copy a node and append it to an existing node
            (tryit.asp?filename=try_dom_clonenode)

            This example uses cloneNode() to copy a node and append it to
            the root node of the XML document


            Copy a Node

            The cloneNode() method creates a copy of a specified node.

            The cloneNode() method has a parameter (true or false). This
            parameter indicates if the cloned node should include all
            attributes and child nodes of the original node.

            The following code fragment copies the first <book> node and
            appends it to the root node of the document:

            Example

            xmlDoc=loadXMLDoc("books.xml");
            oldNode=xmlDoc.getElementsByTagName('book')[0];
            newNode=oldNode.cloneNode(true);

                evince -p 474 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            xmlDoc.documentElement.appendChild(newNode);

            //Output all titles
            y=xmlDoc.getElementsByTagName("title");
            for (i=0;i<y.length;i++)
              {
              document.write(y[i].childNodes[0].nodeValue);
              document.write("<br>");
              }

            Output:

            Everyday Italian
            Harry Potter
            XQuery Kick Start
            Learning XML
            Everyday Italian


            Example explained:

            1. Load "books.xml (books.xml)" into xmlDoc using
                loadXMLDoc() (dom_loadxmldoc.asp)
            2. Get the node to copy
            3. Copy the node into "newNode" using the cloneNode method
            4. Append the new node to the the root node of the XML document
            5. Output all titles for all books in the document

                evince -p 479 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The XMLHttpRequest Object

            With the XMLHttpRequest object you can update parts of a
            web page, without reloading the whole page.


            The XMLHttpRequest Object

            The XMLHttpRequest object is used to exchange data with a
            server behind the scenes.

            The XMLHttpRequest object is the developers dream, because
            you can:

            - Update a web page without reloading the page
            - Request data from a server after the page has loaded
            - Receive data from a server after the page has loaded
            - Send data to a server in the background


            Create an XMLHttpRequest Object

            All modern browsers (IE7+, Firefox, Chrome, Safari, and Opera)
            have a built-in XMLHttpRequest object.

            Syntax for creating an XMLHttpRequest object:

            xmlhttp=new XMLHttpRequest();

            Old versions of Internet Explorer (IE5 and IE6) uses an ActiveX Object:

                evince -p 480 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");

            To handle all modern browsers, including IE5 and IE6, check if
            the browser supports the XMLHttpRequest object. If it does,
            create an XMLHttpRequest object, if not, create an ActiveXObject:

            Example

            if (window.XMLHttpRequest)
              {// code for IE7+, Firefox, Chrome, Opera, Safari
              xmlhttp=new XMLHttpRequest();
              }
            else
              {// code for IE6, IE5
              xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
              }


            Send a Request To a Server

            To send a request to a server, we use the open() and send()
            methods of the XMLHttpRequest object:

            xmlhttp.open("GET","xmlhttp_info.txt",true);
            xmlhttp.send();


            Method      Description

            open(method,url,async)
             --
            Specifies the type of request, the
            URL, and if the request should be
            handled asynchronously or not.
                    --
            method: the type of request: GET or POST
            url: the location of the file on the server
            async: true (asynchronous) or false (synchronous)

            send(string) 
             --
            Sends the request off to the server.
                    --
            string: Only used for POST requests

                evince -p 481 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            GET or POST?

            GET is simpler and faster than POST, and can be used in most cases.

            However, always use POST requests when:

            - A cached file is not an option (update a file or database on the server)
            - Sending a large amount of data to the server (POST has no size limitations)
            - Sending user input (which can contain unknown
            characters), POST is more robust and secure than GET


            The url - A File On a Server

            The url parameter of the open() method, is an address to a file
            on a server:

            xmlhttp.open("GET","xmlhttp_info.txt",true);

            The file can be any kind of file, like .txt and .xml, or server
            scripting files like .asp and .php (which can perform actions on
            the server before sending the response back).


            Asynchronous - True or False?

            To send the request asynchronously, the async parameter of the
            open() method has to be set to true:

            xmlhttp.open("GET","xmlhttp_info.txt",true);

            Sending asynchronously requests is a huge improvement for web
            developers. Many of the tasks performed on the server are very
            time consuming.

                evince -p 482 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            By sending asynchronously, the JavaScript does not have to wait
            for the server response, but can instead:
            - execute other scripts while waiting for server response
            - deal with the response when the response is ready


            Async=true

            When using async=true, specify a function to execute when the
            response is ready in the onreadystatechange event:

            Example

            xmlhttp.onreadystatechange=function()
              {
              if (xmlhttp.readyState==4 && xmlhttp.status==200)
                {
                document.getElementById("myDiv").innerHTML=xmlhttp.re
                sponseText;
                }
              }
            xmlhttp.open("GET","xmlhttp_info.txt",true);
            xmlhttp.send();


            Async=false

            To use async=false, change the third parameter in the open()
            method to false:

            xmlhttp.open("GET","xmlhttp_info.txt",false);

            Using async=false is not recommended, but for a few small
            requests this can be ok.

            Remember that the JavaScript will NOT continue to execute, until
            the server response is ready. If the server is busy or slow, the
            application will hang or stop.

            Note: When you use async=false, do NOT write an
            onreadystatechange function - just put the code after the send()
            statement:

                evince -p 483 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example

            xmlhttp.open("GET","xmlhttp_info.txt",false);
            xmlhttp.send();
            document.getElementById("myDiv").innerHTML=xmlhttp.responseText;


            Server Response

            To get the response from a server, use the responseText or
            responseXML property of the XMLHttpRequest object.

            Property    Description

            responseText
             --
            get the response data as a string

            responseXML
             --
            get the response data as XML data


            The responseText Property

            If the response from the server is not XML, use the responseText property.

            The responseText property returns the response as a string, and
            you can use it accordingly:

            Example

            document.getElementById("myDiv").innerHTML=xmlhttp.responseText;


            The responseXML Property

            If the response from the server is XML, and you want to parse it
            as an XML object, use the responseXML property:


            Example

            Request the file cd_catalog.xml (cd_catalog.xml) and parse the response:

                evince -p 484 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            xmlDoc=xmlhttp.responseXML;
            var txt="";
            x=xmlDoc.getElementsByTagName("ARTIST");
            for (i=0;i<x.length;i++)
              {
              txt=txt + x[i].childNodes[0].nodeValue + "<br>";
              }
            document.getElementById("myDiv").innerHTML=txt;


            The onreadystatechange event

            When a request to a server is sent, we want to perform some
            actions based on the response.

            The onreadystatechange event is triggered every time the
            readyState changes.

            The readyState property holds the status of the XMLHttpRequest.

            Three important properties of the XMLHttpRequest object:

            Property        Description

            onreadystatechange
             --
            Stores a function (or the name of a
            function) to be called automatically each
            time the readyState property changes

            readyState
             --
            Holds the status of the XMLHttpRequest.
            Changes from 0 to 4:
            0: request not initialized
            1: server connection established
            2: request received
            3: processing request
            4: request finished and response is ready

            status
             --
            200: "OK"
            404: Page not found

            In the onreadystatechange event, we specify what will happen
            when the server response is ready to be processed.

            When readyState is 4 and status is 200, the response is ready:

                evince -p 485 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example

            xmlhttp.onreadystatechange=function()
              {
              if (xmlhttp.readyState==4 && xmlhttp.status==200)
                {
                document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
                }
              }

            Note: The onreadystatechange event is triggered four times, one
            time for each change in readyState.


            More Examples

            Retrieve header information with getAllResponseHeaders()
            (tryit.asp?filename=try_dom_xmlhttprequest_header)
            Retrieve header information of a resource (file).

            Retrieve specific header information with getResponseHeader()
            (tryit.asp?filename=try_dom_xmlhttprequest_lastmodified)
            Retrieve specific header information of a resource (file).

            Retrieve the content of an ASP file
            (tryit.asp?filename=try_dom_xmlhttprequest_suggest)
            How a web page can communicate with a web server while a
            user type characters in an input field.

            Retrieve content from a database
            (tryit.asp?filename=try_dom_xmlhttprequest_database)
            How a web page can fetch information from a database with the
            XMLHttpRequest object.

            Retrieve the content of an XML file
            (tryit.asp?filename=try_dom_xmlhttprequest_xml)
            Create an XMLHttpRequest to retrieve data from an XML file and
            display the data in an HTML table.

                evince -p 489 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Applications

            This chapter demonstrates some small XML applications
            built on XML, HTML, XML DOM and JavaScript.


            The XML Document Used

            In this application we will use the "cd_catalog.xml"
            (cd_catalog.xml) file.


            Display the First CD in an HTML div Element

            The following example gets the XML data from the first CD
            element and displays it in an HTML element with
            id="showCD". The displayCD() function is called when the
            page is loaded:

            Example

            x=xmlDoc.getElementsByTagName("CD");
            i=0;

                evince -p 490 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            function displayCD()
            {
            artist=(x[i].getElementsByTagName("ARTIST")
            [0].childNodes[0].nodeValue);
            title=(x[i].getElementsByTagName("TITLE")
            [0].childNodes[0].nodeValue);
            year=(x[i].getElementsByTagName("YEAR")
            [0].childNodes[0].nodeValue);
            txt="Artist: " + artist + "<br />Title: " + title
            + "<br />Year: "+ year;
            document.getElementById("showCD").innerHTML=txt;
            }


            Navigate Between the CDs

            To navigate between the CDs, in the example above, add a
            next() and previous() function:

            Example

            function next()
            { // display the next CD, unless you are on the
            last CD
            if (i<x.length-1)
              {
              i++;
              displayCD();
              }
            }

            function previous()
            { // displays the previous CD, unless you are on
            the first CD
            if (i>0)
              {
              i--;
              displayCD();
              }
            }

                evince -p 491 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Show Album Information When Clicking On a CD

            The last example shows how you can show album
            information when the user clicks on a CD:

            Try it yourself (tryit.asp?filename=tryxml_app).

            For more information about using JavaScript and the XML
            DOM, visit our XML DOM tutorial. (/dom/default.asp)

                evince -p 495 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML and XPath

            XPath (the XML Path language) is a language for finding
            information in an XML document.


            What is XPath?

            - XPath is a syntax for defining parts of an XML document
            - XPath uses path expressions to navigate in XML documents
            - XPath contains a library of standard functions
            - XPath is a major element in XSLT  (***!!)
            - XPath is also used in XQuery, XPointer and XLink
            - XPath is a W3C recommendation


            XPath Path Expressions

            XPath uses path expressions to select nodes or node-sets in
            an XML document. These path expressions look very much
            like the expressions you see when you work with a
            traditional computer file system.

                evince -p 496 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Today XPath expressions can also be used in JavaScript,
            Java, XML Schema, PHP, Python, C and C++, and lots of
            other languages.


            XPath is Used in XSLT

            XPath is a major element in the XSLT standard. Without
            XPath knowledge you will not be able to create XSLT documents.


            XPath Example

            We will use the following XML document:

            <?xml version="1.0" encoding="UTF-8"?>

            <bookstore>

            <book category="COOKING">
              <title lang="en">Everyday Italian</title>
              <author>Giada De Laurentiis</author>
              <year>2005</year>
              <price>30.00</price>
            </book>

            <book category="CHILDREN">
              <title lang="en">Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>

            <book category="WEB">
              <title lang="en">XQuery Kick Start</title>
              <author>James McGovern</author>
              <author>Per Bothner</author>
              <author>Kurt Cagle</author>
              <author>James Linn</author>
              <author>Vaidyanathan Nagarajan</author>
              <year>2003</year>
              <price>49.99</price>
            </book>

                evince -p 497 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <book category="WEB">
              <title lang="en">Learning XML</title>
              <author>Erik T. Ray</author>
              <year>2003</year>
              <price>39.95</price>
            </book>

            </bookstore>

            In the table below we have listed some XPath expressions
            and the result of the expressions:


            XPath Expression    Result

            /bookstore/book[1]
             --
            Selects the first book element that
            is the child of the bookstore element

            /bookstore
            /book[last()]
             --
            Selects the last book element that
            is the child of the bookstore element

            /bookstore
            /book[last()-1]
             --
            Selects the last but one book
            element that is the child of the
            bookstore element

            /bookstore
            /book[position()<3]
             --
            Selects the first two book
            elements that are children of the
            bookstore element

            //title[@lang]
             --
            Selects all the title elements that
            have an attribute named lang

            //title[@lang='en']
             --
            Selects all the title elements that
            have a "lang" attribute with a
            value of "en"

            /bookstore
            /book[price>35.00]
             --
            Selects all the book elements of
            the bookstore element that have a
            price element with a value greater
            than 35.00

                evince -p 498 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            /bookstore
            /book[price>35.00]
            /title                  // ??
             --
            Selects all the title elements of
            the book elements of the
            bookstore element that have a
            price element with a value greater
            than 35.00


            If you want to learn more about XPath, find our XPath
            tutorial on our homepage (/default.asp).

                evince -p 502 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XPath Operators

            XPath is used to navigate through
            elements and attributes in an XML document.

            XPath is a major element in W3C's XSLT
            standard - and XQuery and XPointer are
            both built on XPath expressions.


            What You Should Already Know

            Before you continue you should have a basic understanding
            of the following:

            - HTML
            - XML

            If you want to study these subjects first, find the tutorials on
            our Home page (/default.asp).

                evince -p 503 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            What is XPath?

            - XPath is a syntax for defining parts of an XML document
            - XPath uses path expressions to navigate in XML documents
            - XPath contains a library of standard functions
            - XPath is a major element in XSLT
            - XPath is a W3C recommendation


            XPath Path Expressions

            XPath uses path expressions to select nodes or node-sets in
            an XML document. These path expressions look very much
            like the expressions you see when you work with a
            traditional computer file system.


            XPath Standard Functions

            XPath includes over 100 built-in functions. There are
            functions for string values, numeric values, date and time
            comparison, node and QName manipulation, sequence
            manipulation, Boolean values, and more.


            XPath is Used in XSLT

            XPath is a major element in the XSLT standard. Without
            XPath knowledge you will not be able to create XSLT documents.

            You can read more about XSLT in our XSLT tutorial
            (/xsl/default.asp).

            XQuery and XPointer are both built on XPath expressions.
            XQuery 1.0 and XPath 2.0 share the same data model and
            support the same functions and operators.

            You can read more about XQuery in our XQuery tutorial
            (/xquery/default.asp).

                evince -p 504 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XPath is a W3C Recommendation

            XPath became a W3C Recommendation 16. November 1999.

            XPath was designed to be used by XSLT, XPointer and other
            XML parsing software.

                evince -p 508 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XPath Nodes


            XPath Terminology

            Nodes

            In XPath, there are seven kinds of nodes: element, attribute,
            text, namespace, processing-instruction, comment, and
            document nodes.

            XML documents are treated as trees of nodes. The topmost
            element of the tree is called the root element.

            Look at the following XML document:

            <?xml version="1.0" encoding="UTF-8"?>

            <bookstore>
              <book>
                <title lang="en">Harry Potter</title>
                <author>J K. Rowling</author>
                <year>2005</year>
                <price>29.99</price>
              </book>
            </bookstore>

            Example of nodes in the XML document above:

            <bookstore> (root element node)

                evince -p 509 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <author>J K. Rowling</author> (element node)
            lang="en" (attribute node)


            Atomic values

            Atomic values are nodes with no children or parent.
            Example of atomic values:

            J K. Rowling
            "en"


            Items

            Items are atomic values or nodes.


            Relationship of Nodes

            Parent

            Each element and attribute has one parent.

            In the following example; the book element is the parent of
            the title, author, year, and price:

            <book>
              <title>Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>


            Children

            Element nodes may have zero, one or more children.

            In the following example; the title, author, year, and price
            elements are all children of the book element:

                evince -p 510 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <book>
              <title>Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>


            Siblings

            Nodes that have the same parent.
            In the following example; the title, author, year, and price
            elements are all siblings:

            <book>
              <title>Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>


            Ancestors

            A node's parent, parent's parent, etc.

            In the following example; the ancestors of the title element
            are the book element and the bookstore element:

            <bookstore>

            <book>
              <title>Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>

            </bookstore>


            Descendants

            A node's children, children's children, etc.
            In the following example; descendants of the bookstore
            element are the book, title, author, year, and price elements:

                evince -p 511 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <bookstore>

            <book>
              <title>Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>

            </bookstore>

                evince -p 515 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XPath Syntax

            XPath uses path expressions to select nodes or node-sets
            in an XML document. The node is selected by following a
            path or steps.


            The XML Example Document

            We will use the following XML document in the examples below.

            <?xml version="1.0" encoding="UTF-8"?>

            <bookstore>

            <book>
              <title lang="en">Harry Potter</title>
              <price>29.99</price>
            </book>

            <book>
              <title lang="en">Learning XML</title>
              <price>39.95</price>
            </book>

            </bookstore>

                evince -p 516 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Selecting Nodes

            XPath uses path expressions to select nodes in an XML
            document. The node is selected by following a path or steps.
            The most useful path expressions are listed below:

            Expression      Description

            nodename
                --
            Selects all nodes with the name
            "nodename"

            /
                --
            Selects from the root node

            //
                --
            Selects nodes in the document from the
            current node that match the selection no
            matter where they are

            .
                --
            Selects the current node

            ..
                --
            Selects the parent of the current node

            @
                --
            Selects attributes


            In the table below we have listed some path expressions and
            the result of the expressions:


            Path Expression     Result

            bookstore
             --
            Selects all nodes with the name
            "bookstore"

            /bookstore
             --
            Selects the root element bookstore
            Note: If the path starts with a slash ( /
            ) it always represents an absolute path
            to an element!

            bookstore/book
             --
            Selects all book elements that are
            children of bookstore

            //book
             --
            Selects all book elements no matter
            where they are in the document

                evince -p 517 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            bookstore//book
             --
            Selects all book elements
            that are
            descendant of the bookstore element,
            no matter where they are under the
            bookstore element

            //@lang
             --
            Selects all attributes that are named lang


            Predicates

            Predicates are used to find a specific node or a node that
            contains a specific value.
            Predicates are always embedded in square brackets.
            In the table below we have listed some path expressions
            with predicates and the result of the expressions:


            Path Expression     Result

            /bookstore/book[1]
             --
            Selects the first book element that is the child
            of the bookstore element.
            Note: In IE 5,6,7,8,9 first node is[0], but
            according to W3C, it is [1]. To solve this
            problem in IE, set the SelectionLanguage to
            XPath:
                --
            In JavaScript:
            xml.setProperty("SelectionLanguage","XPath");

            /bookstore
            /book[last()]
             --
            Selects the last book element that is the child
            of the bookstore element

            /bookstore
            /book[last()-1]
             --
            Selects the last but one book element that is
            the child of the bookstore element

            /bookstore
            /book[position()<3]
             --
            Selects the first two book elements that are
            children of the bookstore element

            //title[@lang]
             --
            Selects all the title elements that have an
            attribute named lang

                evince -p 518 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            //title[@lang='en']
             --
            Selects all the 
            title elements that have a "lang"
            attribute with a value of "en"

            /bookstore
            /book[price>35.00]
             --
            Selects all the book elements of the bookstore
            element that have a price element with a value
            greater than 35.00

            /bookstore
            /book[price>35.00]
            /title
             --
            Selects all the title elements of the book
            elements of the bookstore element that have a
            price element with a value greater than 35.00


            Selecting Unknown Nodes

            XPath wildcards can be used to select unknown XML
            elements.

            Wildcard    Description

            *
                --
            Matches any element node

            @*
                --
            Matches any attribute node

            node()
                --
            Matches any node of any kind


            In the table below we have listed some path expressions and
            the result of the expressions:

            Path Expression     Result

            /bookstore/*
             --
            Selects all the child element nodes of the
            bookstore element

            //*
             --
            Selects all elements in the document

            //title[@*]
             --
            Selects all title elements which have at
            least one attribute of any kind

                evince -p 519 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Selecting Several Paths

            By using the | operator in an XPath expression you can
            select several paths.

            In the table below we have listed some path expressions and
            the result of the expressions:

            Path Expression     Result

            //book/title | //book
            /price
             --
            Selects all the title AND price
            elements of all book elements

            //title | //price
             --
            Selects all the title AND price
            elements in the document

            /bookstore/book/title
            | //price
             --
            Selects all the title elements of
            the book element of the bookstore
            element AND all the price
            elements in the document

                evince -p 524 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XPath Axes

            The XML Example Document

            We will use the following XML document in the examples below.

            <?xml version="1.0" encoding="UTF-8"?>

            <bookstore>

            <book>
              <title lang="en">Harry Potter</title>
              <price>29.99</price>
            </book>

            <book>
              <title lang="en">Learning XML</title>
              <price>39.95</price>
            </book>

            </bookstore>

                evince -p 525 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XPath Axes

            An axis defines a node-set relative to the current node.

            AxisName    Result

            ancestor
             --
            Selects all ancestors (parent,
            grandparent, etc.) of the current node

            ancestor-or-self
             --
            Selects all ancestors (parent,
            grandparent, etc.) of the current
            node and the current node itself

            attribute
             --
            Selects all attributes of the current node

            child
             --
            Selects all children of the current node

            descendant
             --
            Selects all descendants (children,
            grandchildren, etc.) of the current node

            descendant-or-self
             --
            Selects all descendants (children,
            grandchildren, etc.) of the current
            node and the current node itself

            following
             --
            Selects everything in the document
            after the closing tag of the current node

            following-sibling
             --
            Selects all siblings after the current node

            namespace
             --
            Selects all namespace nodes of the
            current node

            parent
             --
            Selects the parent of the current node

            preceding
             --
            Selects all nodes that appear
            before the current node in the
            document, except ancestors,
            attribute nodes and namespace nodes

                evince -p 526 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            preceding-sibling
             --
            Selects all siblings before the current node

            self
             --
            Selects the current node


            Location Path Expression

            A location path can be absolute or relative.
            An absolute location path starts with a slash ( / ) and a
            relative location path does not. In both cases the location
            path consists of one or more steps, each separated by a slash:

            An absolute location path:
            /step/step/...

            A relative location path:
            step/step/...

            Each step is evaluated against the nodes in the current
            node-set.


            A step consists of:

            - an axis (defines the tree-relationship between the
            selected nodes and the current node)
            - a node-test (identifies a node within an axis)
            - zero or more predicates (to further refine the selected node-set)

            The syntax for a location step is:

            axisname::nodetest[predicate]

                evince -p 527 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Examples

            Example     Result

            child::book
             --
            Selects all book nodes that are
            children of the current node

            attribute::lang
             --
            Selects the lang attribute of the
            current node

            child::*
             --
            Selects all element children of the
            current node

            attribute::*
             --
            Selects all attributes of the current node

            child::text()
             --
            Selects all text node children of the
            current node

            child::node()
             --
            Selects all children of the current
            node

            descendant::book
             --
            Selects all book descendants of the
            current node

            ancestor::book
             --
            Selects all book ancestors of the
            current node

            ancestoror-or-self::book

            Selects all book ancestors of the
            current node - and the current as
            well if it is a book node

            child::*/child::price

            Selects all price grandchildren of
            the current node

                evince -p 532 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XPath Operators

            An XPath expression returns either a node-set, a string,
            a Boolean, or a number.

            XPath Operators

            Below is a list of the operators that can be used in XPath
            expressions:

            Operator    Description     Example

            |
                --
            Computes two
            node-sets
                --
            //book | //cd

            +
                --
            Addition
                --
            6+4

            -
                --
            Subtraction
                --
            6-4

            *
                --
            Multiplication
                --
            6*4

            div
                --
            Division
                --
            8 div 4

            =
                --
            Equal
                --
            price=9.80

            !=
                --
            Not equal
                --
            price!=9.80

                evince -p 533 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <
                --
            Less than
                --
            price<9.80

            <=
                --
            Less than or equal to
                --
            price<=9.80

            >
                --
            Greater than
                --
            price>9.80

            >=
                --
            Greater than or
            e   --qual to

            price>=9.80

            or
                --
            or
                --
            price=9.80 or
            price=9.70

            and
                --
            and
                --
            price>9.00 and
            price<9.90

            mod
                --
            Modulus (division remainder)
                --
            5 mod 2

                evince -p 537 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XPath Examples

            Let's try to learn some basic XPath syntax by looking at
            some examples.


            The XML Example Document

            We will use the following XML document in the examples below.

            "books.xml":

            <?xml version="1.0" encoding="UTF-8"?>

            <bookstore>

            <book category="COOKING">
              <title lang="en">Everyday Italian</title>
              <author>Giada De Laurentiis</author>
              <year>2005</year>
              <price>30.00</price>
            </book>

            <book category="CHILDREN">
              <title lang="en">Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>

                evince -p 538 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <book category="WEB">
              <title lang="en">XQuery Kick Start</title>
              <author>James McGovern</author>
              <author>Per Bothner</author>
              <author>Kurt Cagle</author>
              <author>James Linn</author>
              <author>Vaidyanathan Nagarajan</author>
              <year>2003</year>
              <price>49.99</price>
            </book>

            <book category="WEB">
              <title lang="en">Learning XML</title>
              <author>Erik T. Ray</author>
              <year>2003</year>
              <price>39.95</price>
            </book>

            </bookstore>

            View the "books.xml" file in your browser (books.xml).


            Loading the XML Document

            Using XMLHttpRequest to load XML documents is supported
            in all modern browsers.

            Code for most modern browsers:

            var xmlhttp=new XMLHttpRequest()

            Code for old Microsoft browsers (IE 5 and 6):

            var xmlhttp=new
            ActiveXObject("Microsoft.XMLHTTP")


            Selecting Nodes

            Unfortunately, there are different ways of dealing with XPath
            in Internet Explorer and other browsers.

            In our examples we have included code that should work
            with most major browsers.

                evince -p 539 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Internet Explorer uses the selectNodes() method to select
            nodes from the XML document:

            xmlDoc.selectNodes(xpath);

            Firefox, Chrome, Opera and Safari use the evaluate()
            method to select nodes from the XML document:

            xmlDoc.evaluate(xpath, xmlDoc, null, XPathResult.ANY_TYPE,null);


            Select all the titles

            The following example selects all the title nodes:

            Example
            /bookstore/book/title


            Select the title of the first book

            The following example selects the title of the first book node
            under the bookstore element:

            Example
            /bookstore/book[1]/title


            Select all the prices

            The following example selects the text from all the price nodes:

                evince -p 540 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example
            /bookstore/book/price[text()]


            Select price nodes with price>35

            The following example selects all the price nodes with a price
            higher than 35:

            Example
            /bookstore/book[price>35]/price


            Select title nodes with price>35

            The following example selects all the title nodes with a price
            higher than 35:

            Example
            /bookstore/book[price>35]/title

                evince -p 544 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XPath, XQuery, and XSLT Functions

            The following reference library defines the functions required for
            XPath 2.0, XQuery 1.0 and XSLT 2.0.


            Functions Reference

            - Accessor
            - Error and Trace
            - Numeric
            - String
            - AnyURI
            - Boolean
            - Duration/Date/Time
            - QName
            - Node
            - Sequence
            - Context

            Note:
            The default prefix for the function namespace is fn:
            The URI of the function namespace is: http://www.w3.org
            /2005/xpath-functions

            Accessor Functions

            Name    Description

            fn:node-name(node)
             --
            Returns the node-name of the
            argument node

            fn:nilled(node)
             --
            Returns a Boolean value indicating
            whether the argument node is nilled

            fn:data(item.item,...)
             --
            Takes a sequence of items and
            returns a sequence of atomic values

                evince -p 545 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            fn:base-uri()
            fn:base-uri(node)
             --
            Returns the value of the base-uri
            property of the current or specified node

            fn:document-uri(node)
             --
            Returns the value of the
            document-uri property for the
            specified node


            Error and Trace Functions

            Name    Description

            fn:error()
            fn:error(error)
            fn:error(error,description)
            fn:error(error,description,errorobject)
             --
            Example:
            error(fn:QName('http://example.com
            /test', 'err:toohigh'), 'Error: Price is too high')
            Result: Returns http://example.com
            /test#toohigh and the string "Error:
            Price is too high" to the external
            processing environment

            fn:trace(value,label)
             --
            Used to debug queries


            Functions on Numeric Values

            Name    Description

            fn:number(arg)
             --
            Returns the numeric value of the
            argument. The argument could be a
            boolean, string, or node-set
            Example: number('100')
            Result: 100

            fn:abs(num)
             --
            Returns the absolute value of the
            argument
            Example: abs(3.14)
            Result: 3.14
            Example: abs(-3.14)
            Result: 3.14

            fn:ceiling(num)
             --
            Returns the smallest integer that is
            greater than the number argument
            Example: ceiling(3.14)
            Result: 4

                evince -p 546 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Functions on Strings

            Name    Description

            fn:string(arg)
             --
            Returns the string value of the
            argument. The argument could be a
            number, boolean, or node-set
            Example: string(314)
            Result: "314"

            fn:codepoints-to-string((int,int,...))
             --
            Creates a string from a sequence of
            the Unicode Standard code points
            Example: codepoints-to-string((84,
            104, 233, 114, 232, 115, 101))
            Result: 'Th�r�se'

            fn:string-to-codepoints(string)
             --
            Returns the sequence of the
            Unicode standard code points from
            a string
            Example: stringto-codepoints("Th�r�se")
            Result: (84, 104, 233, 114, 232,
            115, 101)

            fn:codepoint-equal(comp1,comp2)
             --
            Returns true if the value of comp1
            is equal to the value of comp2,
            according to the Unicode code point
            collation (http://www.w3.org
            /2005/02/xpath-functions/collation
            /codepoint), otherwise it returns false

            fn:compare(comp1,comp2)
            fn:compare(comp1,comp2,collation)
             --
            Returns -1 if comp1 is less than
            comp2, 0 if comp1 is equal to
            comp2, or 1 if comp1 is greater
            than comp2 (according to the rules
            of the collation that is used)
            Example: compare('ghi', 'ghi')
            Result: 0

            fn:concat(string,string,...)
             --
            Returns the concatenation of the
            strings
            Example: concat('XPath ','is
            ','FUN!')
            Result: 'XPath is FUN!'

                evince -p 547 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            fn:string-join((string,string,...),sep) 
             --
            Returns a string created by
            concatenating the string arguments
            and using the sep argument as the
            separator
            Example: string-join(('We', 'are',
            'having', 'fun!'), ' ')
            Result: ' We are having fun! '
            Example: string-join(('We', 'are',
            'having', 'fun!'))
            Result: 'Wearehavingfun!'
            Example:string-join((), 'sep')
            Result: ''

            fn:substring(string,start,len)
            fn:substring(string,start)
             --
            Returns the substring from the start
            position to the specified length.
            Index of the first character is 1. If
            length is omitted it returns the
            substring from the start position to
            the end
            Example: substring('Beatles',1,4)
            Result: 'Beat'
            Example: substring('Beatles',2)
            Result: 'eatles'

            fn:string-length(string)
            fn:string-length()
             --
            Returns the length of the specified
            string. If there is no string
            argument it returns the length of
            the string value of the current node
            Example: string-length('Beatles')
            Result: 7

            fn:normalize-space(string)
            fn:normalize-space()
             --
            Removes leading and trailing
            spaces from the specified string,
            and replaces all internal sequences
            of white space with one and returns
            the result. If there is no string
            argument it does the same on the
            current node
            Example: normalize-space(' The XML ')
            Result: 'The XML'

                evince -p 548 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            fn:normalize-unicode()
            fn:upper-case(string)
             --
            Converts the string argument to
            upper-case
            Example: upper-case('The XML')
            Result: 'THE XML'

            fn:lower-case(string)
             --
            Converts the string argument to
            lower-case
            Example: lower-case('The XML')
            Result: 'the xml'

            fn:translate(string1,string2,string3)
             --
            Converts string1 by replacing the
            characters in string2 with the
            characters in string3
            Example:
            translate('12:30','30','45')
            Result: '12:45'
            Example:
            translate('12:30','03','54')
            Result: '12:45'
            Example:
            translate('12:30','0123','abcd')
            Result: 'bc:da'

            fn:escape-uri(stringURI,esc-res)
             --
            Example: escapeuri("http://example.com/test#car",
            true())
            Result: "http%3A
            %2F%2Fexample.com%2Ftest#car"
            Example: escapeuri("http://example.com/test#car",
            false())
            Result: "http://example.com
            /test#car"
            Example: escape-uri
            ("http://example.com/~b�b�",
            false())
            Result: "http://example.com
            /~b%C3%A9b%C3%A9"

            fn:contains(string1,string2)
             --
            Returns true if string1 contains
            string2, otherwise it returns false
            Example: contains('XML','XM')
            Result: true

                evince -p 549 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            fn:starts-with(string1,string2)
             --
            Returns true if string1 starts with
            string2, otherwise it returns false
            Example: starts-with('XML','X')
            Result: true

            fn:ends-with(string1,string2)
             --
            Returns true if string1 ends with
            string2, otherwise it returns false
            Example: ends-with('XML','X')
            Result: false

            fn:substring-before(string1,string2)
             --
            Returns the start of string1 before
            string2 occurs in it
            Example: substringbefore('12/10','/')
            Result: '12'

            fn:substring-after(string1,string2)
             --
            Returns the remainder of string1
            after string2 occurs in it
            Example: substringafter('12/10','/')
            Result: '10'

            fn:matches(string,pattern)
             --
            Returns true if the string argument
            matches the pattern, otherwise, it
            returns false
            Example: matches("Merano", "ran")
            Result: true

            fn:replace(string,pattern,replace)
             --
            Returns a string that is created by
            replacing the given pattern with the
            replace argument
            Example: replace("Bella Italia", "l", "*")
            Result: 'Be**a Ita*ia'
            Example: replace("Bella Italia", "l", "")
            Result: 'Bea Itaia'

            fn:tokenize(string,pattern)
             --
            Example: tokenize("XPath is fun", "\s+")
            Result: ("XPath", "is", "fun")

                evince -p 550 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Functions for anyURI

            Name    Description

            fn:resolve-uri(relative,base)


            Functions on Boolean Values

            Name    Description

            fn:boolean(arg)
             --
            Returns a boolean value for a
            number, string, or node-set

            fn:not(arg)
             --
            The argument is first reduced to a
            boolean value by applying the
            boolean() function. Returns true if
            the boolean value is false, and false
            if the boolean value is true
            Example: not(true())
            Result: false

            fn:true()
             --
            Returns the boolean value true
            Example: true()
            Result: true

            fn:false()
             --
            Returns the boolean value false
            Example: false()
            Result: false


            Functions on Durations, Dates and Times

            Component Extraction Functions on Durations, Dates and Times

            Name    Description

            fn:dateTime(date,time)
             --
            Converts the arguments to a date and a time

            fn:yearsfrom-duration(datetimedur)
             --
            Returns an integer that represents the years component in
            the canonical lexical representation of the value of the
            argument

            fn:monthsfrom-duration(datetimedur)
             --
            Returns an integer that represents the months component in
            the canonical lexical representation of the value of the
            argument

            fn:daysfrom-duration(datetimedur)
             --
            Returns an integer that represents the days component in
            the canonical lexical representation of the value of the
            argument

                evince -p 551 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            fn:hoursfrom-duration(datetimedur)
             --
            Returns an integer that represents the hours component in
            the canonical lexical representation of the value of the argument

            fn:minutesfrom-duration(datetimedur)
             --
            Returns an integer that represents the minutes component in
            the canonical lexical representation of the value of the
            argument

            fn:secondsfrom-duration(datetimedur)
             --
            Returns a decimal that represents the seconds component in
            the canonical lexical representation of the value of the
            argument

            fn:yearfrom-dateTime(datetime)
             --
            Returns an integer that represents the year component in
            the localized value of the argument
            Example: year-fromdateTime(xs:dateTime("2005-01-10T12:30-04:10"))
            Result: 2005

            fn:monthfrom-dateTime(datetime)
             --
            Returns an integer that represents the month component in
            the localized value of the argument
            Example: monthfrom-dateTime(xs:dateTime("2005-01-10T12:30-04:10"))
            Result: 01

            fn:dayfrom-dateTime(datetime)
             --
            Returns an integer that represents the day component in the
            localized value of the argument
            Example: day-fromdateTime(xs:dateTime("2005-01-10T12:30-04:10"))
            Result: 10

            fn:hoursfrom-dateTime(datetime)
             --
            Returns an integer that represents the hours component in
            the localized value of the argument
            Example: hoursfrom-dateTime(xs:dateTime("2005-01-10T12:30-04:10"))
            Result: 12

            fn:minutesfrom-dateTime(datetime)
             --
            Returns an integer that represents the minutes component in
            the localized value of the argument
            Example: minutesfrom-dateTime(xs:dateTime("2005-01-10T12:30-04:10"))
            Result: 30

                evince -p 552 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            fn:secondsfrom-dateTime(datetime)
             --
            Returns a decimal that represents the seconds component in
            the localized value of the argument
            Example: secondsfrom-dateTime(xs:dateTime("2005-01-10T12:30:00-04:10"))
            Result: 0

            fn:timezonefrom-dateTime(datetime)
             --
            Returns the time zone component of the argument if any

            fn:year-from-date(date)
             --
            Returns an integer that represents the year in the localized
            value of the argument
            Example: year-from-date(xs:date("2005-04-23"))
            Result: 2005

            fn:month-from-date(date)
             --
            Returns an integer that represents the month in the localized
            value of the argument
            Example: month-from-date(xs:date("2005-04-23"))
            Result: 4

            fn:day-from-date(date)
             --
            Returns an integer that represents the day in the localized
            value of the argument
            Example: day-from-date(xs:date("2005-04-23"))
            Result: 23

            fn:timezone-from-date(date)
             --
            Returns the time zone component of the argument if any

            fn:hours-from-time(time)
             --
            Returns an integer that represents the hours component in
            the localized value of the argument
            Example: hours-from-time(xs:time("10:22:00"))
            Result: 10

            fn:minutes-from-time(time)
             --
            Returns an integer that represents the minutes component in
            the localized value of the argument
            Example: minutes-from-time(xs:time("10:22:00"))
            Result: 22

            fn:seconds-from-time(time)
             --
            Returns an integer that represents the seconds component in
            the localized value of the argument
            Example: seconds-from-time(xs:time("10:22:00"))
            Result: 0

            fn:timezone-from-time(time)
             --
            Returns the time zone component of the argument if any

                evince -p 553 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            fn:adjust-dateTimeto-timezone(datetime,timezone)
             --
            If the timezone argument is empty, it returns a dateTime
            without a timezone. Otherwise, it returns a dateTime with a timezone

            fn:adjust-date-totimezone(date,timezone)
             --
            If the timezone argument is empty, it returns a date without
            a timezone. Otherwise, it returns a date with a timezone

            fn:adjust-time-totimezone(time,timezone)
             --
            If the timezone argument is empty, it returns a time without
            a timezone. Otherwise, it returns a time with a timezone


            Functions Related to QNames

            Name    Description

            fn:QName()
            fn:local-name-from-QName()
            fn:namespace-uri-fromQName()
            fn:namespace-uri-forprefix()
            fn:in-scope-prefixes()
            fn:resolve-QName()


            Functions on Nodes


            Name    Description

            fn:name()
            fn:name(nodeset)
             --
            Returns the name of the current
            node or the first node in the
            specified node set

            fn:local-name()
            fn:local-name(nodeset)
             --
            Returns the name of the current
            node or the first node in the
            specified node set - without the
            namespace prefix

            fn:namespace-uri()
            fn:namespace-uri(nodeset)

            Returns the namespace URI of the
            current node or the first node in the
            specified node set

                evince -p 554 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            fn:lang(lang)
             --
            Returns
            true if the language of the
            current node matches the language
            of the specified language
            Example: Lang("en") is true for
            <p xml:lang="en">...</p>
            Example: Lang("de") is false for
            <p xml:lang="en">...</p>

            fn:root()
            fn:root(node)
             --
            Returns the root of the tree to
            which the current node or the
            specified belongs. This will usually
            be a document node


            Functions on Sequences
            General Functions on Sequences

            Name    Description

            fn:index-of((item,item,...),searchitem)
             --
            Returns the positions
            within the sequence of
            items that are equal to
            the searchitem
            argument
            Example: index-of ((15,
            40, 25, 40, 10), 40)
            Result: (2, 4)
            Example: index-of (("a",
            "dog", "and", "a",
            "duck"), "a")
            Result (1, 4)
            Example: index-of ((15,
            40, 25, 40, 10), 18)
            Result: ()

                evince -p 555 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            fn:remove((item,item,...),position) 
             --
            Returns a new sequence
            constructed from the
            value of the item
            arguments - with the
            item specified by the
            position argument
            removed
            Example: remove(("ab",
            "cd", "ef"), 0)
            Result: ("ab", "cd", "ef")
            Example: remove(("ab",
            "cd", "ef"), 1)
            Result: ("cd", "ef")
            Example: remove(("ab",
            "cd", "ef"), 4)
            Result: ("ab", "cd", "ef")

            fn:empty(item,item,...)
             --
            Returns true if the value
            of the arguments IS an
            empty sequence,
            otherwise it returns false
            Example:
            empty(remove(("ab",
            "cd"), 1))
            Result: false

            fn:exists(item,item,...)
             --
            Returns true if the value
            of the arguments IS NOT
            an empty sequence,
            otherwise it returns false
            Example:
            exists(remove(("ab"), 1))
            Result: false

            fn:distinctvalues((item,item,...),collation)
             --
            Returns only distinct
            (different) values
            Example: distinctvalues((1, 2, 3, 1, 2))
            Result: (1, 2, 3)

                evince -p 556 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            fn:insertbefore((item,item,...),pos,inserts)
             --
            Returns a new sequence
            constructed from the
            value of the item
            arguments - with the
            value of the inserts
            argument inserted in the
            position specified by the
            pos argument
            Example: insertbefore(("ab", "cd"), 0,
            "gh")
            Result: ("gh", "ab", "cd")
            Example: insertbefore(("ab", "cd"), 1,
            "gh")
            Result: ("gh", "ab", "cd")
            Example: insertbefore(("ab", "cd"), 2,
            "gh")
            Result: ("ab", "gh", "cd")
            Example: insertbefore(("ab", "cd"), 5,
            "gh")
            Result: ("ab", "cd", "gh")

            fn:reverse((item,item,...))
             --
            Returns the reversed
            order of the items
            specified
            Example: reverse(("ab",
            "cd", "ef"))
            Result: ("ef", "cd", "ab")
            Example:
            reverse(("ab"))
            Result: ("ab")

                evince -p 557 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            fn:subsequence((item,item,...),start,len)
             --
            Returns a sequence of
            items from the position
            specified by the start
            argument and
            continuing for the
            number of items
            specified by the len
            argument. The first item
            is located at position 1
            Example:
            subsequence(($item1,
            $item2, $item3,...), 3)
            Result: ($item3, ...)
            Example:
            subsequence(($item1,
            $item2, $item3, ...), 2,
            2)
            Result: ($item2, $item3)

            fn:unordered((item,item,...))
             --
            Returns the items in an
            implementation
            dependent order


            Functions That Test the Cardinality of Sequences

            Name    Description

            fn:zero-or-one(item,item,...)
             --
            Returns the argument if it contains
            zero or one items, otherwise it
            raises an error

            fn:oneor-more(item,item,...)
             --
            Returns the argument if it contains
            one or more items, otherwise it
            raises an error

            fn:exactly-one(item,item,...)
             --
            Returns the argument if it contains
            exactly one item, otherwise it raises
            an error


            Equals, Union, Intersection and Except

            Name    Description

            fn:deepequal(param1,param2,collation)

            Returns true if param1 and
            param2 are deep-equal to each
            other, otherwise it returns false

                evince -p 558 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Aggregate Functions

            Name    Description

            fn:count((item,item,...))
             --
            Returns the count of nodes

            fn:avg((arg,arg,...))
             --
            Returns the average of the
            argument values
            Example: avg((1,2,3))
            Result: 2

            fn:max((arg,arg,...))
             --
            Returns the argument that is
            greater than the others
            Example: max((1,2,3))
            Result: 3
            Example: max(('a', 'k'))
            Result: 'k'

            fn:min((arg,arg,...))
             --
            Returns the argument that is less
            than the others
            Example: min((1,2,3))
            Result: 1
            Example: min(('a', 'k'))
            Result: 'a'

            fn:sum(arg,arg,...)
             --
            Returns the sum of the numeric
            value of each node in the specified
            node-set


            Functions that Generate Sequences

            Name    Description

            fn:id((string,string,...),node)
             --
            Returns a sequence of element
            nodes that have an ID value
            equal to the value of one or more
            of the values specified in the
            string argument

            fn:idref((string,string,...),node)
             --
            Returns a sequence of element or
            attribute nodes that have an
            IDREF value equal to the value of
            one or more of the values
            specified in the string argument

                evince -p 559 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            fn:doc(URI)
            fn:doc-available(URI)
             --
            Returns true if the doc() function
            returns a document node,
            otherwise it returns false

            fn:collection()
            fn:collection(string)


            Context Functions

            Name    Description

            fn:position()
             --
            Returns the index position of the
            node that is currently being
            processed
            Example: //book[position()<=3]
            Result: Selects the first three book
            elements

            fn:last()
             --
            Returns the number of items in the
            processed node list
            Example: //book[last()]
            Result: Selects the last book
            element

            fn:current-dateTime()
             --
            Returns the current dateTime (with
            timezone)

            fn:current-date()
             --
            Returns the current date (with
            timezone)

            fn:current-time()
             --
            Returns the current time (with
            timezone)

            fn:implicit-timezone()
             --
            Returns the value of the implicit
            timezone

            fn:default-collation()
             --
            Returns the value of the default
            collation

            fn:static-base-uri()
             --
            Returns the value of the base-uri

                evince -p 563 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Displaying XML with XSLT

            With XSLT you can transform an XML document into HTML.

            Displaying XML with XSLT

            XSLT (eXtensible Stylesheet Language Transformations) is
            the recommended style sheet language for XML.
            XSLT is far more sophisticated than CSS. With XSLT you can
            add/remove elements and attributes to or from the output
            file. You can also rearrange and sort elements, perform tests
            and make decisions about which elements to hide and
            display, and a lot more.
            XSLT uses XPath to find information in an XML document.


            XSLT Example

            We will use the following XML document:

            <?xml version="1.0" encoding="UTF-8"?>
            <breakfast_menu>

            <food>
            <name>Belgian Waffles</name>

                evince -p 564 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <price>$5.95</price>
            <description>Two of our famous Belgian Waffles
            with plenty of real maple syrup</description>
            <calories>650</calories>
            </food>

            <food>
            <name>Strawberry Belgian Waffles</name>
            <price>$7.95</price>
            <description>Light Belgian waffles covered with
            strawberries and whipped cream</description>
            <calories>900</calories>
            </food>

            <food>
            <name>Berry-Berry Belgian Waffles</name>
            <price>$8.95</price>
            <description>Light Belgian waffles covered with
            an assortment of fresh berries and whipped
            cream</description>
            <calories>900</calories>
            </food>

            <food>
            <name>French Toast</name>
            <price>$4.50</price>
            <description>Thick slices made from our homemade
            sourdough bread</description>
            <calories>600</calories>
            </food>

            <food>
            <name>Homestyle Breakfast</name>
            <price>$6.95</price>
            <description>Two eggs, bacon or sausage, toast,
            and our ever-popular hash browns</description>
            <calories>950</calories>
            </food>

            </breakfast_menu>

            Use XSLT to transform XML into HTML, before it is displayed
            in a browser:

            Example XSLT Stylesheet:

            <?xml version="1.0" encoding="UTF-8"?>
            <html xsl:version="1.0"
            xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

                evince -p 565 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <body style="font-family:Arial;font-size:12pt;background-color:#EEEEEE">
            <xsl:for-each select="breakfast_menu/food">
              <div style="background-color:teal;color:white;padding:4px">
                <span style="font-weight:bold"><xsl:value-of select="name"/> - </span>
                <xsl:value-of select="price"/>
                </div>
              <div style="margin-left:20px;margin-bottom:1em;font-size:10pt">
                <p>
                <xsl:value-of select="description"/>
                <span style="font-style:italic">(<xsl:value-of select="calories"/> calories per serving)</span>
                </p>
              </div>
            </xsl:for-each>
            </body>
            </html>

            Transform the XML Document with XSLT » (simplexsl.xml)

            If you want to learn more about XSLT, find our XSLT tutorial
            on our homepage (/default.asp).

                evince -p 570 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT Tutorial

            XSL stands for EXtensible Stylesheet
            Language, and is a style sheet language for
            XML documents.

            XSLT stands for XSL Transformations. In this
            tutorial you will learn how to use XSLT to
            transform XML documents into other formats,
            like XHTML.

            Start learning XSLT now! (xsl_languages.asp)


            Online XSLT Editor

            With our online editor, you can edit the XML and the XSL source
            code, and click on a button to view the result.

            XSLT Example

            <?xml version="1.0"?>

            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
              <html>
              <body>
                <h2>My CD Collection</h2>
                <table border="1">
                  <tr bgcolor="#9acd32">
                    <th>Title</th>

                evince -p 571 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

                    <th>Artist</th>
                  </tr>
                  <xsl:for-each select="catalog/cd">
                    <tr>
                      <td><xsl:value-of select="title"/></td>
                      <td><xsl:value-of select="artist"/></td>
                    </tr>
                  </xsl:for-each>
                </table>
              </body>
              </html>
            </xsl:template>

            </xsl:stylesheet>

            Click on the "Try it Yourself" button to see how it works.


            XSLT References

            XSLT Elements (xsl_w3celementref.asp)
            Description of all the XSLT elements from the W3C
            Recommendation, and information about browser support.

            XSLT Functions (xsl_functions.asp)

            XSLT includes over 100 built-in functions. There are functions for
            string values, numeric values, date and time comparison, node
            and QName manipulation, sequence manipulation, Boolean
            values, and more.

              XML Exam - Get Your Diploma!
              (/cert/default.asp)

              W3Schools'
              Online
              Certification
              The perfect solution for professionals who need to balance work,
              family, and career building.
              More than 10 000 certificates already issued!

                evince -p 572 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Get Your Certificate » (/cert/default.asp)

            The HTML Certificate (/cert/default.asp) documents your
            knowledge of HTML.
            The HTML5 Certificate (/cert/default.asp) documents your
            knowledge of advanced HTML5.
            The CSS Certificate (/cert/default.asp) documents your
            knowledge of advanced CSS.
            The JavaScript Certificate (/cert/default.asp) documents your
            knowledge of JavaScript and HTML DOM.
            The jQuery Certificate (/cert/default.asp) documents your
            knowledge of jQuery.
            The PHP Certificate (/cert/default.asp) documents your
            knowledge of PHP and SQL (MySQL).
            The XML Certificate (/cert/default.asp) documents your
            knowledge of XML, XML DOM and XSLT.

                evince -p 576 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSL Languages

            It Started with XSL

            XSL stands for EXtensible Stylesheet Language.

            The World Wide Web Consortium (W3C) started to develop
            XSL because there was a need for an XML-based Stylesheet Language.


            CSS = Style Sheets for HTML

            HTML uses predefined tags, and the meaning of each tag is
            well understood.

            The <table> tag in HTML defines a table - and a browser
            knows how to display it.

            Adding styles to HTML elements are simple. Telling a browser
            to display an element in a special font or color, is easy with CSS.


            XSL = Style Sheets for XML

            XML does not use predefined tags (we can use any
            tag-names we like), and therefore the meaning of each tag is
            not well understood.

                evince -p 577 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            A <table> tag could mean an HTML table, a piece of
            furniture, or something else - and a browser does not know
            how to display it.

            XSL describes how the XML document should be displayed!


            XSL - More Than a Style Sheet Language

            XSL originally consisted of three parts:

            - XSLT - a language for transforming XML documents
            - XPath - a language for navigating in XML documents
            - XSL-FO - a language for formatting XML documents

            Later, W3C added XQuery (a language for querying XML
            documents), to the XSL family.

            Note:
            With the CSS3 Paged Media Module, W3C has
            delivered a new standard for document formatting.
            So, since 2013, CSS3 is proposed as an XSL-FO replacement.


            This Tutorial is About XSLT

            The rest of this tutorial is about XSLT - the language for
            transforming XML documents.

            To learn more about XPath and XQuery, visit our XPath
            Tutorial (/xpath/default.asp) and our XQuery Tutorial
            (/xquery/default.asp).

                evince -p 582 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT is a language for transforming XML documents into
            XHTML documents or to other XML documents.

            XPath is a language for navigating in XML documents.


            What You Should Already Know

            Before you continue you should have a basic understanding
            of the following:

            - HTML
            - XML
            - XPath

            If you want to study these subjects first, find the tutorials on
            our Home page (/default.asp).


            What is XSLT?

            - XSLT stands for XSL Transformations
            - XSLT is the most important part of XSL
            - XSLT transforms an XML document into another XML document
            - XSLT uses XPath to navigate in XML documents
            - XSLT is a W3C Recommendation

                evince -p 583 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT = XSL Transformations

            XSLT is the most important part of XSL.

            XSLT is used to transform an XML document into another
            XML document, or another type of document that is
            recognized by a browser, like HTML and XHTML. Normally
            XSLT does this by transforming each XML element into an
            (X)HTML element.

            With XSLT you can add/remove elements and attributes to or
            from the output file. You can also rearrange and sort
            elements, perform tests and make decisions about which
            elements to hide and display, and a lot more.

            A common way to describe the transformation process is to
            say that XSLT transforms an XML source-tree into an
            XML result-tree.


            XSLT Uses XPath

            XSLT uses XPath to find information in an XML document.
            XPath is used to navigate through elements and attributes in
            XML documents.

            If you want to study XPath first, please read our XPath
            Tutorial (/xpath/default.asp).


            How Does it Work?

            In the transformation process, XSLT uses XPath to define
            parts of the source document that should match one or more
            predefined templates. When a match is found, XSLT will
            transform the matching part of the source document into the
            result document.

                evince -p 584 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT Browser Support

            All major browsers have support for XML and XSLT.

            Internet Explorer supports XML, XSLT, and XPath from
            version 6.

            Chrome supports XML, XSLT, and XPath from version 1.

            Firefox supports XML, XSLT, and XPath from version 3.

            Safari supports XML and XSLT from version 3.

            Opera supports XML, XSLT, and XPath from version 9.


            XSLT is a W3C Recommendation

            XSLT became a W3C Recommendation 16. November 1999.

                evince -p 589 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT - Transformation

            Example study: How to transform XML into XHTML using XSLT?

            The details of this example will be explained in the next chapter.


            Correct Style Sheet Declaration

            The root element that declares the document to be an XSL
            style sheet is <xsl:stylesheet> or <xsl:transform>.

            Note: <xsl:stylesheet> and <xsl:transform> are completely
            synonymous and either can be used!

            The correct way to declare an XSL style sheet according to
            the W3C XSLT Recommendation is:

            <xsl:stylesheet version="1.0"
            xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            or:

            <xsl:transform version="1.0"
            xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

                evince -p 590 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            To get access to the XSLT elements, attributes and features
            we must declare the XSLT namespace at the top of the document.

            The xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
            points to the official W3C XSLT namespace. If you use this
            namespace, you must also include the attribute
            version="1.0".


            Start with a Raw XML Document

            We want to transform the following XML document
            ("cdcatalog.xml") into XHTML:

            <?xml version="1.0" encoding="UTF-8"?>
            <catalog>
              <cd>
                <title>Empire Burlesque</title>
                <artist>Bob Dylan</artist>
                <country>USA</country>
                <company>Columbia</company>
                <price>10.90</price>
                <year>1985</year>
              </cd>
            .
            .
            </catalog>

            Viewing XML Files in IE, Chrome, Firefox, Safari, and
            Opera: Open the XML file (click on the link below) - The XML
            document will be displayed with color-coded root and child
            elements (except in Safari). Often, there is a plus (+) or
            minus sign (-) to the left of the elements that can be clicked
            to expand or collapse the element structure. Tip: To view
            the raw XML source, right-click in XML file and select "View Source"!

            View "cdcatalog.xml" (cdcatalog.xml)


            Create an XSL Style Sheet

            Then you create an XSL Style Sheet ("cdcatalog.xsl") with a
            transformation template:

                evince -p 591 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <?xml version="1.0" encoding="UTF-8"?>

            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
              <html>
              <body>
              <h2>My CD Collection</h2>
              <table border="1">
                <tr bgcolor="#9acd32">
                  <th>Title</th>
                  <th>Artist</th>
                </tr>
                <xsl:for-each select="catalog/cd">
                <tr>
                  <td><xsl:value-of select="title"/></td>
                  <td><xsl:value-of select="artist"/></td>
                </tr>
                </xsl:for-each>
              </table>
              </body>
              </html>
            </xsl:template>

            </xsl:stylesheet>

            View "cdcatalog.xsl" (cdcatalog.xsl)


            Link the XSL Style Sheet to the XML Document

            Add the XSL style sheet reference to your XML document
            ("cdcatalog.xml"):

            <?xml version="1.0" encoding="UTF-8"?>
            <?xml-stylesheet type="text/xsl" href="cdcatalog.xsl"?>
            <catalog>
              <cd>
                <title>Empire Burlesque</title>
                <artist>Bob Dylan</artist>
                <country>USA</country>
                <company>Columbia</company>
                <price>10.90</price>

                evince -p 592 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

                <year>1985</year>
              </cd>
            .
            .
            </catalog>

            If you have an XSLT compliant browser it will nicely
            transform your XML into XHTML.

            View the result (cdcatalog_with_xsl.xml)

            The details of the example above will be explained in the
            next chapters.

                evince -p 597 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT <xsl:template> Element

            An XSL style sheet consists of one or more set of rules that are
            called templates.

            A template contains rules to apply when a specified node is matched.


            The <xsl:template> Element

            The <xsl:template> element is used to build templates.

            The match attribute is used to associate a template with an XML
            element. The match attribute can also be used to define a template
            for the entire XML document. The value of the match attribute is an
            XPath expression (i.e. match="/" defines the whole document).
            Ok, let's look at a simplified version of the XSL file from the
            previous chapter:

            Example
            <?xml version="1.0" encoding="UTF-8"?>
            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
              <html>
              <body>
              <h2>My CD Collection</h2>
              <table border="1">
                <tr bgcolor="#9acd32">
                  <th>Title</th>
                  <th>Artist</th>
                </tr>

                evince -p 598 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

                <tr>
                  <td>.</td>
                  <td>.</td>
                </tr>
              </table>
              </body>
              </html>
            </xsl:template>

            </xsl:stylesheet>


            Example Explained

            Since an XSL style sheet is an XML document, it always begins with
            the XML declaration: <?xml version="1.0" encoding="UTF-8"?>.

            The next element, <xsl:stylesheet>, defines that this document is
            an XSLT style sheet document (along with the version number and
            XSLT namespace attributes).

            The <xsl:template> element defines a template. The match="/"
            attribute associates the template with the root of the XML source document.

            The content inside the <xsl:template> element defines some HTML
            to write to the output.

            The last two lines define the end of the template and the end of the
            style sheet.

            The result from this example was a little disappointing, because no
            data was copied from the XML document to the output. In the next
            chapter you will learn how to use the <xsl:value-of> element to
            select values from the XML elements.

                evince -p 602 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT <xsl:value-of> Element

            The <xsl:value-of> element is used to extract the value of a
            selected node.


            The <xsl:value-of> Element

            The <xsl:value-of> element can be used to extract the value of an
            XML element and add it to the output stream of the transformation:

            Example

            <?xml version="1.0" encoding="UTF-8"?>
            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
              <html>
              <body>
              <h2>My CD Collection</h2>
              <table border="1">
                <tr bgcolor="#9acd32">
                  <th>Title</th>
                  <th>Artist</th>
                </tr>
                <tr>
                  <td><xsl:value-of select="catalog/cd/title"/></td>
                  <td><xsl:value-of select="catalog/cd/artist"/></td>
                </tr>
              </table>
              </body>
              </html>
            </xsl:template>

            </xsl:stylesheet>

                evince -p 603 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example Explained

            Note: The select attribute, in the example above, contains an
            XPath expression. An XPath expression works like navigating a file
            system; a forward slash (/) selects subdirectories.

            The result from the example above was a little disappointing; only
            one line of data was copied from the XML document to the output.
            In the next chapter you will learn how to use the <xsl:for-each>
            element to loop through the XML elements, and display all of the records.

                evince -p 607 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT <xsl:for-each> Element

            The <xsl:for-each> element allows you to do looping in XSLT.


            The <xsl:for-each> Element

            The XSL <xsl:for-each> element can be used to select every XML
            element of a specified node-set:

            Example

            <?xml version="1.0" encoding="UTF-8"?>
            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
              <html>
              <body>
              <h2>My CD Collection</h2>
              <table border="1">
                <tr bgcolor="#9acd32">
                  <th>Title</th>
                  <th>Artist</th>
                </tr>
                <xsl:for-each select="catalog/cd">
                <tr>
                  <td><xsl:value-of select="title"/></td>
                  <td><xsl:value-of select="artist"/></td>
                </tr>
                </xsl:for-each>
              </table>
              </body>
              </html>
            </xsl:template>

            </xsl:stylesheet>

                evince -p 608 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Note: The value of the select attribute is an XPath expression. An
            XPath expression works like navigating a file system; where a
            forward slash (/) selects subdirectories.


            Filtering the Output

            We can also filter the output from the XML file by adding a criterion
            to the select attribute in the <xsl:for-each> element.

            <xsl:for-each select="catalog/cd[artist='Bob Dylan']">

            Legal filter operators are:
            -  = (equal)
            -  != (not equal)
            -  &lt; less than
            -  &gt; greater than

            Take a look at the adjusted XSL style sheet:

            Example

            <?xml version="1.0" encoding="UTF-8"?>
            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
              <html>
              <body>
              <h2>My CD Collection</h2>
              <table border="1">
                <tr bgcolor="#9acd32">
                  <th>Title</th>
                  <th>Artist</th>
                </tr>
                <xsl:for-each select="catalog/cd[artist='Bob Dylan']">
                <tr>
                  <td><xsl:value-of select="title"/></td>
                  <td><xsl:value-of select="artist"/></td>
                </tr>
                </xsl:for-each>
              </table>
              </body>
              </html>
            </xsl:template>

            </xsl:stylesheet>

                evince -p 612 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT <xsl:sort> Element

            The <xsl:sort> element is used to sort the output.


            Where to put the Sort Information

            To sort the output, simply add an <xsl:sort> element inside the
            <xsl:for-each> element in the XSL file:

            Example

            <?xml version="1.0" encoding="UTF-8"?>
            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
              <html>
              <body>
              <h2>My CD Collection</h2>
              <table border="1">
                <tr bgcolor="#9acd32">
                  <th>Title</th>
                  <th>Artist</th>
                </tr>
                <xsl:for-each select="catalog/cd">
                  <xsl:sort select="artist"/>
                  <tr>
                    <td><xsl:value-of select="title"/></td>
                    <td><xsl:value-of select="artist"/></td>
                  </tr>
                </xsl:for-each>
              </table>
              </body>
              </html>
            </xsl:template>

            </xsl:stylesheet>

                evince -p 613 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Note: The select attribute indicates what XML element to sort on.

                evince -p 617 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT <xsl:if> Element

            The <xsl:if> element is used to put a conditional test against
            the content of the XML file.

            The <xsl:if> Element

            To put a conditional if test against the content of the XML file, add
            an <xsl:if> element to the XSL document.

            Syntax

            <xsl:if test="expression">
              ...some output if the expression is true...
            </xsl:if>


            Where to Put the <xsl:if> Element

            To add a conditional test, add the <xsl:if> element inside the
            <xsl:for-each> element in the XSL file:

            Example

            <?xml version="1.0" encoding="UTF-8"?>
            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
              <html>
              <body>

                evince -p 618 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

              <h2>My CD Collection</h2>
              <table border="1">
                <tr bgcolor="#9acd32">
                  <th>Title</th>
                  <th>Artist</th>
                  <th>Price</th>
                </tr>
                <xsl:for-each select="catalog/cd">
                  <xsl:if test="price &gt; 10">
                    <tr>
                      <td><xsl:value-of select="title"/></td>
                      <td><xsl:value-of select="artist"/></td>
                      <td><xsl:value-of select="price"/></td>
                    </tr>
                  </xsl:if>
                </xsl:for-each>
              </table>
              </body>
              </html>
            </xsl:template>

            </xsl:stylesheet>

            Note: The value of the required test attribute contains the
            expression to be evaluated.

            The code above will only output the title and artist elements of the
            CDs that has a price that is higher than 10.

                evince -p 622 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT <xsl:choose> Element

            The <xsl:choose> element is used in conjunction with
            <xsl:when> and <xsl:otherwise> to express multiple conditional tests.


            The <xsl:choose> Element

            Syntax

            <xsl:choose>
              <xsl:when test="expression">
                ... some output ...
              </xsl:when>
              <xsl:otherwise>
                ... some output ....
              </xsl:otherwise>
            </xsl:choose>


            Where to put the Choose Condition

            To insert a multiple conditional test against the XML file, add the
            <xsl:choose>, <xsl:when>, and <xsl:otherwise> elements to the XSL file:

            Example

            <?xml version="1.0" encoding="UTF-8"?>
            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">

                evince -p 623 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <html>
            <body>
            <h2>My CD Collection</h2>
              <table border="1">
                <tr bgcolor="#9acd32">
                  <th>Title</th>
                  <th>Artist</th>
                </tr>
                <xsl:for-each select="catalog/cd">
                  <tr>
                  <td><xsl:value-of select="title"/></td>
                    <xsl:choose>
                      <xsl:when test="price &gt; 10">
                        <td bgcolor="#ff00ff">
                        <xsl:value-of select="artist"/></td>
                      </xsl:when>
                      <xsl:otherwise>
                        <td><xsl:value-of select="artist"/></td>
                      </xsl:otherwise>
                    </xsl:choose>
                  </tr>
                </xsl:for-each>
              </table>
              </body>
              </html>
            </xsl:template>

            </xsl:stylesheet>

            The code above will add a pink background-color to the "Artist"
            column WHEN the price of the CD is higher than 10.


            Another Example

            Here is another example that contains two <xsl:when> elements:

            Example

            <?xml version="1.0" encoding="UTF-8"?>
            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
              <html>
              <body>
              <h2>My CD Collection</h2>
              <table border="1">
                <tr bgcolor="#9acd32">
                  <th>Title</th>
                  <th>Artist</th>
                </tr>

                evince -p 624 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

                <xsl:for-each select="catalog/cd">
                <tr>
                  <td><xsl:value-of select="title"/></td>
                  <xsl:choose>
                    <xsl:when test="price &gt; 10">
                      <td bgcolor="#ff00ff">
                      <xsl:value-of select="artist"/></td>
                    </xsl:when>
                    <xsl:when test="price &gt; 9">
                      <td bgcolor="#cccccc">
                      <xsl:value-of select="artist"/></td>
                    </xsl:when>
                    <xsl:otherwise>
                      <td><xsl:value-of select="artist"/></td>
                    </xsl:otherwise>
                  </xsl:choose>
                </tr>
                </xsl:for-each>
              </table>
              </body>
              </html>
            </xsl:template>

            </xsl:stylesheet>

            The code above will add a pink background color to the "Artist"
            column WHEN the price of the CD is higher than 10, and a grey
            background-color WHEN the price of the CD is higher than 9 and lower
            or equal to 10.

                evince -p 628 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT <xsl:apply-templates> Element

            The <xsl:apply-templates> element applies a template to the
            current element or to the current element's child nodes.


            The <xsl:apply-templates> Element

            The <xsl:apply-templates> element applies a template to the current
            element or to the current element's child nodes.

            If we add a select attribute to the <xsl:apply-templates> element it
            will process only the child element that matches the value of the
            attribute. We can use the select attribute to specify the order in
            which the child nodes are processed.

            Look at the following XSL style sheet:

            Example

            <?xml version="1.0" encoding="UTF-8"?>
            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
              <html>
              <body>
              <h2>My CD Collection</h2>
              <xsl:apply-templates/>
              </body>
              </html>
            </xsl:template>

            <xsl:template match="cd">

                evince -p 629 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

              <p>
              <xsl:apply-templates select="title"/>
              <xsl:apply-templates select="artist"/>
              </p>
            </xsl:template>

            <xsl:template match="title">
              Title: <span style="color:#ff0000">
              <xsl:value-of select="."/></span>
              <br />
            </xsl:template>

            <xsl:template match="artist">
              Artist: <span style="color:#00ff00">
              <xsl:value-of select="."/></span>
              <br />
            </xsl:template>

            </xsl:stylesheet>

                evince -p 633 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT - On the Client

            XSLT can be used to transform the document to XHTML
            in your browser.


            A JavaScript Solution

            In the previous chapters we have explained how XSLT can be
            used to transform a document from XML to XHTML. We did
            this by adding an XSL style sheet to the XML file and let the
            browser do the transformation.
            Even if this works fine, it is not always desirable to include a
            style sheet reference in an XML file (e.g. it will not work in a
            non XSLT aware browser.)

            A more versatile solution would be to use a JavaScript to do
            the transformation.

            By using a JavaScript, we can:
            - do browser-specific testing
            - use different style sheets according to browser and user needs

            That is the beauty of XSLT! One of the design goals for XSLT
            was to make it possible to transform data from one format to
            another, supporting different browsers and different user needs.

                evince -p 634 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The XML File and the XSL File


            Look at the XML document that you have seen in the
            previous chapters:

            <?xml version="1.0" encoding="UTF-8"?>
            <catalog>
              <cd>
                <title>Empire Burlesque</title>
                <artist>Bob Dylan</artist>
                <country>USA</country>
                <company>Columbia</company>
                <price>10.90</price>
                <year>1985</year>
              </cd>
            .
            .
            </catalog>

            View the XML file (cdcatalog.xml).
            And the accompanying XSL style sheet:

            <?xml version="1.0" encoding="UTF-8"?>
            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
              <html>
              <body>
              <h2>My CD Collection</h2>
              <table border="1">
                <tr bgcolor="#9acd32">
                  <th style="text-align:left">Title</th>
                  <th style="text-align:left">Artist</th>
                </tr>
                <xsl:for-each select="catalog/cd">
                <tr>
                  <td><xsl:value-of select="title" /></td>
                  <td><xsl:value-of select="artist" /></td>
                </tr>
                </xsl:for-each>
              </table>
              </body>
              </html>
            </xsl:template>

            </xsl:stylesheet>

                evince -p 635 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            View the XSL file (cdcatalog.xsl).

            Notice that the XML file does not have a reference to
            the XSL file.  (!!!)

            IMPORTANT: The above sentence indicates that an XML file
            could be transformed using many different XSL style sheets.


            Transforming XML to XHTML in the Browser

            Here is the source code needed to transform the XML file to
            XHTML on the client:

            Example

            <html>
            <head>
            <script>
            function loadXMLDoc(filename)
            {
            if (window.ActiveXObject)
              {
              xhttp = new ActiveXObject("Msxml2.XMLHTTP");
              }
            else
              {
              xhttp = new XMLHttpRequest();
              }
            xhttp.open("GET", filename, false);
            try {xhttp.responseType = "msxml-document"}
            catch(err) {} // Helping IE11
            xhttp.send("");
            return xhttp.responseXML;
            }

            function displayResult()
            {
            xml = loadXMLDoc("cdcatalog.xml");
            xsl = loadXMLDoc("cdcatalog.xsl");
            // code for IE
            if (window.ActiveXObject || xhttp.responseType ==

                evince -p 636 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            "msxml-document")
              {
              ex = xml.transformNode(xsl);
              document.getElementById("example").innerHTML = ex;
              }
            // code for Chrome, Firefox, Opera, etc.
            else if (document.implementation &&
            document.implementation.createDocument)
              {
              xsltProcessor = new XSLTProcessor();
              xsltProcessor.importStylesheet(xsl);
              resultDocument = xsltProcessor.transformToFragment(xml, document);

              document.getElementById("example").appendChild(resultDocument);
              }
            }
            </script>
            </head>
            <body onload="displayResult()">
            <div id="example" />
            </body>
            </html>

            Tip: If you don't know how to write JavaScript, please study
            our JavaScript tutorial (/js/default.asp).


            Example Explained:

            The loadXMLDoc() function does the following:
            - Create an XMLHttpRequest object
            - Use the open() and send() methods of the
              XMLHttpRequest object to send a request to a server
            - Get the response data as XML data

            The displayResult() function is used to display the XML
            file styled by the XSL file:
            - Load XML and XSL files
            - Test what kind of browser the user has
            - If Internet Explorer:
              - Use the transformNode() method to apply the XSL
              style sheet to the xml document

                evince -p 637 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

                - Set the body of the current document
                (id="example") to contain the styled xml document
            - If other browsers:
              - Create a new XSLTProcessor object and import the
                XSL file to it
              - Use the transformToFragment() method to apply
                the XSL style sheet to the xml document
              - Set the body of the current document
                (id="example") to contain the styled xml document

                evince -p 642 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT - On the Server

            To make XML data available to all kind of browsers, we
            can transform the XML document on the SERVER and
            send it back to the browser as XHTML.


            A Cross Browser Solution

            In the previous chapter we explained how XSLT can be used
            to transform a document from XML to XHTML in the browser.
            We used a JavaScript and an XML parser for the
            transformation. However, this will not work in a browser that
            doesn't have an XML parser.

            To make XML data available to all kind of browsers, we can
            transform the XML document on the server and send back to
            the browser as XHTML.

            That's another beauty of XSLT. One of the design goals for
            XSLT was to make it possible to transform data from one
            format to another on a server, returning readable data to all
            kinds of browsers.


            The XML File and the XSLT File

            Look at the XML document that you have seen in the
            previous chapters:

                evince -p 643 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <?xml version="1.0" encoding="UTF-8"?>
            <catalog>
              <cd>
                <title>Empire Burlesque</title>
                <artist>Bob Dylan</artist>
                <country>USA</country>
                <company>Columbia</company>
                <price>10.90</price>
                <year>1985</year>
              </cd>
            .
            .
            </catalog>

            View the XML file (cdcatalog.xml).
            And the accompanying XSL style sheet:

            <?xml version="1.0" encoding="UTF-8"?>
            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
              <html>
              <body>
              <h2>My CD Collection</h2>
              <table border="1">
                <tr bgcolor="#9acd32">
                  <th style="text-align:left">Title</th>
                  <th style="text-align:left">Artist</th>
                </tr>
                <xsl:for-each select="catalog/cd">
                <tr>
                  <td><xsl:value-of select="title" /></td>
                  <td><xsl:value-of select="artist" /></td>
                </tr>
                </xsl:for-each>
              </table>
              </body>
              </html>
            </xsl:template>

            </xsl:stylesheet>

            View the XSL file (cdcatalog.xsl).

            Notice that the XML file does not have a reference to
            the XSL file.

                evince -p 644 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            IMPORTANT: The above sentence indicates that an XML file
            could be transformed using many different XSL style sheets.

            PHP Code: Transform XML to XHTML on the Server

            Here is the PHP source code needed to transform the XML
            file to XHTML on the server:

            <?php
            // Load XML file
            $xml = new DOMDocument;
            $xml->load('cdcatalog.xml');

            // Load XSL file
            $xsl = new DOMDocument;
            $xsl->load('cdcatalog.xsl');

            // Configure the transformer
            $proc = new XSLTProcessor;

            // Attach the xsl rules
            $proc->importStyleSheet($xsl);

            echo $proc->transformToXML($xml);
            ?>

            Tip: If you don't know how to write PHP, please study our
            PHP tutorial (/php/default.asp).

            See how it works with PHP (cdcatalog.php).


            ASP Code: Transform XML to XHTML on the Server

            Here is the ASP source code needed to transform the XML
            file to XHTML on the server:

            <%
            'Load XML file
            set xml = Server.CreateObject("Microsoft.XMLDOM")
            xml.async = false

                evince -p 645 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            xml.load(Server.MapPath("cdcatalog.xml"))

            'Load XSL file
            set xsl = Server.CreateObject("Microsoft.XMLDOM")
            xsl.async = false
            xsl.load(Server.MapPath("cdcatalog.xsl"))

            'Transform file
            Response.Write(xml.transformNode(xsl))
            %>

            Tip: If you don't know how to write ASP, please study our
            ASP tutorial (/asp/default.asp).

            See how it works with ASP (cdcatalog.asp).

                evince -p 650 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT - Editing XML

            Data stored in XML files can be edited from an Internet browser.


            Open, Edit and Save XML

            Now, we will show how to open, edit, and save an XML file
            that is stored on the server.

            We will use XSL to transform the XML document into an
            HTML form. The values of the XML elements will be written
            to HTML input fields in an HTML form. The HTML form is
            editable. After editing the data, the data is going to be
            submitted back to the server and the XML file will be updated
            (we will show code for both PHP and ASP).


            The XML File and the XSL File

            First, take a look at the XML document ("tool.xml"):

            <?xml version="1.0" encoding="UTF-8"?>
            <tool>
              <field id="prodName">
                <value>HAMMER HG2606</value>
              </field>

                evince -p 651 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

              <field id="prodNo">
                <value>32456240</value>
              </field>
              <field id="price">
                <value>$30.00</value>
              </field>
            </tool>

            View the XML file (tool.xml).
            Then, take a look at the following style sheet ("tool.xsl"):

            <?xml version="1.0" encoding="UTF-8"?>
            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
              <html>
              <body>
              <form method="post" action="edittool.asp">
              <h2>Tool Information (edit):</h2>
              <table border="0">
                <xsl:for-each select="tool/field">
                <tr>
                <td><xsl:value-of select="@id"/></td>
                <td>
                <input type="text">
                <xsl:attribute name="id">
                  <xsl:value-of select="@id" />
                </xsl:attribute>
                <xsl:attribute name="name">
                  <xsl:value-of select="@id" />
                </xsl:attribute>
                <xsl:attribute name="value">
                  <xsl:value-of select="value" />
                </xsl:attribute>
                </input>
              </td>
              </tr>
              </xsl:for-each>
              </table>
              <br />
              <input type="submit" id="btn_sub" name="btn_sub" value="Submit" />
              <input type="reset" id="btn_res" name="btn_res" value="Reset" />
              </form>
              </body>
              </html>
            </xsl:template>

            </xsl:stylesheet>

                evince -p 652 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            View the XSL file (tool.xsl).

            The XSL file above loops through the elements in the XML file
            and creates one input field for each XML "field" element. The
            value of the XML "field" element's "id" attribute is added to
            both the "id" and "name" attributes of each HTML input field.
            The value of each XML "value" element is added to the
            "value" attribute of each HTML input field. The result is an
            editable HTML form that contains the values from the XML file.

            Then, we have a second style sheet: "tool_updated.xsl". This
            is the XSL file that will be used to display the updated XML
            data. This style sheet will not result in an editable HTML
            form, but a static HTML table:

            <?xml version="1.0" encoding="UTF-8"?>
            <xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

            <xsl:template match="/">
              <html>
              <body>
              <h2>Updated Tool Information:</h2>
              <table border="1">
                <xsl:for-each select="tool/field">
                <tr>
                  <td><xsl:value-of select="@id" /></td>
                  <td><xsl:value-of select="value" /></td>
                </tr>
                </xsl:for-each>
              </table>
              </body>
              </html>
            </xsl:template>

            </xsl:stylesheet>

            View the XSL file (tool_updated.xsl).

                evince -p 653 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The ASP File

            The HTML form in the "tool.xsl" file above has an action
            attribute with a value of "edittool.asp".

            The "edittool.asp" page contains two functions: The
            loadFile() function loads and transforms the XML file for
            display and the updateFile() function applies the changes to
            the XML file:

            <%
            function loadFile(xmlfile,xslfile)
            Dim xmlDoc,xslDoc
            'Load XML and XSL file
            set xmlDoc =
            Server.CreateObject("Microsoft.XMLDOM")
            xmlDoc.async = false
            xmlDoc.load(xmlfile)
            set xslDoc =
            Server.CreateObject("Microsoft.XMLDOM")
            xslDoc.async = false
            xslDoc.load(xslfile)
            'Transform file
            Response.Write(xmlDoc.transformNode(xslDoc))
            end function

            function updateFile(xmlfile)
            Dim xmlDoc,rootEl,f
            Dim i
            'Load XML file
            set xmlDoc =
            Server.CreateObject("Microsoft.XMLDOM")
            xmlDoc.async = false
            xmlDoc.load(xmlfile)

            'Set the rootEl variable equal to the root element
            Set rootEl = xmlDoc.documentElement

            'Loop through the form collection
            for i = 1 To Request.Form.Count
              'Eliminate button elements in the form
              if instr(1,Request.Form.Key(i),"btn_")=0 then
                'The selectSingleNode method queries the XML file for a single node
                'that matches a query. This query requests the value element that is
                'the child of a field element that has an id attribute which matches
                'the current key value in the Form Collection. When there is a match

                evince -p 654 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

                'set the text property equal to the value of the current field in the
                'Form Collection.
                set f = rootEl.selectSingleNode("field[@id='" & _
                Request.Form.Key(i) & "']/value")
                f.Text = Request.Form(i)
              end if
            next

            'Save the modified XML file
            xmlDoc.save xmlfile

            'Release all object references
            set xmlDoc=nothing
            set rootEl=nothing
            set f=nothing

            'Load the modified XML file with a style sheet that
            'allows the client to see the edited information
            loadFile
            xmlfile,server.MapPath("tool_updated.xsl")
            end function

            'If form is submitted, update the XML file and display result
            ' - if not, transform the XML file for editing
            if Request.Form("btn_sub")="" then
              loadFile
            server.MapPath("tool.xml"),server.MapPath("tool.xsl")
            else
              updateFile server.MapPath("tool.xml")
            end if
            %>

            Tip: If you don't know how to write ASP, please study our
            ASP tutorial (/asp/default.asp).


            The PHP File

            In the "tool.xsl" file above, change the HTML form's action
            attribute to "edittool.php".

            The "edittool.php" page contains two functions: The
            loadFile() function loads and transforms the XML file for
            display and the updateFile() function applies the changes to
            the XML file:

                evince -p 655 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <?php
            function loadFile($xml, $xsl)
            {
            $xmlDoc = new DOMDocument();
            $xmlDoc->load($xml);

            $xslDoc = new DOMDocument();
            $xslDoc->load($xsl);

            $proc = new XSLTProcessor();
            $proc->importStyleSheet($xslDoc);
            echo $proc->transformToXML($xmlDoc);
            }

            function updateFile($xml)
            {
            $xmlLoad = simplexml_load_file($xml);
            $postKeys = array_keys($_POST);

            foreach($xmlLoad->children() as $x)
            {
              foreach($_POST as $key=>$value)
              {
                if($key == $x->attributes())
                {
                  $x->value = $value;
                }
              }
            }

            $xmlLoad->asXML($xml);
            loadFile($xml,"tool_updated.xsl");
            }

            if($_POST["btn_sub"] == "")
            {
              loadFile("tool.xml", "tool.xsl");
            }
            else
            {
              updateFile("tool.xml");
            }
            ?>

            Tip: If you don't know how to write PHP, please study our
            PHP tutorial (/php/default.asp).

                evince -p 656 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Note: We are doing the transformation and applying the
            changes to the XML file on the server. This is a cross-browser
            solution. The client will only get HTML back from the server -
            which will work in any browser.

                evince -p 660 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT Examples

            The <xsl:template> Element

            A template contains rules to apply when a specified node is
            matched (tryxslt.asp?xmlfile=cdcatalog&
            xsltfile=cdcatalog_ex1)

            Example explained (xsl_templates.asp)


            The <xsl:value-of> Element

            Example explained (xsl_value_of.asp)


            The <xsl:for-each> Element

            Select every XML element of a specified node-set with the
            <xsl:for-each> element (tryxslt.asp?xmlfile=cdcatalog&
            xsltfile=cdcatalog_ex3)

            Filter the output in a node-set
            (tryxslt.asp?xmlfile=cdcatalog&xsltfile=cdcatalog_filter)

            Examples explained (xsl_for_each.asp)

                evince -p 661 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The <xsl:sort> Element

            Sort the output in a node-set (tryxslt.asp?xmlfile=cdcatalog&
            xsltfile=cdcatalog_sort)

            Example explained (xsl_sort.asp)


            The <xsl:if> Element

            Put a conditional test against the content of an XML file
            (tryxslt.asp?xmlfile=cdcatalog&xsltfile=cdcatalog_if)

            Example explained (xsl_if.asp)


            The <xsl:choose> Element

            Example 1 (tryxslt.asp?xmlfile=cdcatalog&
            xsltfile=cdcatalog_choose)

            This example will add a pink background-color to the "Artist"
            column WHEN the price of the CD is higher than 10:

            Example 2 (tryxslt.asp?xmlfile=cdcatalog&
            xsltfile=cdcatalog_choose2)

            This example will add a pink background color to the "Artist"
            column WHEN the price of the CD is higher than 10, and a
            grey background-color WHEN the price of the CD is higher
            than 9 and lower or equal to 10.

            Examples explained (xsl_choose.asp)


            The <xsl:apply-templates> Element

            Apply templates to elements (tryxslt.asp?xmlfile=cdcatalog&
            xsltfile=cdcatalog_apply)

            Examples explained (xsl_apply_templates.asp)

                evince -p 666 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT Elements Reference

            The XSLT elements from the W3C Recommendation
            (XSLT Version 1.0).


            XSLT Elements

            The links in the "Element" column point to attributes and
            more useful information about each specific element.

            Element     Description

            apply-imports (el_apply-imports.asp)
             --
            Applies a template rule from
            an imported style sheet

            apply-templates (el_apply-templates.asp)
             --
            Applies a template rule to the
            current element or to the
            current element's child nodes

            attribute (el_attribute.asp)
             --
            Adds an attribute

            attribute-set (el_attributeset.asp)
             --
            Defines a named set of attributes

            call-template (el_calltemplate.asp)
             --
            Calls a named template

                evince -p 667 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            choose (el_choose.asp)
             --
            Used in conjunction with
            <when> and <otherwise> to
            express multiple conditional tests


            comment (el_comment.asp)
             --
            Creates a comment node in the
            result tree

            copy (el_copy.asp)
             --
            Creates a copy of the current
            node (without child nodes and
            attributes)

            copy-of (el_copy-of.asp)
             --
            Creates a copy of the current
            node (with child nodes and
            attributes)

            decimal-format (el_decimal-format.asp)
             --
            Defines the characters and
            symbols to be used when
            converting numbers into
            strings, with the formatnumber() function

            element (el_element.asp)
             --
            Creates an element node in the
            output document

            fallback (el_fallback.asp)
             --
            Specifies an alternate code to
            run if the processor does not
            support an XSLT element

            for-each (el_foreach.asp)
             --
            Loops through each node in a
            specified node set

            if (el_if.asp)
             --
            Contains a template that will
            be applied only if a specified
            condition is true

            import (el_import.asp)
             --
            Imports the contents of one
            style sheet into another. Note:
            An imported style sheet has
            lower precedence than the
            importing style sheet

                evince -p 668 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            include (el_include.asp)
             --
            Includes the contents of one
            style sheet into another. Note:
            An included style sheet has the
            same precedence as the
            including style sheet

            key (el_key.asp)
             --
            Declares a named key that can
            be used in the style sheet with
            the key() function

            message (el_message.asp)
             --
            Writes a message to the output
            (used to report errors)

            namespace-alias (el_namespacealias.asp)
             --
            Replaces a namespace in the
            style sheet to a different
            namespace in the output

            number (el_number.asp)
             --
            Determines the integer
            position of the current node
            and formats a number

            otherwise (el_otherwise.asp)
             --
            Specifies a default action for
            the <choose> element

            output (el_output.asp)
             --
            Defines the format of the
            output document

            param (el_param.asp)
             --
            Declares a local or global
            parameter

            preserve-space (el_preserve-space.asp)
             --
            Defines the elements for which
            white space should be preserved

            processing-instruction (el_processinginstruction.asp)
             --
            Writes a processing instruction
            to the output

            sort (el_sort.asp)
             --
            Sorts the output

            strip-space (el_preservespace.asp)
             --
            Defines the elements for which
            white space should be removed

                evince -p 669 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            stylesheet (el_stylesheet.asp)

            Defines the root element of a
            style sheet

            template (el_template.asp)
             --
            Rules to apply when a specified
            node is matched

            text (el_text.asp)
             --
            Writes literal text to the output

            transform (el_stylesheet.asp)
             --
            Defines the root element of a
            style sheet

            value-of (el_valueof.asp)
             --
            Extracts the value of a selected node

            variable (el_variable.asp)
             --
            Declares a local or global variable

            when (el_when.asp)
             --
            Specifies an action for the
            <choose> element

            with-param (el_withparam.asp)
             --
            Defines the value of a
            parameter to be passed into a template

                evince -p 674 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XSLT Functions

            XQuery 1.0, XPath 2.0, and XSLT 2.0 share the same
            functions library.


            XSLT Functions

            XSLT includes over 100 built-in functions. There are functions
            for string values, numeric values, date and time comparison,
            node and QName manipulation, sequence manipulation,
            Boolean values, and more.

            Note:
            The default prefix for the function namespace is fn:
            The URI of the function namespace is:
            http://www.w3.org/2005/xpath-functions

            Tip: Functions are often called with the fn: prefix, such as
            fn:string(). However, since fn: is the default prefix of the
            namespace, the function names do not need to be prefixed
            when called.

            The reference of all the built-in XSLT 2.0 functions is located
            in our XPath tutorial. (/xpath/xpath_functions.asp)

                evince -p 675 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            In addition, there are the following built-in XSLT functions:

            Name    Description

            current() (func_current.asp)
             --
            Returns the current node

            document() (func_document.asp)
             --
            Used to access the nodes in
            an external XML document

            element-available() (func_elementavailable.asp)
             --
            Tests whether the element
            specified is supported by
            the XSLT processor

            format-number() (func_formatnumber.asp)
             --
            Converts a number into a string

            function-available() (func_functionavailable.asp)
             --
            Tests whether the function
            specified is supported by
            the XSLT processor

            generate-id() (func_generateid.asp)
             --
            Returns a string value that
            uniquely identifies a
            specified node

            key() (func_key.asp)
             --
            Returns a node-set using
            the index specified by an
            <xsl:key> element

            system-property() (func_systemproperty.asp)
             --
            Returns the value of the
            system properties

            unparsed-entity-uri() (func_unparsedentityuri.asp)
             --
            Returns the URI of an
            unparsed entity

                evince -p 680 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML - XLink

            XLink (the XML Linking language) defines methods for
            creating links within XML documents.


            What is XLink?

            - XLink is used to create hyperlinks within XML documents
            - Any element in an XML document can behave as a link
            - XLink supports simple links (like HTML) and extended links (for
                linking multiple resources together)
            - With XLink, the links can be defined outside the linked files
            - XLink is a W3C Recommendation


            XLink Syntax

            In HTML, the <a> element defines a hyperlink. However, this
            is not how it works in XML. In XML documents, you can use
            whatever element names you want - therefore it is
            impossible for browsers to predict what link elements will be
            called in XML documents.

                evince -p 681 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Below is a simple example of how to use XLink to create
            links in an XML document:

            <?xml version="1.0" encoding="UTF-8"?>

            <homepages xmlns:xlink="http://www.w3.org/1999/xlink">
              <homepage xlink:type="simple" xlink:href="http://www.w3schools.com">Visit
                  W3Schools</homepage>
              <homepage xlink:type="simple" xlink:href="http://www.w3.org">Visit
                  W3C</homepage>
            </homepages>

            To get access to the XLink features we must declare the
            XLink namespace. The XLink namespace is:
            "http://www.w3.org/1999/xlink".

            The xlink:type and the xlink:href attributes in the
            <homepage> elements come from the XLink namespace.

            The xlink:type="simple" creates a simple "HTML-like" link
            (means "click here to go there").

            The xlink:href attribute specifies the URL to link to.


            XLink Browser Support

            There is no browser support for XLink in XML documents.
            However, all major browsers support simple XLinks in SVG
            (/svg/svg_text.asp).


            XLink Example

            The following XML document contains XLink features:

            <?xml version="1.0" encoding="UTF-8"?>

            <bookstore xmlns:xlink="http://www.w3.org/1999/xlink">

                evince -p 682 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <book title="Harry Potter">
              <description
              xlink:type="simple"
              xlink:href="/images/HPotter.gif"
              xlink:show="new">
              As his fifth year at Hogwarts School of Witchcraft and
              Wizardry approaches, 15-year-old Harry Potter is.......
              </description>
            </book>

            <book title="XQuery Kick Start">
              <description
              xlink:type="simple"
              xlink:href="/images/XQuery.gif"
              xlink:show="new">
              XQuery Kick Start delivers a concise introduction
              to the XQuery standard.......
              </description>
            </book>

            </bookstore>

            Example explained:

            - The XLink namespace is declared at the top of the
              document (xmlns:xlink="http://www.w3.org
              /1999/xlink")
            - The xlink:type="simple" creates a simple "HTML-like" link
            - The xlink:href attribute specifies the URL to link to (in
              this case - an image)
            - The xlink:show="new" specifies that the link should
              open in a new window


            XLink - Going Further

            In the example above we have demonstrated simple XLinks.
            XLink is getting more interesting when accessing remote
            locations as resources, instead of standalone pages.

            If we set the value of the xlink:show attribute to "embed",
            the linked resource should be processed inline within the page.

                evince -p 683 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            When you consider that this could be another XML
            document you could, for example, build a hierarchy of XML documents.

            You can also specify WHEN the resource should appear, with
            the xlink:actuate attribute.


            XLink Attribute Reference

            Attribute   Value   Description

            xlink:actuate
                --
            onLoad
            onRequest
            other
            none
                --
            Defines when the linked
            resource is read and shown:
            - onLoad - the resource
            should be loaded and
            shown when the
            document loads
            - onRequest - the resource
            is not read or shown
            before the link is clicked

            xlink:href
                --
            URL
                --
            Specifies the URL to link to

            xlink:show
                --
            embed
            new
            replace
            other
            none
                --
            Specifies where to open the
            link. Default is "replace"

            xlink:type
                --
            simple
            extended
            locator
            arc
            resource
            title
            none
                --
            Specifies the type of link

                evince -p 688 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML - XPointer

            XPointer (the XML Pointer language) allows hyperlinks to
            point to specific parts (fragments) of XML documents.


            What is XPointer?

            - XPointer allows the links to point
              to specific parts of an XML document
            - XPointer uses XPath expressions
              to navigate in the XML document
            - XPointer is a W3C Recommendation


            XPointer Browser Support

            There is no browser support for XPointer. But XPointer is
            used in other XML languages.

                evince -p 689 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XPointer Example

            In this example, we will use XPointer in conjunction with
            XLink to point to a specific part of another document.

            We will start by looking at the target XML document (the
            document we are linking to):

            <?xml version="1.0" encoding="UTF-8"?>

            <dogbreeds>

            <dog breed="Rottweiler" id="Rottweiler">
              <picture url="http://dog.com/rottweiler.gif" />
              <history>The Rottweiler's ancestors were probably Roman
              drover dogs.....</history>
              <temperament>Confident, bold, alert and imposing, the Rottweiler
              is a popular choice for its ability to protect....</temperament>
            </dog>

            <dog breed="FCRetriever" id="FCRetriever">
              <picture url="http://dog.com/fcretriever.gif"/>
              <history>One of the earliest uses of retrieving dogs was to
              help fishermen retrieve fish from the water.... </history>
              <temperament>The flat-coated retriever is a sweet, exuberant,
              lively dog that loves to play and retrieve....
              </temperament>
            </dog>

            </dogbreeds>

            Note that the XML document above uses id attributes on
            each element!

            So, instead of linking to the entire document (as with XLink),
            XPointer allows you to link to specific parts of the document.
            To link to a specific part of a page, add a number sign (#)
            and an XPointer expression after the URL in the xlink:href
            attribute, like this: xlink:href="http://dog.com
            /dogbreeds.xml#xpointer(id('Rottweiler'))". The expression
            refers to the element in the target document, with the id
            value of "Rottweiler".

            XPointer also allows a shorthand method for linking to an
            element with an id. You can use the value of the id directly,
            like this: xlink:href="http://dog.com/dogbreeds.xml#Rottweiler".

                evince -p 690 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The following XML document contains links to more
            information of the dog breed for each of my dogs:

            <?xml version="1.0" encoding="UTF-8"?>

            <mydogs xmlns:xlink="http://www.w3.org/1999/xlink">

            <mydog>
              <description>
              Anton is my favorite dog. He has won a lot of.....
              </description>
              <fact xlink:type="simple" xlink:href="http://dog.com/dogbreeds.xml#Rottweiler">
              Fact about Rottweiler
              </fact>
            </mydog>

            <mydog>
              <description>
              Pluto is the sweetest dog on earth......
              </description>
              <fact xlink:type="simple" xlink:href="http://dog.com /dogbreeds.xml#FCRetriever">
              Fact about flat-coated Retriever
              </fact>
            </mydog>

            </mydogs>

                evince -p 695 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XQuery Tutorial

            XQuery is to XML what SQL is to database tables.

            XQuery is designed to query XML data -
            not just XML files, but anything that can
            appear as XML, including databases.


            XQuery Example

            for $x in doc("books.xml")/bookstore/book
            where $x/price>30
            order by $x/title
            return $x/title


            What You Should Already Know

            Before you continue you should have a basic understanding
            of the following:
            - HTML
            - XML
            - XPath

            If you want to study these subjects first, find the tutorials on
            our Home page (/default.asp).

                evince -p 696 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            What is XQuery?

            - XQuery is the language for querying XML data
            - XQuery for XML is like SQL for databases
            - XQuery is built on XPath expressions
            - XQuery is supported by all major databases
            - XQuery is a W3C Recommendation


            XQuery is About Querying XML

            XQuery is a language for finding and extracting elements and
            attributes from XML documents.

            Here is an example of a question that XQuery could solve:

            "Select all CD records with a price less than $10 from the CD
            collection stored in the XML document called cd_catalog.xml"


            XQuery and XPath

            XQuery 1.0 and XPath 2.0 share the same data model and
            support the same functions and operators. If you have
            already studied XPath you will have no problems with
            understanding XQuery.

            You can read more about XPath in our XPath Tutorial (/xpath
            /default.asp).


            XQuery - Examples of Use

            XQuery can be used to:
            - Extract information to use in a Web Service
            - Generate summary reports
            - Transform XML data to XHTML
            - Search Web documents for relevant information

                evince -p 697 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XQuery is a W3C Recommendation

            XQuery is compatible with several W3C standards, such as
            XML, Namespaces, XSLT, XPath, and XML Schema.

            XQuery 1.0 became a W3C Recommendation January 23, 2007.

                evince -p 702 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XQuery Example

            Let's try to learn some basic XQuery syntax by looking at
            an example.


            The XML Example Document

            We will use the following XML document in the examples below.

            "books.xml":

            <?xml version="1.0" encoding="UTF-8"?>

            <bookstore>

            <book category="COOKING">
              <title lang="en">Everyday Italian</title>
              <author>Giada De Laurentiis</author>
              <year>2005</year>
              <price>30.00</price>
            </book>

            <book category="CHILDREN">
              <title lang="en">Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>

                evince -p 703 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <book category="WEB">
              <title lang="en">XQuery Kick Start</title>
              <author>James McGovern</author>
              <author>Per Bothner</author>
              <author>Kurt Cagle</author>
              <author>James Linn</author>
              <author>Vaidyanathan Nagarajan</author>
              <year>2003</year>
              <price>49.99</price>
            </book>

            <book category="WEB">
              <title lang="en">Learning XML</title>
              <author>Erik T. Ray</author>
              <year>2003</year>
              <price>39.95</price>
            </book>

            </bookstore>

            View the "books.xml" file in your browser (books.xml).


            How to Select Nodes From "books.xml"?

            Functions

            XQuery uses functions to extract data from XML documents.

            The doc() function is used to open the "books.xml" file:

            doc("books.xml")


            Path Expressions

            XQuery uses path expressions to navigate through elements
            in an XML document.

            The following path expression is used to select all the title
            elements in the "books.xml" file:

            doc("books.xml")/bookstore/book/title

                evince -p 704 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            (/bookstore selects the bookstore element, /book selects all
            the book elements under the bookstore element, and /title
            selects all the title elements under each book element)

            The XQuery above will extract the following:

            <title lang="en">Everyday Italian</title>
            <title lang="en">Harry Potter</title>
            <title lang="en">XQuery Kick Start</title>
            <title lang="en">Learning XML</title>


            Predicates

            XQuery uses predicates to limit the extracted data
            from XML documents.

            The following predicate is used to select all the book
            elements under the bookstore element that have a price
            element with a value that is less than 30:

            doc("books.xml")/bookstore/book[price<30]

            The XQuery above will extract the following:

            <book category="CHILDREN">
              <title lang="en">Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>

                evince -p 709 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XQuery FLWOR + HTML


            The XML Example Document

            We will use the "books.xml" document in the examples below
            (same XML file as in the previous chapters).

            View the "books.xml" file in your browser (books.xml).


            Present the Result In an HTML List

            Look at the following XQuery FLWOR expression:

            for $x in doc("books.xml")/bookstore/book/title
            order by $x
            return $x

            The expression above will select all the title elements under
            the book elements that are under the bookstore element,
            and return the title elements in alphabetical order.

            Now we want to list all the book-titles in our bookstore in an
            HTML list. We add <ul> and <li> tags to the FLWOR expression:

                evince -p 710 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <ul>
            {
            for $x in doc("books.xml")/bookstore/book/title
            order by $x
            return <li>{$x}</li>
            }
            </ul>

            The result of the above will be:

            <ul>
              <li><title lang="en">Everyday Italian</title></li>
              <li><title lang="en">Harry Potter</title></li>
              <li><title lang="en">Learning XML</title></li>
              <li><title lang="en">XQuery Kick Start</title></li>
            </ul>

            Now we want to eliminate the title element, and show only
            the data inside the title element:

            <ul>
            {
            for $x in doc("books.xml")/bookstore/book/title
            order by $x
            return <li>{data($x)}</li>
            }
            </ul>

            The result will be (an HTML list):

            <ul>
            <li>Everyday Italian</li>
            <li>Harry Potter</li>
            <li>Learning XML</li>
            <li>XQuery Kick Start</li>
            </ul>

                evince -p 715 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XQuery Terms

            In XQuery, there are seven kinds of nodes: element,
            attribute, text, namespace, processing-instruction,
            comment, and document (root) nodes.


            XQuery Terminology

            Nodes

            In XQuery, there are seven kinds of nodes: element,
            attribute, text, namespace, processing-instruction, comment,
            and document (root) nodes. XML documents are treated as
            trees of nodes. The root of the tree is called the document
            node (or root node).

            Look at the following XML document:

            <?xml version="1.0" encoding="UTF-8"?>

            <bookstore>

            <book>
              <title lang="en">Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>

            </bookstore>

                evince -p 716 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example of nodes in the XML document above:

            <bookstore> (document node)

            <author>J K. Rowling</author> (element node)

            lang="en" (attribute node)


            Atomic values

            Atomic values are nodes with no children or parent.

            Example of atomic values:

            J K. Rowling

            "en"


            Items

            Items are atomic values or nodes.


            Relationship of Nodes

            Parent

            Each element and attribute has one parent.

            In the following example; the book element is the parent of
            the title, author, year, and price:

            <book>
              <title>Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>

                evince -p 717 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Children

            Element nodes may have zero, one or more children.

            In the following example; the title, author, year, and price
            elements are all children of the book element:

            <book>
              <title>Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>


            Siblings

            Nodes that have the same parent.

            In the following example; the title, author, year, and price
            elements are all siblings:

            <book>
              <title>Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>


            Ancestors

            A node's parent, parent's parent, etc.

            In the following example; the ancestors of the title element
            are the book element and the bookstore element:

            <bookstore>

            <book>
              <title>Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>

            </bookstore>

                evince -p 718 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Descendants

            A node's children, children's children, etc.

            In the following example; descendants of the bookstore
            element are the book, title, author, year, and price elements:

            <bookstore>

            <book>
              <title>Harry Potter</title>
              <author>J K. Rowling</author>
              <year>2005</year>
              <price>29.99</price>
            </book>

            </bookstore>

                evince -p 723 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XQuery Syntax

            XQuery is case-sensitive and XQuery elements,
            attributes, and variables must be valid XML names.


            XQuery Basic Syntax Rules

            Some basic syntax rules:

            - XQuery is case-sensitive
            - XQuery elements, attributes, and variables must be valid XML names
            - An XQuery string value can be in single or double quotes
            - An XQuery variable is defined with a $ followed by a
                name, e.g. $bookstore
            - XQuery comments are delimited by (: and :), e.g. (: XQuery Comment :)


            The XML Example Document

            We will use the "books.xml" document in the examples below
            (same XML file as in the previous chapters).

            View the "books.xml" file in your browser (books.xml).

                evince -p 724 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XQuery Conditional Expressions

            "If-Then-Else" expressions are allowed in XQuery.

            Look at the following example:

            for $x in doc("books.xml")/bookstore/book
            return if ($x/@category="CHILDREN")
            then <child>{data($x/title)}</child>
            else <adult>{data($x/title)}</adult>

            Notes on the "if-then-else" syntax: parentheses around
            the if expression are required. else is required, but it can be
            just else ().

            The result of the example above will be:

            <adult>Everyday Italian</adult>
            <child>Harry Potter</child>
            <adult>XQuery Kick Start</adult>
            <adult>Learning XML</adult>


            XQuery Comparisons

            In XQuery there are two ways of comparing values.

            1. General comparisons: =, !=, <, <=, >, >=
            2. Value comparisons: eq, ne, lt, le, gt, ge

            The difference between the two comparison methods are
            shown below.

            The following expression returns true if any q attributes have
            a value greater than 10:

            $bookstore//book/@q > 10

            The following expression returns true if there is only one q
            attribute returned by the expression, and its value is greater
            than 10. If more than one q is returned, an error occurs:

            $bookstore//book/@q gt 10

                evince -p 729 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XQuery Adding Elements and Attributes

            The XML Example Document

            We will use the "books.xml" document in the examples below
            (same XML file as in the previous chapters).

            View the "books.xml" file in your browser (books.xml).


            Adding Elements and Attributes to the Result

            As we have seen in a previous chapter, we may include
            elements and attributes from the input document
            ("books.xml) in the result:

            for $x in doc("books.xml")/bookstore/book/title
            order by $x
            return $x

            The XQuery expression above will include both the title
            element and the lang attribute in the result, like this:

            <title lang="en">Everyday Italian</title>
            <title lang="en">Harry Potter</title>
            <title lang="en">Learning XML</title>
            <title lang="en">XQuery Kick Start</title>

                evince -p 730 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The XQuery expression above returns the title elements the
            exact same way as they are described in the input document.

            We now want to add our own elements and attributes to the result!


            Add HTML Elements and Text

            Now, we want to add some HTML elements to the result. We
            will put the result in an HTML list - together with some text:

            <html>
            <body>

            <h1>Bookstore</h1>

            <ul>
            {
              for $x in doc("books.xml")/bookstore/book
              order by $x/title
              return <li>{data($x/title)}. Category:
              {data($x/@category)}</li>
            }
            </ul>

            </body>
            </html>

            The XQuery expression above will generate the following result:

            <html>
            <body>
            <h1>Bookstore</h1>
            <ul>
            <li>Everyday Italian. Category: COOKING</li>
            <li>Harry Potter. Category: CHILDREN</li>
            <li>Learning XML. Category: WEB</li>
            <li>XQuery Kick Start. Category: WEB</li>
            </ul>
            </body>
            </html>

                evince -p 731 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Add Attributes to HTML Elements

            Next, we want to use the category attribute as a class
            attribute in the HTML list:

            <html>
            <body>

            <h1>Bookstore</h1>

            <ul>
            {
              for $x in doc("books.xml")/bookstore/book
              order by $x/title
              return <li class="{data($x/@category)}">{data($x/title)}</li>
            }
            </ul>

            </body>
            </html>

            The XQuery expression above will generate the following result:

            <html>
            <body>
            <h1>Bookstore</h1>

            <ul>
            <li class="COOKING">Everyday Italian</li>
            <li class="CHILDREN">Harry Potter</li>
            <li class="WEB">Learning XML</li>
            <li class="WEB">XQuery Kick Start</li>
            </ul>

            </body>
            </html>

                evince -p 736 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XQuery Selecting and Filtering

            The XML Example Document

            We will use the "books.xml" document in the examples below
            (same XML file as in the previous chapters).

            View the "books.xml" file in your browser (books.xml).


            Selecting and Filtering Elements

            As we have seen in the previous chapters, we are selecting
            and filtering elements with either a Path expression or with a
            FLWOR expression.

            Look at the following FLWOR expression:

            for $x in doc("books.xml")/bookstore/book
            where $x/price>30
            order by $x/title
            return $x/title

            - for - (optional) binds a variable to each item returned
              by the in expression
            - let - (optional)
            - where - (optional) specifies a criteria
            - order by - (optional) specifies the sort-order of the result
            - return - specifies what to return in the result

                evince -p 737 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The for Clause

            The for clause binds a variable to each item returned by the
            in expression. The for clause results in iteration. There can
            be multiple for clauses in the same FLWOR expression.

            To loop a specific number of times in a for clause, you may
            use the to keyword:

            for $x in (1 to 5)
            return <test>{$x}</test>

            Result:

            <test>1</test>
            <test>2</test>
            <test>3</test>
            <test>4</test>
            <test>5</test>

            The at keyword can be used to count the iteration:

            for $x at $i in doc("books.xml")/bookstore
            /book/title
            return <book>{$i}. {data($x)}</book>

            Result:

            <book>1.
            <book>2.
            <book>3.
            <book>4.

            Everyday Italian</book>
            Harry Potter</book>
            XQuery Kick Start</book>
            Learning XML</book>

            It is also allowed with more than one in expression in the for
            clause. Use comma to separate each in expression:

            for $x in (10,20), $y in (100,200)
            return <test>x={$x} and y={$y}</test>

                evince -p 738 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Result:

            <test>x=10 and y=100</test>
            <test>x=10 and y=200</test>
            <test>x=20 and y=100</test>
            <test>x=20 and y=200</test>


            The let Clause

            The let clause allows variable assignments and it avoids
            repeating the same expression many times. The let clause
            does not result in iteration.

            let $x := (1 to 5)
            return <test>{$x}</test>

            Result:

            <test>1 2 3 4 5</test>


            The where Clause

            The where clause is used to specify one or more criteria for
            the result:

            where $x/price>30 and $x/price<100


            The order by Clause

            The order by clause is used to specify the sort order of the
            result. Here we want to order the result by category and title:

            for $x in doc("books.xml")/bookstore/book
            order by $x/@category, $x/title
            return $x/title

            Result:

            <title lang="en">Harry Potter</title>
            <title lang="en">Everyday Italian</title>
            <title lang="en">Learning XML</title>
            <title lang="en">XQuery Kick Start</title>

                evince -p 739 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The return Clause

            The return clause specifies what is to be returned.

            for $x in doc("books.xml")/bookstore/book
            return $x/title

            Result:

            <title lang="en">Everyday Italian</title>
            <title lang="en">Harry Potter</title>
            <title lang="en">XQuery Kick Start</title>
            <title lang="en">Learning XML</title>

                evince -p 744 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XQuery Functions

            XQuery 1.0, XPath 2.0, and XSLT 2.0 share the same
            functions library.


            XQuery Functions

            XQuery includes over 100 built-in functions. There are
            functions for string values, numeric values, date and time
            comparison, node and QName manipulation, sequence
            manipulation, Boolean values, and more. You can also define
            your own functions in XQuery.


            XQuery Built-in Functions

            The URI of the XQuery function namespace is:
            http://www.w3.org/2005/02/xpath-functions

            The default prefix for the function namespace is fn:.

            Tip: Functions are often called with the fn: prefix, such as
            fn:string(). However, since fn: is the default prefix of the
            namespace, the function names do not need to be prefixed
            when called.

            The reference of all the built-in XQuery 1.0 functions is
            located in our XPath tutorial (/xpath/xpath_functions.asp).

                evince -p 745 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Examples of Function Calls

            A call to a function can appear where an expression may
            appear. Look at the examples below:

            Example 1: In an element

            <name>{upper-case($booktitle)}</name>

            Example 2: In the predicate of a path expression

            doc("books.xml")/bookstore
            /book[substring(title,1,5)='Harry']

            Example 3: In a let clause

            let $name := (substring($booktitle,1,4))


            XQuery User-Defined Functions

            If you cannot find the XQuery function you need, you can
            write your own.

            User-defined functions can be defined in the query or in a
            separate library.

            Syntax

            declare function prefix:function_name($parameter
            as datatype)
            as returnDatatype
            {
              ...function code here...
            };

            Notes on user-defined functions:

            - Use the declare function keyword
            - The name of the function must be prefixed
            - The data type of the parameters are mostly the same
                as the data types defined in XML Schema
            - The body of the function must be surrounded by curly braces

                evince -p 746 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example of a User-defined Function Declared in the Query

            declare function local:minPrice($p as
            xs:decimal?,$d as xs:decimal?)
            as xs:decimal?
            {
            let $disc := ($p * $d) div 100
            return ($p - $disc)
            };

            Below is an example of how to call the function above:

            <minPrice>{local:minPrice($book/price,$book/discount)}</minPrice>

                evince -p 751 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XQuery Reference

            XQuery 1.0 and XPath 2.0 share the same data model
            and support the same functions and operators.


            XQuery Functions

            XQuery is built on XPath expressions. XQuery 1.0 and XPath
            2.0 share the same data model and support the same
            functions and operators.

            XPath Operators (/xpath/xpath_operators.asp)

            XPath Functions (/xpath/xpath_functions.asp)


            XQuery Data Types

            XQuery shares the same data types as XML Schema 1.0 (XSD).

            XSD String (/schema/schema_dtypes_string.asp)

            XSD Date (/schema/schema_dtypes_date.asp)

            XSD Numeric (/schema/schema_dtypes_numeric.asp)

            XSD Misc (/schema/schema_dtypes_misc.asp)


                evince -p 756 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML CDATA

            All text in an XML document will be parsed by the parser.
            But text inside a CDATA section will be ignored by the parser.


            PCDATA - Parsed Character Data

            XML parsers normally parse all the text in an XML document.

            When an XML element is parsed, the text between the XML
            tags is also parsed:

            <message>This text is also parsed</message>

            The parser does this because XML elements can contain
            other elements, as in this example, where the <name>
            element contains two other elements (first and last):

            <name><first>Bill</first><last>Gates</last></name>

            and the parser will break it up into sub-elements like this:

            <name>
              <first>Bill</first>
              <last>Gates</last>
            </name>

                evince -p 757 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Parsed Character Data (PCDATA) is a term used about text
            data that will be parsed by the XML parser.


            CDATA - (Unparsed) Character Data

            The term CDATA is used about text data that should not be
            parsed by the XML parser.

            Characters like "<" and "&" are illegal in XML elements.

            "<" will generate an error because the parser interprets it as
            the start of a new element.

            "&" will generate an error because the parser interprets it as
            XML XSLT (xml_xsl.asp) the start of an character entity.

            Some text, like JavaScript code, contains a lot of "<" or "&"
            characters. To avoid errors script code can be defined as CDATA.

            Everything inside a CDATA section is ignored by the parser.

            A CDATA section starts with "<![CDATA[" and ends with "]]>":

            <script>
            <![CDATA[
            function matchwo(a,b)
            {
            if (a < b && a < 0) then
              {
              return 1;
              }
            else
              {
              return 0;
              }
            }
            ]]>
            </script>

                evince -p 758 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            In the example above, everything inside the CDATA section is
            ignored by the parser.

            Notes on CDATA sections:

            A CDATA section cannot contain the string "]]>". Nested
            CDATA sections are not allowed.

            The "]]>" that marks the end of the CDATA section cannot
            contain spaces or line breaks.

                evince -p 762 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML on the Server

            XML files are plain text files just like HTML files.
            XML can easily be stored and generated by a standard
            web server.


            Storing XML Files on the Server

            XML files can be stored on an Internet server exactly the
            same way as HTML files.

            Start Windows Notepad and write the following lines:

            <?xml version="1.0" encoding="UTF-8"?>
            <note>
              <from>Jani</from>
              <to>Tove</to>
              <message>Remember me this weekend</message>
            </note>

            Save the file on your web server with a proper name like
            "note.xml".


            Generating XML with ASP

            XML can be generated on a server without any installed XML software.

                evince -p 763 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            To generate an XML response from the server - simply write
            the following code and save it as an ASP file on the web server:

            <%
            response.ContentType="text/xml"
            response.Write("<?xml version='1.0' encoding='UTF-8'?>")
            response.Write("<note>")
            response.Write("<from>Jani</from>")
            response.Write("<to>Tove</to>")
            response.Write("<message>Remember me this weekend</message>")
            response.Write("</note>")
            %>

            Note that the content type of the response must be set to
            "text/xml".

            See how the ASP file will be returned from the server
            (note.asp).

            If you want to study ASP, you will find our ASP tutorial on our
            homepage (/default.asp).


            Generating XML with PHP

            To generate an XML response from the server using PHP, use
            following code:

            <?php
            header("Content-type: text/xml");
            echo "<?xml version='1.0' encoding='UTF-8'?>";
            echo "<note>";
            echo "<from>Jani</from>";
            echo "<to>Tove</to>";
            echo "<message>Remember me this weekend</message>";
            echo "</note>";
            ?>

            Note that the content type of the response header must be
            set to "text/xml".

                evince -p 764 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            See how the PHP file will be returned from the server (note.php).

            If you want to study PHP, you will find our PHP tutorial on our
            homepage (/default.asp).


            Generating XML From a Database

            XML can be generated from a database without any installed
            XML software.

            To generate an XML database response from the server,
            simply write the following code and save it as an ASP file on
            the web server:

            <%
            response.ContentType = "text/xml"
            set conn=Server.CreateObject("ADODB.Connection")
            conn.provider="Microsoft.Jet.OLEDB.4.0;"
            conn.open server.mappath("/db/database.mdb")

            sql="select fname,lname from tblGuestBook"
            set rs=Conn.Execute(sql)

            response.write("<?xml version='1.0'
            encoding='UTF-8'?>")
            response.write("<guestbook>")
            while (not rs.EOF)
            response.write("<guest>")
            response.write("<fname>" & rs("fname") &
            "</fname>")
            response.write("<lname>" & rs("lname") &
            "</lname>")
            response.write("</guest>")
            rs.MoveNext()
            wend

            rs.close()
            conn.close()
            response.write("</guestbook>")
            %>

            See the real life database output from the ASP file above
            (guestbook.asp).

            The example above uses ASP with ADO.

                evince -p 765 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            If you want to study ASP and ADO, you will find the tutorials
            on our homepage (/default.asp).


            Transforming XML with XSLT on the Server

            This ASP transforms an XML file to XHTML on the server:

            <%
            'Load XML
            set xml = Server.CreateObject("Microsoft.XMLDOM")
            xml.async = false
            xml.load(Server.MapPath("simple.xml"))

            'Load XSL
            set xsl = Server.CreateObject("Microsoft.XMLDOM")
            xsl.async = false
            xsl.load(Server.MapPath("simple.xsl"))

            'Transform file
            Response.Write(xml.transformNode(xsl))
            %>

            Example explained
            - The first block of code creates an instance of the
                Microsoft XML parser (XMLDOM), and loads the XML file
                into memory.
            - The second block of code creates another instance of
                the parser and loads the XSL file into memory.
            - The last line of code transforms the XML document
                using the XSL document, and sends the result as
                XHTML to your browser. Nice!

            See how it works (simple.asp).


            Saving XML To a File Using ASP

            This ASP example creates a simple XML document and saves
            it on the server:

                evince -p 766 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <%
            text="<note>"
            text=text & "<to>Tove</to>"
            text=text & "<from>Jani</from>"
            text=text & "<heading>Reminder</heading>"
            text=text & "<body>Don't forget me this weekend!
            </body>"
            text=text & "</note>"

            set
            xmlDoc=Server.CreateObject("Microsoft.XMLDOM")
            xmlDoc.async=false
            xmlDoc.loadXML(text)

            xmlDoc.Save("test.xml")
            %>

                evince -p 771 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The XML DOM - Advanced

            In an earlier chapter of this tutorial (xml_dom.asp) we
            introduced the XML DOM, and we used the
            getElementsByTagName() method to retrieve data from an XML document.

            In this chapter we will explain some other important XML DOM methods.

            You can learn more about the XML DOM in our XML DOM tutorial
            (/dom/default.asp).


            Get the Value of an Element

            The XML file used in the examples below: books.xml (books.xml).

            The following example retrieves the text value of the first
            <title> element:


            Example

            txt=xmlDoc.getElementsByTagName("title")[0].childNodes[0].nodeValue;

                evince -p 772 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Get the Value of an Attribute

            The following example retrieves the text value of the "lang"
            attribute of the first <title> element:


            Example

            txt=xmlDoc.getElementsByTagName("title")
            [0].getAttribute("lang");


            Change the Value of an Element

            The following example changes the text value of the first
            <title> element:

            Example

            x=xmlDoc.getElementsByTagName("title")
            [0].childNodes[0];
            x.nodeValue="Easy Cooking";


            Create a New Attribute

            The XML DOM setAttribute() method can be used to change the
            value of an existing attribute, or to create a new attribute.

            The following example adds a new attribute (edition="first") to
            each <book> element:


            Example

            x=xmlDoc.getElementsByTagName("book");

            for(i=0;i<x.length;i++)
              {
              x[i].setAttribute("edition","first");
              }

                evince -p 773 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Create an Element

            The XML DOM createElement() method creates a new element node.

            The XML DOM createTextNode() method creates a new text node.

            The XML DOM appendChild() method adds a child node to a
            node (after the last child).

            To create a new element with text content, it is necessary to
            both create a new element node and a new text node, and then
            append it to an existing node.

            The following example creates a new element (<edition>), with
            the following text: First, and adds it to the first <book> element:


            Example

            newel=xmlDoc.createElement("edition");
            newtext=xmlDoc.createTextNode("First");
            newel.appendChild(newtext);

            x=xmlDoc.getElementsByTagName("book");
            x[0].appendChild(newel);


            Example explained:
            - Create an <edition> element
            - Create a text node with the following text: First
            - Append the text node to the new <edition> element
            - Append the <edition> element to the first <book> element


            Remove an Element

            The following example removes the first node in the first
            <book> element:

                evince -p 774 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            Example

            x=xmlDoc.getElementsByTagName("book")[0];
            x.removeChild(x.childNodes[0]);

            Note: The result of the example above may be different
            depending on what browser you use. Firefox treats new lines as
            empty text nodes, Internet Explorer does not. You can read
            more about this and how to avoid it in our XML DOM tutorial
            (/dom/default.asp).

                evince -p 779 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML in Real Life

            Some examples of how XML can be used to exchange information.


            Example: XML News

            XMLNews is a specification for exchanging news and
            other information.

            Using such a standard makes it easier for both news
            producers and news consumers to produce, receive, and
            archive any kind of news information across different
            hardware, software, and programming languages.

            An example XMLNews document:

            <?xml version="1.0" encoding="UTF-8"?>
            <nitf>
              <head>
                <title>Colombia Earthquake</title>
              </head>
              <body>
                <headline>
                  <hl1>143 Dead in Colombia Earthquake</hl1>
                </headline>
                <byline>
                  <bytag>By Jared Kotler, Associated Press Writer</bytag>

                evince -p 780 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

                  </byline>
                  <dateline>
                    <location>Bogota, Colombia</location>
                  <date>Monday January 25 1999 7:28 ET</date>
                </dateline>
              </body>
            </nitf>


            Example: XML Weather Service

            An example of an XML national weather service from NOAA
            (National Oceanic and Atmospheric Administration):

            <?xml version="1.0" encoding="UTF-8"?>
            <current_observation>

            <credit>NOAA's National Weather Service</credit>
            <credit_URL>http://weather.gov/</credit_URL>

            <image>
              <url>http://weather.gov/images/xml_logo.gif</url>
              <title>NOAA's National Weather Service</title>
              <link>http://weather.gov</link>
            </image>

            <location>New York/John F. Kennedy Intl Airport, NY</location>
            <station_id>KJFK</station_id>
            <latitude>40.66</latitude>
            <longitude>-73.78</longitude>
            <observation_time_rfc822>Mon, 11 Feb 2008 06:51:00 -0500 EST
            </observation_time_rfc822>

            <weather>A Few Clouds</weather>
            <temp_f>11</temp_f>
            <temp_c>-12</temp_c>
            <relative_humidity>36</relative_humidity>
            <wind_dir>West</wind_dir>
            <wind_degrees>280</wind_degrees>
            <wind_mph>18.4</wind_mph>
            <wind_gust_mph>29</wind_gust_mph>
            <pressure_mb>1023.6</pressure_mb>
            <pressure_in>30.23</pressure_in>
            <dewpoint_f>-11</dewpoint_f>
            <dewpoint_c>-24</dewpoint_c>

                evince -p 781 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            <windchill_f>-7</windchill_f>
            <windchill_c>-22</windchill_c>
            <visibility_mi>10.00</visibility_mi>
            <icon_url_base>http://weather.gov/weather/images
            /fcicons/</icon_url_base>
            <icon_url_name>nfew.jpg</icon_url_name>
            <disclaimer_url>http://weather.gov
            /disclaimer.html</disclaimer_url>
            <copyright_url>http://weather.gov
            /disclaimer.html</copyright_url>
            </current_observation>

                evince -p 786 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Examples

            These examples demonstrate XML files, XML formatting
            and XML transformation (XSLT).

            They also demonstrate JavaScript used together with
            XML (AJAX).


            Viewing XML Files

            View a simple XML file (note.xml) (note.xml)
            View the same XML file with an error (note_error.xml)
            View an XML CD catalog (cd_catalog.xml)
            View an XML plant catalog (plant_catalog.xml)
            View an XML food menu (simple.xml)

            Examples explained (xml_view.asp)


            XML and CSS

            View an XML CD catalog (cd_catalog.xml)
            View the corresponding CSS file (cd_catalog.txt)
            Display the CD catalog formatted with the CSS file
              (cd_catalog_with_css.xml)

            Examples explained (xml_display.asp)

                evince -p 787 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML and XSLT

            View an XML food menu (simple.xml)
            Display the food menu styled with an XSLT style sheet
              (simplexsl.xml)

            Examples explained (xml_xsl.asp)


            Parsing XML and the XML DOM

            View a simple XML file (note.xml) (note.xml)
            Parse the XML file - Crossbrowser example
              (tryit.asp?filename=tryxml_parsertest)
            Parse an XML string - Crossbrowser example
              (tryit.asp?filename=tryxml_parsertest2)

            Examples explained (xml_dom.asp)


            XML to HTML

            View an XML CD catalog (cd_catalog.xml)
            Display XML data in an HTML table
            (tryit.asp?filename=tryxml_display_table)
            Examples explained (xml_to_html.asp)


            XML Applications

            View an XML CD catalog (cd_catalog.xml)
            Show XML data inside an HTML div element
            (tryit.asp?filename=tryxml_app_first)
            XML DOM Advanced
            XML in Real Life
            (tryit.asp?filename=tryxml_app_navigate)
            A simple CD catalog application
            (tryit.asp?filename=tryxml_app)

            Examples explained (xml_applications.asp)


            XML Output From a Server

            See how ASP can return XML (note.asp)
            See how PHP can return XML (note.php)

                evince -p 788 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            View XML output from a database (guestbook.asp)

            Examples explained (xml_server.asp)


            XML DOM Advanced

            Get the value of an XML element
            (tryit.asp?filename=tryxml_dom_getelement)
            Get the value of an XML attribute
            (tryit.asp?filename=tryxml_dom_getattribute)
            Change the value of an XML element
            (tryit.asp?filename=tryxml_dom_changeelement)
            Add a new attribute to an XML element
            (tryit.asp?filename=tryxml_dom_addattribute)
            Create a new XML element
            (tryit.asp?filename=tryxml_dom_createelement)
            Remove an XML element
            (tryit.asp?filename=tryxml_dom_removeelement)

            Examples explained (xml_dom_advanced.asp)

                evince -p 793 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XML Quiz

            You can test your XML skills with W3Schools' Quiz.


            The Test

            The test contains 20 questions and there is no time limit.


            XML Quiz

            The test is not official, it's just a nice way to see how much you
            know, or don't know, about XML.


              Count Your Score
              You will get 1 point for each correct answer. At the end of the
              Quiz, your total score will be displayed. Maximum score is 20
              points.
              Good luck! Start the XML Quiz (/quiztest
              /quiztest.asp?qtest=XML)

              (/cert/default.asp)

              W3Schools'
              Online
              Certification

                evince -p 794 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The perfect solution for professionals who need to balance

            work, family, and career building.
            More than 10 000 certificates already issued!
            Get Your Certificate » (/cert/default.asp)

            The HTML Certificate (/cert/default.asp) documents your
            knowledge of HTML.
            The HTML5 Certificate (/cert/default.asp) documents your
            knowledge of advanced HTML5.
            The CSS Certificate (/cert/default.asp) documents your
            knowledge of advanced CSS.
            The JavaScript Certificate (/cert/default.asp) documents your
            knowledge of JavaScript and HTML DOM.
            The jQuery Certificate (/cert/default.asp) documents your
            knowledge of jQuery.
            The PHP Certificate (/cert/default.asp) documents your
            knowledge of PHP and SQL (MySQL).
            The XML Certificate (/cert/default.asp) documents your
            knowledge of XML, XML DOM and XSLT.

                evince -p 798 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            XQuery FLWOR Expressions

            How to Select Nodes From "books.xml" With FLWOR

            Look at the following path expression:

            doc("books.xml")/bookstore/book[price>30]/title

            The expression above will select all the title elements under
            the book elements that are under the bookstore element that
            have a price element with a value that is higher than 30.

            The following FLWOR expression will select exactly the same
            as the path expression above:

            for $x in doc("books.xml")/bookstore/book
            where $x/price>30
            return $x/title

                evince -p 799 ~/Empire/Doks/Comp/lang/xml/xml-w3schools.pdf &

            The result will be:

            <title lang="en">XQuery Kick Start</title>
            <title lang="en">Learning XML</title>

            With FLWOR you can sort the result:

            for $x in doc("books.xml")/bookstore/book
            where $x/price>30
            order by $x/title
            return $x/title

            FLWOR is an acronym for "For, Let, Where, Order by, Return".

            The for clause selects all book elements under the bookstore
            element into a variable called $x.

            The where clause selects only book elements with a price
            element with a value greater than 30.

            The order by clause defines the sort-order. Will be sort by
            the title element.

            The return clause specifies what should be returned. Here it
            returns the title elements.

            The result of the XQuery expression above will be:

            <title lang="en">Learning XML</title>
            <title lang="en">XQuery Kick Start</title>
# ~/Dropbox/rsc/Doks/phone/Comp/lang/xml/p_xmlwhite.txt

~/Empire/Doks/Comp/lang/xml/xml-tutorial_02.pdf
        TODO =INCLUDE
~/Dropbox/rsc/data/lists/learnqna/vanki/xml1.va.txt
~/Dropbox/rsc/Doks/phone/Comp/lang/xml/p_xmlwhite.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/pinkjuice-vimxml.txt
~/Dropbox/rsc/Doks/Comp/xml-w3schools.txt
~/Dropbox/rsc/aubooks/comp/vimxmled-pinkjuice.txt

