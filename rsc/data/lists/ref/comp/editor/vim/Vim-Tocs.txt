vim:fdm=indent:fdl=2:
set fdm=indent fdl=2
___zzzz

[TODO: =REFMAN COMPLETE TO 'CHECKABLE REFLIST(??)(****)']

~/Dropbox/Udt/rsc/data/lists/Tagged/vimscr-ibmtuts.Tags1.txt
                            - cutoff version for document
                                7.2 or higher
                            - vim: get version
                                vim --version, :version
                            - 'vim offers an integrated debugger' (??)
                            - :h vim-script-intro
                            - save a backup of current file  :call MyBackupFunc(expand('%'), {'all':1, 'save':'recent'})  (=sourcing files / calling functions)
                            - mapping  :nmap \b :call MyBackupFunc(expand('%'), { 'all': 1 })<CR>
~/Dropbox/Udt/rsc/data/lists/Tagged/vdocs-Usr41.Tags1.txt
                        .
                                ~/Dropbox/rsc/Doks/phone/Comp/editor/vim/Man2021plus-01uman.usr41.txt
                                ~/Dropbox/rsc/Doks/phone/Comp/editor/vim/z_vdocs-Usr41.txt
                                ~/Dropbox/rsc/Doks/phone/Comp/editor/vim/z_vdocs-Eval.txt
                                ~/Dropbox/rsc/Doks/phone/Comp/editor/vim/Man2021plus-02refman.eval.txt
~/Dropbox/Udt/rsc/data/lists/Tagged/lvimscrhard.Tags2.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/vdocs-aucmds.txt
  ~/Dropbox/rsc/Doks/phone/Comp/editor/vim/zzz_autocmd.txt
  ~/Dropbox/rsc/Doks/phone/Comp/editor/vim/vdocs_0autocmd-vim.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/vimhack.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/viml-prim.txt

~/Dropbox/rsc/Doks/phone/Comp/editor/vim/neovimLua.Tags1.txt
+ 1 dok

        ~/Dropbox/rsc/Doks/phone/Comp/editor/vim/vimlikepro.txt
 ~/Empire/Doks/Comp/editor/vim/vimtips.pdf
 ~/Dropbox/rsc/Doks/phone/Comp/editor/vim/zz_vimtips_2REF-CHECKLIST.txt
   ~/Empire/Doks/Comp/editor/vim/vimantecknOLD.pdf
 ~/Dropbox/rsc/Doks/phone/Comp/editor/vim/zz_vim-powofg.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/z_vdocs-pattern.txt
--
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/practvim.txt
~/Empire/Doks/Comp/editor/vim/PRACTICAL_VIM.pdf
            Read Me
            Read the Forgotten Manual
            1 -  The Vim Way ----
            Tip 1. Meet the Dot Command
            Tip 2. Don't Repeat Yourself
            Tip 3. Take One Step Back, Then Three Forward
            Tip 4. Act, Repeat, Reverse
            Tip 5. Find and Replace by Hand
            Tip 6. Meet the Dot Formula
            ==== Part I - Modes ====
            2 - Normal Mode ----
            Tip 7. Pause with Your Brush Off the Page
            Tip 8. Chunk Your Undos
            Tip 9. Compose Repeatable Changes
            Tip 10. Use Counts to Do Simple Arithmetic
            Tip 11. Don't Count If You Can Repeat
            Tip 12. Combine and Conquer
            3 - Insert Mode ----
            Tip 13. Make Corrections Instantly from Insert Mode
            Tip 14. Get Back to Normal Mode
            Tip 15. Paste from a Register Without Leaving Insert Mode
            Tip 16. Do Back-of-the-Envelope Calculations in Place
            Tip 17. Insert Unusual Characters by Character Code
            Tip 18. Insert Unusual Characters by Digraph
            Tip 19. Overwrite Existing Text with Replace Mode
            4 - Visual Mode ----
            Tip 20. Grok Visual Mode
            Tip 21. Define a Visual Selection
            Tip 22. Repeat Line-Wise Visual Commands
            Tip 23. Prefer Operators to Visual Commands Where Possible
            Tip 24. Edit Tabular Data with Visual-Block Mode
            Tip 25. Change Columns of Text
            Tip 26. Append After a Ragged Visual Block
            5 - Command-Line Mode ----
            Tip 27. Meet Vim's Command Line
            Tip 28. Execute a Command on One or More Consecutive Lines
            Tip 29. Duplicate or Move Lines Using ':t' and ':m' Commands
            Tip 30. Run Normal Mode Commands Across a Range
            Tip 31. Repeat the Last Ex Command
            Tip 32. Tab-Complete Your Ex Commands
            Tip 33. Insert the Current Word at the Command Prompt
            Tip 34. Recall Commands from History
            Tip 35. Run Commands in the Shell
            ==== Part II - Files ====
            6 - Manage Multiple Files ----
            Tip 36. Track Open Files with the Buffer List
            Tip 37. Group Buffers into a Collection with the Argument List
            Tip 38. Manage Hidden Files
            Tip 39. Divide Your Workspace into Split Windows
            Tip 40. Organize Your Window Layouts with Tab Pages
            7 - Open Files and Save Them to Disk ----
            Tip 41. Open a File by Its Filepath Using ':edit'
            Tip 42. Open a File by Its Filename Using ':find'
            Tip 43. Explore the File System with netrw
            Tip 44. Save Files to Nonexistent Directories
            Tip 45. Save a File as the Super User
            ==== Part III - Getting Around Faster ====
            8.  Navigate Inside Files with Motions
            Tip 46. Keep Your Fingers on the Home Row
            Tip 47. Distinguish Between Real Lines and Display Lines
            Tip 48. Move Word-Wise
            Tip 49. Find by Character
            Tip 50. Search to Navigate
            Tip 51. Trace Your Selection with Precision Text Objects
            Tip 52. Delete Around, or Change Inside
            Tip 53. Mark Your Place and Snap Back to It
            Tip 54. Jump Between Matching Parentheses
            9 - Navigate Between Files with Jumps ----
            Tip 55. Traverse the Jump List
            Tip 56. Traverse the Change List
            Tip 57. Jump to the Filename Under the Cursor
            Tip 58. Snap Between Files Using Global Marks
            ==== Part IV - Registers ====
            10 - Copy and Paste ----
            Tip 59. Delete, Yank, and Put with Vim's Unnamed Register
            Tip 60. Grok Vim's Registers
            Tip 61. Replace a Visual Selection with a Register
            Tip 62. Paste from a Register
            Tip 63. Interact with the System Clipboard
            11 - Macros ----
            Tip 64. Record and Execute a Macro
            Tip 65. Normalize, Strike, Abort
            Tip 66. Play Back with a Count
            Tip 67. Repeat a Change on Contiguous Lines
            Tip 68. Append Commands to a Macro
            Tip 69. Act Upon a Collection of Files
            Tip 70. Evaluate an Iterator to Number Items in a List
            Tip 71. Edit the Contents of a Macro
            ==== Part V - Patterns ====
            12 - Matching Patterns and Literals ----
            Tip 72. Tune the Case Sensitivity of Search Patterns
            Tip 73. Use the \v Pattern Switch for Regex Searches
            Tip 74. Use the \V Literal Switch for Verbatim Searches
            Tip 75. Use Parentheses to Capture Submatches
            Tip 76. Stake the Boundaries of a Word
            Tip 77. Stake the Boundaries of a Match
            Tip 78. Escape Problem Characters
            13 - Search ----
            Tip 79. Meet the Search Command
            Tip 80. Highlight Search Matches
            Tip 81. Preview the First Match Before Execution
            Tip 82. Count the Matches for the Current Pattern
            Tip 83. Offset the Cursor to the End of a Search Match
            Tip 84. Operate on a Complete Search Match
            Tip 85. Create Complex Patterns by Iterating upon Search History
            Tip 86. Search for the Current Visual Selection
            14 - Substitution ----
            Tip 87. Meet the Substitute Command
            Tip 88. Find and Replace Every Match in a File
            Tip 89. Eyeball Each Substitution
            Tip 90. Reuse the Last Search Pattern
            Tip 91. Replace with the Contents of a Register
            Tip 92. Repeat the Previous Substitute Command
            Tip 93. Rearrange CSV Fields Using Submatches
            Tip 94. Perform Arithmetic on the Replacement
            Tip 95. Swap Two or More Words
            Tip 96. Find and Replace Across Multiple Files
            15 - Global Commands ----
            Tip 97. Meet the Global Command
            Tip 98. Delete Lines Containing a Pattern
            Tip 99. Collect TODO Items in a Register
            Tip 100. Alphabetize the Properties of Each Rule in a CSS File
            ==== Part VI - Tools ====
            16 - Index and Navigate Source Code with ctags ----
            Tip 101. Meet ctags
            Tip 102. Configure Vim to Work with ctags
            Tip 103. Navigate Keyword Definitions with Vim's Tag Navigation Commands
            17 - Compile Code and Navigate Errors with the Quickfix List ----
            Tip 104. Compile Code Without Leaving Vim
            Tip 105. Browse the Quickfix List
            Tip 106. Recall Results from a Previous Quickfix List
            Tip 107. Customize the External Compiler
            18 - Search Project-Wide with grep, vimgrep, and Others ----
            Tip 108. Call grep Without Leaving Vim
            Tip 109. Customize the grep Program
            Tip 110. Grep with Vim's Internal Search Engine
            19 - Dial X for Autocompletion ----
            Tip 111. Meet Vim's Keyword Autocompletion
            Tip 112. Work with the Autocomplete Pop-Up Menu
            Tip 113. Understand the Source of Keywords
            Tip 114. Autocomplete Words from the Dictionary
            Tip 115. Autocomplete Entire Lines
            Tip 116. Autocomplete Filenames
            Tip 117. Autocomplete with Context Awareness
            20 - Find and Fix Typos with Vim's Spell Checker ----
            Tip 118. Spell Check Your Work
            Tip 119. Use Alternate Spelling Dictionaries
            Tip 120. Add Words to the Spell File
            Tip 121. Fix Spelling Errors from Insert Mode
            21 - Now What? ----
            21.1 Keep Practicing!
            21.2 Make Vim Your Own
            21.3 Know the Saw, Then Sharpen It
            A1 - Customize Vim to Suit Your Preferences ----
            A1.1 Change Vim's Settings on the Fly
            A1.2 Save Your Configuration in a vimrc File
            A1.3 Apply Customizations to Certain Types of Files
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/modvim.txt
            1 - Get Modern Vim ----
            Tip 1.  Installing Vim 8
            Tip 2.  Switching to Neovim
            Tip 3.  Enabling Python Support in Neovim
            2 - Installing Plugins ----
            Tip 4.  Understanding Scripts, Plugins, and Packages
            Tip 5.  Installing Plugins to Your Package
            Tip 6.  Managing Plugins with minpac
            3 - Opening Files ----
            Tip 7.  Finding Files Using Fuzzy Path Matching
            Tip 8.  Finding Files Semantically
            Tip 9.  Jumping to an Alternate File
            4 - Working with the Quickfix List ----
            Tip 10.  Running a Build and Navigating Failures
            Tip 11.  Switching Compilers
            Tip 12.  Linting the Current File
            Tip 13.  Searching Files with Grep-Alikes
            Tip 14.  Running Tests and Browsing Failures
            5 - Neovim's Built-In Terminal Emulator ----
            Tip 15.  Grokking Terminal Mode
            Tip 16.  Running Programs in a Terminal Buffer
            Tip 17.  Managing Windows That Contain Terminal Buffers
            Tip 18.  Using Normal Mode Commands in a Terminal Buffer
            Tip 19.  Sending Commands to a Terminal Buffer
            Tip 20.  Applying Customizations to Your Shell in a Terminal Buffer
            Tip 21.  Avoiding Nested Neovim Instances
            Tip 22.  Using an Existing nvim Instance as the Preferred Editor
            6 - Sessions ----
            Tip 23.  Saving and Restoring Sessions
            Tip 24.  Making Undo Persist Between Sessions
            Tip 25.  Restarting Terminal Processes When Resuming a Session
            7 - Configuring Vim ----
            Tip 26.  Using Autocommands to Respond to Events
            Tip 27.  Respecting Project Conventions
            Tip 28.  Setting Buffer-Local Configuration Per Project
            A1 - What's Next for Modern Vim? ----
            Integrating with the Language Server Protocol
            What's Next for Vim 8
            What's Next for Neovim
  ~/Dropbox/rsc/Doks/phone/Comp/editor/vim/vimmast-idenvim.txt
  --
  ~/Dropbox/rsc/Doks/phone/Comp/editor/vim/version8.txt

~/Dropbox/rsc/Doks/phone/Comp/editor/vim/pinkjuice-vimxml.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/z_emmet-vim.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/v-bashsupport-shortkeys.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/vdocs-bashsupport.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/zz_vimoutliner.txt

~/Dropbox/rsc/Doks/phone/Comp/editor/vim/lvimscrhard.Tags1.txt
  ~/Dropbox/rsc/Doks/phone/Comp/editor/vim/lvimscrhard.txt
~/Empire/Doks/Comp/editor/vim/lvimscrhard.pdf
~/Empire/Doks/Comp/editor/vim/lvimscrhard.txt
~/Empire/Doks/Comp/editor/vim/lvimscrhard_def20.txt
            Acknowledgements
            Prerequisites
            Creating a Vimrc File  
            1 - Echoing Messages ----
            1.1 Persistent Echoing  
            1.2 Comments  
            1.3 Exercises  
            2 - Setting Options ----
            2.1 Boolean Options  
            2.2 Toggling Boolean Options  
            2.3 Checking Options  
            2.4 Options with Values  
            2.5 Setting Multiple Options at Once  
            2.6 Exercises  
            3 - Basic Mapping ----
            3.1 Special Characters  
            3.2 Commenting  
            3.3 Exercises  
            4 - Modal Mapping ----
            4.1 Muscle Memory  
            4.2 Insert Mode  
            4.3 Exercises  
            5 - Strict Mapping ----
            5.1 Recursion  
            5.2 Side Effects  
            5.3 Nonrecursive Mapping  
            5.4 Exercises  
            6 - Leaders ----
            6.1 Mapping Key Sequences  
            6.2 Leader  
            6.3 Local Leader  
            6.4 Exercises  
            7 - Editing Your Vimrc ----
            7.1 Editing Mapping  
            7.2 Sourcing Mapping  
            7.3 Exercises  
            8 - Abbreviations ----
            8.1 Keyword Characters  
            8.2 More Abbreviations  
            8.3 Why Not Use Mappings?  
            8.4 Exercises  
            9 - More Mappings ----
            9.1 A More Complicated Mapping  
            9.2 Exercises  
            10 - Training Your Fingers ----
            10.1 Learning the Map  
            10.2 Exercises  
            11 - Buffer-Local Options and Mappings ----
            11.1 Mappings  
            11.2 Local Leader  
            11.3 Settings  
            11.4 Shadowing  
            11.5 Exercises  
            12 - Autocommands ----
            12.1 Autocommand Structure  
            12.2 Another Example  
            12.3 Multiple Events  
            12.4 FileType Events  
            12.5 Exercises  
            13 - Buffer-Local Abbreviations ----
            13.1 Autocommands and Abbreviations  
            13.2 Exercises  
            14 - Autocommand Groups ----
            14.1 The Problem  
            14.2 Grouping Autocommands  
            14.3 Clearing Groups  
            14.4 Using Autocommands in Your Vimrc  
            14.5 Exercises  
            15 - Operator-Pending Mappings ----
            15.1 Movement Mappings  
            15.2 Changing the Start  
            15.3 General Rules  
            15.4 Exercises  
            16 - More Operator-Pending Mappings ----
            16.1 Normal  
            16.2 Execute  
            16.3 Results  
            16.4 Exercises  
            17 - Status Lines ----
            17.1 Width and Padding  
            17.2 General Format  
            17.3 Splitting  
            17.4 Exercises  
            18 - Responsible Coding ----
            18.1 Commenting  
            18.2 Grouping  
            18.3 Short Names  
            18.4 Exercises  
            19 - Variables ----
            19.1 Options as Variables  
            19.2 Local Options  
            19.3 Registers as Variables  
            19.4 Exercises  
            20 - Variable Scoping ----
            20.1 Exercises  
            21 - Conditionals ----
            21.1 Multiple-Line Statements  
            21.2 Basic If  
            21.3 Else and Elseif  
            21.4 Exercises  
            22 - Comparisons ----
            22.1 Case Sensitivity  
            22.2 Code Defensively  
            22.3 Exercises  
            23 - Functions ----
            23.1 Calling Functions  
            23.2 Implicit Returning  
            23.3 Exercises  
            24 - Function Arguments ----
            24.1 Varargs  
            24.2 Assignment  
            24.3 Exercises  
            25 - Numbers ----
            25.1 Number Formats  
            25.2 Float Formats  
            25.3 Coercion  
            25.4 Division  
            25.5 Exercises  
            26 - Strings ----
            26.1 Concatenation  
            26.2 Special Characters  
            26.3 Literal Strings  
            26.4 Truthiness  
            26.5 Exercises  
            27 - String Functions ----
            27.1 Length  
            27.2 Splitting  
            27.3 Joining  
            27.4 Lower and Upper Case  
            27.5 Exercises  
            28 - Execute ----
            28.1 Basic Execution  
            28.2 Is Execute Dangerous?  
            28.3 Exercises  
            29 - Normal ----
            29.1 Avoiding Mappings  
            29.2 Special Characters  
            29.3 Exercises  
            29.4 Extra Credit  
            30 - Execute Normal! ----
            30.1 Exercises  
            31 - Basic Regular Expressions ----
            31.1 Highlighting  
            31.2 Searching  
            31.3 Magic  
            31.4 Literal Strings  
            31.5 Very Magic  
            31.6 Exercises  
            32 - Case Study: Grep Operator, Part One ----
            32.1 Grep  
            32.2 Usage  
            32.3 A Preliminary Sketch  
            32.4 The Search Term  
            32.5 Escaping Shell Command Arguments  
            32.6 Cleanup  
            32.7 Exercises  
            33 - Case Study: Grep Operator, Part Two ----
            33.1 Create a File  
            33.2 Skeleton  
            33.3 Visual Mode  
            33.4 Motion Types  
            33.5 Copying the Text  
            33.6 Escaping the Search Term  
            33.7 Running Grep  
            33.8 Exercises  
            34 - Case Study: Grep Operator, Part Three ----
            34.1 Saving Registers  
            34.2 Namespacing  
            34.3 Exercises  
            35 - Lists ----
            35.1 Indexing  
            35.2 Slicing  
            35.3 Concatenation  
            35.4 List Functions  
            35.5 Exercises  
            36 - Looping ----
            36.1 For Loops  100
            36.2 While Loops  100
            36.3 Exercises  101
            37 - Dictionaries ----
            37.1 Indexing  102
            37.2 Assigning and Adding  103
            37.3 Removing Entries  103
            37.4 Dictionary Functions  104
            37.5 Exercises  104
            38 - Toggling ----
            38.1 Toggling Options  105
            38.2 Toggling Other Things  106
            38.3 Improvements  107
            38.4 Restoring Windows/Buffers  108
            38.5 Exercises  109
            39 - Functional Programming ----
            39.1 Immutable Data Structures  110
            39.2 Functions as Variables  111
            39.3 Higher-Order Functions  112
            39.4 Performance  113
            39.5 Exercises  114
            40 - Paths ----
            40.1 Absolute Paths  115
            40.2 Listing Files  115
            40.3 Exercises  116
            41 - Creating a Full Plugin ----
            41.1 Potion  117
            41.2 Exercises  117
            42 - Plugin Layout in the Dark Ages ----
            42.1 Basic Layout  119
            42.2 ∼/.vim/colors/  119
            42.3 ∼/.vim/plugin/  119
            42.4 ∼/.vim/ftdetect/  119
            42.5 ∼/.vim/ftplugin/  120
            42.6 ∼/.vim/indent/  120
            42.7 ∼/.vim/compiler/  120
            42.8 ∼/.vim/after/  120
            42.9 ∼/.vim/autoload/  121
            42.10 ∼/.vim/doc/  121
            42.11 Exercises  121
            43 - A New Hope: Plugin Layout with Pathogen ----
            43.1 Runtimepath  122
            43.2 Pathogen  123
            43.3 Being Pathogen-Compatible  123
            43.4 Exercises  124
            44 - Detecting Filetypes ----
            44.1 Detecting Potion Files  125
            44.2 Exercises  126
            45 - Basic Syntax Highlighting ----
            45.1 Highlighting Keywords  127
            45.2 Highlighting Functions  128
            45.3 Exercises  129
            46 - Advanced Syntax Highlighting ----
            46.1 Highlighting Comments  130
            46.2 Highlighting Operators  131
            46.3 Exercises  132
            47 - Even More Advanced Syntax Highlighting ----
            47.1 Highlighting Strings  133
            47.2 Exercises  134
            48 - Basic Folding ----
            48.1 Types of Folding  135
            48.2 Potion Folding  136
            48.3 Exercises  137
            49 - Advanced Folding ----
            49.1 Folding Theory  139
            49.2 First: Make a Plan  140
            49.3 Getting Started  141
            49.4 Expr Folding  141
            49.5 Blank Lines  142
            49.6 Special Foldlevels  143
            49.7 An Indentation Level Helper  143
            49.8 One More Helper  144
            49.9 Finishing the Fold Function  145
            49.10 Review  150
            49.11 Exercises  153
            50 - Section Movement Theory ----
            50.1 Nroff Files  154
            50.2 Braces  155
            50.3 Exercises  156
            51 - Potion Section Movement ----
            51.1 Custom Mappings  158
            51.2 Using a Function  158
            51.3 Base Movement  159
            51.4 Top Level Text Sections  160
            51.5 Search Flags  161
            51.6 Function Definitions  162
            51.7 Visual Mode  162
            51.8 Why Bother?  164
            51.9 Exercises  165
            52 - External Commands ----
            52.1 Compiling  166
            52.2 Bang!  167
            52.3 Displaying Bytecode  168
            52.4 system()  169
            52.5 Scratch Splits  170
            52.6 Exercises  172
            52.7 Extra Credit  172
            52.8 More Extra Credit  172
            53 - Autoloading ----
            53.1 How Autoload Works  173
            53.2 Experimenting  174
            53.3 What to Autoload  175
            53.4 Adding Autoloading to the Potion Plugin  176
            53.5 Exercises  178
            54 - Documentation ----
            54.1 How Documentation Works  179
            54.2 Help Header  179
            54.3 What to Document  180
            54.4 Table of Contents  181
            54.5 Sections  182
            54.6 Examples  183
            54.7 Write!  183
            54.8 Exercises  184
            55 - Distribution ----
            55.1 Hosting  186
            55.2 Documentation  186
            55.3 Publicity  187
            55.4 Exercises  187
            56 - What Now? ----
            56.1 Color Schemes  188
            56.2 The Command Command  188
            56.3 runtimepath  188
            56.4 Omnicomplete  189
            56.5 Compiler Support  189
            56.6 Other Languages  189
            56.7 Vim's Documentation  190
            56.8 Exercises  190
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/vimscr-ibmtuts.txt
        TODO: INPUT INDEXES(!!!!)
            TODO(??(!!)):
            - Split down end-of-line "-comments to own lines(***(!!(!)))
            - Convert double spaces(##) to one space

                https://developer.ibm.com/articles/l-vim-script-1/

            Scripting the Vim editor, Part 1: Variables, values, and expressions
            Start with the basic elements of Vimscript

            By Damian Conway
            Published May 6, 2009

              About Vimscript and this series

              Vimscript is a powerful scripting
              language that lets you modify and
              extend the Vim editor. You can
              use it to create new tools,
              simplify common tasks, and even
              rework existing features of the
              editor. This ongoing series of
              articles assumes some familiarity
              with the Vim editor.

            A great text editor

            There's an old joke that Emacs
            would be a great operating system
            if only it had a decent text
            editor, whereas vi would be a great
            text editor if only it had a decent
            operating system. This gag reflects
            the single greatest strategic
            advantage that Emacs has always had
            over vi: an embedded extension
            programming language. Indeed, the
            fact that Emacs users are happy to
            put up with RSI-inducing control
            chords and are willing to write
            their extensions in Lisp shows just
            how great an advantage a built-in
            extension language must be.

            But vi programmers no longer need
            cast envious glances towards Emacs'
            parenthetical scripting language.
            Our favorite editor can be scripted
            too - and much more humanely than
            Emacs.

            In this series of articles, we'll
            look at the most popular modern
            variant of vi, the Vim editor, and
            at the simple yet extremely
            powerful scripting language that
            Vim provides. This first article
            explores the basic building blocks
            of Vim scripting: variables,
            values, expressions, simple flow
            control, and a few of Vim's
            numerous utility functions.

            I'll assume that you already have
            access to Vim and are familiar with
            its interactive features. If that's
            not the case, some good starting
            points are Vim's own Web site and
            various online resources and
            hardcopy books, or you can simply
            type :help inside Vim itself.

            Unless otherwise indicated, all the
            examples in this series of articles
            assume you're using Vim version 7.2
            or higher. You can check which
            version of Vim you're using by
            invoking the editor like so:

            vim --version

            or by typing :version within Vim
            itself. If you're using an older
            incarnation of Vim, upgrading to
            the latest release is strongly
            recommended, as previous versions
            do not support many of the features
            of Vimscript that we'll be
            exploring.


            Vimscript

            Vim's scripting language, known as
            Vimscript, is a typical dynamic
            imperative language and offers most
            of the usual language features:
            variables, expressions, control
            structures, built-in functions,
            user-defined functions, first-class
            strings, high-level data structures
            (lists and dictionaries), terminal
            and file I/O, regex pattern
            matching, exceptions, and an
            integrated debugger.

            You can read Vim's own
            documentation of Vimscript via the
            built-in help system, by typing:

            :help vim-script-intro

            inside any Vim session. Or just
            read on.


            Running Vim scripts

            There are numerous ways to execute
            Vim scripting commands. The
            simplest approach is to put them in
            a file (typically with a .vim
            extension) and then execute the
            file by :source-ing it from within
            a Vim session:

            :source /full/path/to/the/scriptfile.vim

            Alternatively, you can type
            scripting commands directly on the
            Vim command line, after the colon.
            For example:

            :call MyBackupFunc(expand('%'), { 'all':1, 'save':'recent'})

            But very few people do that. After all, the whole point of scripting is to reduce the amount of typing you have to do. So the most common way to invoke Vim scripts is by creating new keyboard mappings, like so:

            :nmap ;s :source /full/path/to/the/scriptfile.vim<CR>
            :nmap \b :call MyBackupFunc(expand('%'), { 'all': 1 })<CR>

            Commands like these are usually
            placed in the .vimrc initialization
            file in your home directory.
            Thereafter, when you're in Normal
            mode (in other words, not inserting
            text), the key sequence ;s will
            execute the specified script file,
            and a \b sequence will call the
            MyBackupFunc() function (which you
            presumably defined somewhere in
            your .vimrc as well).

            All of the Vimscript examples in
            this article use key mappings of
            various types as triggers. In later
            articles, we'll explore two other
            common invocation techniques:
            running scripts as colon commands
            from Vim's command line, and using
            editor events to trigger scripts
            automatically.


            A syntactic example

            Vim has very sophisticated syntax
            highlighting facilities, which you
            can turn on with the built-in
            :syntax enable command, and off
            again with :syntax off.

            It's annoying to have to type ten
            or more characters every time you
            want to toggle syntax highlighting,
            though. Instead, you could place
            the following lines of Vimscript in
            your .vimrc file:

            Listing 1. Toggling syntax highlighting

            function! ToggleSyntax()
              if exists("g:syntax_on")
                syntax off
              else
                syntax enable
              endif
            endfunction

            nmap <silent> ;s :call ToggleSyntax()<CR>

            This causes the ;s sequence to flip
            syntax highlighting on or off each
            time it's typed when you're in
            Normal mode. Let's look at each
            component of that script.

            The first block of code is
            obviously a function declaration,
            defining a function named
            ToggleSyntax(), which takes no
            arguments. That user-defined
            function first calls a built-in Vim
            function named exists(), passing it
            a string. The exists() function
            determines whether a variable with
            the name specified by the string
            (in this case, the global variable
            g:syntax_on) has been defined.

            If so, the if statement executes a
            syntax off; otherwise it executes a
            syntax enable. Because syntax
            enable defines the g:syntax_on
            variable, and syntax off undefines
            it, calling the ToggleSyntax()
            function repeatedly alternates
            between enabling and disabling
            syntax highlighting.

            All that remains is to set up a key
            sequence (;s in this example) to
            call the ToggleSyntax() function:

            nmap <silent> ;s :call ToggleSyntax()<CR>

            nmap stands for "normal-mode key
            mapping." The <silent> option after
            the nmap causes the mapping not to
            echo any command it's executing,
            ensuring that the new ;s command
            will do its work unobtrusively.
            That work is to execute the
            command:

            :call ToggleSyntax()<CR>

            which is how you call a function in
            Vimscript when you intend to ignore
            the return value.

            Note that the <CR> at the end is
            the literal sequence of characters
            <,C,R,>. Vimscript recognizes this
            as being equivalent to a literal
            carriage return. In fact, Vimscript
            understands many other similar
            representations of unprintable
            characters. For example, you could
            create a keyboard mapping to make
            your space bar act like the
            page-down key (as it does in most
            Web browsers), like so:

            :nmap <Space> <PageDown>

            You can see the complete list of
            these special symbols by typing
            :help keycodes within Vim.


            Note too that ToggleSyntax() was
            able to call the built-in syntax
            command directly. That's because
            every built-in colon command in Vim
            is automatically also a statement
            in Vimscript. For example, to make
            it easier to create centered titles
            for documents written in Vim, you
            could create a function that
            capitalizes each word on the
            current line, centers the entire
            line, and then jumps to the next
            line, like so:

            Listing 2. Creating centered titles

            function! CapitalizeCenterAndMoveDown()
              s/\<./\u&/g   "Built‑in substitution capitalizes each word
              center        "Built‑in center command centers entire line
              +1            "Built‑in relative motion (+1 line down)
            endfunction

            nmap <silent>  \C  :call CapitalizeCenterAndMoveDown()<CR>


            Vimscript statements

            As the previous examples
            illustrate, all statements in
            Vimscript are terminated by a
            newline (as in shell scripts or
            Python). If you need to run a
            statement across multiple lines,
            the continuation marker is a single
            backslash. Unusually, the backslash
            doesn't go at the end of the line
            to be continued, but rather at the
            start of the continuation line:

            Listing 3. Continuing lines using backslash

            call SetName(
            \             first_name,
            \             middle_initial,
            \             family_name
            \           )

            You can also put two or more
            statements on a single line by
            separating them with a vertical
            bar:

            echo "Starting..." | call Phase(1) | call Phase(2) | echo "Done"

            That is, the vertical bar in
            Vimscript is equivalent to a
            semicolon in most other programming
            languages. Unfortunately, Vim
            couldn't use the semicolon, as that
            character already means something
            else at the start of a command
            (specifically, it means "from the
            current line to…" as part of the
            command's line range).


            Comments

            One important use of the vertical
            bar as a statement separator is in
            commenting. Vimscript comments
            start with a double-quote and
            continue to the end of the line,
            like so:

            Listing 4. Commenting in Vimscript

            if exists("g:syntax_on")
              syntax off      
            else
              syntax enable   
            endif

            Unfortunately, Vimscript strings
            can also start with a double-quote
            and always take precedence over
            comments. This means you can't put
            a comment anywhere that a string
            might be expected, because it will
            always be interpreted as a string:

            echo "> " "Print generic prompt

            The echo command expects one or
            more strings, so this line produces
            an error complaining about the
            missing closing quote on (what Vim
            assumes to be) the second string.

            Comments can, however, always
            appear at the very start of a
            statement, so you can fix the above
            problem by using a vertical bar to
            explicitly begin a new statement
            before starting the comment, like
            so:

            echo "> " |"Print generic prompt


            Values and variables

            Variable assignment in Vimscript
            requires a special keyword, let:

            Listing 5. Using the let keyword

            let name = "Damian"

            let height = 165

            let interests =  'Cinema', 'Literature', 'World Domination', 101 
            let phone     = { 'cell':5551017346, 'home':5558038728, 'work':'?' }

            Note that strings can be specified
            with either double-quotes or
            single-quotes as delimiters.
            Double-quoted strings honor special
            "escape sequences" such as "\n"
            (for newline), "\t" (for tab),
            "\u263A" (for Unicode smiley face),
            or "\<ESC>" (for the escape
            character). In contrast,
            single-quoted strings treat
            everything inside their delimiters
            as literal characters - except two
            consecutive single-quotes, which
            are treated as a literal
            single-quote.

            Values in Vimscript are typically
            one of the following three types:

            - scalar: a single value, such as a
              string or a number. For example:
              "Damian" or 165
            - list: an ordered sequence of
              values delimited by square
              brackets, with implicit integer
              indices starting at zero. For
              example: ['Cinema', 'Literature',
              'World Domination', 101]
            - dictionary: an unordered set of
              values delimited by braces, with
              explicit string keys. For
              example: {'cell':5551017346,
              'home':5558038728, 'work':'?'}

            Note that the values in a list or
            dictionary don't have to be all of
            the same type; you can mix strings,
            numbers, and even nested lists and
            dictionaries if you wish.

            Unlike values, variables have no
            inherent type. Instead, they take
            on the type of the first value
            assigned to them. So, in the
            preceding example, the name and
            height variables are now scalars
            (that is, they can henceforth store
            only strings or numbers), interests
            is now a list variable (that is, it
            can store only lists), and phone is
            now a dictionary variable (and can
            store only dictionaries). Variable
            types, once assigned, are permanent
            and strictly enforced at runtime:

            let interests = 'unknown' " Error: variable type mismatch

            By default, a variable is scoped to
            the function in which it is first
            assigned to, or is global if its
            first assignment occurs outside any
            function. However, variables may
            also be explicitly declared as
            belonging to other scopes, using a
            variety of prefixes, as summarized
            in Table 1.

            Table 1. Vimscript variable scoping

            Prefix
            Meaning

            g: varname 
                The variable is global

            s: varname 
                The variable is local to the
                current script file

            w: varname 
                The variable is local to the
                current editor window

            t: varname 
                The variable is local to the
                current editor tab

            b: varname 
                The variable is local to the
                current editor buffer

            l: varname 
                The variable is local to the
                current function

            a: varname 
                The variable is a parameter of
                the current function

            v: varname 
                The variable is one that Vim
                predefines

            There are also pseudovariables that
            scripts can use to access the other
            types of value containers that Vim
            provides. These are summarized in
            Table 2.

            Table 2. Vimscript pseudovariables

            Prefix
            Meaning

            & varname 
                A Vim option (local option if
                defined, otherwise global)

            &l: varname 
                A local Vim option

            &g: varname 
                A global Vim option

            @ varname 
                A Vim register

            $ varname 
                An environment variable

            The "option" pseudovariables can be
            particularly useful. For example,
            you could set up two key-maps to
            increase or decrease the current
            tabspacing like so:

            nmap <silent> ]] :let &tabstop += 1<CR>
            nmap <silent> [[ :let &tabstop -= &tabstop > 1 ? 1 : 0<CR>


            Expressions

            Note that the [[ key-mapping in the
            previous example uses an expression
            containing a C-like "ternary
            expression":

            &tabstop > 1 ? 1 : 0

            This prevents the key map from
            decrementing the current tab
            spacing below the sane minimum of
            1. As this example suggests,
            expressions in Vimscript are
            composed of the same basic
            operators that are used in most
            other modern scripting languages,
            and with generally the same syntax.
            The available operators (grouped by
            increasing precedence) are
            summarized in Table 3.

            Table 3. Vimscript operator precedence table

            Operation
            Operator syntax

            Assignment
                let var = expr
            Numeric-add-and-assign
                let var += expr
            Numeric-subtract-and-assign
                let var -= expr
            String-concatenate-and-assign
                let var .= expr

            Ternary operator
                bool ? expr-if-true : expr-if-false

            Logical OR
                bool || bool

            Logical AND
                bool && bool

            Numeric or string equality
                expr==expr
            Numeric or string inequality
                expr!=expr
            Numeric or string greater-then
                expr>expr
            Numeric or string greater-or-equal
                expr>=expr
            Numeric or string less than
                expr<expr
            Numeric or string less-or-equal
                expr<=expr

            Numeric addition
                num+num
            Numeric subtraction
                num-num
            String concatenation
                str.str

            Numeric multiplication
                num*num
            Numeric division
                num/num
            Numeric modulus
                num%num

            Convert to number
                +num
            Numeric negation
                -num
            Logical NOT
                !bool

            Parenthetical precedence
                (expr)


            Logical caveats

            In Vimscript, as in C, only the
            numeric value zero is false in a
            boolean context; any non-zero
            numeric value - whether positive or
            negative - is considered true.
            However, all the logical and
            comparison operators consistently
            return the value 1 for true.

            When a string is used as a boolean,
            it is first converted to an
            integer, and then evaluated for
            truth (non-zero) or falsehood
            (zero). This implies that the vast
            majority of strings - including
            most non-empty strings - will
            evaluate as being false. A typical
            mistake is to test for an empty
            string like so:

            Listing 6. Flawed test for empty string

            let result_string = GetResult();

            if !result_string
              echo "No result"
            endif

            The problem is that, although this
            does work correctly when
            result_string is assigned an empty
            string, it also indicates "No
            result" if result_string contains a
            string like "I am NOT an empty
            string", because that string is
            first converted to a number (zero)
            and then to a boolean (false).

            The correct solution is to
            explicitly test strings for
            emptiness using the appropriate
            built-in function:

            Listing 7. Correct test for empty string

            if empty(result_string)
              echo "No result"
            endif


            Comparator caveats

            In Vimscript, comparators always
            perform numeric comparison, unless
            both operands are strings. In
            particular, if one operand is a
            string and the other a number, the
            string will be converted to a
            number and the two operands then
            compared numerically. This can lead
            to subtle errors:

            let ident = 'Vim'

            if ident == 0 "Always true (string 'Vim' converted to number 0)

            A more robust solution in such
            cases is:

            if ident == '0'
              "Uses string equality if ident
               contains string"but numeric
               equality if ident contains number

            String comparisons normally honor
            the local setting of Vim's
            ignorecase option, but any string
            comparator can also be explicitly
            marked as case-sensitive (by
            appending a #) or case-insensitive
            (by appending a ?):

            Listing 8. Casing string comparators

            if name ==? 'Batman'         |"Equality always case insensitive
              echo "I'm Batman"
            elseif name <#'ee cummings' |"Less‑than always case sensitive
              echo "the sky was can dy lu minous"
            endif

            Using the "explicitly cased"
            operators for all string
            comparisons is strongly
            recommended, because they ensure
            that scripts behave reliably
            regardless of variations in the
            user's option settings.


            Arithmetic caveats

            When using arithmetic expressions,
            it's also important to remember
            that, until version 7.2, Vim
            supported only integer arithmetic.
            A common mistake under earlier
            versions was writing something
            like:

            Listing 9. Problem with integer arithmetic

            "Step through each file...
            for filenum in range(filecount)
              " Show progress...
              echo (filenum / filecount ∗ 100) . '% done'" Make progress...
              call process_file(filenum)
            endfor

            Because filenum will always be less
            than filecount, the integer
            division filenum/filecount will
            always produce zero, so each
            iteration of the loop will echo:

            Now 0% done

            Even under version 7.2, Vim does
            only floating-point arithmetic if
            one of the operands is explicitly
            floating-point:

            let filecount = 234

            echo filecount/100   |" echoes 2
            echo filecount/100.0 |" echoes 2.34


            Another toggling example

            It's easy to adapt the
            syntax-toggling script shown
            earlier to create other useful
            tools. For example, if there is a
            set of words that you frequently
            misspell or misapply, you could add
            a script to your .vimrc to activate
            Vim's match mechanism and highlight
            problematic words when you're
            proofreading text.

            For example, you could create a
            key-mapping (say: ;p) that causes
            text like the previous paragraph to
            be displayed within Vim like so:

            "It's easy to adapt the
            syntax-toggling script shown
            earlier to create other useful
            tools. For example, if there is a
            set of words that you frequently
            misspell or misapply, you could add
            a script to your .vimrc to activate
            Vim's match mechanism and highlight
            problematic words when you're
            proofreading text."

            That script might look like this:

            Listing 10. Highlighting frequently misused words

            "Create a text highlighting style that always stands out...
            highlight STANDOUT term=bold cterm=bold gui=bold

            "List of troublesome words...
            let s:words = 
                         \ "it's",  "its",
                         \ "your",  "you're",
                         \ "were",  "we're",   "where",
                         \ "their", "they're", "there",
                         \ "to",    "too",     "two"
                         \ 
            "Build a Vim command to match troublesome words...
            let s:words_matcher
            \ = 'match STANDOUT /\c\<\(' . join(s:words, '\|') . '\)\>/'

            "Toggle word checking on or off...
            function! WordCheck ()
              "Toggle the flag (or set it if it doesn't yet exist)...
              let w:check_words = exists('w:check_words') ? !w:check_words : 1

              "Turn match mechanism on/off, according to new state of flag...
              if w:check_words
                exec s:words_matcher
              else
                match none
              endif
            endfunction

            "Use ;p to toggle checking...
            nmap <silent>  ;p  :call WordCheck()<CR>

            The variable w:check_words is used
            as a boolean flag to toggle word
            checking on or off. The first line
            of the WordCheck() function checks
            to see if the flag already exists,
            in which case the assignment simply
            toggles the variable's boolean
            value:

            let w:check_words = exists('w:check_words') ? !w:check_words : 1

            If w:check_words does not yet
            exist, it is created by assigning
            the value 1 to it:

            let w:check_words = exists('w:check_words') ? !w:check_words : 1

            Note the use of the w: prefix,
            which means that the flag variable
            is always local to the current
            window. This allows word checking
            to be toggled independently for
            each editor window (which is
            consistent with the behavior of the
            match command, whose effects are
            always local to the current window
            as well).

            Word checking is enabled by setting
            Vim's match command. A match
            expects a text-highlighting
            specification (STANDOUT in this
            example), followed by a regular
            expression that specifies which
            text to highlight. In this case,
            that regex is constructed by OR'ing
            together all of the words specified
            in the script's s:words list
            variable (that is: join(s:words,
            '\|')). That set of alternatives is
            then bracketed by case-insensitive
            word boundaries (\c\<\(...\)\>) to
            ensure that only entire words are
            matched, regardless of
            capitalization.

            The WordCheck() function then
            converts the resulting string as a
            Vim command and executes it (exec
            s:words_matcher) to turn on the
            matching facility. When
            w:check_words is toggled off, the
            function performs a match none
            command instead, to deactivate the
            special matching.


            Scripting in Insert mode

            Vimscripting is by no means
            restricted to Normal mode. You can
            also use the imap or iabbrev
            commands to set up key-mappings or
            abbreviations that can be used
            while inserting text. For example:

            imap <silent> <C-D><C-D> <C-R>=strftime("%e %b %Y")<CR>
            imap <silent> <C-T><C-T> <C-R>=strftime("%l:%M %p")<CR>

            With these mappings in your .vimrc,
            typing CTRL-D twice while in Insert
            mode causes Vim to call its
            built-in strftime() function and
            insert the resulting date, while
            double-tapping CTRL-T likewise
            inserts the current time.

            You can use the same general
            pattern to cause an insertion map
            or an abbreviation to perform any
            scriptable action. Just put the
            appropriate Vimscript expression or
            function call between an initial
            <C-R>= (which tells Vim to insert
            the result of evaluating what
            follows) and a final <CR> (which
            tells Vim to actually evaluate the
            preceding expression). Remember,
            though, that <C-R> (Vim's
            abbreviation for CTRL-R) is not the
            same as <CR> (Vim's abbreviation
            for a carriage return).

            For example, you could use Vim's
            built-in getcwd() function to
            create an abbreviation for the
            current working directory, like so:

            iabbrev <silent> CWD <C-R>=getcwd()<CR>

            Or you could embed a simple
            calculator that can be called by
            typing CTRL-C during text
            insertions:

            imap <silent> <C-C> <C-R>=string(eval(input("Calculate: ")))<CR>

            Here, the expression:

            string(eval(input("Calculate: ")))

            first calls the built-in input()
            function to request the user to
            type in their calculation, which
            input() then returns as a string.
            That input string is then passed to
            the built-in eval(), which
            evaluates it as a Vimscript
            expression and returns the result.
            Next, the built-in string()
            function converts the numeric
            result back to a string, which the
            key-mapping's <C-R>= sequence is
            then able to insert.


            A more complex Insert-mode script

            Insertion mappings can involve
            scripts considerably more
            sophisticated than the previous
            examples. In such cases, it's
            usually a good idea to refactor the
            code out into a user-defined
            function, which the key-mapping can
            then call.

            For example, you could change the
            behavior of CTRL-Y during
            insertions. Normally a CTRL-Y in
            Insert mode does a "vertical copy."
            That is, it copies the character in
            the same column from the line
            immediately above the cursor. For
            example, a CTRL-Y in the following
            situation would insert an "m" at
            the cursor:

            Glib jocks quiz nymph to vex dwarf

            Glib jocks quiz ny_

            However, you might prefer your
            vertical copies to ignore any
            intervening empty lines and instead
            copy the character from the same
            column of the first non-blank line
            anywhere above the insertion point.
            That would mean, for instance, that
            a CTRL-Y in the following situation
            would also insert an "m", even
            though the immediately preceding
            line is empty:

            Glib jocks quiz nymph to vex dwarf

            Glib jocks quiz ny_

            You could achieve this enhanced
            behavior by placing the following
            in your .vimrc file:

            Listing 11. Improving vertical
            copies to ignore blank lines

            "Locate and return character "above" current cursor position...
            function! LookUpwards()
              "Locate current column and preceding line from which to copy...
              let column_num      = virtcol('.')
              let target_pattern  = '\%' . column_num . 'v.'
              let target_line_num = search(target_pattern . '∗\S', 'bnW')

              "If target line found, return vertically copied character...
              if !target_line_num
                return ""
              else
                return matchstr(getline(target_line_num), target_pattern)
              endif
            endfunction

            "Reimplement CTRL‑Y within insert mode...
            imap <silent>  <C‑Y>  <C‑R><C‑R>=LookUpwards()<CR>

            The LookUpwards() function first
            determines which on-screen column
            (or "virtual column") the insertion
            point is currently in, using the
            built-in virtcol() function. The
            '.' argument specifies that you
            want the column number of the
            current cursor position:

            let column_num = virtcol('.')

            LookUpwards() then uses the
            built-in search() function to look
            backwards through the file from the
            cursor position:

            let target_pattern = '\%' . column_num . 'v.'
            let target_line_num = search(target_pattern . '*\S', 'bnW')

            The search uses a special target
            pattern (namely: \%column_numv.*\S)
            to locate the closest preceding
            line that has a non-whitespace
            character (\S) at or after (.*) the
            cursor column (\%column_numv). The
            second argument to search() is the
            configuration string bnW, which
            tells the function to search
            backwards but not to move the
            cursor nor to wrap the search. If
            the search is successful, search()
            returns the line number of the
            appropriate preceding line; if the
            search fails, it returns zero.

            The if statement then works out
            which character - if any - is to be
            copied back down to the insertion
            point. If a suitable preceding line
            was not found, target_line_num will
            have been assigned zero, so the
            first return statement is executed
            and returns an empty string
            (indicating "insert nothing").

            If, however, a suitable preceding
            line was identified, the second
            return statement is executed
            instead. It first gets a copy of
            that preceding line from the
            current editor buffer:

            return matchstr(getline(target_line_num), target_pattern)

            It then finds and returns the
            one-character string that the
            previous call to search()
            successfully matched:

            return matchstr(getline(target_line_num), target_pattern)

            Having implemented this new
            vertical copy behavior inside
            LookUpwards(), all that remains is
            to override the standard CTRL-Y
            command in Insert mode, using an
            imap:

            imap <silent> <C-Y> <C-R><C-R>=LookUpwards()<CR>

            Note that, whereas earlier imap
            examples all used <C-R>= to invoke
            a Vimscript function call, this
            example uses <C-R><C-R>= instead.
            The single-CTRL-R form inserts the
            result of the subsequent expression
            as if it had been directly typed,
            which means that any special
            characters within the result retain
            their special meanings and
            behavior. The double-CTRL-R form,
            on the other hand, inserts the
            result as verbatim text without any
            further processing.

            Verbatim insertion is more
            appropriate in this example, since
            the aim is to exactly copy the text
            above the cursor. If the
            key-mapping used <C-R>=, copying a
            literal escape character from the
            previous line would be equivalent
            to typing it, and would cause the
            editor to instantly drop out of
            Insert mode.


            Learning Vim's built-in functions

            As you can see from each of the
            preceding examples, much of
            Vimscript's power comes from its
            extensive set of over 200 built-in
            functions. You can start learning
            about them by typing:

            :help functions

            or, to access a (more useful)
            categorized listing:

            :help function-list


            Looking ahead

            Vimscript is a mechanism for
            reshaping and extending the Vim
            editor. Scripting lets you create
            new tools (such as a problem-word
            highlighter) and simplify common
            tasks (like changing tabspacing, or
            inserting time and date
            information, or toggling syntax
            highlighting), and even completely
            redesign existing editor features
            (for example, enhancing CTRL-Y's
            "copy-the-previous-line" behavior).

            For many people, the easiest way to
            learn any new language is by
            example. To that end, you can find
            an endless supply of sample
            Vimscripts - most of which are also
            useful tools in their own right -
            on the Vim Tips wiki. Or, for more
            extensive examples of Vim
            scripting, you can trawl the 2000+
            larger projects housed in the Vim
            script archive.

            If you're already familiar with
            Perl or Python or Ruby or PHP or
            Lua or Awk or Tcl or any shell
            language, then Vimscript will be
            both hauntingly familiar (in its
            general approach and concepts) and
            frustratingly different (in its
            particular syntactic
            idiosyncrasies). To overcome that
            cognitive dissonance and master
            Vimscript, you're going to have to
            spend some time experimenting,
            exploring, and playing with the
            language. To that end, why not take
            your biggest personal gripe about
            the way Vim currently works and see
            if you can script a better solution
            for yourself?

            This article has described only
            Vimscript's basic variables,
            values, expressions, and functions.
            The range of "better solutions"
            you're likely to be able to
            construct with just those few
            components is, of course, extremely
            limited. So, in future
            installments, we'll look at more
            advanced Vimscript tools and
            techniques: data structures, flow
            control, user-defined commands,
            event-driven scripting, building
            Vim modules, and extending Vim
            using other scripting languages. In
            particular, the next article in
            this series, User-defined functions
            will focus on the features of
            Vimscript's user-defined functions
            and on the many ways they can make
            your Vim experience better.



                https://developer.ibm.com/tutorials/l-vim-script-2/

            Tutorial

            Scripting the Vim editor, Part 2: User-defined functions
            (Create the fundamental building blocks of automation)

              Vimscript is a powerful scripting
              language that lets you modify and
              extend the Vim editor. You can
              use it to create new tools,
              simplify common tasks, and even
              rework existing features of the
              editor. This ongoing series of
              articles assumes some familiarity
              with the Vim editor. You should
              also read " Scripting the Vim
              editor, Part 1," which covers
              variables, values, and
              expressions, prerequisite
              knowledge for building functions.


            User-defined functions

            Ask Haskell or Scheme programmers,
            and they'll tell you that functions
            are the most important feature of
            any serious programming language.
            Ask C or Perl programmers, and
            they'll tell you exactly the same
            thing.

            Functions provide two essential
            benefits to the serious programmer:

            1. They enable complex
            computational tasks to be
            subdivided into pieces small enough
            to fit comfortably into a single
            human brain.

            2. They allow those subdivided
            pieces to be given logical and
            comprehensible names, so they can
            be competently manipulated by a
            single human brain.

            Vimscript is a serious programming
            language, so it naturally supports
            the creation of user-defined
            functions. Indeed, it arguably has
            better support for user-defined
            functions than Scheme, C, or Perl.
            This article explores the various
            features of Vimscript functions,
            and show how you can use those
            features to enhance and extend
            Vim's built-in functionality in a
            maintainable way.


            Declaring functions

            Functions in Vimscript are defined
            using the function keyword,
            followed by the name of the
            function, then the list of
            parameters (which is mandatory,
            even if the function takes no
            arguments). The body of the
            function then starts on the next
            line, and continues until a
            matching endfunction keyword is
            encountered. For example:

            Listing 1. A correctly structured function

            functionExpurgateText (text)
                let expurgated_text = a:text

                for expletive in [ 'cagal', 'frak', 'gorram', 'mebs', 'zarking']
                    let expurgated_text
                    \   = substitute(expurgated_text, expletive, '[DELETED]', 'g')
                endfor

                return expurgated_text
            endfunction

            The return value of the function is
            specified with a return statement.
            You can specify as many separate
            return statements as you need. You
            can include none at all if the
            function is being used as a
            procedure and has no useful return
            value. However, Vimscript functions
            always return a value, so if no
            return is specified, the function
            automatically returns zero.

            Function names in Vimscript must
            start with an uppercase letter:

            Listing 2. Function names start
            with an uppercase letter

            function SaveBackup ()
                let b:backup_count = exists('b:backup_count') ? b:backup_count+1 : 1
                return writefile(getline(1,'$'), bufname('%') . '_' . b:backup_count)
            endfunction

            nmap <silent> <C-B> :call SaveBackup()<CR>

            This example defines a function
            that increments the value of the
            current buffer's
            b:backup_countb:backup_count
            variable (or initializes it to 1,
            if it doesn't yet exist). The
            function then grabs every line in
            the current file (getline(1,'$'))
            and calls the built-in writefile()
            function to write them to disk. The
            second argument to writefile() is
            the name of the new file to be
            written; in this case, the name of
            the current file (bufname('%'))
            with the counter's new value
            appended. The value returned is the
            success/failure value of the call
            to writefile(). Finally, the nmap
            sets up CTRL-B to call the function
            to create a numbered backup of the
            current file.

            Instead of using a leading capital
            letter, Vimscript functions can
            also be declared with an explicit
            scope prefix (like variables can
            be, as described in Part 1). The
            most common choice is s:, which
            makes the function local to the
            current script file. If a function
            is scoped in this way, its name
            need not start with a capital; it
            can be any valid identifier.
            However, explicitly scoped
            functions must always be called
            with their scoping prefixes. For
            example:

            Listing 3. Calling a function with
            its scoping prefix

            " Function scoped to current script file...
            function s:save_backup ()
                let b:backup_count = exists('b:backup_count') ? b:backup_count+1 : 1
                return writefile(getline(1,'$'), bufname('%') . '_' . b:backup_count)
            endfunction

            nmap <silent> <C-B> :call s:save_backup()<CR>


            Redeclarable functions

            Function declarations in Vimscript
            are runtime statements, so if a
            script is loaded twice, any
            function declarations in that
            script will be executed twice,
            re-creating the corresponding
            functions.

            Redeclaring a function is treated
            as a fatal error (to prevent
            collisions where two separate
            scripts accidentally declare
            functions of the same name). This
            makes it difficult to create
            functions in scripts that are
            designed to be loaded repeatedly,
            such as custom syntax-highlighting
            scripts.

            So Vimscript provides a keyword
            modifier (function!) that allows
            you to indicate that a function
            declaration may be safely reloaded
            as often as required:

            Listing 4. Indicating that a
            function declaration may be safely
            reloaded

            function! s:save_backup ()
                let b:backup_count = exists('b:backup_count') ? b:backup_count+1 : 1
                return writefile(getline(1,'$'), bufname('%') . '_' . b:backup_count)
            endfunction

            No redeclaration checks are
            performed on functions defined with
            this modified keyword, so it is
            best used with explicitly scoped
            functions (in which case the
            scoping already ensures that the
            function won't collide with one
            from another script).


            Calling functions

            To call a function and use its
            return value as part of a larger
            expression, simply name it and
            append a parenthesized argument
            list:

            Listing 5. Using a function's
            return value

            "Clean up the current line...
            let success = setline('.', ExpurgateText(getline('.')) )

            Note, however, that, unlike C or
            Perl, Vimscript does not allow you
            to throw away the return value of a
            function without using it. So, if
            you intend to use the function as a
            procedure or subroutine and ignore
            its return value, you must prefix
            the invocation with the call
            command:

            Listing 6. Using a function without
            using its return value

            "Checkpoint the text...
            call SaveBackup()

            Otherwise, Vimscript will assume
            that the function call is actually
            a built-in Vim command and will
            most likely complain that no such
            command exists. We'll look at the
            difference between functions and
            commands in a future article in
            this series.


            Parameter lists

            Vimscript allows you to define both
            explicit parameters and variadic
            parameter lists, and even
            combinations of the two.

            You can specify up to 20 explicitly
            named parameters immediately after
            the declaration of the subroutine's
            name. Once specified, the
            corresponding argument values for
            the current call can be accessed
            within the function by prefixing an
            a: to the parameter name:

            Listing 7. Accessing argument
            values within the function

            function PrintDetails(name, title, email)
                echo 'Name:   '  a:title  a:name
                echo 'Contact:'  a:email
            endfunction

            If you don't know how many
            arguments a function may be given,
            you can specify a variadic
            parameter list, using an ellipsis
            (...) instead of named parameters.
            In this case, the function may be
            called with as many arguments as
            you wish, and those values are
            collected into a single variable:
            an array named a:000. Individual
            arguments are also given positional
            parameter names: a:1, a:2, a:3,
            etc. The number of arguments is
            available as a:0. For example:

            Listing 8. Specifying and using a variadic parameter list

            function Average(...)
                let sum = 0.0

                for nextval in a:000"a:000 is the list of arguments
                    let sum += nextval
                endfor

                return sum / a:0"a:0 is the number of arguments
            endfunction

            Note that, in this example, sum
            must be initialized to an explicit
            floating-point value; otherwise,
            all the subsequent computations
            will be done using integer
            arithmetic.


            Combining named and variadic parameters

            Named and variadic parameters can
            be used in the same function,
            simply by placing the variadic
            ellipsis after the list of named
            parameters.

            For example, suppose you wanted to
            create a CommentBlock() function
            that was passed a string and
            formatted it into an appropriate
            comment block for various
            programming languages. Such a
            function would always require the
            caller to supply the string to be
            formatted, so that parameter should
            be explicitly named. But you might
            prefer that the comment introducer,
            the "boxing" character, and the
            width of the comment all be
            optional (with sensible defaults
            when omitted). Then you could call:

            Listing 9. A simple CommentBlock
            function call

            call CommentBlock("This is a comment")

            and it would return a multi-line
            string containing:

            Listing 10. The CommentBlock return

            //*******************
            // This is a comment
            //*******************

            Whereas, if you provided extra
            arguments, they would specify
            non-default values for the comment
            introducer, the "boxing" character,
            and the comment width. So this
            call:

            Listing 11. A more involved
            CommentBlock function call

            call CommentBlock("This is a comment", '#', '=', 40)

            would return the string:

            Listing 12. The CommentBlock return

#========================================
# This is a comment
#========================================

            Such a function might be
            implemented like so:

            Listing 13. The CommentBlock implementation

            function CommentBlock(comment, ...)
                "If 1 or more optional args, first optional arg is introducer...
                let introducer =  a:0 >= 1  ?  a:1  :  "//"

                "If 2 or more optional args, second optional arg is boxing character...
                let box_char   =  a:0 >= 2  ?  a:2  :  "*"

                "If 3 or more optional args, third optional arg is comment width...
                let width      =  a:0 >= 3  ?  a:3  :  strlen(a:comment) + 2

                " Build the comment box and put the comment inside it...
                return introducer . repeat(box_char,width) . "\<CR>"
                \    . introducer . " " . a:comment        . "\<CR>"
                \    . introducer . repeat(box_char,width) . "\<CR>"
            endfunction

            If there is at least one optional
            argument (a:0 >= 1), the introducer
            parameter is assigned that first
            option (that is, a:1); otherwise,
            it is assigned a default value of
            "//". Likewise, if there are two or
            more optional arguments (a:0 >= 2),
            the box_char variable is assigned
            the second option (a:2), or else a
            default value of "*". If three or
            more optional arguments are
            supplied, the third option is
            assigned to the widthwidth
            variable. If no width argument is
            given, the appropriate width is
            autocomputed from the comment
            argument itself
            (strlen(a:comment)+2).

            Finally, having resolved all the
            parameter values, the top and
            bottom lines of the comment box are
            constructed using the leading
            comment introducer, followed by the
            appropriate number of repetitions
            of the boxing character
            (repeat(box_char,width)), with the
            comment text itself sandwiched
            between them.

            Of course, to use this function,
            you'd need to invoke it somehow. An
            insertion map is probably the ideal
            way to do that:

            Listing 14. Invoking the function
            using an insertion map

            "C++/Java/PHP comment...
            imap <silent>  ///  <C-R>=CommentBlock(input("Enter comment: "))<CR>

            "Ada/Applescript/Eiffel comment...
            imap <silent>  ---  <C-R>=CommentBlock(input("Enter comment: "),'--')<CR>

            "Perl/Python/Shell comment...
            imap <silent>  ###  <C-R>=CommentBlock(input("Enter comment: "),'#','#')<CR>

            In each of these maps, the built-in
            input() function is first called to
            request that the user type in the
            text of the comment. The
            CommentBlock() function is then
            called to convert that text into a
            comment block. Finally, the leading
            <C-R>= inserts the resulting
            string.

            Note that the first mapping passes
            only a single argument, so it
            defaults to using // as its comment
            marker. The second and third
            mappings pass a second argument to
            specify # or -- as their respective
            comment introducers. The final
            mapping also passes a third
            argument, to make the "boxing"
            character match its comment
            introducer.


            Functions and line ranges

            You can invoke any standard Vim
            command - including call - with a
            preliminary line range, which
            causes the command to be repeated
            once for every line in the range:

            "Delete every line from the current line (.) to the end-of-file ($)...
            :.,$delete

            "Replace "foo" with "bar" everywhere in lines 1 to 10
            :1,10s/foo/bar/

            "Center every line from five above the current line to five below it...
            -:5,+5center

            You can type :help cmdline-ranges
            in any Vim session to learn more
            about this facility.

            In the case of the call command,
            specifying a range causes the
            requested function to be called
            repeatedly: once for each line in
            the range. To see why that's
            useful, let's consider how to write
            a function that converts any "raw"
            ampersands in the current line to
            proper XML & entities, but that is
            also smart enough to ignore any
            ampersand that is already part of
            some other entity. That function
            could be implemented like so:

            Listing 15. Function to convert
            ampersands

            function DeAmperfy()
                "Get current line...
                let curr_line   = getline('.')

                "Replace raw ampersands...
                let replacement = substitute(curr_line,'&\(\w\+;\)\@!','&','g')

                "Update current line...
                call setline('.', replacement)
            endfunction

            The first line of DeAmperfy() grabs
            the current line from the editor
            buffer (getline('.')). The second
            line looks for any & in that line
            that isn't followed by an
            identifier and a colon, using the
            negative lookahead pattern
            '&\(\w\+;\)\@!'(see :help \@! for
            details). The substitute() call
            then replaces all such "raw"
            ampersands with the XML entity &.
            Finally, the third line of
            DeAmperfy()updates the current line
            with the modified text.

            If you called this function from
            the command line:

            :call DeAmperfy()

            it would perform the replacement on
            the current line only. But if you
            specified a range before the call:

            :1,$call DeAmperfy()

            then the function would be called
            once for each line in the range (in
            this case, for every line in the
            file).


            Internalizing function line ranges

            This
            call-the-function-repeatedly-for-each-line
            behavior is a convenient default.
            However, sometimes you might prefer
            to specify a range but then have
            the function called only once, and
            then handle the range semantics
            within the function itself. That's
            also easy in Vimscript. You simply
            append a special modifier (range)
            to the function declaration:

            Listing 16. Range semantics within a function

            function DeAmperfyAll() range"Step through each line in the range...
                for linenum in range(a:firstline, a:lastline)
                    "Replace loose ampersands (as in DeAmperfy())...
                    let curr_line   = getline(linenum)
                    let replacement = substitute(curr_line,'&\(\w\+;\)\@!','&','g')
                    call setline(linenum, replacement)
                endfor

                "Report what was done...
                if a:lastline > a:firstline
                    echo "DeAmperfied" (a:lastline - a:firstline + 1) "lines"
                endif
            endfunction

            With the range modifier specified
            after the parameter list, any time
            DeAmperfyAll() is called with a
            range such as:

            :1,$call DeAmperfyAll()

            then the function is invoked only
            once, and two special arguments,
            a:firstline and a:lastline, are set
            to the first and last line numbers
            in the range. If no range is
            specified, both a:firstline and
            a:lastline are set to the current
            line number.

            The function first builds a list of
            all the relevant line numbers
            (range(a:firstline, a:lastline)).
            Note that this call to the built-in
            range() function is entirely
            unrelated to the use of the range
            modifier as part of the function
            declaration. The range() function
            is simply a list constructor, very
            similar to the range() function in
            Python, or the .. operator in
            Haskell or Perl.

            Having determined the list of line
            numbers to be processed, the
            function uses a for loop to step
            through each:

            for linenum in range(a:firstline, a:lastline)

            and updates each line accordingly
            (just as the original DeAmperfy()
            did).

            Finally, if the range covers more
            than a single line (in other words,
            if a:lastline > a:firstline), the
            function reports how many lines
            were updated.


            Visual ranges

            Once you have a function call that
            can operate on a range of lines, a
            particularly useful technique is to
            call that function via Visual mode
            (see :help Visual-mode for
            details).

            For example, if your cursor is
            somewhere in a block of text, you
            could encode all the ampersands
            anywhere in the surrounding
            paragraph with:

            Vip:call DeAmperfyAll()

            Typing V in Normal mode swaps you
            into Visual mode. The ip then
            causes Visual mode to highlight the
            entire paragraph you're inside.
            Then, the : swaps you to Command
            mode and automatically sets the
            command's range to the range of
            lines you just selected in Visual
            mode. At this point you call
            DeAmperfyAll() to deamperfy all of
            them.

            Note that, in this instance, you
            could get the same effect with
            just:

            Vip:call DeAmperfy()

            The only difference is that the
            DeAmperfy() function would be
            called repeatedly: once for each
            line the Vip highlighted in Visual
            mode.


            A function to help you code

            Most user-defined functions in
            Vimscript require very few
            parameters, and often none at all.
            That's because they usually get
            their data directly from the
            current editor buffer and from
            contextual information (such as the
            current cursor position, the
            current paragraph size, the current
            window size, or the contents of the
            current line).

            Moreover, functions are often far
            more useful and convenient when
            they obtain their data through
            context, rather than through their
            argument lists. For example, a
            common problem when maintaining
            source code is that assignment
            operators fall out of alignment as
            they accumulate, which reduces the
            readability of the code:

            Listing 17. Assignment operators out of alignment

            let applicants_name = 'Luke'
            let mothers_maiden_name = 'Amidala'
            let closest_relative = 'sister'
            let fathers_occupation = 'Sith'

            Realigning them manually every time
            a new statement is added can be
            tedious:

            Listing 18. Manually realigned
            assignment operators

            let applicants_name     = 'Luke'
            let mothers_maiden_name = 'Amidala'
            let closest_relative    = 'sister'
            let fathers_occupation  = 'Sith'

            To reduce the tedium of that
            everyday coding task, you could
            create a key-mapping (such as ;=)
            that selects the current block of
            code, locates any lines with
            assignment operators, and
            automatically aligns those
            operators. Like so:

            Listing 19. Function to align assignment operators

            function AlignAssignments ()
                "Patterns needed to locate assignment operators...
                let ASSIGN_OP   = '[-+*/%|&]\?=\@<!=[=~]\@!'
                let ASSIGN_LINE = '^\(.\{-}\)\s*\(' . ASSIGN_OP . '\)'

                "Locate block of code to be considered (same indentation, no blanks)
                let indent_pat = '^' . matchstr(getline('.'), '^\s*') . '\S'
                let firstline  = search('^\%('. indent_pat . '\)\@!','bnW') + 1
                let lastline   = search('^\%('. indent_pat . '\)\@!', 'nW') - 1
                if lastline < 0
                    let lastline = line('$')
                endif

                "Find the column at which the operators should be aligned...
                let max_align_col = 0
                let max_op_width  = 0
                for linetext in getline(firstline, lastline)
                    "Does this line have an assignment in it?
                    let left_width = match(linetext, '\s*' . ASSIGN_OP)

                    "If so, track the maximal assignment column and operator width...
                    if left_width >= 0
                        let max_align_col = max([max_align_col, left_width])

                        let op_width      = strlen(matchstr(linetext, ASSIGN_OP))
                        let max_op_width  = max([max_op_width, op_width+1])
                     endif
                endfor

                "Code needed to reformat lines so as to align operators...
                let FORMATTER = '\=printf("%-*s%*s", max_align_col, submatch(1),
                \                                    max_op_width,  submatch(2))'

                " Reformat lines with operators aligned in the appropriate column...
                for linenum in range(firstline, lastline)
                    let oldline = getline(linenum)
                    let newline = substitute(oldline, ASSIGN_LINE, FORMATTER, "")
                    call setline(linenum, newline)
                endfor
            endfunction

            nmap <silent>  ;=  :call AlignAssignments()<CR>

            The AlignAssignments() function
            first sets up two regular
            expressions (see :help pattern for
            the necessary details of Vim's
            regex syntax):

            let ASSIGN_OP   = '[-+*/%|&]\?=\@<!=[=~]\@!'
            let ASSIGN_LINE = '^\(.\{-}\)\s*\(' . ASSIGN_OP . '\)'

            The pattern in ASSIGN_OP matches
            any of the standard assignment
            operators: =, +=, -=, *=, etc. but
            carefully avoids matching other
            operators that contain =, such as
            == and =~. If your favorite
            language has other assignment
            operators (such as .= or ||= or
            ^=), you could extend the ASSIGN_OP
            regex to recognize those as well.
            Alternatively, you could redefine
            ASSIGN_OP to recognize other types
            of "alignables," such as comment
            introducers or column markers, and
            align them instead.

            The pattern in ASSIGN_LINE matches
            only at the start of a line (^),
            matching a minimal number of
            characters (.\{-}), then any
            whitespace (\s*), then an
            assignment operator.

            Note that both the initial "minimal
            number of characters" subpattern
            and the operator subpattern are
            specified within capturing
            parentheses: \(…\). The substrings
            captured by those two components of
            the regex will later be extracted
            using calls to the built-in
            submatch() function; specifically,
            by calling submatch(1) to extract
            everything before the operator, and
            submatch(2) to extract the operator
            itself.

            AlignAssignments() then locates the
            range of lines on which it will
            operate:

            let indent_pat = '^' . matchstr(getline('.'), '^\s*') . '\S'
            let firstline  = search('^\%('. indent_pat . '\)\@!','bnW') + 1
            let lastline   = search('^\%('. indent_pat . '\)\@!', 'nW') - 1
            if lastline < 0
                let lastline = line('$')
            endif

            In earlier examples, functions have
            relied on an explicit command range
            or a Visual mode selection to
            determine which lines they operate
            on, but this function computes its
            own range directly. Specifically,
            it first calls the built-in
            matchstr() function to determine
            what leading whitespace ('^\s*')
            appears at the start of the current
            line (getline('.'). It then builds
            a new regular expression in
            indent_patindent_pat that matches
            exactly the same sequence of
            whitespace at the start of any
            non-empty line (hence the trailing
            '\S').

            AlignAssignments() then calls the
            built-in search() function to
            search upwards (using the flags
            'bnW') and locate the first line
            above the cursor that does not have
            precisely the same indentation.
            Adding 1 to this line number gives
            the start of the range of interest,
            namely, the first contiguous line
            with the same indentation as the
            current line.

            A second call to search() then
            searches downwards ('nW') to
            determine lastlinelastline: the
            number of the final contiguous line
            with the same indentation. In this
            second case, the search might hit
            the end of the file without finding
            a differently indented line, in
            which case search() would return
            -1. To handle this case correctly,
            the following if statement would
            explicitly set lastlinelastline to
            the line number of the end of file
            (that is, to the line number
            returned by line('$')).

            The result of these two searches is
            that AlignAssignments() now knows
            the full range of lines immediately
            above or below the current line
            that all have precisely the same
            indentation as the current line. It
            uses this information to ensure
            that it aligns only those
            assignment statements at the same
            scoping level in the same block of
            code. Unless, of course, the
            indentation of your code doesn't
            correctly reflect its scope, in
            which case you fully deserve the
            formatting catastrophe about to
            befall you.

            The first for loop in
            AlignAssignments() determines the
            column in which the assignment
            operators should be aligned. This
            is done by walking through the list
            of lines in the selected range (the
            lines retrieved by
            getline(firstline, lastline)) and
            checking whether each line contains
            an assignment operator (possibly
            preceded by whitespace):

            let left_width = match(linetext, '\\s∗' . ASSIGN_OP)

            If there is no operator in the
            line, the built-in match() function
            will fail to find a match and will
            return -1. In that case, the loop
            simply skips on to the next line.
            If there is an operator, match()
            will return the (positive) index at
            which that operator appears. The if
            statement then uses the built-in
            max() function to determine whether
            this latest column position is
            further right than any previously
            located operator, thereby tracking
            the maximum column position
            required to align all the
            assignments in the range:

            let max_align_col = max([max_align_col, left_width])

            The remaining two lines of the if
            use the built-in matchstr()
            function to retrieve the actual
            operator, then the built-in
            strlen() to determine its length
            (which will be 1 for a "=" but 2
            for '+=', '-=', etc.) The
            max_op_width variable is then used
            to track the maximum width required
            to align the various operators in
            the range:

            let op_width     = strlen(matchstr(linetext, ASSIGN_OP))
            let max_op_width = max([max_op_width, op_width+1])

            Once the location and width of the
            alignment zone have been
            determined, all that remains is to
            iterate through the lines in the
            range and reformat them
            accordingly. To do that
            reformatting, the function uses the
            built-in printf() function. This
            function is very useful, but also
            very badly named. It is not the
            same as the printf function in C or
            Perl or PHP. It is, in fact, the
            same as the sprintf function in
            those languages. That is, in
            Vimscript, printf doesn't print a
            formatted version of its list of
            data arguments; it returns a string
            containing a formatted version of
            its list of data arguments.

            Ideally, in order to reformat each
            line, AlignAssignments() would use
            the built-in substitute() function,
            and replace everything up to the
            operator with a printf'd
            rearrangement of that text.
            Unfortunately, substitute() expects
            a fixed string as its replacement
            value, not a function call.

            So, in order to use a printf() to
            reformat each replacement text, you
            need to use the special embedded
            replacement form: "\=expr". The
            leading \= in the replacement
            string tells substitute() to
            evaluate the expression that
            follows and use the result as the
            replacement text. Note that this is
            similar to the <C-R>= mechanism in
            Insert mode, except this magic
            behavior only works for the
            replacement string of the built-in
            substitute() function (or in the
            standard :s/…/…/ Vim command).

            In this example, the special
            replacement form will be the same
            printf for every line, so it is
            pre-stored in the
            FORMATTERFORMATTER variable before
            the second for loop begins:

            let FORMATTER = '\\=printf("%‑∗s%∗s", max_align_col, submatch(1),
            \\                                    max_op_width,  submatch(2))'

            When it is eventually called by
            substitute(), this embedded
            printf() will left-justify (using a
            %-*s placeholder) everything to the
            left of the operator (submatch(1))
            and place the result in a field
            that's max_align_col characters
            wide. It will then right-justify
            (using a %*s) the operator itself
            (submatch(2)) into a second field
            that's max_op_width characters
            wide. See :help printf() for
            details on how the - and * options
            modify the two %s format specifiers
            used here.

            With this formatter now available,
            the second for loop can finally
            iterate through the full range of
            line numbers, retrieving the
            corresponding text buffer contents
            one line at a time:

            for linenum in range(firstline, lastline)
            let oldline = getline(linenum)

            The loop then uses substitute() to
            transform those contents, by
            matching everything up to and
            including any assignment operator
            (using the pattern in ASSIGN_LINE)
            and replacing that text with the
            result of the printf() call (as
            specified by FORMATTER):

            let newline = substitute(oldline, ASSIGN_LINE, FORMATTER, "")
            call setline(linenum, newline)
            endfor

            Once the for loop has iterated all
            the lines, any assignment operators
            within them will now be aligned
            correctly. All that remains is to
            create a key-mapping to invoke
            AlignAssignments(), like so:

            nmap <silent>  ;=  :call AlignAssignments()<CR>


            Looking ahead

            Functions are an essential tool for
            decomposing an application into
            correct and maintainable
            components, in order to manage the
            complexity of real-world Vim
            programming tasks.

            Vimscript allows you to define
            functions with fixed or variadic
            parameter lists, and to have them
            interact either automatically or in
            user-controlled ways with ranges of
            lines in the editor's text buffer.
            Functions can call back to Vim's
            built-in features (for example, to
            search() or substitute() text), and
            they can also directly access
            editor state information (such as
            determining the current line the
            cursor is on via line('.')) or
            interact with any text buffer
            currently being edited (via
            getline() and setline()).

            This is undoubtedly a powerful
            facility, but our ability to
            programmatically manipulate state
            and content is always limited by
            how cleanly and accurately we can
            represent the data on which our
            code operates. So far in this
            series of articles, we've been
            restricted to the use of single
            scalar values (numbers, strings,
            and booleans). In the next two
            articles, we'll explore the use of
            much more powerful and convenient
            data structures: ordered lists and
            random-access dictionaries.



                https://developer.ibm.com/tutorials/l-vim-script-3/

            Tutorial

            Scripting the Vim editor, Part 3: Built-in lists
            (Explore Vimscript's support for lists and arrays)

            By Damian Conway
            Updated September 13, 2021 | Published January 27, 2010

            The heart of all programming is the
            creation and manipulation of data
            structures. The true power of
            programming Vim becomes apparent
            when its scripts can operate on
            entire collections of related data
            at once: reformatting lists of text
            lines, accessing multidimensional
            tables of configuration data,
            filtering sequences of filenames,
            and sorting sets of line numbers.

            In this article, we'll explore
            Vimscript's excellent support for
            lists and the arrays that store
            them, as well as the language's
            many built-in functions that make
            using lists so easy, efficient, and
            maintainable.


            Lists in Vimscript

            In Vimscript, a list is a sequence
            of scalar values: strings, numbers,
            references, or any mixture thereof.

            Vimscript lists are arguably
            misnamed. In most languages, a
            "list" is a value (rather than a
            container), an immutable ordered
            sequence of simpler values. In
            contrast, lists in Vimscript are
            mutable and in many ways far more
            like (references to)
            anonymous-array data structures. A
            Vimscript variable that is storing
            a list is, for most purposes, an
            array.

            You create a list by placing a
            comma-separated sequence of scalar
            values inside a pair of square
            brackets. List elements are indexed
            from zero, and are accessed and
            modified via the usual notation:
            postfix square brackets with the
            index inside them:

            Listing 1. Creating a list

            let data = [1,2,3,4,5,6,"seven"]
            echo data[0]                 |" echoes: 1
            let data[1] = 42             |" [1,42,3,4,5,6,"seven"]
            let data[2] += 99            |" [1,42,102,4,5,6,"seven"]
            let data[6] .= ' samurai'    |" [1,42,102,4,5,6,"seven samurai"]

            You can also use indices less than
            zero, which then count backward
            from the end of the list. So the
            final statement of the previous
            example could also be written like
            so:

            let data[-1] .=  ' samurai'

            As in most other dynamic languages,
            Vimscript lists require no explicit
            memory management: they
            automatically grow or shrink to
            accommodate the elements they're
            asked to store, and they're
            automatically garbage-collected
            when the program no longer requires
            them.


            Nested lists

            In addition to storing strings or
            numbers, a list can also store
            other lists. As in C, C++, or Perl,
            if a list contains other lists, it
            acts like a multidimensional array.
            For example:

            Listing 2. Creating a nested list

            let pow = [
            \   [ 1, 0, 0, 0  ],
            \   [ 1, 1, 1, 1  ],
            \   [ 1, 2, 4, 8  ],
            \   [ 1, 3, 9, 27 ],
            \]
            " and later...
            echo pow[x][y]

            Here, the first indexing operation
            (pow[x]) returns one of the
            elements of the list in pow. That
            element is itself a list, so the
            second indexing ([y]) returns one
            of the nested list's elements.


            List assignments and aliasing

            When you assign any list to a
            variable, you're really assigning a
            pointer or reference to the list.
            So, assigning from one list
            variable to another causes them to
            both point at or refer to the same
            underlying list. This usually leads
            to unpleasant action-at-a-distance
            surprises like the one you see
            here:

            Listing 3. Assign with caution

            let old_suffixes = ['.c', '.h', '.py']
            let new_suffixes = old_suffixes
            let new_suffixes[2] = '.js'
            echo old_suffixes      |" echoes: ['.c', '.h', '.js']
            echo new_suffixes      |" echoes: ['.c', '.h', '.js']

            To avoid this aliasing effect, you
            need to call the built-in copy()
            function to duplicate the list, and
            then assign the copy instead:

            Listing 4. Copying a list

            let old_suffixes = ['.c', '.h', '.py']
            let new_suffixes = copy(old_suffixes)
            let new_suffixes[2] = '.js'
            echo old_suffixes      |" echoes: ['.c', '.h', '.py']
            echo new_suffixes      |" echoes: ['.c', '.h', '.js']

            Note, however, that copy() only
            duplicates the top level of the
            list. If any of those values is
            itself a nested list, it's really a
            pointer/reference to some separate
            external list. In that case, copy()
            will duplicate that
            pointer/reference, and the nested
            list will still be shared by both
            the original and the copy, as shown
            here:

            Listing 5. Shallow copy

            let pedantic_pow = copy(pow)
            let pedantic_pow[0][0] = 'indeterminate'
            " also changes pow[0][0] due to shared nested list

            If that's not what you want (and
            it's almost always not what you
            want), then you can use the
            built-in deepcopy() function
            instead, which duplicates any
            nested data structure "all the way
            down":

            Listing 6. Deep copy

            let pedantic_pow = deepcopy(pow)
            let pedantic_pow[0][0] = 'indeterminate'
            " pow[0][0] now unaffected; no nested list is shared


            Basic list operations

            Most of Vim's list operations are
            provided via built-in functions.
            The functions usually take a list
            and return some property of it:

            Listing 7. Finding size, range, and indexes

            " Size of list...
            let list_length   = len(a_list)
            let list_is_empty = empty(a_list)     " same as: len(a_list) == 0" Numeric minima and maxima...
            let greatest_elem = max(list_of_numbers)
            let least_elem    = min(list_of_numbers)

            " Index of first occurrence of value or pattern in list...
            let value_found_at = index(list, value)      " uses == comparison
            let pat_matched_at = match(list, pattern)    " uses =~ comparison

            The range() function can be used to
            generate a list of integers. If
            called with a single-integer
            argument, it generates a list from
            zero to one less than that
            argument. Called with two
            arguments, it generates an
            inclusive list from the first to
            the second. With three arguments,
            it again generates an inclusive
            list, but increments each
            successive element by the third
            argument:

            Listing 8. Generating a list using the range() function

            let sequence_of_ints = range(max)              " 0...max-1
            let sequence_of_ints = range(min, max)         " min...max
            let sequence_of_ints = range(min, max, step)   " min, min+step,...max

            You can also generate a list by
            splitting a string into a sequence
            of "words":

            Listing 9. Generating a list by splitting text

            let words = split(str)                         " split on whitespace
            let words = split(str, delimiter_pat)          " split where pattern matches

            To reverse that, you can join the
            list back together:

            Listing 10. Joining the elements of a list

            let str = join(list)                           " use a single space char to join
            let str = join(list, delimiter)                " use delimiter string to join


            Other list-related procedures

            You can explore the many other
            list-related functions by typing
            :help function-list in any Vim
            session, then scrolling down to
            "List manipulation"). Most of these
            functions are actually procedures,
            however, because they modify their
            list argument in-place.

            For example, to insert a single
            extra element into a list, you can
            use insert() or add():

            Listing 11. Adding a value to a list

            call insert(list, newval)          " insert new value at start of list
            call insert(list, newval, idx)     " insert new value before index idx
            call    add(list, newval)          " append new value to end of list

            You can insert a list of values
            with extend():

            Listing 12. Adding a set of values to a list

            call extend(list, newvals)         " append new values to end of list
            call extend(list, newvals, idx)    " insert new values before index idx

            Or remove specified elements from a
            list:

            Listing 13. Removing elements

            call remove(list, idx)             " remove element at index idx
            call remove(list, from, to)        " remove elements in range of indices

            Or sort or reverse a list:

            Listing 14. Sorting or reversing a list

            call sort(list)                    " re-order the elements of list alphabetically
            call reverse(list)                 " reverse order of elements in list


            A common mistake with list procedures

            Note that all list-related
            procedures also return the list
            they've just modified, so you could
            write:

            let sorted_list = reverse(sort(unsorted_list))

            Doing so would almost always be a
            serious mistake, however, because
            even when their return values are
            used in this way, list-related
            functions still modify their
            original argument. So, in the
            previous example, the list in
            unsorted_list would also be sorted
            and reversed. Moreover,
            unsorted_list and sorted_list would
            now be aliased to the same
            sorted-and-reversed list (as
            described under "List assignments
            and aliasing").

            This is highly counterintuitive for
            most programmers, who typically
            expect functions like sort and
            reverse to return modified copies
            of the original data, without
            changing the original itself.

            Vimscript lists simply don't work
            that way, so it's important to
            cultivate good coding habits that
            will help you avoid nasty
            surprises. One such habit is to
            only ever call sort(), reverse(),
            and the like, as pure functions,
            and to always pass a copy of the
            data to be modified. You can use
            the built-in copy() function for
            this purpose:

            let sorted_list = reverse(sort(copy(unsorted_list)))


            Filtering and transforming lists

            Two particularly useful procedural
            list functions are filter() and
            map(). The filter() function takes
            a list and removes those elements
            that fail to meet some specified
            criterion:

            let filtered_list = filter(copy(list), criterion_as_str)

            The call to filter() converts the
            string that is passed as its second
            argument to a piece of code, which
            it then applies to each element of
            the list that is passed as its
            first argument. In other words, it
            repeatedly performs an eval() on
            its second argument. For each
            evaluation, it passes the next
            element of its first argument to
            the code, via the special variable
            v:val. If the result of the
            evaluated code is zero (that is,
            false), the corresponding element
            is removed from the list.

            For example, to remove any negative
            numbers from a list, type:

            let positive_only = filter(copy(list_of_numbers), 'v:val >= 0')

            To remove any names from a list
            that contain the pattern /.*nix/,
            type:

            let non_starnix = filter(copy(list_of_systems), 'v:val !~ ".*nix"')


            The map() function

            The map() function is similar to
            filter(), except that instead of
            removing some elements, it replaces
            every element with a user-specified
            transformation of its original
            value. The syntax is:

            let transformed_list = map(copy(list), transformation_as_str)

            Like filter(), map() evaluates the
            string passed as its second
            argument, passing each list element
            in turn, via v:val. But, unlike
            filter(), a map() always keeps
            every element of a list, replacing
            each value with the result of
            evaluating the code on that value.

            For example, to increase every
            number in a list by 10, type:

            let increased_numbers = map(copy(list_of_numbers), 'v:val + 10')

            Or to capitalize each word in a
            list: type:

            let LIST_OF_WORDS = map(copy(list_of_words), 'toupper(v:val)')

            Once again, remember that filter()
            and map() modify their first
            argument in-place. A very common
            error when using them is to write
            something like:

            let squared_values = map(values, 'v:val * v:val')

            instead of:

            let squared_values = map(copy(values), 'v:val * v:val')


            List concatenation

            You can concatenate lists with the
            + and += operators, like so:

            Listing 15. Concatenating lists

            let activities = ['sleep', 'eat'] + ['game', 'drink']
            let activities += ['code']

            Remember that both sides must be
            lists. Don't think of += as
            "append"; you can't use it to add a
            single value directly to the end of
            a list:

            Listing 16. Concatenation needs two lists

            let activities += 'code'
            " Error: Wrong variable type for +=


            Sublists

            You can extract part of a list by
            specifying a colon-separated range
            in the square brackets of an
            indexing operation. The limits of
            the range can be constants,
            variables with numeric values, or
            any numeric expression:

            Listing 17. Extracting parts of a list

            let week = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']
            let weekdays = week[1:5]
            let freedays = week[firstfree : lastfree-2]

            If you omit the starting index, the
            sublist automatically starts at
            zero; if you omit the ending index,
            the sublist finishes at the last
            element. For example, to split a
            list into two (near-)equal halves,
            type:

            Listing 18. Splitting a list into two sublists

            let middle = len(data)/2
            let first_half  = data[: middle-1]    " same as: data[0 : middle-1]
            let second_half = data[middle :]      " same as: data[middle : len(data)-1]


            Example 1: Revisiting autoalignments

              The full power and utility of
              lists is best illustrated by
              example. Let's start by improving
              an existing tool.

            The second article in this series
            explored a user-defined function
            called AlignAssignments(), which
            lined up assignment operators in
            elegant columns. Listing 19
            reproduces that function.

            Listing 19. The original AlignAssignments() function

            function AlignAssignments ()
                " Patterns needed to locate assignment operators...
                let ASSIGN_OP   = '[-+*/%|&]\?=\@<!=[=~]\@!'
                let ASSIGN_LINE = '^\(.\{-}\)\s*\(' . ASSIGN_OP . '\)'

                " Locate block of code to be considered (same indentation, no blanks)
                let indent_pat = '^' . matchstr(getline('.'), '^\s*') . '\S'
                let firstline  = search('^\%('. indent_pat . '\)\@!','bnW') + 1
                let lastline   = search('^\%('. indent_pat . '\)\@!', 'nW') - 1
                if lastline < 0
                    let lastline = line('$')
                endif

                " Find the column at which the operators should be aligned...
                let max_align_col = 0
                let max_op_width  = 0
                for linetext in getline(firstline, lastline)
                    " Does this line have an assignment in it?
                    let left_width = match(linetext, '\s*' . ASSIGN_OP)

                    " If so, track the maximal assignment column and operator width...
                    if left_width >= 0
                        let max_align_col = max([max_align_col, left_width])

                        let op_width      = strlen(matchstr(linetext, ASSIGN_OP))
                        let max_op_width  = max([max_op_width, op_width+1])
                    endif
                endfor

                " Code needed to reformat lines so as to align operators...
                let FORMATTER = '\=printf("%-*s%*s", max_align_col, submatch(1),
                \                                    max_op_width,  submatch(2))'

                " Reformat lines with operators aligned in the appropriate column...
                for linenum in range(firstline, lastline)
                    let oldline = getline(linenum)
                    let newline = substitute(oldline, ASSIGN_LINE, FORMATTER, "")
                    call setline(linenum, newline)
                endfor
            endfunction

            One deficiency of this function is
            that it has to grab each line being
            processed twice: once (in the first
            for loop) to gather information on
            the paragraph's existing structure,
            and a second time (in the final for
            loop) to adjust each line to fit
            the new structure.

            This duplicated effort is clearly
            suboptimal. It would be better to
            store the lines in some internal
            data structure and reuse them
            directly. Knowing what you do about
            lists, it is indeed possible to
            rewrite AlignAssignments() more
            efficiently and more cleanly.
            Listing 20 shows a new version of
            the function that takes advantage
            of several list data structures and
            the various list-manipulation
            functions described earlier.

            Listing 20. An updated AlignAssignments() function

            function! AlignAssignments ()
                " Patterns needed to locate assignment operators...
                let ASSIGN_OP   = '[-+*/%|&]\?=\@<!=[=~]\@!'
                let ASSIGN_LINE = '^\(.\{-}\)\s*\(' . ASSIGN_OP . '\)\(.*\)$'

                " Locate block of code to be considered (same indentation, no blanks)
                let indent_pat = '^' . matchstr(getline('.'), '^\s*') . '\S'
                let firstline  = search('^\%('. indent_pat . '\)\@!','bnW') + 1
                let lastline   = search('^\%('. indent_pat . '\)\@!', 'nW') - 1
                if lastline < 0
                    let lastline = line('$')
                endif

                " Decompose lines at assignment operators...
                let lines = []
                for linetext in getline(firstline, lastline)
                    let fields = matchlist(linetext, ASSIGN_LINE)
                    call add(lines, fields[1:3])
                endfor

                " Determine maximal lengths of lvalue and operator...
                let op_lines = filter(copy(lines),'!empty(v:val)')
                let max_lval = max( map(copy(op_lines), 'strlen(v:val[0])') ) + 1
                let max_op   = max( map(copy(op_lines), 'strlen(v:val[1])'  ) )

                " Recompose lines with operators at the maximum length...
                let linenum = firstline
                for line in lines
                    if !empty(line)
                        let newline
                        \    = printf("%-*s%*s%s", max_lval, line[0], max_op, line[1], line[2])
                        call setline(linenum, newline)
                    endif
                    let linenum += 1
                endfor
            endfunction

            Note that the first two code blocks
            within the new function are almost
            identical to those in the original.
            As before, they locate the range of
            lines whose assignments are to be
            aligned, based on the current
            indentation of the text.

            The changes begin in the third code
            block, which uses the two-argument
            form of the built-in getline()
            function to return a list of all
            the lines in the range to be
            realigned.

            The for loop then iterates through
            each line, matching it against the
            regular expression in ASSIGN_LINE
            using the built-in matchlist()
            function:

            let fields = matchlist(linetext, ASSIGN_LINE)

            The call to matchlist() returns a
            list of all the fields captured by
            the regex (that is, anything
            matched by those parts of the
            pattern inside \(...\) delimiters).
            In this example, if the match
            succeeds, the resulting fields are
            a decomposition that separates out
            the lvalue, operator, and rvalue of
            any assignment line.

            Specifically, a successful call to
            matchlist() will return a list with
            the following elements:

            - The full line (because
              matchlist()always_ returns the
              entire match as its first
              element)
            - Everything to the left of the
              assignment operator
            - The assignment operator itself
            - Everything to the right of the
              assignment operator

            In that case, the call to add()
            adds a sublist of the final three
            fields to the lines list. If the
            match failed (that is, the line
            didn't contain an assignment), then
            matchlist() will return an empty
            list, so the sublist that add()
            appends (fields[1:3] below) will
            also be empty. This will be used to
            indicate a line of no further
            interest to the reformatter:

            call add(lines, fields[1:3])

            The fourth code block deploys the
            filter() and map() functions to
            analyze the structure of each line
            containing an assignment. It first
            uses a filter() to winnow the list
            of lines, keeping only those that
            were successfully decomposed into
            multiple components by the previous
            code block:

            let op_lines = filter(copy(lines), '!empty(v:val)')

            Next the function determines the
            length of each assignment's lvalue,
            by mapping the strlen() function
            over a copy of the filtered lines:

            map(copy(op_lines), 'strlen(v:val[0])')

            The resulting list of lvalue
            lengths is then passed to the
            built-in max() function to
            determine the longest lvalue in any
            assignment. The maximal length
            determines the column at which all
            the assignment operators will need
            to be aligned (that is, one column
            beyond the widest lvalue):

            let max_lval = max( map(copy(op_lines),'strlen(v:val[0])') ) + 1

            In the same way, the final line of
            the fourth code block determines
            the maximal number of columns
            required to accommodate the various
            assignment operators that were
            found, by mapping and then
            maximizing their individual string
            lengths:

            let max_op = max( map(copy(op_lines),'strlen(v:val[1])'  ) )

            The final code block then reformats
            the assignment lines, by iterating
            through the original buffer line
            numbers (linenum) and through each
            line in the lines list, in
            parallel:

            let linenum = firstline
            for line in lines

            Each iteration of the loop checks
            whether a particular line needs to
            be reformatted (that is, whether it
            was decomposed successfully around
            an assignment operation). If so,
            the function creates a new version
            of the line, using a printf() to
            reformat the line's components:

            if !empty(line)
                let newline = printf("%-*s%*s%s", max_lval, line[0], max_op, line[1], line[2])

            That new line is then written back
            to the editor buffer by calling
            setline(), and the line tracking is
            updated for the next iteration:

            call setline(linenum, newline)
            endif
            let linenum += 1

            Once all the lines have been
            processed, the buffer will have
            been completely updated and all the
            relevant assignment operators
            aligned to a suitable column.
            Because it can take advantage of
            Vimscript's excellent support for
            lists and list operations, the code
            for this second version of
            AlignAssignments() is about 15
            percent shorter than that of the
            previous version. Far more
            importantly, however, the function
            does only one-third as many buffer
            accesses, and the code is much
            clearer and more maintainable.


            Example 2: Enhancing Vim's completion facilities

            Vim has a sophisticated built-in
            text-completion mechanism, which
            you can learn about by typing :help
            ins-completion in any Vim session.

            One of the most commonly used
            completion modes is keyword
            completion. You can use it any time
            you're inserting text, by pressing
            CTRL-N. When you do, it searches
            various locations (as specified by
            the "complete" option), looking for
            words that start with whatever
            sequence of characters immediately
            precedes the cursor. By default, it
            looks in the current buffer you're
            editing, any other buffers you've
            edited in the same session, any tag
            files you've loaded, and any files
            that are included from your text
            (via the include option).

            For example, if you had the
            preceding two paragraphs in a
            buffer, and then - in insertion
            mode - you typed:

            My use of Vim is increasingly so<CTRL-N>

            Vim would search the text and
            determine that the only word
            beginning with "so…" was
            sophisticated, and would complete
            that word immediately:

            My use of Vim is increasingly sophisticated_

            On the other hand, if you typed:

            My repertoire of editing skills is bu<CTRL-N>

            Vim would detect three possible
            completions: built, buffer, and
            buffers. By default, it would show
            a menu of alternatives:

            Listing 21. Text completion with alternatives

            My repertoire of editing skills is bu_
                                               built
                                               buffer
                                               buffers

            and you could then use a sequence
            of CTRL-N and CTRL-P (or the up-
            and down-arrows) to step through
            the menu and select the word you
            wanted.

            To cancel a completion at any time,
            you can type CTRL-E; to accept and
            insert the currently selected
            alternative, you can type CTRL-Y.
            Typing anything else (typically, a
            space or newline) also accepts and
            inserts the currently selected
            word, as well as whatever extra
            character you typed.


            Designing smarter completions

            There's no doubt that Vim's
            built-in completion mechanism is
            extremely useful, but it's not very
            clever. By default, it matches only
            sequences of "keyword" characters
            (alphanumerics and underscore), and
            it has no deep sense of context
            beyond matching what's immediately
            to the left of the cursor.

            The completion mechanism is also
            not very ergonomic. CTRL-N isn't
            the easiest sequence to type, nor
            is it the one a programmer's
            fingers are particularly used to
            typing. Most command-line users are
            more accustomed to using TAB or ESC
            as their completion key.

            Happily, with Vimscript, we can
            easily remedy those deficiencies.
            Let's redefine the TAB key in
            insertion mode so that it can be
            taught to recognize patterns in the
            text on either side of the cursor
            and select an appropriate
            completion for that context. We'll
            also arrange it so that, if the new
            mechanism doesn't recognize the
            current insertion context, it will
            fall back to Vim's built-in CTRL-N
            completion mechanism. Oh, and while
            we're at it, we should probably
            make sure we can still use the TAB
            key to type tab characters, where
            that's appropriate.


            Specifying smarter completions

            To build this smarter completion
            mechanism, we'll need to store a
            series of "contextual responses" to
            a completion request. So we'll need
            a list. Or rather, a list of lists,
            given each contextual response will
            itself consist of four elements.
            Listing 22 shows how to set up that
            data structure.

            Listing 22. Setting up a look-up table in Vimscript

            " Table of completion specifications (a list of lists)...
            let s:completions = []
            " Function to add user-defined completions...
            function! AddCompletion (left, right, completion, restore)
                call insert(s:completions, [a:left, a:right, a:completion, a:restore])
            endfunction
            let s:NONE = ""
            " Table of completions...
            "                    Left   Right    Complete with...       Restore
            "                    =====  =======  ====================   =======
            call AddCompletion(  '{',   s:NONE,  "}",                      1    )
            call AddCompletion(  '{',   '}',     "\<CR>\<C-D>\<ESC>O",     0    )
            call AddCompletion(  '\[',  s:NONE,  "]",                      1    )
            call AddCompletion(  '\[',  '\]',    "\<CR>\<ESC>O\<TAB>",     0    )
            call AddCompletion(  '(',   s:NONE,  ")",                      1    )
            call AddCompletion(  '(',   ')',     "\<CR>\<ESC>O\<TAB>",     0    )
            call AddCompletion(  '<',   s:NONE,  ">",                      1    )
            call AddCompletion(  '<',   '>',     "\<CR>\<ESC>O\<TAB>",     0    )
            call AddCompletion(  '"',   s:NONE,  '"',                      1    )
            call AddCompletion(  '"',   '"',     "\\n",                    1    )
            call AddCompletion(  "'",   s:NONE,  "'",                      1    )
            call AddCompletion(  "'",   "'",     s:NONE,                   0    )

            The list-of-lists we create will
            act as a table of contextual
            response specifications, and will
            be stored in the list variable
            s:completions. Each entry in the
            list will itself be a list, with
            four values:

            - A string specifying a regular
              expression to match what's to the
              left of the cursor
            - A string specifying a regular
              expression to match what's to the
              right of the cursor
            - A string to be inserted when both
              contexts are detected
            - A flag indicating whether to
              automatically restore the cursor
              to its pre-completion position,
              after the completion text has
              been inserted

            To populate the table, we create a
            small function: AddCompletion().
            This function expects four
            arguments: the left and right
            contexts, and the replacement text,
            and the "restore cursor" flag. The
            series of arguments are simply
            collected into a single list:

            [a:left, a:right, a:completion, a:restore]

            and that list is then prepended as
            a single element at the start of
            the s:completions variable using
            the built-in insert() function:

            call insert(s:completions, [a:left, a:right, a:completion, a:restore])

            Repeated calls to AddCompletion()
            therefore build up a list of lists,
            each of which specifies one
            completion. The code in Listing 22
            does the work.

            The first call to AddCompletion():

            "                    Left   Right    Complete with...       Restore
            "                    =====  =======  ====================   =======
            call AddCompletion( '{',    s:NONE,  '}',                   1      )

            specifies that, when the new
            mechanism encounters a curly brace
            to the left of the cursor and
            nothing to the right, it should
            insert a closing curly brace and
            then restore the cursor to its
            pre-completion position. That is,
            when completing:

            while (1) {_

            (where the _ represents the
            cursor), the mechanism will now
            produce:

            while (1) {_}

            leaving the cursor conveniently in
            the middle of the newly closed
            block.

            The second call to AddCompletion():

            "                    Left   Right    Complete with...       Restore
            "                    =====  =======  ====================   =======
            call AddCompletion(  '{',   '}',     "\<CR>\<C-D>\<ESC>O",  0      )

            then proceeds to make the
            completion mechanism smarter still.
            It specifies that, when the
            mechanism encounters an opening
            curly brace to the left of the
            cursor and a closing brace to the
            right of the cursor, it should
            insert a newline, outdent the
            closing curly (via a CTRL-D), then
            escape from insertion mode (ESC)
            and open a new line above the
            closing curly (O).

            Assuming the "smartindent" option
            is enabled, the net effect of the
            sequence is that, when you press
            TAB in the following context

            while (1) {_}

            the mechanism will produce:

            while (1) {
                _
            }

            In other words, because of the
            first two additions to the
            completion table, TAB -completion
            after an opening brace closes it on
            the same line, and then immediately
            doing a second TAB -completion
            "stretches" the block across
            several lines (with correct
            indenting).

            The remaining calls to
            AddCompletion() replicate this
            arrangement for the three other
            kinds of brackets (square, round,
            and angle) and also provide special
            completion semantics for single-
            and double-quotes. Completing after
            a double-quote appends the matching
            double-quote, while completing
            between two double quotes appends a
            \n (newline) metacharacter.
            Completing after a single quote
            appends the matching single quote,
            and then a second completion
            attempt does nothing.


            Implementing smarter completions

            Once the list of
            completion-specifications has been
            set up, all that remains is to
            implement a function to select the
            appropriate completion from the
            table, and then bind that function
            to the TAB key. Listing 23 shows
            that code.

            Listing 23. A smarter completion function

            " Implement smart completion magic...
            function! SmartComplete ()
                " Remember where we parked...
                let cursorpos = getpos('.')
                let cursorcol = cursorpos[2]
                let curr_line = getline('.')

                " Special subpattern to match only at cursor position...
                let curr_pos_pat = '\%' . cursorcol . 'c'

                " Tab as usual at the left margin...
                if curr_line =~ '^\s*' . curr_pos_pat
                    return "\<TAB>"
                endif

                " How to restore the cursor position...
                let cursor_back = "\<C-O>:call setpos('.'," . string(cursorpos) . ")\<CR>"

                " If a matching smart completion has been specified, use that...
                for [left, right, completion, restore] in s:completions
                    let pattern = left . curr_pos_pat . right
                    if curr_line =~ pattern
                        " Code around bug in setpos() when used at EOL...
                        if cursorcol == strlen(curr_line)+1 && strlen(completion)==1
                            let cursor_back = "\<LEFT>"
                        endif

                        " Return the completion...
                        return completion . (restore ? cursor_back : "")
                    endif
                endfor

                " If no contextual match and after an identifier, do keyword completion...
                if curr_line =~ '\k' . curr_pos_pat
                    return "\<C-N>"

                " Otherwise, just be a <TAB>...
                else
                    return "\<TAB>"
                endif
            endfunction

            " Remap <TAB> for smart completion on various characters...
            inoremap <silent> <TAB>   <C-R>=SmartComplete()<CR>

            The SmartComplete() function first
            locates the cursor, using the
            built-in getpos() function with a
            '.' argument (that is, "get
            position of cursor"). That call
            returns a list of four elements:
            the buffer number (usually zero),
            the row and column numbers (both
            indexed from 1), and a special
            "virtual offset" (which is also
            usually zero, and not relevant
            here). We're primarily interested
            in the middle two values, as they
            indicate the location of the
            cursor. In particular,
            SmartComplete() needs the column
            number, which is extracted by
            indexing into the list that
            getpos() returned, like so:

            let cursorcol = cursorpos[2]

            The function also needs to know the
            text on the current line, which can
            be retrieved using getline(), and
            is stored in curr_line.

            SmartComplete() is going to convert
            each entry in the s:completions
            table into a pattern to be matched
            against the current line. In order
            to correctly match left and right
            contexts around the cursor, it
            needs to ensure the pattern matches
            only at the cursor's column. Vim
            has a special subpattern for that:
            \%Nc (where N is the column number
            required). So, the function creates
            that subpattern by interpolating
            the cursor's column position found
            earlier:

            let curr_pos_pat = '\%' . cursorcol . 'c'

            Because we're eventually going to
            bind this function to the TAB key,
            we'd like the function to still
            insert a TAB whenever possible, and
            especially at the start of a line.
            So SmartComplete() first checks if
            there is only whitespace to the
            left of the cursor position, in
            which case it returns a simple
            tabspace:

            if curr_line =~ '^\s*' . curr_pos_pat
                return "\<TAB>"
            endif

            If the cursor isn't at the start of
            a line, then SmartComplete() needs
            to check all the entries in the
            completion table and determine
            which, if any, apply. Some of those
            entries will specify that the
            cursor should be returned to its
            previous position after completion,
            which will require executing a
            custom command from within
            insertion mode. That command is
            simply a call to the built-in
            setpos() function, passing the
            value the original information from
            the earlier call to getpos(). To
            execute that function call from
            within insertion mode requires a
            CTRL-O escape (see :help i_CTRL-O
            in any Vim session). So
            SmartComplete() prebuilds the
            necessary CTRL-O command as a
            string and stores in cursor_back:

            let cursor_back = "\<C-O>:call setpos('.'," . string(cursorpos) . ")\<CR>"


            A more-sophisticated for loop

            To walk through the completions
            table, the function uses a special
            version of the for statement. The
            standard for loop in Vimscript
            walks through a one-dimensional
            list, one element at a time:

            Listing 24. A standard for loop

            for name in list
                echo name
            endfor

            However, if the list is
            two-dimensional (that is, each
            element is itself a list), then you
            often want to "unpack" the contents
            of each nested list as it is
            iterated. You could do that like
            so:

            Listing 25. Iterating over nested lists

            for nested_list in list_of_lists
                let name   = nested_list[0]
                let rank   = nested_list[1]
                let serial = nested_list[2]

                echo rank . ' ' . name . '(' . serial . ')'
            endfor

            but Vimscript has a much cleaner
            shorthand for it:

            Listing 26. A cleaner shorthand for
            iterating over nested lists

            for [name, rank, serial] in list_of_lists
                echo rank . ' ' . name . '(' . serial . ')'
            endfor

            On each iteration, the loop takes
            the next nested list from
            list_of_lists and assigns the first
            element of that nested list to
            name, the second nested element to
            rank, and the third to serial.

            Using this special form of for loop
            makes it easy for SmartComplete()
            to walk through the table of
            completions and give a logical name
            to each component of each
            completion:

            for [left, right, completion, restore] in s:completions


            Recognizing a completion context

            Within the loop, SmartComplete()
            constructs a regular expression by
            placing the left and right context
            patterns around the special
            subpattern that matches the cursor
            position:

            let pattern = left . curr_pos_pat . right

            If the current line matches the
            resulting regex, then the function
            has found the correct completion
            (the text of which is already in
            completion) and can return it
            immediately. Of course, it also
            needs to append the cursor
            restoration command it built
            earlier, if the selected completion
            has requested it (that is, if
            restore is true).

            Unfortunately, that setpos()-based
            cursor restoration command has a
            problem. In Vim versions 7.2 or
            earlier, there's an obscure
            idiosyncrasy in setpos(): it
            doesn't correctly reposition the
            cursor in insertion mode if the
            cursor was previously at the end of
            a line and the completion text to
            be inserted is only one character
            long. In that special case, the
            restoration command has to be
            changed to a single left-arrow,
            which moves the cursor back over
            the one newly inserted character.

            So, before the selected completion
            is returned, the following code
            makes that change:

            Listing 27. Restoring the cursor
            after a one-character insertion at
            end-of-line

            if cursorcol == strlen(curr_line)+1 && strlen(completion)==1
                let cursor_back = "\<LEFT>"
            endif

            All that remains is to return the
            selected completion, appending the
            cursor_back command if cursor
            restoration was requested:

            return completion . (restore ? cursor_back : "")

            If none of the entries from the
            completion table match the current
            context, SmartComplete() will
            eventually fall out of the for loop
            and will then try two final
            alternatives. If the character
            immediately before the cursor was a
            "keyword" character, it invokes a
            normal keyword-completion by
            returning a CTRL-N:

            Listing 28. Falling back to CTRL-N behavior

            " If no contextual match and after an identifier, do keyword completion...
            if curr_line =~ '\k' . curr_pos_pat
                return "\<C-N>"

            Otherwise, no completion was
            possible, so it falls back to
            acting like a normal TAB key, by
            returning a literal tab character:

            Listing 29. Falling back to normal TAB key behavior

            " Otherwise, just be a <TAB>...
            else
                return "\<TAB>"
            endif


            Deploying the new mechanism

            Now we just have to make the TAB
            key call SmartComplete() in order
            to work out what it should insert.
            That's done with an inoremap, like
            so:

            inoremap <silent> <TAB>   <C-R>=SmartComplete()<CR>

            The key-mapping converts any
            insert-mode TAB to a CTRL-R=,
            calling SmartComplete() and
            inserting the completion string it
            returns (see :help i_CTRL-R or the
            first article in this series for
            details of this mechanism).

            The inoremap form of imap is used
            here because some of the completion
            strings that SmartComplete()
            returns also contain a TAB
            character. If a regular imap were
            used, inserting that returned TAB
            would immediately cause this same
            key-mapping to be re-invoked,
            calling SmartComplete() again,
            which might return another TAB, and
            so on.

            With the inoremap in place, we now
            have a TAB key that can:

            - Recognize special user-defined
              insertion contexts and complete
              them appropriately
            - Fall back to regular CTRL-N
              completion after an identifier
            - Still act like a TAB everywhere
              else

            In addition, with the code from
            Listings 22 and 23 placed in your
            .vimrc file, you will be able to
            add new contextual completions
            simply by extending the completion
            table with extra calls to
            AddCompletion(). For example, you
            could make it easier to start new
            Vimscript functions with:

            call AddCompletion( 'function!\?',  "",  "\<CR>endfunction", 1 )

            so that tabbing immediately after a
            function keyword appends the
            corresponding endfunction keyword
            on the next line.

            Or, you could autocomplete C/C++
            comments intelligently (assuming
            the cindent option is also set)
            with:

            call AddCompletion( '/\*', "",    '*/',                        1 )
            call AddCompletion( '/\*', '\*/', "\<CR>* \<CR>\<ESC>\<UP>A",  0 )

            So that:

            /*_<TAB>

            appends a closing comment delimiter
            after the cursor:

            /*_*/

            and a second TAB at that point
            inserts an elegant multiline
            comment and positions the cursor in
            the middle of it:

            /*
             * _
             */


            Looking ahead

            The ability to store and manipulate
            lists of data greatly increases the
            range of tasks that Vimscript can
            easily accomplish, but lists are
            not always the ideal solution for
            aggregating and storing collections
            of information. For example, the
            re-implemented version of
            AlignAssignments() shown in Listing
            20 contains a printf() call that
            looks like this:

            printf("%-*s%*s%s", max_lval, line[0], max_op, line[1], line[2])

            Using line[0], line[1], and line[2]
            for the various components of a
            code line is certainly not very
            readable, and hence both
            error-prone during initial
            implementation, and unnecessarily
            hard to maintain thereafter.

            This is a common situation: related
            data needs to be collected
            together, but has no inherent or
            meaningful order. In such cases,
            each datum is often better
            identified by some logical name,
            rather than by a numeric index. Of
            course, we could always create a
            set of variables to "name" the
            respective numeric constants:

            let LVAL = 0
            let OP   = 1
            let RVAL = 2

            " and later...

            printf("%-*s%*s%s", max_lval, line[LVAL], max_op, line[OP], line[RVAL])

            But that's a clunky and brittle
            solution, prone to hard-to-find
            errors if the order of components
            were to change within the line
            list, but the variables weren't
            updated appropriately.

            Because collections of named data
            are such a common requirement in
            programming, in most dynamic
            languages there's a common
            construct that provides them: the
            associative array, or hash table,
            or dictionary. As it turns out, Vim
            has dictionaries too. In the next
            article in this series,
            Dictionaries, we'll look at
            Vimscript's implementation of that
            very useful data structure.



                https://developer.ibm.com/tutorials/l-vim-script-4/

            Tutorial

            Scripting the Vim editor, Part 4: Dictionaries
            (Learn when to use dictionaries for cleaner, faster code)

            A dictionary in Vimscript is
            essentially the same as an AWK
            associative array, a Perl hash, or
            a Python dictionary. That is, it's
            an unordered container, indexed by
            strings rather than integers.

            This fourth article in a series on
            Vimscript introduces this important
            data structure and explains its
            various functions for copying,
            filtering, extending, and pruning.
            The examples focus on the
            differences between lists and
            dictionaries, and on those cases
            where the use of a dictionary is a
            better alternative to the
            list-based solutions developed in
            Part 3 on built-in lists.


            Dictionaries in Vimscript

            You create a dictionary in
            Vimscript by using curly braces
            around a list of key/value pairs.
            In each pair, the key and value are
            separated by a colon. For example:

            Listing 1. Creating a dictionary

            let seen = {}   " Haven't seen anything yet

            let daytonum = { 'Sun':0, 'Mon':1, 'Tue':2, 'Wed':3, 'Thu':4, 'Fri':5, 'Sat':6 }
            let diagnosis = {
                \   'Perl'   : 'Tourettes',
                \   'Python' : 'OCD',
                \   'Lisp'   : 'Megalomania',
                \   'PHP'    : 'Idiot-Savant',
                \   'C++'    : 'Savant-Idiot',
                \   'C#'     : 'Sociopathy',
                \   'Java'   : 'Delusional',
                \}

            Once you have created a dictionary,
            you can access its values using the
            standard square-bracket indexing
            notation, but using a string as the
            index instead of a number:

            let lang = input("Patient's name? ")
            let Dx = diagnosis[lang]

            If the key doesn't exist in the
            dictionary, an exception is thrown:

            let Dx = diagnosis['Ruby']
            **E716: Key not present in Dictionary: Ruby**

            However, you can access potentially
            non-existent entries safely, using
            the get() function. get() takes two
            arguments: the dictionary itself,
            and a key to look up in it. If the
            key exists in the dictionary, the
            corresponding value is returned; if
            the key doesn't exist, get()
            returns zero. Alternately, you can
            specify a third argument, in which
            case get() returns that value if
            the key isn't found:

            let Dx = get(diagnosis, 'Ruby')
            " Returns: 0

            let Dx = get(diagnosis, 'Ruby', 'Schizophrenia')
            " Returns: 'Schizophrenia'

            There's a third way to access a
            particular dictionary entry. If the
            entry's key consists only of
            identifier characters
            (alphanumerics and underscores),
            you can access the corresponding
            value using the "dot notation,"
            like so:

            let Dx = diagnosis.Lisp                    " Same as: diagnosis['Lisp']
            diagnosis.Perl = 'Multiple Personality'    " Same as: diagnosis['Perl']

            This special limited notation makes
            dictionaries very easy to use as
            records or structs:

            let user = {}

            let user.name    = 'Bram'
            let user.acct    = 123007
            let user.pin_num = '1337'


            Batch-processing of dictionaries

            Vimscript provides functions that
            allow you to get a list of all the
            keys in a dictionary, a list of all
            its values, or a list of all its
            key/value pairs:

            let keylist   = keys(dict)
            let valuelist = values(dict)
            let pairlist  = items(dict)

            This items() function actually
            returns a list of lists, where each
            "inner" list has exactly two
            elements: one key and the
            corresponding value. Hence items()
            is especially handy for iterating
            through the entries of a
            dictionary:

            for [next_key, next_val] in items(dict)
                let result = process(next_val)
                echo "Result for " next_key " is " result
            endfor


            Assignments and identities

            Assignments in dictionaries work
            exactly as they do for Vimscript
            lists. Dictionaries are represented
            by references (that is, pointers),
            so assigning a dictionary to
            another variable aliases the two
            variables to the same underlying
            data structure. You can get around
            this by first copying or
            deep-copying the original:

            let dict2 = dict1             " dict2 just another name for dict1
            let dict3 = copy(dict1)       " dict3 has a copy of dict1's top-level elements
            let dict4 = deepcopy(dict1)   " dict4 has a copy of dict1 (all the way down)

            Just as for lists, you can compare
            identity with the is operator, and
            value with the == operator:

            if dictA is dictB
                " They alias the same container, so must have the same keys and values
            elseif dictA == dictB
                " Same keys and values, but maybe in different containers
            else
                " Different keys and/or values, so must be different containers
            endif


            Adding and removing entries

            To add an entry to a dictionary,
            just assign a value to a new key:

            let diagnosis['COBOL'] = 'Dementia'

            To merge in multiple entries from
            another dictionary, use the
            extend() function. Both the first
            argument (which is being extended)
            and the second argument (which
            contains the extra entries) must be
            dictionaries:

            call extend(diagnosis, new_diagnoses)

            extend() is also convenient when
            you want to add multiple entries
            explicitly:

            call extend(diagnosis, {'COBOL':'Dementia', 'Forth':'Dyslexia'})

            There are two ways to remove a
            single entry from a dictionary: the
            built-in remove() function, or the
            unlet command:

            let removed_value = remove(dict, "key")unlet dict["key"]

            When removing multiple entries from
            a dictionary, it is cleaner and
            more efficient to use filter(). The
            filter() function works much the
            same way as for lists, except that
            in addition to testing each entry's
            value using v:val, you can also
            test its key using v:key. For
            example:

            Listing 2. Testing values and keys

            " Remove any entry whose key starts with C...
            call filter(diagnosis, 'v:key[0] != "C"')

            " Remove any entry whose value doesn't contain 'Savant'...
            call filter(diagnosis, 'v:val =~ "Savant"')

            " Remove any entry whose value is the same as its key...
            call filter(diagnosis, 'v:key != v:val')


            Other dictionary-related functions

            In addition to filter(),
            dictionaries can use several other
            of the same built-in functions and
            procedures as lists. In almost
            every case (the notable exception
            being string()), a list function
            applied to a dictionary behaves as
            if the function had been passed a
            list of the values of the
            dictionary. Listing 3 shows the
            most commonly used functions.

            Listing 3. Other list functions
            that also work on dictionaries

            let is_empty = empty(dict)           " True if no entries at all

            let entry_count = len(dict)          " How many entries?

            let occurrences = count(dict, str)   " How many values are equal to str?

            let greatest = max(dict)             " Find largest value of any entry
            let least    = min(dict)             " Find smallest value of any entry

            call map(dict, value_transform_str)  " Transform values by eval'ing string

            echo string(dict)                    " Print dictionary as key/value pairs

            The filter() built-in is
            particularly handy for normalizing
            the data in a dictionary. For
            example, given a dictionary
            containing the preferred names of
            users (perhaps indexed by userids),
            you could ensure that each name was
            correctly capitalized, like so:

            call map( names, 'toupper(v:val[0]) . tolower(v:val[1:])' )

            The call to map() walks through
            each value, aliases it to v:val,
            evaluates the expression in the
            string, and replaces the value with
            the result of that expression. In
            this example, it converts the first
            character of the name to uppercase,
            and the remaining characters to
            lowercase, and then uses that
            modified string as the new name
            value.


            Deploying dictionaries for cleaner code

            The third article in this series
            explained Vimscript's variadic
            function arguments with a small
            example that generated comment
            boxes around a specified text.
            Optional arguments could be added
            after the text string to specify
            the comment introducer, the
            character used as the "box," and
            the width of the comment. Listing 4
            reproduces the original function.

            Listing 4. Passing optional arguments as variadic parameters

            function! CommentBlock(comment, ...)
                " If 1 or more optional args, first optional arg is introducer...
                let introducer =  a:0 >= 1  ?  a:1  :  "//"

                " If 2 or more optional args, second optional arg is boxing character...
                let box_char   =  a:0 >= 2  ?  a:2  :  "*"

                " If 3 or more optional args, third optional arg is comment width...
                let width      =  a:0 >= 3  ?  a:3  :  strlen(a:comment) + 2

                " Build the comment box and put the comment inside it...
                return introducer . repeat(box_char,width) . "\<CR>"
                \    . introducer . " " . a:comment        . "\<CR>"
                \    . introducer . repeat(box_char,width) . "\<CR>"
            endfunction

            Variadic arguments are convenient
            for specifying function options but
            suffer from two major drawbacks:
            they impose an explicit ordering on
            the function's parameters, and they
            leave that ordering implicit in
            function calls.


            Revisiting autocomments

            As Listing 4 illustrates, when any
            arguments are optional, it is
            usually necessary to decide in
            advance the order in which they
            must be specified. This necessity
            presents a design problem, however:
            in order to specify a later option,
            the user will have to explicitly
            specify all the options before it
            as well. Ideally, the first option
            would be the most commonly used
            one, the second would be the
            second-most commonly used, etc. In
            reality, deciding on this order
            before the function is widely
            deployed can be difficult: how are
            you supposed to know which option
            will be most important to most
            people?

            The CommentBlock() function in
            Listing 4, for example, assumes
            that the comment introducer is the
            optional argument that is most
            likely to be needed, and so places
            it first in the parameter list. But
            what if a user of the function only
            ever programs in C and C++, and so
            never alters the default
            introducer? Worse, what if it turns
            out that the width of comment
            blocks varies for every new
            project? This will prove very
            annoying, because developers will
            now have to specify all three
            optional arguments every time, even
            though the first two are always
            given their default values:

            " Comment of required width, with standard delimiter and box character...
            let new_comment = CommentBlock(comment_text, '//', '*', comment_width)

            This leads directly to the second
            issue, namely that when any options
            do need to be specified explicitly,
            it is likely that several of them
            will have to be specified. However,
            because options default to the most
            commonly needed values, the user
            may be unfamiliar with specifying
            options, and hence unfamiliar with
            the necessary order. This can lead
            to implementation errors like the
            following:

            " Box comment using ==== to standard line width...
            let new_comment = CommentBlock(comment_text, '=', 72)

            …which, rather disconcertingly,
            produces a (non-)comment that looks
            like this:

            =727272727272727272727272727272 = A bad comment
            =727272727272727272727272727272

            The problem is that the optional
            arguments have nothing explicit to
            indicate which option they are
            supposed to set. Their meaning is
            determined implicitly by their
            position in the argument list, and
            so any mistake in their ordering
            silently changes their meaning.

            This is a classic case of using the
            wrong tool for the job. Lists are
            perfect when order is significant
            and identity is best implied by
            position. But, in this example, the
            order of the optional arguments is
            more a nuisance than a benefit and
            their positions are easily
            confused, which can lead to subtle
            errors of misidentification.

            What's wanted is, in a sense, the
            exact opposite of a list: a data
            structure where order is
            irrelevant, and identity is
            explicit. In other words, a
            dictionary. Listing 5 shows the
            same function, but with its options
            specified via a dictionary, rather
            than with variadic parameters.

            Listing 5. Passing optional
            arguments in a dictionary

            function! CommentBlock(comment, opt)
                " Unpack optional arguments...
                let introducer = get(a:opt, 'intro', '//'                 )
                let box_char   = get(a:opt, 'box',   '*'                  )
                let width      = get(a:opt, 'width', strlen(a:comment) + 2)" Build the comment box and put the comment inside it...
                return introducer . repeat(box_char,width) . "\<CR>"
                \    . introducer . " " . a:comment        . "\<CR>"
                \    . introducer . repeat(box_char,width) . "\<CR>"
            endfunction

            In this version of the function,
            only two arguments are passed: the
            essential comment text, followed by
            a dictionary of options. The
            built-in get() function is then
            used to retrieve each option, or
            its default value, if the option
            was not specified. Calls to the
            function then use the named
            option/value pairs to configure its
            behavior. The implementation of the
            parameter parsing within the
            function becomes a little cleaner,
            and calls to the function becomes
            much more readable, and less
            error-prone. For example:

            " Comment of required width, with standard delimiter and box character...
            let new_comment = CommentBlock(comment_text, {'width':comment_width})

            " Box comment using ==== to standard line width...
            let new_comment = CommentBlock(comment_text, {'box':'=', 'width':72})


            Refactoring autoalignments

            In the third article in this
            series, we updated an earlier
            example function called
            AlignAssignments(), converting it
            to use lists to store the text
            lines it was modifying. Listing 6
            reproduces that updated version of
            the function.

            Listing 6. The updated AlignAssignments() function

            function! AlignAssignments ()
                " Patterns needed to locate assignment operators...
                let ASSIGN_OP   = '[-+*/%|&]\?=\@<!=[=~]\@!'
                let ASSIGN_LINE = '^\(.\{-}\)\s*\(' . ASSIGN_OP . '\)\(.*\)$'

                " Locate block of code to be considered (same indentation, no blanks)...
                let indent_pat = '^' . matchstr(getline('.'), '^\s*') . '\S'
                let firstline  = search('^\%('. indent_pat . '\)\@!','bnW') + 1
                let lastline   = search('^\%('. indent_pat . '\)\@!', 'nW') - 1
                if lastline < 0
                    let lastline = line('$')
                endif

                " Decompose lines at assignment operators...
                let lines = []
                for linetext in getline(firstline, lastline)
                    let fields = matchlist(linetext, ASSIGN_LINE)
                    call add(lines, fields[1:3])
                endfor

                " Determine maximal lengths of lvalue and operator...
                let op_lines = filter(copy(lines),'!empty(v:val)')
                let max_lval = max( map(copy(op_lines), 'strlen(v:val[0])') ) + 1
                let max_op   = max( map(copy(op_lines), 'strlen(v:val[1])'  ) )

                " Recompose lines with operators at the maximum length...
                let linenum = firstline
                for line in lines
                    if !empty(line)
                        let newline
                        \    = printf("%-*s%*s%s", max_lval, line[0], max_op, line[1], line[2])
                        call setline(linenum, newline)
                    endif
                    let linenum += 1
                endfor
            endfunction

            This version greatly improved the
            efficiency of the function, by
            caching data rather than reloading
            it, but it did so at the expense of
            maintainability. Specifically,
            because it stored the various
            components of each line in small
            three-element arrays, the code is
            littered with "magic indexes" (such
            as v:val[0] and line[1]) whose
            names give no clue as to their
            purpose.

            Dictionaries are tailor-made for
            solving this problem, because, like
            lists, they aggregate data into a
            single structure, but, unlike
            lists, they label each datum with a
            string, rather than with a number.
            If those strings are selected
            carefully, they can make the
            resulting code much clearer.
            Instead of magic indexes, we get
            meaningful names (such as
            v:val.lval for each line's lvalue
            and line.op for each line's
            operator).

            Rewriting the function using
            dictionaries is trivially easy, as
            Listing 7 demonstrates.

            Listing 7. A further-improved
            AlignAssignments() function

            function! AlignAssignments ()
                " Patterns needed to locate assignment operators...
                let ASSIGN_OP   = '[-+*/%|&]\?=\@<!=[=~]\@!'
                let ASSIGN_LINE = '^\(.\{-}\)\s*\(' . ASSIGN_OP . '\)\(.*\)$'

                " Locate block of code to be considered (same indentation, no blanks)...
                let indent_pat = '^' . matchstr(getline('.'), '^\s*') . '\S'
                let firstline  = search('^\%('. indent_pat . '\)\@!','bnW') + 1
                let lastline   = search('^\%('. indent_pat . '\)\@!', 'nW') - 1
                if lastline < 0
                    let lastline = line('$')
                endif

                " Decompose lines at assignment operators...
                let lines = []
                for linetext in getline(firstline, lastline)
                    let fields = matchlist(linetext, ASSIGN_LINE)
                    if len(fields)
                        call add(lines, {'lval':fields[1], 'op':fields[2], 'rval':fields[3]})
                    else
                        call add(lines, {'text':linetext,  'op':''                         })
                    endif
                endfor

                " Determine maximal lengths of lvalue and operator...
                let op_lines = filter(copy(lines),'!empty(v:val.op)')
                let max_lval = max( map(copy(op_lines), 'strlen(v:val.lval)') ) + 1
                let max_op   = max( map(copy(op_lines), 'strlen(v:val.op)'  ) )

                " Recompose lines with operators at the maximum length...
                let linenum = firstline
                for line in lines
                    let newline = empty(line.op)
                    \ ? line.text
                    \ : printf("%-*s%*s%s", max_lval, line.lval, max_op, line.op, line.rval)
                    call setline(linenum, newline)
                    let linenum += 1
                endfor
            endfunction

            The differences in this new version
            are marked in bold. There are only
            two: the record for each line is
            now a dictionary rather than a
            hash, and the subsequent accesses
            to elements of each record use
            named lookups instead of numeric
            indexing. The overall result is
            that the code is more readable and
            less prone to the kinds of
            off-by-one errors common to array
            indexing.


            Dictionaries as data structures

            Vim provides a built-in command
            that allows you to remove duplicate
            lines from a file:

            :%sort u

            The u option causes the built-in
            sort command to remove duplicate
            lines (once they've been sorted),
            and the leading % applies that
            special sort to the entire file.
            That's handy, but only if you don't
            care about preserving the original
            order of the unique lines in the
            file. This might be a problem if
            the lines are a list of prize
            winners, a sign-up sheet for a
            finite resource, a to-do list, or
            any other sequence in which
            first-in should remain
            best-dressed.


            Sort-free uniqueness

            The keys of a dictionary are
            inherently unique, so it's possible
            to use a dictionary to remove
            duplicate lines from a file, and to
            do so in a way that preserves the
            original ordering of those lines.
            Listing 8 illustrates a simple
            function that achieves this goal.

            Listing 8. A function for order-preserving uniqueness

            function! Uniq () range
                " Nothing unique seen yet...
                let have_already_seen = {}
                let unique_lines = []

                " Walk through the lines, remembering only the hitherto-unseen ones...
                for original_line in getline(a:firstline, a:lastline)
                    let normalized_line = '>' . original_line
                    if !has_key(have_already_seen, normalized_line)
                        call add(unique_lines, original_line)
                        let have_already_seen[normalized_line] = 1
                    endif
                endfor

                " Replace the range of original lines with just the unique lines...
                exec a:firstline . ',' . a:lastline . 'delete'
                call append(a:firstline-1, unique_lines)
            endfunction

            The Uniq() function is declared to
            take a range, so it will only be
            called once, even when invoked on a
            range of lines in the buffer.

            When called, it first sets up an
            empty dictionary
            (have_already_seen) that will be
            used to track which lines have
            already been encountered within the
            specified range. Lines that haven't
            been seen before will then be added
            to the list stored in unique_lines.

            The function then provides a loop
            that does precisely that. It grabs
            the specified range of lines from
            the buffer with a getline() and
            iterates through each. It first
            adds a leading '>' to each line to
            ensure it is not empty. Vimscript
            dictionaries cannot store an entry
            whose key is an empty string, so
            empty lines from the buffer would
            not be correctly added to
            have_already_seen.

            Once the line is normalized, the
            function then checks whether that
            line has already been used as a key
            in the have_already_seen
            dictionary. If so, an identical
            line must already have been seen
            and added to unique_lines, so the
            copy can be ignored. Otherwise, the
            line is being encountered for the
            first time, so the original
            (un-normalized) line must be added
            to unique_lines, and the normalized
            version must be added as a key in
            have_already_seen.

            When all the lines have been
            filtered in this way, unique_lines
            will contain only the unique subset
            of them, in the order in which they
            were first encountered. All that
            remains is to delete the original
            set of lines and replace it (via an
            append()) with these accumulated
            unique lines.

            With such a function available, you
            could set up a Normal-mode keymap
            to invoke the command on entire
            files, like so:

            nmap ;u :%call Uniq()<CR>

            Or you could apply it to a specific
            set of lines (for example, a range
            that had been selected in Visual
            mode), like so:

            vmap  u :call Uniq()<CR>


            Looking ahead

            The basic features of Vimscript
            covered so far (statements and
            functions, arrays, and hashes) are
            sufficient to create almost any
            kind of addition to Vim's core
            feature set. But all the extensions
            we have seen have required the user
            to explicitly request behavior, by
            issuing a Normal-mode command or
            typing a particular sequence in
            Insert mode.

            In the next article in this series,
            Event-driven scripting and
            automation, we'll investigate Vim's
            built-in event model and explore
            how to set up user-defined
            functions that trigger
            automatically as the user edits.



                https://developer.ibm.com/tutorials/l-vim-script-5/

            Tutorial

            Scripting the Vim editor, Part 5: Event-driven scripting and automation
            (Automate your workflow with Vim's autocommands)

            By Damian Conway
            Published March 3, 2010


            Vim's event model

            Vim's editing functions behave as
            if they are event-driven. For
            performance reasons, the actual
            implementation is more complex than
            that, with much of the event
            handling optimized away or handled
            several layers below the event loop
            itself, but you can still think of
            the editor as a simple while loop
            responding to a series of editing
            events.

            Whenever you start a Vim session,
            open a file, edit a buffer, change
            your editing mode, switch windows,
            or interact with the surrounding
            filesystem, you are effectively
            queuing an event that Vim
            immediately receives and handles.

            For example, if you start Vim, edit
            a file named demo.txt, swap into
            Insert mode, type in some text,
            save the file, and then exit, your
            Vim session receives a series of
            events like what is shown in
            Listing 1.

            Listing 1. Event sequence in a
            simple Vim editing session

            > vim
                BufWinEnter     (create a default window)
                BufEnter        (create a default buffer)
                VimEnter        (start the Vim session):edit example.txt
                BufNew          (create a new buffer to contain demo.txt)
                BufAdd          (add that new buffer to the session's buffer list)
                BufLeave        (exit the default buffer)
                BufWinLeave     (exit the default window)
                BufUnload       (remove the default buffer from the buffer list)
                BufDelete       (deallocate the default buffer)
                BufReadCmd      (read the contexts of demo.txt into the new buffer)
                BufEnter        (activate the new buffer)
                BufWinEnter     (activate the new buffer's window)i
                InsertEnter     (swap into Insert mode)
            Hello
                CursorMovedI    (insert a character)
                CursorMovedI    (insert a character)
                CursorMovedI    (insert a character)
                CursorMovedI    (insert a character)
                CursorMovedI    (insert a character)<ESC>
                InsertLeave     (swap back to Normal mode):wq
                BufWriteCmd     (save the buffer contents back to disk)
                BufWinLeave     (exit the buffer's window)
                BufUnload       (remove the buffer from the buffer list)
                VimLeavePre     (get ready to quit Vim)
                VimLeave        (quit Vim)

            More interestingly, Vim provides
            "hooks" that allow you to intercept
            any of these editing events. So you
            can cause a particular Vimscript
            command or function to be executed
            every time a specific event occurs:
            every time Vim starts, every time a
            file is loaded, every time you
            leave Insert mode… or even every
            time you move the cursor. This
            makes it possible to add automatic
            behaviors almost anywhere
            throughout the editor.


            Vim provides notifications for 78
            distinct editing events, which fall
            into eight broad categories:
            session start-up and clean-up
            events, file-reading events,
            file-writing events, buffer-change
            events, option-setting events,
            window-related events,
            user-interaction events, and
            asynchronous notifications.

            To see the complete list of these
            events, type :help autocmd-events
            on the Vim command line. For
            detailed descriptions of each
            event, see :help
            autocmd-events-abc.

            This article explains how events
            work in Vim and then introduces a
            series of scripts for automating
            editing events and behaviours.


            Event handling with autocommands

            The mechanism Vim provides for
            intercepting events is known as the
            autocommand. Each autocommand
            specifies the type of event to be
            intercepted, the name of the edited
            file in which such events are to be
            intercepted, and the command-line
            mode action to be taken when the
            event is detected. The keyword for
            all this is autocmd (which is often
            abbreviated to just au). The usual
            syntax is:

            autocmd  EventName  filename_pattern   :command

            The event name is one of the 78
            valid Vim event names (as listed
            under :help autocmd-events). The
            filename pattern syntax is similar
            - but not identical - to a normal
            shell pattern (see :help
            autocmd-patterns for details). The
            command is any valid Vim command,
            including calls to Vimscript
            functions. The colon at the start
            of the command is optional, but
            it's a good idea to include it;
            doing so makes the command easier
            to locate in the (usually complex)
            argument list of an autocmd.

            For example, you could surrender
            all remaining dignity and specify
            an event handler for the
            FocusGained event by adding the
            following to your .vimrc file:

            autocmd  FocusGained  *.txt   :echo 'Welcome back, ' . $USER . '! You look great!'

            FocusGained events are queued
            whenever a Vim window becomes the
            window system's input focus, so now
            whenever you swap back to your Vim
            session, if you're editing any file
            whose name matches the filename
            pattern *.txt, then Vim will
            automatically execute the specified
            echo command.

            You can set up as many handlers for
            the same event as you wish, and all
            of them will be executed in the
            sequence in which they were
            originally specified. For example,
            a far more useful automation for
            FocusGained events might be to have
            Vim briefly emphasize the cursor
            line whenever you swap back to your
            editing session, as shown in
            Listing 2.

            Listing 2. A useful automation for FocusGained events

            autocmd  FocusGained  *.txt   :set cursorline
            autocmd  FocusGained  *.txt   :redraw
            autocmd  FocusGained  *.txt   :sleep 1
            autocmd  FocusGained  *.txt   :set nocursorline

            These four autocommands cause Vim
            to automatically highlight the line
            containing the cursor (set
            cursorline), reveal that
            highlighting (redraw), wait one
            second (sleep 1), and then switch
            the highlighting back off (set
            nocursorline).

            You can use any series of commands
            in this way; you can even break up
            a single control structure across
            multiple autocommands. For example,
            you could set up a global variable
            (g:autosave_on_focus_change) to
            control an "autosave"mechanism that
            automatically writes any modified
            .txt file whenever the user swaps
            away from Vim to some other window
            (causing a FocusLost event to be
            queued):

            Listing 3. Autocommand to autosave
            when leaving an editor window

            autocmd  FocusLost  *.txt   :    if &modified && g:autosave_on_focus_change
            autocmd  FocusLost  *.txt   :    write
            autocmd  FocusLost  *.txt   :    echo "Autosaved file while you were absent"
            autocmd  FocusLost  *.txt   :    endif

            Multi-line autocommands like this
            require that you repeat the
            essential event-selector
            specification (i.e., FocusLost
            *.txt) multiple times. Hence they
            are generally unpleasant to
            maintain, and more error-prone.
            It's much cleaner and safer to
            factor out any control structure,
            or other command sequences, into a
            separate function and then have a
            single autocommand call that
            function. For example:

            Listing 4. A cleaner way to handle
            multi-line autocommands

            function! Highlight_cursor ()
                set cursorline
                redraw
                sleep 1
                set nocursorline
            endfunction
            function! Autosave ()
               if &modified && g:autosave_on_focus_change
                   write
                   echo "Autosaved file while you were absent"
               endif
            endfunction

            autocmd  FocusGained  *.txt   :call Highlight_cursor()
            autocmd  FocusLost    *.txt   :call Autosave()


            Universal and single-file autocommands

            So far, all the examples shown have
            restricted event handling to files
            that matched the pattern *.txt.
            Obviously, that implies that you
            can use any file-globbing pattern
            to specify the files to which a
            particular autocommand applies. For
            example, you could make the
            previous cursor-highlighting
            FocusGained autocommand apply to
            any file simply by using the
            universal file-matching pattern *
            as the filename filter:

            " Cursor-highlight any file when context-switching ...
            autocmd  FocusGained  *          :call Highlight_cursor()

            Alternatively, you can restrict
            commands to a single file:

            " Only cursor-highlight for my .vimrc ...
            autocmd  FocusGained  ~/.vimrc   :call Highlight_cursor()

            Note that this also implies that
            you can specify different behaviors
            for the same event, depending on
            which file is being edited. For
            example, when the user turns their
            attention elsewhere, you might
            choose to have text files
            autosaved, or have Perl or Python
            scripts check-pointed, while a
            documentation file might be
            instructed to reformat the current
            paragraph, as shown in Listing 5.

            Listing 5. What to do when the
            user's attention is elsewhere

            autocmd  FocusLost  *.txt   :call Autosave()
            autocmd  FocusLost  *.p[ly] :call Checkpoint_sourcecode()
            autocmd  FocusLost  *.doc  :call Reformat_current_para()


            Autocommand groups

            Autocommands have an associated
            namespace mechanism that allows
            them to be gathered into
            autocommand groups, whence they can
            be manipulated collectively.

            To specify an autocommand group,
            you can use the augroup command.
            The general syntax for the command
            is:

            augroup GROUPNAME
                " autocommand specifications here ...
            augroup END

            The group's name can be any series
            of non-whitespace characters,
            except "end"or "END ", which are
            reserved for specifying the end of
            a group.

            Within an autocommand group, you
            can place any number of
            autocommands. Typically, you would
            group commands by the event they
            all respond to, as shown in Listing
            6.

            Listing 6. Defining a group for
            autocommands responding to
            FocusLost events

            augroup Defocus
                autocmd  FocusLost  *.txt   :call Autosave()
                autocmd  FocusLost  *.p[ly] :call Checkpoint_sourcecode()
                autocmd  FocusLost  *.doc   :call Reformat_current_para()
            augroup END

            Or you might group a series of
            autocommands relating to a single
            filetype, such as:

            Listing 7. Defining a group of
            autocommands for handling text
            files

            augroup TextEvents
                autocmd  FocusGained  *.txt   :call Highlight_cursor()
                autocmd  FocusLost    *.txt   :call Autosave()
            augroup END


            Deactivating autocommands

            You can remove specific event
            handlers using the autocmd! command
            (that is, with an exclamation
            mark). The general syntax for this
            command is:

            autocmd!  [group]  [EventName [filename_pattern]]

            To remove a single event handler,
            specify all three arguments. For
            example, to remove the handler for
            FocusLost events on .txt files from
            the Unfocussed group, use:

            autocmd!  Unfocussed  FocusLost  *.txt

            Instead of a specific event name,
            you can use an asterisk to indicate
            that every kind of event should be
            removed for the particular group
            and filename pattern. If you wanted
            to remove all events for .txt files
            within the Unfocussed group, you
            would use:

            autocmd!  Unfocussed      *      *.txt

            If you leave off the filename
            pattern, then every handler for the
            specified event type is removed.
            You could remove all the FocusLost
            handlers in the Unfocussed group
            like so:

            autocmd!  Unfocussed  FocusLost

            If you also leave out the event
            name, then every event handler in
            the specified group is removed. So,
            to turn off all event handling
            specified in the Unfocussed group:

            autocmd!  Unfocussed

            Finally, if you omit the group
            name, the autocommand removal
            applies to the currently active
            group. The typical use of this
            option is to "clear the decks"
            within a group before setting up a
            series of autocommands. For
            example, the Unfocussed group is
            better specified like so:

            Listing 8. Making sure a group is
            empty before adding new
            autocommands

            augroup Unfocussed
                autocmd!

                autocmd  FocusLost  *.txt   :call Autosave()
                autocmd  FocusLost  *.p[ly] :call Checkpoint_sourcecode()
                autocmd  FocusLost  *.doc   :call Reformat_current_para()
            augroup END

            Adding an autocmd! to the start of
            every group is important because
            autocommands do not statically
            declare event handlers; they
            dynamically create them. If you
            execute the same autocmd twice, you
            get two event handlers, both of
            which will be separately invoked by
            the same combination of event and
            filename from that point onward. By
            starting each autocommand group
            with an autocmd!, you wipe out any
            existing handlers within the group
            so that subsequent autocmd
            statements replace any existing
            handlers, rather than augmenting
            them. This, in turn, means that
            your script can be executed as many
            times as necessary (or your .vimrc
            can be source'd repeatedly) without
            multiplying event-handling entities
            unnecessarily.


            Some practical examples

            The appropriate use of autocommands
            can make your editing life vastly
            easier. Let's look at a few ways
            you can use autocommands to
            streamline your editing process and
            remove existing frustrations.


            Managing simultaneous edits

            One of the most useful features of
            Vim is that it automatically
            detects when you attempt to edit a
            file that is currently being edited
            by some other instance of Vim. That
            often happens in multi-window
            environments, where you're already
            editing a file in another terminal;
            or in multi-user setups, where
            someone else is already working on
            a shared file. When Vim detects a
            second attempt to edit a particular
            file, you get the following
            request:

            Swap file ".filename.swp" already exists!
            [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort: _

            Depending on the environment in
            which you're working, your fingers
            probably automatically hit one of
            those options every time, without
            much conscious thought on your
            part. For example, if you rarely
            work on shared files, you probably
            just hit q to terminate the
            session, and then go hunting for
            the terminal window where you're
            already editing the file. On the
            other hand, if you typically edit
            shared resources, perhaps your
            fingers are trained to immediately
            hit \<enter\>, in order to select
            the default option and open the
            file read-only.

            With autocommands, however, you can
            completely eliminate the need to
            see, recognize, and respond to that
            message, simply by automating the
            response to the SwapExists event
            that triggers it. For example, if
            you never want to edit files that
            are already being edited elsewhere,
            you could add the following to your
            .vimrc:

            Listing 9. Automatically quitting
            on simultaneous edits

            augroup NoSimultaneousEdits
                autocmd!
                autocmd  SwapExists  *  :let v:swapchoice = 'q'
            augroup END

            This sets up an autocommand group,
            and removes any previous handlers
            (via the autocmd! command). It then
            installs a handler for the
            SwapExists event on any file (using
            the universal file pattern: *).
            That handler simply assigns the
            response 'q' to the special
            v:swapchoice variable. Vim consults
            this variable prior to displaying
            the "swapfile exists"message. If
            the variable has been set, it uses
            the value as the automatic response
            and doesn't bother showing the
            message. So now you'll never see
            the swapfile message; your Vim
            session will just automatically
            quit if you try to edit a file
            that's being edited elsewhere.

            Alternately, if you'd prefer always
            to open already edited files in
            read-only mode, you can simply
            change the NoSimultaneousEdits
            group to:

            Listing 10. Automating read-only
            access to existing files

            augroup NoSimultaneousEdits
                autocmd!
                autocmd  SwapExists  *  :let v:swapchoice = 'o'
            augroup END

            More interestingly, you could
            arrange to select between these two
            (or any other) alternatives, based
            on the location of the file being
            considered. For example, you might
            prefer to auto-quit files in your
            own subdirectories, but open shared
            files under /dev/shared/ as
            read-only. You could do that with
            the following:

            Listing 11. Automating a context-sensitive response

            augroup NoSimultaneousEdits
                autocmd!
                autocmd  SwapExists  ~/*            :let v:swapchoice = 'q'
                autocmd  SwapExists  /dev/shared/*  :let v:swapchoice = 'o'
            augroup END

            That is: if the full filename
            begins with the home directory,
            followed by anything at all (~/*),
            then preselect the "quit"
            behaviour; but if the full filename
            starts with the shared directory
            (/dev/shared/*), then preselect the
            "read-only" behaviour instead.


            Autoformatting code consistently

            Vim has good support for automatic
            edit-time code layout (see :help
            indent.txt and :help filter). For
            example, you can turn on the
            'autoindent' and 'smartindent'
            options and have Vim re-indent your
            code blocks automatically as you
            type. Or you can hook your own
            language-specific code reformatter
            to the standard = command by
            setting the 'equalprg' option.

            Unfortunately, Vim doesn't have an
            option or a command to deal with
            one of the commonest
            code-formatting situations: being
            forced to read someone else's
            abysmally malformatted code.
            Specifically, there's no built-in
            option to tell Vim to automatically
            sanitize the formatting of any code
            file you open.

            That's okay because it's trivially
            easy to set up an autocommand to do
            that instead.

            For example, you could add the
            following autocommand group to your
            .vimrc, so that C, Python, Perl,
            and XML files are automatically run
            through the appropriate code
            formatter whenever you open a file
            of the corresponding type, as shown
            in Listing 12.

            Listing 12. Beautiful code, on autocommand

            augroup CodeFormatters
                autocmd!

                autocmd  BufReadPost,FileReadPost   *.py    :silent %!PythonTidy.py
                autocmd  BufReadPost,FileReadPost   *.p[lm] :silent %!perltidy -q
                autocmd  BufReadPost,FileReadPost   *.xml   :silent %!xmlpp -t -c -n
                autocmd  BufReadPost,FileReadPost   *.[ch]  :silent %!indent
            augroup END

            All of the autocommands in the
            group are identical in structure,
            differing only in the filename
            extensions to which they apply and
            the corresponding pretty-printer
            they invoke.

            Note that the autocommands do not
            name a single event to be handled.
            Instead, each one specifies a list
            of events. Any autocmd can be
            specified with a comma-separated
            list of event types, in which case
            the handler will be invoked for any
            of the events listed.

            In this case, the events listed for
            each handler are BufReadPost (which
            is queued whenever an existing file
            is loaded into a new buffer) and
            FileReadPost (which is queued
            immediately after any :read command
            is executed). These two events are
            often specified together because
            between them they cover the most
            common ways of loading the contents
            of an existing file into a buffer.

            After the event list, each
            autocommand specifies the file
            suffix(es) to which it applies:
            Python's .py, Perl's .pl and .pm,
            XML's .xml, or the .c and .h files
            of C. Note that, as with events,
            these filename patterns could also
            have been specified as a
            comma-separated list, rather than a
            single pattern. For example, the
            Perl handler could have been
            written:

            autocmd  BufReadPost,FileReadPost   *.pl,*.pm   :silent %!perltidy -q

            or the C handler could be extended
            to handle common C++ variants (.C,
            .cc, .cxx, etc.) as well, like so:

            autocmd  BufReadPost,FileReadPost   *.[chCH],*.cc,*.hh,*.[ch]xx  :silent %!indent

            As usual, the final component of
            each autocommand is the command to
            be executed. In each case, it is a
            global filter command
            (**%!filter_program**), which takes
            the entire contents of the file (%)
            and pipes it out (!) to the
            specified external program (one of:
            PythonTidy.py, perltidy, xmlpp, or
            indent). The output of each program
            is then pasted back into the
            buffer, replacing the original
            contents.

            Normally, when filter commands like
            these are used, Vim automatically
            displays a notification after the
            command completes, like so:

            42 lines filtered
            Press ENTER or type command to continue_

            To prevent this annoyance, each of
            the autocommands prefixes its
            action with a :silent, which
            neutralizes any ordinary
            information messages, but still
            allows error messages to be
            displayed.


            Opportunistic code autoformatting

            Vim has excellent support for
            automatically formatting C code as
            you type it, but it offers less
            support for other languages. That's
            not entirely Vim's fault; some
            languages - yes, Perl, I'm looking
            at you - can be extremely hard to
            format correctly on the fly.

            If Vim doesn't give you adequate
            support for autoformatting source
            code in your preferred language,
            you can easily have your editor
            invoke an external utility to do
            that for you.

            The simplest approach is to make
            use of the InsertLeave event. This
            event is queued whenever you exit
            from Insert mode (most commonly,
            immediately after you hit <ESC>).
            You can easily set up a handler
            that reformats your code every time
            you finish adding to it, like so:

            Listing 13. Invoking PerlTidy after every edit

            function! TidyAndResetCursor ()
                let cursor_pos = getpos('.')
                %!perltidy -q
                call setpos('.', cursor_pos)
            endfunction

            augroup PerlTidy
                autocmd!
                autocmd InsertLeave *.p[lm]  :call TidyAndResetCursor()
            augroup END

            The TidyAndResetCursor() function
            first makes a record of the current
            cursor position, by storing the
            cursor information returned by the
            built-in getpos() in the variable
            cursor_pos. It then runs the
            external perltidy utility over the
            entire file (%!perltidy -q), and
            finally restores the cursor to its
            original position, by passing the
            saved cursor information to the
            built-in setpos() function.

            Inside the PerlTidy group, you then
            just set up a single autocommand
            that calls TidyAndResetCursor()
            every time the user leaves Insert
            mode within any Perl file.

            This same code pattern could be
            adapted to perform any appropriate
            action each time you insert text.
            For example, if you were working on
            a very unreliable system and wished
            to maximize your ability to recover
            files (see :help usr_11.txt) if
            something went wrong, you could
            arrange for Vim to update its
            swap-file every time you left
            Insert mode, like so:

            augroup UpdateSwap
                autocmd!
                autocmd  InsertLeave  *  :preserve
            augroup END


            Timestamping files

            Another useful set of events are
            BufWritePre, FileWritePre, and
            FileAppendPre. These "Pre" events
            are queued just before your Vim
            session writes a buffer back to
            disk (as a result of a command such
            as :write, :update, or :saveas). A
            BufWritePre event occurs just
            before the entire buffer is
            written, a FileWritePre occurs just
            before part of a buffer is written
            (that is, when you specify a range
            of lines to be written:
            :1,10write). A FileAppendPre occurs
            just before a :write command is
            used to append rather than replace;
            for example:

            :write >> logfile.log).

            For all three types of events, Vim
            sets the special line-number
            aliases '[ and '] to the range of
            lines being written. These aliases
            can then be used in the range
            specifier of any subsequent
            command, to ensure that autocommand
            actions are applied only to the
            relevant lines.

            Typically, you would set up a
            single handler that covered all
            three types of pre-writing event.
            For example, you could have Vim
            automatically update an internal
            timestamp whenever a file was
            written (or appended) to disk, as
            shown in Listing 14.

            Listing 14. Automatically updating
            an internal timestamp whenever a
            file is saved

            function! UpdateTimestamp ()
                '[,']s/^This file last updated: \zs.*/\= strftime("%c") /
            endfunction

            augroup TimeStamping
                autocmd!

                autocmd BufWritePre,FileWritePre,FileAppendPre  *  :call UpdateTimestamp()
            augroup END

            The UpdateTimestamp() function
            performs a substitution
            (s/.../.../) on every line being
            written, by specifically limiting
            the range of the substitution to
            between '[ and '] like so:
            '[,']s/.../.../. The substitution
            looks for lines starting with "This
            file last updated: ", followed by
            anything (.*). The \zs before the
            .* causes the substitution to
            pretend that the match only started
            after the colon, so only the actual
            timestamp is replaced.

            To update the timestamp, the
            substitution uses the special \=
            escape sequence in the replacement
            text. This escape sequence tells
            Vim to treat the replacement text
            as a Vimscript expression,
            evaluating it to get the actual
            replacement string. In this case,
            that expression is a call to the
            built-in strftime() function, which
            returns a standard timestamp string
            of the form: "Fri Oct 23 14:51:01
            2009". This string is then written
            back into the timestamp line by the
            substitution command.

            All that remains is to set up an
            event handler (autocmd) for all
            three event types (BufWritePre,
            FileWritePre, FileAppendPre) in any
            file (*) and have it invoke the
            appropriate timestamping function
            (:call UpdateTimestamp()). Now, any
            time a file is written, any
            timestamp in the lines being saved
            will be updated to the current
            time.

            Note that Vim provides two other
            sets of events that you can use to
            modify the behavior of write
            operations. To automate some action
            that should happen after a write,
            you can use BufWritePost,
            FileWritePost, and FileAppendPost.
            To completely replace the standard
            write behavior with your own
            script, you can use BufWriteCmd,
            FileWriteCmd, and FileAppendCmd
            (but consult :help Cmd-event first
            for some important caveats).


            Table-driven timestamps

            Of course, you could also create
            much more elaborate mechanisms to
            handle files with different
            timestamping conventions. For
            example, you might prefer to
            specify the various timestamp
            signatures and their replacements
            in a Vim dictionary (see the
            previous article in this series)
            and then loop through each pair to
            determine how the timestamp should
            be updated. This approach is shown
            in Listing 15.

            Listing 15. Table-driven automatic timestamps

            let s:timestamps = {
            \  'This file last updated: \zs.*'             :  'strftime("%c")',
            \  'Last modification: \zs.*'                  :  'strftime("%Y%m%d.%H%M%S")',
            \  'Copyright (c) .\{-}, \d\d\d\d-\zs\d\d\d\d' :  'strftime("%Y")',
            \}

            function! UpdateTimestamp ()
                for [signature, replacement] in items(s:timestamps)
                    silent! execute "'[,']s/" . signature . '/\= ' . replacement . '/'
                endfor
            endfunction

            Here, the for loop iterates through
            each timestamp's
            signature/replacement pair in the
            s:timestamps dictionary, like so:

            for [signature, replacement] in items(s:timestamps)

            It then generates a string
            containing the corresponding
            substitution command. The following
            substitution command is identical
            in structure to the one in the
            previous example, but is here
            constructed by interpolating the
            signature/replacement pair into a
            string:

            "'[,']s/" . signature . '/\= ' . replacement . '/'

            Finally, it executes the generated
            command silently:

            silent! execute "'[,']s/" . signature . '/\= ' . replacement . '/'

            The use of silent! is important
            because it ensures that any
            substitutions that don't match will
            not result in the annoying Pattern
            not found error message.

            Note that the last entry in
            s:timestamps is a particularly
            useful example: it automatically
            updates the year-range of any
            embedded copyright notices,
            whenever a file containing them is
            written.


            Filename-driven timestamps

            Instead of listing all possible
            timestamp formats in a single
            table, you might prefer to
            parameterize the UpdateTimestamp()
            function and then create a series
            of distinct autocmds for different
            filetypes, as shown in Listing 16.

            Listing 16. Context-sensitive
            timestaming for different filetypes

            function! UpdateTimestamp (signature, replacement)silent! execute "'[,']s/" . a:signature . '/\= ' . a:replacement . '/'
            endfunction

            augroup Timestamping
                autocmd!

                " C header files use one timestamp format ... autocmd BufWritePre,FileWritePre,FileAppendPre  *.h
                    \ :call UpdateTimestamp('This file last updated: \zs.*', 'strftime("%c")')" C code files use another ...autocmd BufWritePre,FileWritePre,FileAppendPre  *.c
                    \ :call UpdateTimestamp('Last update: \zs.*', 'strftime("%Y%m%d.%H%M%S")')
            augroup END

            In this version, the signature and
            replacement components are passed
            explicitly to UpdateTimestamp(),
            which then generates a string
            containing the single corresponding
            substitution command and executes
            it. Within the Timestamping group,
            you then set up individual
            autocommands for each required file
            type, passing the appropriate
            timestamp signature and replacement
            text for each.


            Conjuring directories

            Autocommands can be useful even
            before you begin editing. For
            example, when you start editing a
            new file, you will occasionally see
            a message like this one:

            "dir/subdir/filename" [New DIRECTORY]

            This means that the file you
            specified (in this case filename)
            does not exist and that the
            directory it's supposed to be in
            (in this case dir/subdir) doesn't
            exist either.

            Vim will happily allow you to
            ignore this warning (many users
            don't even recognize that it is a
            warning) and continue to edit the
            file. But when you try to save it
            you'll be confronted with the
            following unhelpful error message:

            "dir/subdir/filename" E212: Can't open file for writing.

            Now, in order to save your work,
            you have to explicitly create the
            missing directory before writing
            the file into it. You can do that
            from within Vim like so:

            :write
            "dir/subdir/filename" E212: Can't open file for writing.
            :call mkdir(expand("%:h"),"p")
            :write

            Here, the call to the built-in
            expand() function is applied to
            "%:h", where the % means the
            current filepath (in this case
            dir/subdir/filename), and the :h
            takes just the "head" of that path,
            removing the filename to leave the
            path of the intended directory
            (dir/subdir). The call to Vim's
            built-in mkdir() then takes this
            directory path and creates all the
            interim directories along it (as
            requested by the second argument,
            "p").

            Realistically, though, most Vim
            users would be more likely to
            simply escape to the shell to build
            the necessary directories. For
            example:

            :write
            "dir/subdir/filename" E212: Can't open file for writing.
            :! mkdir -p dir/subdir/
            :write

            Either way, it's a hassle. If
            you're eventually going to have to
            create the missing directory
            anyway, why not have Vim notice
            up-front that it doesn't exist, and
            simply create it for you before you
            even start? That way, you'll never
            encounter the obscure [New
            DIRECTORY] hint; nor will your
            workflow be later interrupted by an
            equally mysterious E212 error.

            To have Vim take care of
            prebuilding non-existent
            directories, you could hook a
            handler into the BufNewFile event,
            which is queued whenever you start
            to edit a file that does not yet
            exist. Listing 17 shows the code
            you would add to your .vimrc file
            to make this work.

            Listing 17. Unconditionally
            autocreating non-existent
            directories

            augroup AutoMkdir
                autocmd!
                autocmd  BufNewFile  *  :call EnsureDirExists()
            augroup END
            function! EnsureDirExists ()
                let required_dir = expand("%:h")
                if !isdirectory(required_dir)
                    call mkdir(required_dir, 'p')
                endif
            endfunction

            The AutoMkdir group sets up a
            single autocommand for BufNewFile
            events on any kind of file, calling
            the EnsureDirExists() function
            whenever a new file is edited.
            EnsureDirExists() first determines
            the directory being requested by
            expanding the "head"of the current
            filepath: expand("%:h"). It then
            uses the built-in isdirectory()
            function to check whether the
            requested directory exists. If not,
            it attempts to create the directory
            using Vim's built-in mkdir().

            Note that, if the mkdir() call
            can't create the requested
            directory for any reason, it will
            produce a slightly more precise and
            informative error message:

            E739: Cannot create directory: dir/subdir


            Conjuring directories more carefully

            The only problem with this solution
            is that, occasionally, autocreating
            non-existent subdirectories is
            exactly the wrong thing to do. For
            example, suppose you requested the
            following:

            > vim /share/sites/corporate/root/.htaccess

            You had intended to create a new
            access control file in the already
            existing subdirectory
            /share/corporate/website/root/.
            Except, of course, because you got
            the path wrong, what you actually
            did was create a new access control
            file in the formerly non-existent
            subdirectory
            /share/website/corporate/root/. And
            because that happened
            automatically, with no warnings of
            any kind, you might not even
            realize the mistake. At least, not
            until the misapplied access control
            precipitates some online disaster.

            To guard against errors like this,
            you might prefer that Vim be a
            little less helpful in autocreating
            missing directories. Listing 18
            shows a more elaborate version of
            EnsureDirExists(), which still
            detects missing directories but now
            asks the user what to do about
            them. Note that the autocommand
            set-up is exactly the same as in
            Listing 17; only the
            EnsureDirExists() function has
            changed.

            Listing 18. Conditionally
            autocreating non-existent
            directories

            augroup AutoMkdir
                autocmd!
                autocmd  BufNewFile  *  :call EnsureDirExists()
            augroup END
            function! EnsureDirExists ()
                let required_dir = expand("%:h")
                if !isdirectory(required_dir)
                    call AskQuit("Directory '" . required_dir . "' doesn't exist.", "&Create it?")

                    try
                        call mkdir( required_dir, 'p' )
                    catch
                        call AskQuit("Can't create '" . required_dir . "'", "&Continue anyway?")
                    endtry
                endif
            endfunction

            function! AskQuit (msg, proposed_action)
                if confirm(a:msg, "&Quit?\n" . a:proposed_action) == 1
                    exit
                endif
            endfunction

            In this version of the function,
            EnsureDirExists() locates the
            required directory and detects
            whether it exists, exactly as
            before. However, if the directory
            is missing, EnsureDirExists() now
            calls a helper function: AskQuit().
            This function uses the built-in
            confirm() function to inquire
            whether you want to exit the
            session or autocreate the
            directory. "Quit?" is presented as
            the first option, which also makes
            it the default if you just hit
            <ENTER>.

            If you do select the "Quit?"
            option, the helper function
            immediately terminates the Vim
            session. Otherwise, the helper
            function simply returns. In that
            case, EnsureDirExists() continues
            to execute, and attempts to call
            mkdir().

            Note, however, that the call to
            mkdir() is now inside a
            try...endtry construct. This is -
            as you might expect - an exception
            handler, which will now catch the
            E739 error that is thrown if
            mkdir() is unable to create the
            requested directory.

            When that error is thrown, the
            catch block will intercept it and
            will call AskQuit() again,
            informing you that the directory
            could not be created, and asking
            whether you still want to continue.
            For more details on Vim's extensive
            exception handling mechanisms see:
            :help exception-handling.

            The overall effect of this second
            version of EnsureDirExists() is to
            highlight the non-existent
            directory but require you to
            explicitly request that it be
            created (by typing a single 'c'
            when prompted to). If the directory
            cannot be created, you are again
            warned and given the option of
            continuing with the session anyway
            (again, by typing a single 'c' when
            asked). This also makes it
            trivially easy to escape from a
            mistaken edit (simply by hitting
            <ENTER> to select the default
            "Quit?" option at either prompt).

            Of course, you might prefer that
            continuing was the default, in
            which case, you would just change
            the first line of AskQuit() to:

            if confirm(a:msg, a:proposed_action . "\n&Quit?") == 2

            In this case the proposed action
            would be the first alternative, and
            hence the default behaviour. Note
            that "Quit?" is now the second
            alternative, so the response now
            has to be compared against the
            value 2.


            Looking ahead

            Autocommands can save you a great
            deal of effort and error by
            automating repetitive actions that
            you would otherwise have to perform
            yourself. A productive way to get
            started is to take a mental step
            back as you edit and watch for
            repetitive patterns of usage that
            might be suitably automated using
            Vim's event-handling mechanisms.
            Scripting those patterns into
            autocommands may require some extra
            work up front, but the automated
            actions will repay your investment
            every day. By automating everyday
            actions you'll save time and
            effort, avoid errors, smooth your
            workflow, eliminate trivial
            stressors, and thereby improve your
            productivity.

            Though your autocommands will
            probably start out as simple
            single-line automations, you may
            soon find yourself redesigning and
            elaborating them, as you think of
            better ways to have Vim do more of
            your grunt work. In this fashion,
            your event handlers can grow
            progressively smarter, safer, and
            more perfectly adapted to the way
            you want to work.

            As Vim scripts like these become
            more complex, however, you also
            will need better tools to manage
            them. Adding 10 or 20 lines to your
            .vimrc every time you devise a
            clever new keymapping or
            autocommand will eventually produce
            a configuration file that is
            several thousand lines long … and
            utterly unmaintainable.








                https://developer.ibm.com/tutorials/au-customize_vi/

            Tutorial

            Customizing the vi and Vim editors
            Extending standard editors with custom commands

            By William von Hagen
            Published January 18, 2011

            The vi text editor (or a workalike
            clone) has been included as part of
            every UNIX and UNIX-like system
            since 1978. Due to AT&T licensing
            restrictions, UNIX-like open source
            systems had to write their own vi
            clones from scratch, which led to
            vi workalikes such as Elvis, nvi,
            and Vim (the latter of which is
            discussed in this article along
            with the original vi). This
            ubiquity makes it one of the truly
            indispensable tools for a system
            administrator of any UNIX, Linux,
            Berkeley Software Distribution
            (BSD), or other UNIX-like computer
            system.

            Fans of the Emacs text editor on
            UNIX and UNIX-like systems, myself
            included, delight in its
            flexibility, expandability, and
            configurability. This article
            highlights those same capabilities
            in vi and its most popular clone,
            Vim. The vi and Vim editors provide
            essentially the same customization
            and configuration possibilities as
            Emacs, and vi's support for
            abbreviations is unmatched in
            Emacs. Knowing vi makes it possible
            for any system administrator to be
            instantly productive on any
            UNIX-like system, long before you
            figure out how to install Emacs.

            This article explains how to
            customize vi and Vim, not how to
            use them. See resources section in
            the right for links to some great
            vi and Vim tutorials. That section
            also lists other popular vi clones
            and where to get them.


            Types of vi and Vim customizations

            The vi and Vim editors store
            customizations in text files or
            environment variables (which are
            discussed in the next section).
            Each of the vi or Vim configuration
            files can contain any number of the
            types of configuration and
            customization commands shown in
            Table 1.

            Table 1. Configuration and customization commands

            Command
            Description

            ab
                Define abbreviations that are
                expanded into a specific
                sequence of characters when
                they are encountered while you
                are typing text in Insert mode.
                These abbreviations can
                function like the AutoCorrect
                feature in Microsoft ® Word.

            map
                Assign existing vi or Vim
                commands to a custom key or
                define your own custom
                commands. See " Customizing key
                bindings and creating commands"
                for more information.

            set
                Set a vi or Vim variable.
                Depending on the type of
                variable and how it is used,
                variables are set either by
                simply naming the specific
                variable or by specifying and
                assigning an explicit value.
                See " Setting vi and Vim
                configuration options" for more
                information.

            You can intersperse configuration
            commands and comments within the
            command in a vi or Vim
            configuration file. In Vim
            configuration files, any characters
            following a double quotation mark
            (") that appear anywhere on a line
            are viewed as a comment, while a
            comment in standard vi
            configuration files must have the
            double quotation marks as the first
            character of the line. Standard vi
            configuration files cannot contain
            any blank lines, whereas they are
            fine in a Vim configuration file.

            The Vim editor supports additional
            keywords that enable you to take
            advantage of capabilities that are
            not present in the original vi
            editor, including those shown in
            Table 2.


            Table 2. Additional keywords supported by Vim

            Keyword
            Description

            autocmd
                Automatically execute specific
                commands based on the type of
                file you are editing. See
                Downloadable resources for a
                sample.vimrc file that includes
                an autocmd example.

            filetype
                Load and activate various
                plugins that provide extra
                capabilities when you are
                editing files of specific
                types.

            function
                Define a custom function which
                you can then map to a key
                command.

            syntax
                Activate or deactivate syntax
                highlighting.

            The configuration files used by Vim
            also support a rich set of internal
            functions that you can use in
            conditional expressions. These
            enable you to write your own
            functions and execute them in
            different contexts. See resources
            section in the right for links to
            more information about such
            conditionals.


            Startup files for vi and Vim

            You can define the vi and Vim
            configuration options discussed in
            the previous section in environment
            variables, configuration files, or
            both. Both vi and Vim use a
            sequence of environment variables
            and configuration files to load
            customizations and share much of
            the same configuration sequence,
            though Vim uses a more extensive
            set.

            By default, the vi and Vim editors
            check the locations in Table 3, in
            the order listed, for configuration
            information.

            Table 3. Locations vi and Vim check for configuration information

            Order
            Location
            Description

            1
            Specific file invoked by -u option     
                (Vim only): If invoked with the
                -u option followed by the name
                of a configuration file, Vim
                ignores the rest of its
                configuration sequence and
                loads only settings from the
                specified file. To skip all
                configuration files, you can
                specify NONE as the argument to
                the -u option.

                You can prevent standard vi
                from loading any configuration
                files by setting the EXINIT
                environment variable to the
                ":set noexrc" string and then
                executing vi. The following
                example does this from the
                command line if you are using
                the Bash shell:

                EXINIT=":set noexrc" vi file1.txt

            2
            Specific configuration file
            identified when Vim is compiled
                (Vim only): A specific
                configuration file identified
                when Vim is compiled (usually
                /etc/vim/vimrc or
                /usr/share/vim/vimrc) that
                contains system-wide
                configuration settings for Vim.
                This file typically sets some
                configuration options and loads
                other Vim configuration files
                that are specific to the
                operating system and operating
                system distribution that you
                are running.

            3
            VIMINIT environment variable
                (Vim only): An environment
                variable that consists of a
                sequence of one or more
                configuration commands. If this
                environment variable is set,
                Vim does not look for any
                subsequent configuration files
                or examine other environment
                variables.

            4
            $HOME/.vimrc
                (Vim only): A file named
                .vimrc, located in the user's
                home directory, that contains
                configuration options. If this
                file is found, Vim does not
                look for any subsequent
                configuration files or examine
                other environment variables.

            5
            EXINIT environment variable
                An environment variable that
                consists of a sequence of one
                or more configuration commands.

            6
            $HOME/.exrc
                A file named . exrc, located in
                the user's home directory, that
                contains configuration options.
                If this file is found, vi and
                Vim do not look for any
                subsequent configuration files
                unless the exrc option is set
                in this configuration file. See
                Downloadable resources for the
                sample. exrc file.

            7
            .exrc
                A file named . exrc, located in
                the current working directory,
                that contains configuration
                options. (If you are using Vim
                on a Microsoft Windows ®
                system, the name of this file
                is _ exrc.) An . exrc file in
                the current directory is read
                only if a previous
                configuration instruction or
                file set the exrc option (or if
                you are starting vi or Vim from
                your home directory and you
                have an . exrc file there,
                which therefore matches the
                following step in the search
                sequence).

            This impressive series of
            alternatives makes it especially
            easy to configure system-wide
            defaults for Vim, while also
            enabling some clever interaction
            between Vim and standard vi
            configuration files. For example,
            whenever my home directory is not
            located in a networked file system,
            I copy all my configuration files
            for shells and applications to each
            of the systems where I have an
            account. Some of these systems use
            vi, while Vim is provided (as vi)
            on others. Thus, I put all my
            vi-specific configuration options
            in an .exrc file, put all the
            Vim-specific configuration commands
            in a .vimrc file, and put the
            following line at the beginning of
            my .vimrc file:

            so .exrc

            This causes Vim to read all the
            configuration commands stored in my
            .exrc file before loading those in
            the remainder of my .vimrc file. On
            systems where only vi is present,
            my .exrc file is read normally and
            the .vimrc file is ignored. Loading
            configuration commands at the
            beginning of my .vimrc file enables
            key mappings that are present in
            both files to be overridden by
            fancier Vim versions when I'm using
            Vim.


            Setting vi and Vim configuration options

            The set command enables users to
            set internal vi and Vim variables.
            Variables are set in different ways
            depending upon their type:

            - Variables, set to on or off, are
              set by the set variableset
              variable command and unset using
              the set novariableset novariable
              command.
            - Variables that take values are
              set by the set variable=valueset
              variable=value command.

            For example, the set list command
            sets the list option, which tells
            vi or Vim to display characters
            that represent end of line ($) and
            unexpanded tab (^I) characters. (In
            Vim, this option also displays
            trailing whitespace.) The list
            option does not require a value -
            simply setting it is sufficient to
            activate the feature. You can unset
            the list option by executing the
            set nolist command.

            Other variables take explicit
            values or types of values, which
            you assign using the equal sign (=)
            followed by a value or
            comma-separated list of values. For
            example, in the Vim editor, you can
            configure the characters used by
            the list command to represent end
            of line, trailing whitespace, and
            unexpanded tabs by setting the
            value of the listchars variable.
            The following command displays
            unexpanded tabs as >>, trailing
            whitespace as !, and end of line as
            $:

            set listchars=tab:>>,trail:!,eol:$

            To see the current value of all of
            the options that you can set in vi
            or Vim, use the :set all command
            within vi or Vim. To display the
            current value of a specific option,
            use the f:set option? command. To
            show all options you have modified
            from their default values, use the
            :set command.


            Customizing key bindings and creating commands

            The map command enables users to
            bind existing or new commands to
            specific keys or key combinations
            using the map key-sequence
            commandmap key-sequence command
            syntax for vi's command mode and
            map! key-sequence commandmap!
            key-sequence command for vi's
            insert mode.

            The following are some sample map
            commands for Vim:

            map <C‑T> hhxpmap <F5> !}fmt <CR>

            The first of these maps the key
            sequence control-t to the vi
            command sequence hhxp, which
            reverses the order of the two
            characters in front of the current
            cursor position (as does control-t
            in Emacs). The second of these maps
            the F5 key to a key sequence that
            invokes the fmt command to reformat
            the current paragraph.

            One important difference between
            map commands in configuration files
            for standard vi and Vim is that, as
            shown in the previous examples, Vim
            supports key identifiers within
            angle brackets to identify keys
            that would otherwise be
            non-printable characters. vi
            requires that you actually insert
            the control sequence (which you do
            by pressing control-v followed by
            the key sequence). The vi versions
            of the sample map commands would
            look like the following:

            map ^T hhxpmap ^@ !}fmt ^M


            Defining abbreviations

            The ab command enables you to
            identify abbreviations for long but
            commonly-used terms, bits of code,
            spelling corrections, and so on.
            Abbreviations that you define are
            expanded as you enter text in
            insert mode, whenever you type a
            whitespace or punctuation
            character. For example, some of my
            favorite abbreviations are the
            following:

            ab het theab teh the

            Abbreviations work only in insert
            mode in standard vi, but they also
            work in replace mode and
            command-line mode in Vim. The Vim
            editor provides the cab
            (command-line-abbreviation), iab
            (insert-mode abbreviation), and rab
            (replace-mode abbreviation)
            commands to enable you to restrict
            the expansion of specific
            abbreviations to specific modes in
            Vim.


            Summary

            Knowing how to use the vi and Vim
            editors is a fundamental skill for
            any administrator of any UNIX,
            Linux, or other UNIX-like system.
            Though vi is a classic UNIX tool,
            it is extremely configurable and is
            used by many developers for
            day-to-day work as well as on
            systems where it is the only editor
            available.

            This article introduced the basic
            vi and Vim configuration commands
            and provided an overview of how vi
            and Vim locate and load customized
            configuration settings. There is
            much more to learn about these
            topics than can fit into a single
            article. See resources section in
            the right for links on much more
            information.


            Downloadable resources

            Sample .vimrc file (sample.vimrc | 3KB)
                http://public.dhe.ibm.com/software/dw/aix/sample.vimrc
            Sample .exrc file (sample.exrc | 1KB)
                http://public.dhe.ibm.com/software/dw/aix/sample.exrc
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/z_vdocs-Usr41.txt
            https://vimhelp.org/usr_41.txt.html
            41.1 Introduction
            41.2 Variables
            41.3 Expressions
            41.4 Conditionals
            41.5 Executing an expression
            41.6 Using functions
            41.7 Defining a function
            41.8 Lists and Dictionaries
            41.9 White space
            41.10 Line continuation
            41.11 Comments
            41.12 Fileformat
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/z_vdocs-Eval.txt
            https://vim-jp.org/vimdoc-en/eval.html
            1.  Variables                   variables
              1.1 Variable types
              1.2 Function references             Funcref
              1.3 Lists                           Lists
              1.4 Dictionaries                    Dictionaries
              1.5 Blobs                           Blobs
              1.6 More about variables            more-variables
            2.  Expression syntax           expression-syntax
            3.  Internal variable           internal-variables
            4.  Builtin Functions           functions
            5.  Defining functions          user-functions
            6.  Curly braces names          curly-braces-names
            7.  Commands                    expression-commands
            8.  Exception handling          exception-handling
            9.  Examples                    eval-examples
            10. Vim script version          vimscript-version
            11. No +eval feature            no-eval-feature
            12. The sandbox                 eval-sandbox
            13. Textlock                    textlock
~/Empire/Doks/Comp/editor/vim/hacking_vim.pdf
~/Empire/Doks/Comp/editor/vim/vimhack.pdf
            Preface
            Chapter 1 - Introduction ----
            Vi, Vim, and Friends
              vi
              STEVIE
              Elvis
              Nvi
              Vim
              Vile
              Compatibility
            Vim is Charityware
            Summary8
            Chapter 2 - Personalizing Vim ----
            Where are the Config Files?
              vimrc
              gvimrc
              exrc
            Changing the Fonts
            Changing Color Scheme
            Personal Highlighting
            A More Informative Status Line
            Toggle Menu and Toolbar
            Adding Your Own Menu and Toolbar Buttons
              Adding a Menu
              Adding Toolbar Icons
            Modifying Tabs
            Work Area Personalization
              Adding a More Visual Cursor
              Adding Line Numbers
              Spell Checking Your Language
              Adding Helpful Tool Tips
              Using Abbreviations
              Modifying Key Bindings
            Chapter 3 - Better Navigation ----
              Faster Navigation in a File
              Context-Aware Navigation
              Navigating Long Lines
            Faster Navigation in Vim Help
              Faster Navigation in Multiple Buffers
              Open Referenced Files Faster
            Search and You Will Find
              Search the Current File
              Search in Multiple Files
              Search the Help System
            X Marks the Spot
              Visible Markers—Using Signs
              Hidden Markers—Using Marks
            Summary
            Chapter 4 - Production Boosters ----
            Using Templates
              Using Template Files
              Abbreviations as Templates
            Using Tag Lists
              Easier Taglist Navigation
              Other Usages of Taglists
            Using Auto-Completion
              Auto-Completion with Known Words
              Auto-Completion using Dictionary Lookup
              Omni-Completion
              All-in-One Completion
            Using Macro Recording
            Using Sessions
              Simple Session Usage
               Satisfy your own Session Needs
              Sessions as a Project Manager
            Registers and Undo Branching
              Using Registers
               The Unnamed Register
               The Small Delete Register
               The Numbered Registers
               The Named Registers
               The Read-Only Registers
               The Selection and Drop Registers
               The Black Hole Register
               Search Pattern Register
               The Expression Register
              Using Undo Branching
            Folding
               Simple Text File Outlining
              Using vimdiff to Track the Changes
              Navigation in vimdiff
              Using Diff to Track Changes
            Open Files Anywhere
              Faster Remote File Editing
            Chapter 5 - Advanced Formatting ----
            Formatting Text
              Putting Text into Paragraphs
              Aligning Text
              Marking Headlines
              Creating Lists
            Formatting Code
               Autoindent
               Smartindent
               Cindent
               Indentexpr
               Fast Code Block Formatting
              Auto Format Pasted Code
            Using External Formatting Tools
               Indent
               Berkeley Par
               Tidy
            Chapter 6 - Vim Scripting ----
            Syntax-Color Schemes
              Your First Syntax-Color File
              Syntax Regions
              Color Scheme and Syntax Coloring
            Using Scripts
              Script Types
              Installing Scripts
               Uninstalling Scripts
            Script Development
              Scripting Basics
               Types
               Variables
               Conditions
               Lists and Dictionaries
               Loops
               Creating Functions
              Script Structure
              Scripting Tips
               Gvim or Vim?
               Which Operating System?
               Which Version of Vim?
               Printing Longer Lines
              Debugging Vim Scripts
              Distributing Vim Scripts
              Making Vimballs
               Using External Interpreters
              Remember the Documentation
               Vim Scripting in Perl
               Vim Scripting in Python
               Vim Scripting in Ruby
            Appendix A - Vim Can Do Everything ----
            Vim Games
              Game of Life
              Nibbles
              Rubik's Cube
              Tic-Tac-Toe
              Mines
              Sokoban
              Tetris
            Programmers IDE
            Mail Program
            Chat with Vim
            Appendix B - Vim Configuration Alternatives ----
            Tips for Keeping your Vimrc Clean
                · sourcing
                · using the plugin/-dir
                · rtp(??)
            A Vimrc Setup System
            Storing Vimrc Online
~/Empire/Doks/Comp/editor/vim/vimlang-ibmtuts_5parts.txt
            Vimscript
            Running Vim scripts
            A syntactic example
            Vimscript statements
            Comments
            Values and variables
            Expressions
            Logical caveats
            Comparator caveats
            Arithmetic caveats
            Another toggling example
            Scripting in Insert mode
            A more complex Insert-mode script
            Learning Vim's built-in functions
            Looking ahead
            User-defined functions
            Declaring functions
            Redeclarable functions
            Calling functions
            Parameter lists
            Combining named and variadic parameters
            Functions and line ranges
            Internalizing function line ranges
            Visual ranges
            A function to help you code
            Looking ahead
            Lists in Vimscript
            Nested lists
            List assignments and aliasing
            Basic list operations
            Other list-related procedures
            A common mistake with list procedures
            Filtering and transforming lists
            The map() function
            List concatenation
            Sublists
            Example 1: Revisiting autoalignments
            Example 2: Enhancing Vim's completion facilities
            Designing smarter completions
            Specifying smarter completions
            Implementing smarter completions
            A more-sophisticated for loop
            Recognizing a completion context
            Deploying the new mechanism
            Looking ahead
            Dictionaries in Vimscript
            Batch-processing of dictionaries
            Assignments and identities
            Adding and removing entries
            Other dictionary-related functions
            Deploying dictionaries for cleaner code
            Revisiting autocomments
            Refactoring autoalignments
            Dictionaries as data structures
            Sort-free uniqueness
            Looking ahead
            Vim's event model
            Vim provides notifications for 78
            Event handling with autocommands
            Universal and single-file autocommands
            Autocommand groups
            Deactivating autocommands
            Some practical examples
            Managing simultaneous edits
            Autoformatting code consistently
            Opportunistic code autoformatting
            Timestamping files
            Table-driven timestamps
            Filename-driven timestamps
            Conjuring directories
            Conjuring directories more carefully
            Looking ahead
            Types of vi and Vim customizations
            Table 2. Additional keywords supported by Vim
            Startup files for vi and Vim
            Setting vi and Vim configuration options
            Customizing key bindings and creating commands
            Defining abbreviations
            Summary
            Downloadable resources
~/Empire/Doks/Comp/editor/vim/vimmast-idenvim.pdf
~/Empire/Doks/Comp/editor/vim/vimmast-idenvim.txt
            Chapter 1 - Getting Started ----
            Technical requirements  6
            Let's start a conversation (about modal interfaces)  6
            Installation  7
              Setting up on Linux  7
              Setting up on MacOS  9
               Using Homebrew  9
               Downloading a .dmg image  13
              Setting up On Windows  15
               Unix-like experience with Cygwin  15
                Installing Cygwin
                Using Cygwin
               Visual Vim with gVim  21
              Verifying and troubleshooting the installation  24
            Vanilla Vim vs gVim  26
            Configuring Vim with your .vimrc  27
            Common operations (or how to exit Vim)  29
              Opening files  29
              Changing text  31
              Saving and closing files
              Verifying and troubleshooting the installation
            Vanilla Vim vs gVim
            Configuring Vim with your .vimrc
            Common operations (or how to exit Vim)
              Opening files
              Changing text
              Saving and closing files
               A word about swap files
            Moving around: talk to your editor
            Making simple edits in insert mode
            Persistent undo and repeat
            Read the Vim manual using :help
            Chapter 2 - Advanced Editing and Navigation ----
            Technical requirements
            Installing plugins
            Organizing workspace
              Buffers
              Plugin spotlight - unimpaired
              Windows
               Creating, deleting, and navigating windows
               Moving windows
               Resizing Windows
              Tabs
              Folds
               Folding Python code
               Types of folds
            Navigating file trees
              Netrw
              :e with wildmenu enabled
              Plugin spotlight - NERDTree
              Plugin spotlight - Vinegar
              Plugin spotlight - CtrlP
            Navigating text
              Jumping Into insert mode
              Searching with / and ?
               Searching across files
               ack
              Utilizing text objects
              Plugin spotlight - EasyMotion
            Copying and pasting with registers
              Where do the registers come In?
              Copying from outside of Vim
            Chapter 3 - Follow the Leader - Plugin Management ----
            Technical requirements
            Managing plugins
              Vim-plug
              Honorable mentions
               Vundle
               Do it yourself
               Pathoqen
            Technical requirements
            Managing plugins
              Vim-plug
              Honorable mentions
               Vundle
               Do it yourself
               Pathogen
              Profiling Slow plugins
               Profiling startup
               Profiling specific actions
            Deeper dive into modes
              Normal mode
              Command-line and ex modes
              Insert mode
              Visual and select mode
              Replace and virtual replace mode
              Terminal mode
            Remapping commands
              Mode - aware remapping
            The leader key
            Configuring plugins
            Chapter 4 - Understanding the Text ----
            Technical requirements
            Code autocomplete
              Built-in autocomplete
              YouCompleteMe
               Installation
               Using YouCompleteMe
            Navigating the code base with tags
              Exuberant Ctags
              Automatically updating the tags
            Undo tree and Gundo
            Chapter 5 - Build, Test, and Execute ----
            Technical requirements
            Working with version control
              Quick-and-dirty version control and Git introduction
               Concepts
               Setting up a new Project
               Cloning an existing repository
               Working with Git
                Addind files, committing, and pushing
                Creating and merging branches
              Integrating Git with Vim (vim-fugitive)
            Resolving conflicts with vimdiff
              Comparing two files
              vimdiff and Git
               git config
               Creating merge conflict
               Resolving a merge conflict
            tmux, Screen, and Vim terminal mode
            Resolving conflicts with vimdiff
              Comparing two files
              vimdiff and Git
               git config
               Creating merge conflict
               Resolving a merge conflict
            tmux, Screen, and Vim terminal mode
              tmux
               Panes are just like splits
               Windows are just like tabs
               Sessions are Invaluable
               tmux and Vim splits
              Screen
              Terminal mode
            Building and testing
              Quickfix list
              Location list
              Building code
               Plugin spotlight: vim-dispatch
              Testing code
               Plugin spotlight - vim-test
              Syntax checking code with linters
               Using linters with Vim
               Plugin spotlight - Syntastic
               Plugin spotlight - ALE
            Chapter 6 - Refactoring Code with Regex and Macros ----
            Technical requirements
            Search or replace with regular expressions
              Search and replace
              Operations across files using arglist
              Regex basics
               Special redex characters
               Alternation and qrouDind
               Quantifiers or multis
              More about magic
               Magic
               No magic
               Very magic
              Applying the knowledge in practice
               Renaming a variable, a method, or a class
               Reordering function arguments
            Recording and playing macros
              Editing macros
              Recursive macros
              Running macros across multiple files
            Using plugins to do the job
            Recording and playing macros
              Editing macros
              Recursive macros
              Running macros across multiple files
            Using plugins to do the job
            Chapter 7 - Making Vim Your Own ----
            Technical requirements
            Playing with the Vim UI
              Color schemes
              Browsing the color schemes
              Common issues
              The status line
              Powerline
              Airline
              gVim-specific configuration
            Keeping track of configuration files
            Healthy Vim customization habits
              Optimizing your workflow
              Keeping .vimrc organized
            Chapter 8 - Transcending the Mundane with Vimscript ----
            Technical requirements
            Why Vimscript?
            How to execute Vimscript
            Learning the syntax
              Setting variables
              Surfacing output  239
              Conditional statements  240
              Lists  242
              Dictionaries  245
              Loops  246
              Functions  249
              Classes  251
              Lambda expressions  252
              Map and filter  253
              Interacting with Vim  256
              File-related commands  257
              Prompts  257
              Using Help  262
            A word about style guides  262
            Let's build a plugin  263
              Plugin layout  263
              The basics  264
              Housekeeping  269
              Improving our plugin  272
              Distributing the plugin  277
              Where to take the plugin from here  278
            Further reading  278
            Chapter 9 - Neovim ----
            Technical requirements
            Why make another Vim?
            Installing and configuring Neovim
              Checking health
              Sane defaults
            Oni
            Neovim plugin highlights
            Chapter 10 - Where to Go from Here ----
            Seven habits of effective text editing
            Modal interfaces everywhere
              A Vim-like web browsing experience
               Vimium and Vimium-FF
               Alternatives
              Vim everywhere else
               Vim-anywhere for Linux and macOS
               Text Editor Anywhere for Windows
            Recommended reading and communities
            Mailing lists
            IRC
            Other communities  300
            Other Books You May Enjoy  302
--
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/vdocs_0autocmd-vim.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/vdocs-aucmds.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/zzz_autocmd.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/z_vdocs-pattern.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/Man2021plus-01uman.usr41.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/Man2021plus-02refman.eval.txt
  ~/Dropbox/rsc/Doks/Comp/vimdoc8/
--
  ~/Dropbox/rsc/data/lists/learnqna/vanki/pick.legacy/Vim-PractHardwtips.txt  #90% without plugins
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/version8.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/pinkjuice-vimxml.txt
--

=130 Question-Posts [**]
--
~/Empire/Doks/Comp/editor/vim/cheatsh-qref/vimqrc.pdf
~/Empire/Doks/Comp/editor/vim/cheatsh-qref/vimwiki_quickreference.pdf
~/Empire/Doks/Comp/editor/vim/cheatsh-qref/netrw_keys.pdf
 ___netrw_start
 ___netrw_start2
gvim -O ~/Dropbox/rsc/data/lists/learnqna/vanki/tmp/netrw2020.bmk.txt ~/Dropbox/rsc/Doks/Comp/vimdoc8/rman.files/pi_netrw.txt
~/Dropbox/rsc/data/lists/learnqna/vanki/decks/DECK.MASTER.txt  #=netrw
                        if has("win95") && g:netrw_win95ftp
                         fun! NetReadFixup(method, line1, line2)
                           if method == 3   " ftp (no <.netrc>)
                            let fourblanklines= line2 - 3
                            silent fourblanklines.",".line2."g/^\s*/d"
                           endif
                         endfunction
                        endif
                   
                    (Related topics: |ftp| |netrw-userpass| |netrw-start|)

                    ==============================================================================
                    9. Browsing     *netrw-browsing* *netrw-browse* *netrw-help*
                                *netrw-browser*  *netrw-dir*    *netrw-list*

                    INTRODUCTION TO BROWSING            *netrw-intro-browse*
                        (Quick References: |netrw-quickmaps| |netrw-quickcoms|)

                    Netrw supports the browsing of directories on your local system and on remote
                    hosts; browsing includes listing files and directories, entering directories,
                    editing files therein, deleting files/directories, making new directories,
                    moving (renaming) files and directories, copying files and directories, etc.
                    One may mark files and execute any system command on them!  The Netrw browser
                    generally implements the previous explorer's maps and commands for remote
                    directories, although details (such as pertinent global variable names)
                    necessarily differ.  To browse a directory, simply "edit" it!

                        vim /your/directory/
                        vim .
                        vim c:\your\directory\
                    <
                    (Related topics: |netrw-cr|  |netrw-o|  |netrw-p| |netrw-P| |netrw-t|
                                     |netrw-mf|  |netrw-mx| |netrw-D| |netrw-R| |netrw-v| )

                    The Netrw remote file and directory browser handles two protocols: ssh and
                    ftp.  The protocol in the url, if it is ftp, will cause netrw also to use ftp
                    in its remote browsing.  Specifying any other protocol will cause it to be
                    used for file transfers; but the ssh protocol will be used to do remote
                    browsing.

                    To use Netrw's remote directory browser, simply attempt to read a "file" with
                    a trailing slash and it will be interpreted as a request to list a directory:
                   
                        vim [protocol]://[user@]hostname/path/
                    <
                    where [protocol] is typically scp or ftp.  As an example, try:

                        vim ftp://ftp.home.vim.org/pub/vim/
                    <
                    For local directories, the trailing slash is not required.  Again, because it's
                    easy to miss: to browse remote directories, the URL must terminate with a
                    slash!

                    If you'd like to avoid entering the password repeatedly for remote directory
                    listings with ssh or scp, see |netrw-ssh-hack|.  To avoid password entry with
                    ftp, see |netrw-netrc| (if your ftp supports it).

                    There are several things you can do to affect the browser's display of files:

                        * To change the listing style, press the "i" key (|netrw-i|).
                          Currently there are four styles: thin, long, wide, and tree.
                          To make that change "permanent", see |g:netrw_liststyle|.

                        * To hide files (don't want to see those xyz~ files anymore?) see
                          |netrw-ctrl-h|.

                        * Press s to sort files by name, time, or size.

                    See |netrw-browse-cmds| for all the things you can do with netrw!

                                *netrw-getftype* *netrw-filigree* *netrw-ftype*
                    The |getftype()| function is used to append a bit of filigree to indicate
                    filetype to locally listed files:

                        directory  : /
                        executable : *
                        fifo       : |
                        links      : @
                        sockets    : =

                    The filigree also affects the |g:netrw_sort_sequence|.

                    ___netrw_start
                    QUICK HELP                      *netrw-quickhelp*
                                           (Use ctrl-] to select a topic)~
                        Intro to Browsing...............................|netrw-intro-browse|
                          Quick Reference: Maps.........................|netrw-quickmap|
                          Quick Reference: Commands.....................|netrw-browse-cmds|
                        Hiding
                          Edit hiding list..............................|netrw-ctrl-h|
                          Hiding Files or Directories...................|netrw-a|
                          Hiding/Unhiding by suffix.....................|netrw-mh|
                          Hiding  dot-files.............................|netrw-gh|
                        Listing Style
                          Select listing style (thin/long/wide/tree)....|netrw-i|
                          Associated setting variable...................|g:netrw_liststyle|
                          Shell command used to perform listing.........|g:netrw_list_cmd|
                          Quick file info...............................|netrw-qf|
                        Sorted by
                          Select sorting style (name/time/size).........|netrw-s|
                          Editing the sorting sequence..................|netrw-S|
                          Sorting options...............................|g:netrw_sort_options|
                          Associated setting variable...................|g:netrw_sort_sequence|
                          Reverse sorting order.........................|netrw-r|


                                    *netrw-quickmap* *netrw-quickmaps*
                    QUICK REFERENCE: MAPS               *netrw-browse-maps*
                   
                          ---           -----------------           ----
                          Map           Quick Explanation           Link
                          ---           -----------------           ----
                    <    <F1>   Causes Netrw to issue help
                         <cr>   Netrw will enter the directory or read the file      |netrw-cr|
                         <del>  Netrw will attempt to remove the file/directory      |netrw-del|
                         <c-h>  Edit file hiding list                                |netrw-ctrl-h|
                         <c-l>  Causes Netrw to refresh the directory listing        |netrw-ctrl-l|
                         <c-r>  Browse using a gvim server                           |netrw-ctrl-r|
                         <c-tab> Shrink/expand a netrw/explore window                |netrw-c-tab|
                           -    Makes Netrw go up one directory                      |netrw--|
                           a    Cycles between normal display,                       |netrw-a|
                                hiding (suppress display of files matching g:netrw_list_hide)
                                and showing (display only files which match g:netrw_list_hide)
                           c    Make browsing directory the current directory        |netrw-c|
                           C    Setting the editing window                           |netrw-C|
                           d    Make a directory                                     |netrw-d|
                           D    Attempt to remove the file(s)/directory(ies)         |netrw-D|
                           gb   Go to previous bookmarked directory                  |netrw-gb|
                           gd   Force treatment as directory                         |netrw-gd|
                           gf   Force treatment as file                              |netrw-gf|
                           gh   Quick hide/unhide of dot-files                       |netrw-gh|
                           gn   Make top of tree the directory below the cursor      |netrw-gn|
                           i    Cycle between thin, long, wide, and tree listings    |netrw-i|
                           I    Toggle the displaying of the banner                  |netrw-I|
                           mb   Bookmark current directory                           |netrw-mb|
                           mc   Copy marked files to marked-file target directory    |netrw-mc|
                           md   Apply diff to marked files (up to 3)                 |netrw-md|
                           me   Place marked files on arg list and edit them         |netrw-me|
                           mf   Mark a file                                          |netrw-mf|
                           mF   Unmark files                                         |netrw-mF|
                           mg   Apply vimgrep to marked files                        |netrw-mg|
                           mh   Toggle marked file suffices' presence on hiding list |netrw-mh|
                           mm   Move marked files to marked-file target directory    |netrw-mm|
                           mp   Print marked files                                   |netrw-mp|
                           mr   Mark files using a shell-style |regexp|                |netrw-mr|
                           mt   Current browsing directory becomes markfile target   |netrw-mt|
                           mT   Apply ctags to marked files                          |netrw-mT|
                           mu   Unmark all marked files                              |netrw-mu|
                           mv   Apply arbitrary vim   command to marked files        |netrw-mv|
                           mx   Apply arbitrary shell command to marked files        |netrw-mx|
                           mX   Apply arbitrary shell command to marked files en bloc|netrw-mX|
                           mz   Compress/decompress marked files                     |netrw-mz|
                           o    Enter the file/directory under the cursor in a new   |netrw-o|
                                browser window.  A horizontal split is used.
                           O    Obtain a file specified by cursor                    |netrw-O|
                           p    Preview the file                                     |netrw-p|
                           P    Browse in the previously used window                 |netrw-P|
                           qb   List bookmarked directories and history              |netrw-qb|
                           qf   Display information on file                          |netrw-qf|
                           qF   Mark files using a quickfix list                     |netrw-qF|
                           qL   Mark files using a |location-list|                     |netrw-qL|
                           r    Reverse sorting order                                |netrw-r|
                           R    Rename the designated file(s)/directory(ies)         |netrw-R|
                           s    Select sorting style: by name, time, or file size    |netrw-s|
                           S    Specify suffix priority for name-sorting             |netrw-S|
                           t    Enter the file/directory under the cursor in a new tab|netrw-t|
                           u    Change to recently-visited directory                 |netrw-u|
                           U    Change to subsequently-visited directory             |netrw-U|
                           v    Enter the file/directory under the cursor in a new   |netrw-v|
                                browser window.  A vertical split is used.
                           x    View file with an associated program                 |netrw-x|
                           X    Execute filename under cursor via |system()|           |netrw-X|

                           %    Open a new file in netrw's current directory         |netrw-%|

                        *netrw-mouse* *netrw-leftmouse* *netrw-middlemouse* *netrw-rightmouse*
                        <leftmouse> (gvim only) selects word under mouse as if a <cr>
                                had been pressed (ie. edit file, change directory)
                        <middlemouse>   (gvim only) same as P selecting word under mouse;
                                see |netrw-P|
                        <rightmouse>    (gvim only) delete file/directory using word under
                                mouse
                        <2-leftmouse>   (gvim only) when:
                                 * in a netrw-selected file, AND
                                 * |g:netrw_retmap| == 1       AND
                                 * the user doesn't already have a <2-leftmouse>
                                   mapping defined before netrw is autoloaded,
                                then a double clicked leftmouse button will return
                                to the netrw browser window.  See |g:netrw_retmap|.
                        <s-leftmouse>   (gvim only) like mf, will mark files.  Dragging
                                the shifted leftmouse will mark multiple files.
                                (see |netrw-mf|)

                        (to disable mouse buttons while browsing: |g:netrw_mousemaps|)

                                    *netrw-quickcom* *netrw-quickcoms*
                    QUICK REFERENCE: COMMANDS   *netrw-explore-cmds* *netrw-browse-cmds*
                         :NetrwClean[!]............................................|netrw-clean|
                         :NetrwSettings............................................|netrw-settings|
                         :Ntree....................................................|netrw-ntree|
                         :Explore[!]  [dir] Explore directory of current file......|netrw-explore|
                         :Hexplore[!] [dir] Horizontal Split & Explore.............|netrw-explore|
                         :Lexplore[!] [dir] Left Explorer Toggle...................|netrw-explore|
                         :Nexplore[!] [dir] Vertical Split & Explore...............|netrw-explore|
                         :Pexplore[!] [dir] Vertical Split & Explore...............|netrw-explore|
                         :Rexplore          Return to Explorer.....................|netrw-explore|
                         :Sexplore[!] [dir] Split & Explore directory .............|netrw-explore|
                         :Texplore[!] [dir] Tab & Explore..........................|netrw-explore|
                         :Vexplore[!] [dir] Vertical Split & Explore...............|netrw-explore|

                    BANNER DISPLAY                      *netrw-I*
                One may toggle the displaying of the banner by pressing "I".  Also See: |g:netrw_banner|
                One may easily "bookmark" the currently browsed directory by using
                    mb
                    .
                Bookmarks are retained in between sessions of vim in a file called ___
                    .netrwbook  as a |List|,  which is typically stored in the first directory on the user's 'runtimepath'
                    entries are kept in sorted order.
                Addtionally, one may use ____(=command) to bookmark files or directories.
                    :NetrwMB[!] [files/directories]
                    No bang: enters files/directories into Netrw's bookmark system
                    --
                    No argument and in netrw buffer:
                      if there are marked files        : bookmark marked files
                      otherwise                        : bookmark file/directory under cursor
                    No argument and not in netrw buffer: bookmarks current open file
                    Has arguments                      : |glob()|s each arg and bookmarks them
                    With bang: deletes files/directories from Netrw's bookmark system
                    The :NetrwMB command is available outside of netrw buffers (once netrw has been invoked in the session).
                The file ".netrwbook" holds bookmarks when netrw (and vim) is not active.
                    By default, its stored on the first directory on the user's |'runtimepath'|.

                    Related Topics:
                    |netrw-gb| how to return (go) to a bookmark
                    |netrw-mB| how to delete bookmarks
                    |netrw-qb| how to list bookmarks
                    |g:netrw_home| controls where .netrwbook is kept

                    BROWSING                    *netrw-enter*   *netrw-cr*

                    Browsing is simple: move the cursor onto a file or directory of interest.
                    Hitting the <cr> (the return key) will select the file or directory.
                    Directories will themselves be listed, and files will be opened using the
                    protocol given in the original read request.

                    CAVEAT: There are four forms of listing (see |netrw-i|). Netrw assumes that
                    two or more spaces delimit filenames and directory names for the long and
                    wide listing formats.
                =If your filename or directory name has two or more sequential spaces embedded in it, or any trailing spaces, then you'll need to use the ____ to select it.
                        .
                        "thin" format
                The |g:netrw_browse_split| option, which is zero by default, may be used to cause the opening of files to be done in a new window or tab instead of the default.
                    When the option is one or two, the splitting will be taken horizontally or vertically, respectively. When the option is set to three, a <cr> will cause the file to appear in a new tab.
                    When using the gui (gvim), one may select a file by pressing the <leftmouse> button.
                    In addition, if
                    * |g:netrw_retmap| == 1       AND   (its default value is 0)
                    * in a netrw-selected file, AND
                    * the user doesn't already have a <2-leftmouse> mapping defined before netrw is loaded
                    then a doubly-clicked leftmouse button will return to the netrw browser window.

                    Netrw attempts to speed up browsing, especially for remote browsing where one
                    may have to enter passwords, by keeping and re-using previously obtained
                    directory listing buffers. The |g:netrw_fastbrowse| variable is used to
                    control this behavior; one may have slow browsing (no buffer re-use), medium
                    speed browsing (re-use directory buffer listings only for remote directories),
                    and fast browsing (re-use directory buffer listings as often as possible).
                    The price for such re-use is that when changes are made (such as new files
                    are introduced into a directory), the listing may become out-of-date. One may
                    always refresh directory listing buffers by pressing ctrl-L (see
                    |netrw-ctrl-l|).
                                                    *netrw-s-cr*
                    Squeezing the Current Tree-Listing Directory~
                When the tree listing style is enabled (see |netrw-i|) and one is using gvim, then the <s-cr> mapping may be used to squeeze (close) the directory currently containing the cursor.
                    Otherwise, one may remap a key combination of one's own choice to get this effect:
                    nmap <buffer> <silent> <nowait> YOURKEYCOMBO <Plug>NetrwTreeSqueeze
                    Put this line in $HOME/ftplugin/netrw/netrw.vim; it needs to be generated for netrw buffers only.

                    Related topics:
                        |netrw-ctrl-r|  |netrw-o|   |netrw-p|
                        |netrw-P|   |netrw-t|   |netrw-v|
                    Associated setting variables:
                       |g:netrw_browse_split|   |g:netrw_fastbrowse|
                       |g:netrw_ftp_list_cmd|   |g:netrw_ftp_sizelist_cmd|
                       |g:netrw_ftp_timelist_cmd|   |g:netrw_ssh_browse_reject|
                       |g:netrw_ssh_cmd|        |g:netrw_use_noswf|

                    BROWSING WITH A HORIZONTALLY SPLIT WINDOW   *netrw-o* *netrw-horiz*

                    Normally one enters a file or directory using the <cr>.
                However, the "o" map allows one to open a new window to hold the new directory listing or file.
                A horizontal split is used. (for vertical splitting, see |netrw-v|)
                    Normally, the o key splits the window horizontally with the new window and cursor at the top.
                    Associated setting variables: |g:netrw_alto| |g:netrw_winsize|
                    Related topics:
                        |netrw-ctrl-r|  |netrw-o|   |netrw-p|
                        |netrw-P|   |netrw-t|   |netrw-v|
                    Associated setting variables:
                       |g:netrw_alto|    control above/below splitting
                       |g:netrw_winsize| control initial sizing
                    --
                    BROWSING WITH A NEW TAB             *netrw-t*
                    Normally one enters a file or directory using the <cr>.
                The "t" map allows one to open a new window holding the new directory listing or file in a new tab.
                If you'd like to have the new listing in a background tab, use |gT|.
                    Related topics:
                        |netrw-ctrl-r|  |netrw-o|   |netrw-p|
                        |netrw-P|   |netrw-t|   |netrw-v|
                    Associated setting variables:
                       |g:netrw_winsize| control initial sizing

                    BROWSING WITH A VERTICALLY SPLIT WINDOW         *netrw-v*

                    Normally one enters a file or directory using the <cr>. However, the "v" map
                    allows one to open a new window to hold the new directory listing or file. A
                    vertical split is used. (for horizontal splitting, see |netrw-o|)

                    Normally, the v key splits the window vertically with the new window and
                    cursor at the left.

                    There is only one tree listing buffer; using "v" on a displayed subdirectory
                    will split the screen, but the same buffer will be shown twice.

                    Related topics:
                        |netrw-ctrl-r|  |netrw-o|   |netrw-p|
                        |netrw-P|   |netrw-t|   |netrw-v|
                    Associated setting variables:
                       |g:netrw_altv|    control right/left splitting
                       |g:netrw_winsize| control initial sizing

                    BROWSING USING A GVIM SERVER            *netrw-ctrl-r*

                    One may keep a browsing gvim separate from the gvim being used to edit.
                Use the <c-r> map on a file (not a directory) in the netrw browser, and it will use a gvim server (see |g:netrw_servername|).
                Subsequent use of <cr> (see |netrw-cr|) will re-use that server for editing files.
                    Related topics:
                        |netrw-ctrl-r|  |netrw-o|   |netrw-p|
                        |netrw-P|   |netrw-t|   |netrw-v|
                    Associated setting variables:
                        |g:netrw_servername|   : sets name of server
                        |g:netrw_browse_split| : controls how <cr> will open files
                    --
                    CHANGE LISTING STYLE (THIN LONG WIDE TREE)          *netrw-i*
                The "i" map cycles between the thin, long, wide, and tree listing formats.
                  The thin listing format gives just the files' and directories' names.
                    The long listing is either based on the "ls" command via ssh for remote
                    directories or displays the filename, file size (in bytes), and the time and
                    date of last modification for local directories. With the long listing
                    format, netrw is not able to recognize filenames which have trailing spaces.
                    Use the thin listing format for such files.
                    --
                    The wide listing format uses two or more contiguous spaces to delineate
                    filenames; when using that format, netrw won't be able to recognize or use
                    filenames which have two or more contiguous spaces embedded in the name or any
                    trailing spaces. The thin listing format will, however, work with such files.
                    The wide listing format is the most compact.
                The tree listing format has a top directory followed by files and directories
                    preceded by one or more "|"s, which indicate the directory depth.
                    .
                One may open and close directories by pressing the <cr> key while atop the directory name.
                One may make a preferred listing style your default; see |g:netrw_liststyle|.
                    As an example, by putting the following line in your .vimrc,  let g:netrw_liststyle= 3
                    the tree style will become your default listing style.
                One typical way to use the netrw tree display is to: [***(*)] __ __
                    vim .
                    (use i until a tree display shows)
                    navigate to a file
                    v (edit as desired in vertically split window)
                    ctrl-w h (to return to the netrw listing)
                    P (edit newly selected file in the previous window)
                    ctrl-w h (to return to the netrw listing)
                    P (edit newly selected file in the previous window)
                    ...etc...

                    Associated setting variables: |g:netrw_liststyle| |g:netrw_maxfilenamelen|
                                                  |g:netrw_timefmt|   |g:netrw_list_cmd|

                    CHANGE FILE PERMISSION                      *netrw-gp*
                "gp" will ask you for a new permission for the file named under the cursor.
                    Note: Currently, this only works for local files.

                    Associated setting variables: |g:netrw_chgperm|

                    CHANGING TO A BOOKMARKED DIRECTORY          *netrw-gb*
                To change directory back to a bookmarked directory, use ___ ****
                    {cnt}gb

                    Any count may be used to reference any of the bookmarks.
                    Note that |netrw-qb| shows both bookmarks and history;
                to go to a location stored in the history see |netrw-u| and |netrw-U|.
                    Related Topics:
                        |netrw-mB| how to delete bookmarks
                        |netrw-mb| how to make a bookmark
                        |netrw-qb| how to list bookmarks

                    CHANGING TO A PREDECESSOR DIRECTORY     *netrw-u* *netrw-updir*
                Every time you change to a new directory (new for the current session), netrw will save the directory in a recently-visited directory history list (unless |g:netrw_dirhistmax| is zero;
                    by default, it holds ten entries).
                    .
                With the "u" map, one can change to an earlier directory (predecessor).
                To do the opposite, see |netrw-U|.
                    The "u" map also accepts counts to go back in the history several slots.
                    For your convenience, qb (see |netrw-qb|) lists the history number which may be used in that count.
                                            *.netrwhist*
                    See |g:netrw_dirhistmax| for how to control the quantity of history stack slots.
                    The file ".netrwhist" holds history when netrw (and vim) is not active.
                    By default, it's stored on the first directory on the user's |'runtimepath'|.

                    Related Topics:
                        |netrw-U| changing to a successor directory
                        |g:netrw_home| controls where .netrwhist is kept

                    CHANGING TO A SUCCESSOR DIRECTORY       *netrw-U* *netrw-downdir*
                With the "U" map, one can change to a later directory (successor).
                    This map is the opposite of the "u" map. (see |netrw-u|) Use the
                    qb map to list both the bookmarks and history. (see |netrw-qb|)
                The "U" map also accepts counts to go forward in the history several slots.
                    See |g:netrw_dirhistmax| for how to control the quantity of history stack slots.

                    CHANGING TREE TOP           *netrw-ntree* *:Ntree* *netrw-gn*
                One may specify a new tree top for tree listings using
                    :Ntree [dirname]

                    Without a "dirname", the current line is used (and any leading depth information is elided).
                    With a "dirname", the specified directory name is used.
                The "gn" map will take the word below the cursor and use that for changing the top of the tree listing.
                    NETRW CLEAN                 *netrw-clean* *:NetrwClean*
                    .
                With :NetrwClean one may easily remove netrw from one's home directory;
                  more precisely, from the first directory on your |'runtimepath'|.
                With :NetrwClean!, netrw will attempt to remove netrw from all directories on your |'runtimepath'|.
                    Of course, you have to have write/delete permissions correct to do this.
                    With either form of the command, netrw will first ask for confirmation
                    that the removal is in fact what you want to do. If netrw doesn't have
                    permission to remove a file, it will issue an error message.
                                            *netrw-gx*
                    CUSTOMIZING BROWSING WITH A SPECIAL HANDLER *netrw-x* *netrw-handler*
                                            (also see |netrw_filehandler|)
                    Certain files, such as html, gif, jpeg, (word/office) doc, etc, files, are
                    best seen with a special handler (ie. a tool provided with your computer's
                    operating system).
                Netrw allows one to invoke such special handlers by:
                    when Exploring, hit the "x" key
                    when editing, hit gx with the cursor atop the special filename
                      (latter not available if the |g:netrw_nogx| variable exists)
                    Netrw determines which special handler by the following method:
                    * if |g:netrw_browsex_viewer| exists, then it will be used to attempt to
                    view files. Examples of useful settings (place into your <.vimrc>):
                    :let g:netrw_browsex_viewer= "kfmclient exec"
                    or
                    :let g:netrw_browsex_viewer= "xdg-open"
                    If g:netrw_browsex_viewer == '-', then netrwFileHandlers#Invoke() will be used instead (see |netrw_filehandler|).
                    * for Windows 32 or 64, the URL and FileProtocolHandler dlls are used.
                    * for Gnome (with gnome-open): gnome-open is used.
                    * for KDE (with kfmclient)   : kfmclient is used
                    * for Mac OS X               : open is used.
                    * otherwise the netrwFileHandler plugin is used.
                    --
                    The file's suffix is used by these various approaches to determine an
                    appropriate application to use to "handle" these files. Such things as
                    OpenOffice (*.sfx), visualization (*.jpg, *.gif, etc), and PostScript (*.ps,
                    *.eps) can be handled.

                    The gx mapping extends to all buffers; apply "gx" while atop a word and netrw
                    will apply a special handler to it (like "x" works when in a netrw buffer).
                    One may also use visual mode (see |visual-start|) to select the text that the
                    special handler will use. Normally gx uses expand("<cfile>") to pick up the
                    text under the cursor;
                    one may change what |expand()| uses via the |g:netrw_gx| variable (options include "<cword>", "<cWORD>").
                    Note that expand("<cfile>") depends on the |'isfname'| setting. Alternatively, one may select the text to be used by gx by making a visual selection (see |visual-block|) and then pressing gx.

                    Associated setting variables:
                    |g:netrw_gx|    control how gx picks up the text under the cursor
                    |g:netrw_nogx|  prevent gx map while editing
                    |g:netrw_suppress_gx_mesg| controls gx's suppression of browser messages
                                                *netrw_filehandler*
                    When |g:netrw_browsex_viewer| exists and is "-", then netrw will attempt to
                    handle the special file with a vim function. The "x" map applies a function
                    to a file, based on its extension. Of course, the handler function must exist for it to be called!
                    Ex. mypgm.html   x -> NFH_html("scp://user@host/some/path/mypgm.html")
                    Users may write their own netrw File Handler functions to support more suffixes with special handling.
                See <autoload/netrwFileHandlers.vim> for examples on how to make file handler functions.
                    As an example:
                    " NFH_suffix(filename)
                    fun! NFH_suffix(filename)
                    ..do something special with filename..
                    endfun
                    --
                    These functions need to be defined in some file in your .vim/plugin (vimfiles\plugin) directory.
                    Vim's function names may not have punctuation characters (except for the underscore) in them.
                    To support suffices that contain such characters, netrw will first convert the suffix using the following table:

                    @ -> AT       ! -> EXCLAMATION    % -> PERCENT
                    : -> COLON    = -> EQUAL          ? -> QUESTION
                    , -> COMMA    - -> MINUS          ; -> SEMICOLON
                    $ -> DOLLAR   + -> PLUS           ~ -> TILDE
                    So, for example:
                        file.rcs,v -> NFH_rcsCOMMAv()
                    If more such translations are necessary, please send me email:
                            NdrOchip at ScampbellPfamily.AbizM - NOSPAM
                    with a request.
                    Associated setting variable: |g:netrw_browsex_viewer|
                                                *netrw-curdir*
                    DELETING BOOKMARKS                  *netrw-mB*
                To delete a bookmark, use  {cnt}mB
                    If there are marked files, then mB will remove them from the bookmark list.
                    Alternatively, one may use :NetrwMB! (see |netrw-:NetrwMB|).
                    :NetrwMB! [files/directories]
                    Related Topics:
                    |netrw-gb| how to return (go) to a bookmark
                    |netrw-mb| how to make a bookmark
                    |netrw-qb| how to list bookmarks
                    --
                    DELETING FILES OR DIRECTORIES   *netrw-delete* *netrw-D* *netrw-del*
                    If files have not been marked with |netrw-mf|:   (local marked file list)
                Deleting/removing files and directories  involves moving the cursor to the file/directory to be deleted and pressing "D".
                  Directories must be empty first before they can be successfully removed.
                    If the directory is a softlink to a directory, then netrw will make two requests to remove the directory before succeeding.
                    Netrw will ask for confirmation before doing the removal(s).
                You may select a range of lines with the "V" command (visual selection), and then pressing "D".
                    If files have been marked with |netrw-mf|:   (local marked file list)
                    Marked files (and empty directories) will be deleted; again, you'll be
                    asked to confirm the deletion before it actually takes place.
                A further approach is to delete files which match a pattern.
                  * use :MF pattern (see |netrw-:MF|); then press "D".
                  * use mr (see |netrw-mr|) which will prompt you for pattern.
                  This will cause the matching files to be marked. Then, press "D".
                    --
                    If your vim has 7.4 with patch#1107, then |g:netrw_localrmdir| no longer
                    is used to remove directories; instead, vim's |delete()| is used with
                    the "d" option. Please note that only empty directories may be deleted
                    with the "D" mapping. Regular files are deleted with |delete()|, too.

                    The |g:netrw_rm_cmd|, |g:netrw_rmf_cmd|, and |g:netrw_rmdir_cmd| variables are used to control the attempts to remove remote files and directories.
                    The g:netrw_rm_cmd is used with files, and its default value is:
                        g:netrw_rm_cmd: ssh HOSTNAME rm
                    The g:netrw_rmdir_cmd variable is used to support the removal of directories.
                    Its default value is:
                        |g:netrw_rmdir_cmd|: ssh HOSTNAME rmdir
                    If removing a directory fails with g:netrw_rmdir_cmd, netrw then will attempt to remove it again using the g:netrw_rmf_cmd variable. Its default value is:
                    |g:netrw_rmf_cmd|: ssh HOSTNAME rm -f
                    Related topics: |netrw-d|
                    Associated setting variable: |g:netrw_localrmdir| |g:netrw_rm_cmd|
                                                 |g:netrw_rmdir_cmd|   |g:netrw_ssh_cmd|
                    *netrw-explore* *netrw-hexplore* *netrw-nexplore* *netrw-pexplore*
                    *netrw-rexplore* *netrw-sexplore* *netrw-texplore* *netrw-vexplore* *netrw-lexplore*
                [ DIRECTORY EXPLORATION COMMANDS ]
                    :[N]Explore[!] [dir]... Explore directory of current file      *:Explore*
                    :[N]Hexplore[!] [dir]... Horizontal Split & Explore             *:Hexplore*
                    :[N]Lexplore[!] [dir]... Left Explorer Toggle                   *:Lexplore*
                    :[N]Sexplore[!] [dir]... Split&Explore current file's directory *:Sexplore*
                    :[N]Vexplore[!] [dir]... Vertical   Split & Explore             *:Vexplore*
                    :Texplore       [dir]... Tab & Explore                          *:Texplore*
                    :Rexplore            ... Return to/from Explorer                *:Rexplore*
                    Used with :Explore **/pattern : (also see |netrw-starstar|)
                    :Nexplore............. go to next matching file                *:Nexplore*
                    :Pexplore............. go to previous matching file            *:Pexplore*
                                            *netrw-:Explore*
                    :Explore will open the local-directory browser on the current file's directory (or on directory [dir] if specified).
                    The window will be split only if the file has been modified and |'hidden'| is not set,
                    otherwise the browsing window will take over that window.
                    Normally the splitting is taken horizontally.
                    Also see: |netrw-:Rexplore|
                    :Explore! is like :Explore, but will use vertical splitting.
                                            *netrw-:Hexplore*
                    :Hexplore [dir] does an :Explore with |:belowright| horizontal splitting.
                    :Hexplore! [dir] does an :Explore with |:aboveleft| horizontal splitting.
                                            *netrw-:Lexplore*
                    :[N]Lexplore [dir] toggles a full height Explorer window on the left hand side of the current tab.
                    It will open a netrw window on the current
                          directory if [dir] is omitted; a :Lexplore [dir] will show the
                          specified directory in the left-hand side browser display no matter
                          from which window the command is issued.

                          By default, :Lexplore will change an uninitialized |g:netrw_chgwin|
                          to 2; edits will thus preferentially be made in window#2.

                          The [N] specifies a |g:netrw_winsize| just for the new :Lexplore
                          window.

                          Those who like this method often also like tree style displays;
                          see |g:netrw_liststyle|.

                    :[N]Lexplore! [dir] is similar to :Lexplore, except that the full-height
                          Explorer window will open on the right hand side and an
                          uninitialized |g:netrw_chgwin| will be set to 1 (eg. edits will
                          preferentially occur in the leftmost window).

                          Also see: |netrw-C|           |g:netrw_browse_split|   |g:netrw_wiw|
                                |netrw-p| |netrw-P|   |g:netrw_chgwin|
                                |netrw-c-tab|       |g:netrw_winsize|

                                            *netrw-:Sexplore*
                    :[N]Sexplore will always split the window before invoking the local-directory browser.
                     As with Explore, the splitting is normally done horizontally.
                    :[N]Sexplore! [dir] is like :Sexplore, but the splitting will be done vertically.

                                            *netrw-:Texplore*
                    :Texplore [dir] does a |:tabnew| before generating the browser window

                                            *netrw-:Vexplore*
                    :[N]Vexplore [dir] does an :Explore with |:leftabove| vertical splitting.
                    :[N]Vexplore! [dir] does an :Explore with |:rightbelow| vertical splitting.

                    The optional parameters are:

                     [N]: This parameter will override |g:netrw_winsize| to specify the quantity of
                          rows and/or columns the new explorer window should have.
                          Otherwise, the |g:netrw_winsize| variable, if it has been specified by the
                          user, is used to control the quantity of rows and/or columns new
                          explorer windows should have.

                     [dir]: By default, these explorer commands use the current file's directory.
                            However, one may explicitly provide a directory (path) to use instead;
                        ie.

                        :Explore /some/path
                    <
                                            *netrw-:Rexplore*
                    :Rexplore This command is a little different from the other Explore commands
                           as it doesn't necessarily open an Explorer window.

                           Return to Explorer~
                           When one edits a file using netrw which can occur, for example,
                           when pressing <cr> while the cursor is atop a filename in a netrw
                           browser window, a :Rexplore issued while editing that file will
                           return the display to that of the last netrw browser display in
                           that window.

                           Return from Explorer~
                           Conversely, when one is editing a directory, issuing a :Rexplore
                           will return to editing the file that was last edited in that
                           window.

                           The <2-leftmouse> map (which is only available under gvim and
                           cooperative terms) does the same as :Rexplore.

                    Also see: |g:netrw_alto| |g:netrw_altv| |g:netrw_winsize|
                    *netrw-star* *netrw-starpat* *netrw-starstar* *netrw-starstarpat* *netrw-grep*
                [ EXPLORING WITH STARS AND PATTERNS ] __ __ ****
                    When Explore, Sexplore, Hexplore, or Vexplore are used with one of the following four patterns
                    Explore generates a list of files which satisfy the request for the local file system.
                    These exploration patterns will not work with remote file browsing.
                    */filepat   files in current directory which satisfy filepat
                    **/filepat  files in current directory or below which satisfy the
                        file pattern
                    *//pattern  files in the current directory which contain the
                        pattern (vimgrep is used)
                    **//pattern files in the current directory or below which contain
                        the pattern (vimgrep is used)
                    --
                    The cursor will be placed on the first file in the list.
                    One may then continue to go to subsequent files on that list via |:Nexplore| or to preceding files on that list with |:Pexplore|.
                    Explore will update the directory and place the cursor appropriately.
                    A plain
                        :Explore
                    will clear the explore list.
                If your console or gui produces recognizable shift-up or shift-down sequences, then you'll likely find using shift-downarrow and shift-uparrow convenient. [__]
                    They're mapped by netrw as follows:
                    <s-down> == Nexplore, and
                    <s-up>   == Pexplore.
                    As an example, consider
                        :Explore */*.c
                        :Nexplore
                        :Nexplore
                        :Pexplore
                    The status line will show, on the right hand side of the status line, a message like "Match 3 of 20".
                    Associated setting variables:
                    |g:netrw_keepdir|          |g:netrw_browse_split|
                    |g:netrw_fastbrowse|       |g:netrw_ftp_browse_reject|
                    |g:netrw_ftp_list_cmd|     |g:netrw_ftp_sizelist_cmd|
                    |g:netrw_ftp_timelist_cmd| |g:netrw_list_cmd|
                    |g:netrw_liststyle|
                    --
                    DISPLAYING INFORMATION ABOUT FILE               *netrw-qf*
                With the cursor atop a filename, pressing "qf" will reveal the file's size and last modification timestamp.
                    Currently this capability is only available for local files.
                    --
                    EDIT FILE OR DIRECTORY HIDING LIST  *netrw-ctrl-h* *netrw-edithide*
                The "<ctrl-h>" map brings up a requestor allowing the user to change the file/directory hiding list contained in |g:netrw_list_hide|.
                    The hiding list consists of one or more patterns delimited by commas.
                    Files and/or directories satisfying these patterns will either be hidden (ie. not shown) or be the only ones displayed (see |netrw-a|).
                The "gh" mapping (see |netrw-gh|) quickly alternates between the usual hiding list and the hiding of files or directories that begin with ".".
                As an example,  let g:netrw_list_hide= '\(^\|\s\s\)\zs\.\S\+'
                    Effectively, this makes the effect of a |netrw-gh| command the initial setting.
                    What it means:
                    \(^\|\s\s\)   : if the line begins with the following, -or- two consecutive spaces are encountered
                    \zs           : start the hiding match now
                    \.            : if it now begins with a dot
                    \S\+          : and is followed by one or more non-whitespace characters
                    Associated setting variables: |g:netrw_hide| |g:netrw_list_hide|
                    Associated topics: |netrw-a| |netrw-gh| |netrw-mh|
                                        *netrw-sort-sequence*
                    EDITING THE SORTING SEQUENCE        *netrw-S* *netrw-sortsequence*
                    When "Sorted by" is name, one may specify priority via the sorting sequence (g:netrw_sort_sequence).
                    The sorting sequence typically prioritizes the name-listing by suffix, although any pattern will do.
                    Patterns are delimited by commas.
                    The default sorting sequence is (all one line):
                    For Unix:
                        '[\/]$,\<core\%(\.\d\+\)\=,\.[a-np-z]$,\.h$,\.c$,\.cpp$,*,\.o$,\.obj$,
                        \.info$,\.swp$,\.bak$,\~$'
                    Otherwise:
                        '[\/]$,\.[a-np-z]$,\.h$,\.c$,\.cpp$,*,\.o$,\.obj$,\.info$,
                        \.swp$,\.bak$,\~$'
                    The lone * is where all filenames not covered by one of the other patterns will end up.
                    One may change the sorting sequence by modifying the g:netrw_sort_sequence variable (either manually or in your <.vimrc>) or by using the "S" map.
                    Related topics:               |netrw-s|               |netrw-S|
                    Associated setting variables: |g:netrw_sort_sequence| |g:netrw_sort_options|
                    --
                    EXECUTING FILE UNDER CURSOR VIA SYSTEM()            *netrw-X*
                ( Pressing X while the cursor is atop an executable file will yield a prompt using the filename asking for any arguments. )
                    Upon pressing a [return], netrw will then call |system()| with that command and arguments.
                    The result will be displayed by |:echomsg|, and so |:messages| will repeat display of the result.
                    Ansi escape sequences will be stripped out.
                    See |cmdline-window| for directions for more on how to edit the arguments.
                    --
                    FORCING TREATMENT AS A FILE OR DIRECTORY    *netrw-gd* *netrw-gf*
                    Remote symbolic links (ie. those listed via ssh or ftp) are problematic in that it is difficult to tell whether they link to a file or to a directory.
                To force treatment as a file: use gf
                To force treatment as a directory: use gd
                    GOING UP                            *netrw--*
                To go up a directory, press "-"
                or press the <cr> when atop the ../ directory entry in the listing.
                    Netrw will use the command in |g:netrw_list_cmd| to perform the directory listing operation after changing HOSTNAME to the host specified by the user-prpvided url.
                    By default netrw provides the command as:
                        ssh HOSTNAME ls -FLa
                    where the HOSTNAME becomes the [user@]hostname as requested by the attempt to read.
                    Naturally, the user may override this command with whatever is preferred.
                    The NetList function which implements remote browsing
                    expects that directories will be flagged by a trailing slash.
                    --
                    HIDING FILES OR DIRECTORIES         *netrw-a* *netrw-hiding*
                    Netrw's browsing facility allows one to use the hiding list in one of three ways: ignore it, hide files which match, and show only those files which match.
                    If no files have been marked via |netrw-mf|:
                The "a" map allows the user to cycle through the three hiding modes.
                The |g:netrw_list_hide| variable holds a comma delimited list of patterns based on regular expressions (ex. ^.*\.obj$,^\.) which specify the hiding list.
                    (also see |netrw-ctrl-h|) To set the hiding list, use the <c-h> map.
                    As an example, to hide files which begin with a ".", one may use the <c-h> map to set the hiding list to '^\..*' (or one may put let g:netrw_list_hide= '^\..*' in one's <.vimrc>).
                    One may then use the "a" key to show all files, hide matching files, or to show only the matching files.
                    Example: \.[ch]$
                    This hiding list command will hide/show all *.c and *.h files.
                    Example: \.c$,\.h$
                    This hiding list command will also hide/show all *.c and *.h files.
                    Don't forget to use the "a" map to select the mode (normal/hiding/show) you want!
                If files have been marked using |netrw-mf|, then this command will:
                     if showing all files or non-hidden files:
                      modify the g:netrw_list_hide list by appending the marked files to it
                      and showing only non-hidden files.

                     else if showing hidden files only:
                      modify the g:netrw_list_hide list by removing the marked files from it
                      and showing only non-hidden files.
                     endif
                                        *netrw-gh* *netrw-hide*
                As a quick shortcut, one may press gh to toggle between hiding files which begin with a period (dot) and not hiding them.
                    Associated setting variables: |g:netrw_list_hide| |g:netrw_hide|
                    Associated topics: |netrw-a| |netrw-ctrl-h| |netrw-mh|
                                        *netrw-gitignore*
                Netrw provides a helper function 'netrw_gitignore#Hide()' that, when used with |g:netrw_list_hide| automatically hides all git-ignored files.
                    'netrw_gitignore#Hide' searches for patterns in the following files:
                    './.gitignore'
                    './.git/info/exclude'
                    global gitignore file: `git config --global core.excludesfile`
                    system gitignore file: `git config --system core.excludesfile`
                    Files that do not exist, are ignored.
                    Git-ignore patterns are taken from existing files, and converted to patterns for hiding files.
                    For example, if you had '*.log' in your '.gitignore' file, it would be converted to '.*\.log'.
                To use this function, simply assign its output to |g:netrw_list_hide| option.
                        Example: let g:netrw_list_hide= netrw_gitignore#Hide()
                            Git-ignored files are hidden in Netrw.

                        Example: let g:netrw_list_hide= netrw_gitignore#Hide('my_gitignore_file')
                            Function can take additional files with git-ignore patterns.

                        Example: g:netrw_list_hide= netrw_gitignore#Hide() . '.*\.swp$'
                            Combining 'netrw_gitignore#Hide' with custom patterns.

                    IMPROVING BROWSING          *netrw-listhack* *netrw-ssh-hack*
                Especially with the remote directory browser, constantly entering the password is tedious.
                    For Linux/Unix systems, the book "Linux Server Hacks - 100 industrial strength tips & tools" by Rob Flickenger (O'Reilly, ISBN 0-596-00461-3) gives a tip for setting up no-password ssh and scp and discusses associated security issues.
                    It used to be available at http://hacks.oreilly.com/pub/h/66, but apparently that address is now being redirected to some "hackzine".
                    I'll attempt a summary based on that article and on a communication from Ben Schmidt:
                        1. Generate a public/private key pair on the local machine
                           (ssh client):
                            ssh-keygen -t rsa
                            (saving the file in ~/.ssh/id_rsa as prompted)
                        2. Just hit the <CR> when asked for passphrase (twice) for no
                           passphrase. If you do use a passphrase, you will also need to use
                           ssh-agent so you only have to type the passphrase once per session.
                           If you don't use a passphrase, simply logging onto your local
                           computer or getting access to the keyfile in any way will suffice
                           to access any ssh servers which have that key authorized for login.

                        3. This creates two files:
                            ~/.ssh/id_rsa
                            ~/.ssh/id_rsa.pub
                        4. On the target machine (ssh server):
                            cd
                            mkdir -p .ssh
                            chmod 0700 .ssh
                        5. On your local machine (ssh client): (one line)
                            ssh {serverhostname}
                              cat '>>' '~/.ssh/authorized_keys2' < ~/.ssh/id_rsa.pub
                           or, for OpenSSH, (one line)
                            ssh {serverhostname}
                              cat '>>' '~/.ssh/authorized_keys' < ~/.ssh/id_rsa.pub
                    You can test it out with
                        ssh {serverhostname}
                    and you should be log onto the server machine without further need to type
                    anything.
                    --
                    If you decided to use a passphrase, do:
                        ssh-agent $SHELL
                        ssh-add
                        ssh {serverhostname}
                    You will be prompted for your key passphrase when you use ssh-add, but not
                    subsequently when you use ssh. For use with vim, you can use
                        ssh-agent vim
                    and, when next within vim, use
                        :!ssh-add
                    Alternatively, you can apply ssh-agent to the terminal you're planning on
                    running vim in:
                        ssh-agent xterm &
                    and do ssh-add whenever you need.
                    --
                    For Windows, folks on the vim mailing list have mentioned that Pageant helps
                    with avoiding the constant need to enter the password.
                    --
                    Kingston Fung wrote about another way to avoid constantly needing to enter
                    passwords:
                        In order to avoid the need to type in the password for scp each time, you
                        provide a hack in the docs to set up a non password ssh account. I found a
                        better way to do that: I can use a regular ssh account which uses a
                        password to access the material without the need to key-in the password
                        each time. It's good for security and convenience. I tried ssh public key
                        authorization + ssh-agent, implementing this, and it works! Here are two
                        links with instructions:

                        http://www.ibm.com/developerworks/library/l-keyc2/
                        http://sial.org/howto/openssh/publickey-auth/

                        Ssh hints:

                        Thomer Gil has provided a hint on how to speed up netrw+ssh:
                            http://thomer.com/howtos/netrw_ssh.html

                        Alex Young has several hints on speeding ssh up:
                            http://usevim.com/2012/03/16/editing-remote-files/

                    LISTING BOOKMARKS AND HISTORY       *netrw-qb* *netrw-listbookmark*
                Pressing "qb" (query bookmarks) will list both the bookmarked directories and directory traversal history.
                    Related Topics:
                    |netrw-gb| how to return (go) to a bookmark
                    |netrw-mb| how to make a bookmark
                    |netrw-mB| how to delete bookmarks
                    |netrw-u| change to a predecessor directory via the history stack
                    |netrw-U| change to a successor   directory via the history stack

                    MAKING A NEW DIRECTORY                  *netrw-d*
                With the "d" map one may make a new directory either remotely (which depends on the global variable g:netrw_mkdir_cmd) or locally (which depends on the global variable g:netrw_localmkdir).
                    Netrw will issue a request for the new directory's name.
                    A bare <CR> at that point will abort the making of the directory.
                    Attempts to make a local directory that already exists (as either a file or a directory) will be detected, reported on, and ignored.
                    Related topics: |netrw-D|
                    Associated setting variables:   |g:netrw_localmkdir|   |g:netrw_mkdir_cmd|
                                    |g:netrw_remote_mkdir| |netrw-%|

                    MAKING THE BROWSING DIRECTORY THE CURRENT DIRECTORY *netrw-cd*
                ( By default, |g:netrw_keepdir| is 1. )
                    This setting means that the current directory will not track the browsing directory. (done for backwards compatibility with v6's file explorer).
                Setting g:netrw_keepdir to 0 tells netrw to make vim's current directory track netrw's browsing directory.
                    However, given the default setting for g:netrw_keepdir of 1 where netrw maintains its own separate notion of the current directory, in order to make the two directories the same, use the "cd" map (type cd).
                That map will set Vim's notion of the current directory to netrw's current browsing directory.
                    *netrw-c* : This map's name has been changed from "c" to cd (see |netrw-cd|).
                              This change was done to allow for |netrw-cb| and |netrw-cB| maps.
                    Associated setting variable: |g:netrw_keepdir|
                    MARKING FILES                   *netrw-:MF* *netrw-mf*
                        (also see |netrw-mr|)
                    Netrw provides several ways to mark files:
                * One may mark files with the cursor atop a filename and then pressing "mf".
                * With gvim, in addition one may mark files with <s-leftmouse>. (see |netrw-mouse|)
                * One may use the :MF command, which takes a list of files (for local directories, the list may include wildcards -- see |glob()|)
                            :MF *.c
                        (Note that :MF uses |<f-args>| to break the line at spaces)
                * Mark files using the |argument-list| (|netrw-mA|)
                * Mark files based upon a |location-list| (|netrw-qL|)
                * Mark files based upon the quickfix list (|netrw-qF|)
                          (|quickfix-error-lists|)
                          .
                Ref: The following netrw maps make use of marked files: ****
                    |netrw-a|   Hide marked files/directories
                    |netrw-D|   Delete marked files/directories
                    |netrw-ma|  Move marked files' names to |arglist|
                    |netrw-mA|  Move |arglist| filenames to marked file list
                    |netrw-mb|  Append marked files to bookmarks
                    |netrw-mB|  Delete marked files from bookmarks
                    |netrw-mc|  Copy marked files to target
                    |netrw-md|  Apply vimdiff to marked files
                    |netrw-me|  Edit marked files
                    |netrw-mF|  Unmark marked files
                    |netrw-mg|  Apply vimgrep to marked files
                    |netrw-mm|  Move marked files to target
                    |netrw-mp|  Print marked files
                    |netrw-ms|  Netrw will source marked files
                    |netrw-mt|  Set target for |netrw-mm| and |netrw-mc|
                    |netrw-mT|  Generate tags using marked files
                    |netrw-mv|  Apply vim command to marked files
                    |netrw-mx|  Apply shell command to marked files
                    |netrw-mX|  Apply shell command to marked files, en bloc
                    |netrw-mz|  Compress/Decompress marked files
                    |netrw-O|   Obtain marked files
                    |netrw-R|   Rename marked files
                One may unmark files one at a time the same way one marks them; ie. place the cursor atop a marked file and press "mf".
                    This process also works with <s-leftmouse> using gvim.
                    .
                One may unmark all files by pressing "mu" (see |netrw-mu|).
                Marked files are highlighted using the "netrwMarkFile" highlighting group,
                    which by default is linked to "Identifier" (see Identifier under |group-name|).
                    You may change the highlighting group by putting something like
                        highlight clear netrwMarkFile
                        hi link netrwMarkFile ..whatever..
                    into $HOME/.vim/after/syntax/netrw.vim .
                If the mouse is enabled and works with your vim, you may use <s-leftmouse> to mark one or more files.
                You may mark multiple files by dragging the shifted leftmouse. (see |netrw-mouse|)
                                *markfilelist* *global_markfilelist* *local_markfilelist*
                    All marked files are entered onto the global marked file list; there is only one such list.
                In addition, every netrw buffer also has its own buffer-local marked file list;
                    since netrw buffers are associated with specific directories, this means that each directory has its own local marked file list.
                    The various commands which operate on marked files use one or the other of the marked file lists.
                    --
                    Known Problem: if one is using tree mode (|g:netrw_liststyle|) and several
                    directories have files with the same name, then marking such a file will
                    result in all such files being highlighted as if they were all marked.
                    The |markfilelist|, however, will only have the selected file in it.
                    This problem is unlikely to be fixed.

                    UNMARKING FILES                         *netrw-mF*
                        (also see |netrw-mf|, |netrw-mu|)
                The "mF" command will unmark all files in the current buffer.
                    One may also use mf (|netrw-mf|) on a specific, already marked, file to unmark just that file.
                    .
                    MARKING FILES BY LOCATION LIST                  *netrw-qL*
                    (also see |netrw-mf|)
                One may convert |location-list|s into a marked file list using "qL". __
                    You may then proceed with commands such as me (|netrw-me|) to edit them.
                    MARKING FILES BY QUICKFIX LIST                  *netrw-qF*
                        (also see |netrw-mf|)
                One may convert |quickfix-error-lists| into a marked file list using "qF". __
                    You may then proceed with commands such as me (|netrw-me|) to edit them.
                    Quickfix error lists are generated, for example, by calls to |:vimgrep|.  @
                    --
                      MARKING FILES BY REGULAR EXPRESSION             *netrw-mr*
                      (also see |netrw-mf|)
                One may also mark files by pressing "mr"; netrw will then issue a prompt, "Enter regexp: ".
                    You may then enter a shell-style regular expression such as *.c$ (see |glob()|).
                    For remote systems, glob() doesn't work -- so netrw converts "*" into ".*" (see |regexp|) and marks files based on that.
                    In the future I may make it possible to use |regexp|s instead of glob()-style expressions (yet-another-option).
                    See |cmdline-window| for directions on more on how to edit the regular expression.
                    --
                    MARKED FILES, ARBITRARY VIM COMMAND             *netrw-mv*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (uses the local marked-file list)
                The "mv" map causes netrw to execute an arbitrary vim command on each file on the local marked file list, individually:
                    * 1split
                    * sil! keepalt e file
                    * run vim command
                    * sil! keepalt wq!
                    A prompt, "Enter vim command: ", will be issued to elicit the vim command you wish used.
                    See |cmdline-window| for directions for more on how to edit the command.
                    --
                    MARKED FILES, ARBITRARY SHELL COMMAND               *netrw-mx*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (uses the local marked-file list)
                Upon activation of the "mx" map, netrw will query the user for some (external) command to be applied to all marked files.
                    All "%"s in the command will be substituted with the name of each marked file in turn.
                    If no "%"s are in the command, then the command will be followed by a space and a marked filename.
                    Example:
                    (mark files)
                    mx
                    Enter command: cat
                    The result is a series of shell commands:
                    cat 'file1'
                    cat 'file2'
                    ...
                    MARKED FILES, ARBITRARY SHELL COMMAND, EN BLOC          *netrw-mX*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (uses the global marked-file list)
                Upon activation of the 'mX' map, netrw will query the user for some (external) command to be applied to all marked files on the global marked file list.
                    The "en bloc" means that one command will be executed on all the files at once:
                    command files
                    This approach is useful, for example, to select files and make a tarball:
                    (mark files)
                    mX
                    Enter command: tar cf mynewtarball.tar
                    The command that will be run with this example:
                    tar cf mynewtarball.tar 'file1' 'file2' ...
                    --
                    MARKED FILES: ARGUMENT LIST             *netrw-ma* *netrw-mA*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (uses the global marked-file list)
                Using ma, one moves filenames from the marked file list to the argument list.
                Using mA, one moves filenames from the argument list to the marked file list.
                    See Also: |netrw-cb| |netrw-cB| |netrw-qF| |argument-list| |:args|
                    MARKED FILES: BUFFER LIST               *netrw-cb* *netrw-cB*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (uses the global marked-file list)
                Using cb, one moves filenames from the marked file list to the buffer list.
                Using cB, one copies filenames from the buffer list to the marked file list.
                    See Also: |netrw-ma| |netrw-mA| |netrw-qF| |buffer-list| |:buffers|
                    --
                    MARKED FILES: COMPRESSION AND DECOMPRESSION     *netrw-mz*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (uses the local marked file list)
                If any marked files are compressed, then "mz" will decompress them.  If any marked files are decompressed, then "mz" will compress them
                    using the command specified by |g:netrw_compress|; by default, that's "gzip".
                    For decompression, netrw uses a |Dictionary| of suffices and their associated decompressing utilities; see |g:netrw_decompress|.
                    Remember that one can mark multiple files by regular expression
                    tip: (see |netrw-mr|); this is particularly useful to facilitate compressing and decompressing a large number of files.
                    Associated setting variables: |g:netrw_compress| |g:netrw_decompress|
                    --
                    MARKED FILES: COPYING                       *netrw-mc*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (Uses the global marked file list)
                Select a target directory with mt (|netrw-mt|).  Then change directory, select file(s) (see |netrw-mf|), and press "mc".
                    The copy is done from the current window (where one does the mf) to the target.
                    If one does not have a target directory set with |netrw-mt|, then netrw will query you for a directory to copy to.
                    One may also copy directories and their contents (local only) to a target directory.
                    Associated setting variables:
                    |g:netrw_localcopycmd|      |g:netrw_localcopycmdopt|
                    |g:netrw_localcopydircmd|   |g:netrw_localcopydircmdopt|
                    |g:netrw_ssh_cmd|
                    --
                MARKED FILES: DIFF                      *netrw-md*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (uses the global marked file list)
                    Use |vimdiff| to visualize difference between selected files (two or three may be selected for this).
                    Uses the global marked file list.
                    --
                    MARKED FILES: EDITING                       *netrw-me*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (uses the global marked file list)
                The "me" command will place the marked files on the |arglist| and commence editing them.
                 One may return the to explorer window with |:Rexplore|.
                (use |:n| and |:p| to edit next and previous files in the arglist)
                    --
                    MARKED FILES: GREP                      *netrw-mg*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (uses the global marked file list)
                The "mg" command will apply |:vimgrep| to the marked files.
                    The command will ask for the requested pattern; one may then enter:
                      /pattern/[g][j]
                      ! /pattern/[g][j]
                      pattern
                    With /pattern/, editing will start with the first item on the |quickfix| list that vimgrep sets up (see |:copen|, |:cnext|, |:cprevious|, |:cclose|).
                    The |:vimgrep| command is in use, so without 'g' each line is added to quickfix list only once; with 'g' every match is included.
                With /pattern/j, "mg" will winnow the current marked file list to just those marked files also possessing the specified pattern.
                    Thus, one may use
                      mr ...file-pattern...
                      mg /pattern/j
                    to have a marked file list satisfying the file-pattern but also restricted to files containing some desired pattern.
                    MARKED FILES: HIDING AND UNHIDING BY SUFFIX         *netrw-mh*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (uses the local marked file list)
                The "mh" command extracts the suffices of the marked files and toggles their presence on the hiding list.
                    Please note that marking the same suffix this way multiple times
                    will result in the suffix's presence being toggled for each file
                    (so an even quantity of marked files having the same suffix is the same as not having bothered to select them at all).
                    Related topics: |netrw-a| |g:netrw_list_hide|
                    --
                ! MARKED FILES: MOVING                        *netrw-mm*  @@
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (uses the global marked file list)
                      WARNING: moving files is more dangerous than copying them.
                      A file being moved is first copied and then deleted; if the copy operation fails and the delete succeeds, you will lose the file.
                      Either try things out with unimportant files first or do the copy and then delete yourself using mc and D.
                      Use at your own risk!
                    Select a target directory with mt (|netrw-mt|).
                    Then change directory, select file(s) (see |netrw-mf|), and press "mm".
                    The move is done from the current window (where one does the mf) to the target.
                    Associated setting variable: |g:netrw_localmovecmd| |g:netrw_ssh_cmd|
                    --
                    MARKED FILES: PRINTING                      *netrw-mp*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (uses the local marked file list)
                When "mp" is used, netrw will apply the |:hardcopy| command to marked files.
                    What netrw does is open each file in a one-line window, execute hardcopy, then close the one-line window.
                    MARKED FILES: SOURCING                      *netrw-ms*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (uses the local marked file list)
                With "ms", netrw will source the marked files (using vim's |:source| command)  @
                MARKED FILES: SETTING THE TARGET DIRECTORY          *netrw-mt*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    Set the marked file copy/move-to target (see |netrw-mc| and |netrw-mm|):
                    * If the cursor is atop a file name, then the netrw window's currently
                      displayed directory is used for the copy/move-to target.
                    * Also, if the cursor is in the banner, then the netrw window's currently
                      displayed directory is used for the copy/move-to target.
                      Unless the target already is the current directory.
                      In which case, typing "mf" clears the target.
                    * However, if the cursor is atop a directory name, then that directory is used for the copy/move-to target
                    * One may use the :MT [directory] command to set the target   *netrw-:MT*
                      This command uses |<q-args>|, so spaces in the directory name are permitted without escaping.
                    * With mouse-enabled vim or with gvim, one may select a target by using <c-leftmouse>
                    There is only one copy/move-to target at a time in a vim session; ie. the
                    target is a script variable (see |s:var|) and is shared between all netrw
                    windows (in an instance of vim).
                    --
                    When using menus and gvim, netrw provides a "Targets" entry which allows one to pick a target from the list of bookmarks and history.
                    Related topics:
                    Marking Files......................................|netrw-mf|
                    Marking Files by Regular Expression................|netrw-mr|
                    Marked Files: Target Directory Using Bookmarks.....|netrw-Tb|
                    Marked Files: Target Directory Using History.......|netrw-Th|
                    --
                    MARKED FILES: TAGGING                       *netrw-mT*
                    (See |netrw-mf| and |netrw-mr| for how to mark files)
                    (uses the global marked file list)
                The "mT" mapping will apply the command in |g:netrw_ctags| (by default, it is "ctags") to marked files.  (@)
                    For remote browsing, in order to create a tags file netrw will use ssh (see |g:netrw_ssh_cmd|),
                    and so ssh must be available for this to work on remote systems.
                    For your local system, see |ctags| on how to get a version.
                    I myself use hdrtags, currently available at http://www.drchip.org/astronaut/src/index.html, and have
                      let g:netrw_ctags= "hdrtag"
                    in my <.vimrc>.
                    When a remote set of files are tagged, the resulting tags file is "obtained";
                    ie. a copy is transferred to the local system's directory.
                    The now local tags file is then modified so that one may use it through the network.
                    The modification made concerns the names of the files in the tags;
                    each filename is preceded by the netrw-compatible URL used to obtain it.
                    When one subsequently uses one of the go to tag actions (|tags|),
                    the URL will be used by netrw to edit the desired file and go to the tag.
                    --
                    Associated setting variables: |g:netrw_ctags| |g:netrw_ssh_cmd|
                    --
                MARKED FILES: TARGET DIRECTORY USING BOOKMARKS      *netrw-Tb*
                    Sets the marked file copy/move-to target.
                    .
                The |netrw-qb| map will give you a list of bookmarks (and history).
                One may choose one of the bookmarks to become your marked file target by using [count]Tb (default count: 1).
                    Related topics:
                    Copying files to target............................|netrw-mc|
                    Listing Bookmarks and History......................|netrw-qb|
                    Marked Files: Setting The Target Directory.........|netrw-mt|
                    Marked Files: Target Directory Using History.......|netrw-Th|
                    Marking Files......................................|netrw-mf|
                    Marking Files by Regular Expression................|netrw-mr|
                    Moving files to target.............................|netrw-mm|
                    --
                    MARKED FILES: TARGET DIRECTORY USING HISTORY            *netrw-Th*
                    Sets the marked file copy/move-to target.
                    The |netrw-qb| map will give you a list of history (and bookmarks).
                One may choose one of the history entries to become your marked file target by using [count]Th (default count: 0; ie. the current directory).
                    Related topics:
                    Copying files to target............................|netrw-mc|
                    Listing Bookmarks and History......................|netrw-qb|
                    Marked Files: Setting The Target Directory.........|netrw-mt|
                    Marked Files: Target Directory Using Bookmarks.....|netrw-Tb|
                    Marking Files......................................|netrw-mf|
                    Marking Files by Regular Expression................|netrw-mr|
                    Moving files to target.............................|netrw-mm|
                    --
                    MARKED FILES: UNMARKING                     *netrw-mu*
                    (See |netrw-mf|, |netrw-mF|)
                The "mu" mapping will unmark all currently marked files.
                This command differs from "mF" as the latter only unmarks files in the current directory
                    whereas "mu" will unmark global and all buffer-local marked files.
                    (see |netrw-mF|)
                    *netrw-browser-settings*
                [[ NETRW BROWSER VARIABLES     *netrw-browser-options* *netrw-browser-var* ]]
                    (if you're interested in the netrw file transfer settings, see |netrw-options| and |netrw-protocol|)
                    The <netrw.vim> browser provides settings in the form of variables which you may modify;
                    by placing these settings in your <.vimrc>, you may customize your browsing preferences. (see also: |netrw-settings|)
                    ---              -----------
                    Var              Explanation
                    ---              -----------
                    < *g:netrw_altfile*     some like |CTRL-^| to return to the last
                                    edited file. Choose that by setting this
                                    parameter to 1.
                                    Others like |CTRL-^| to return to the
                                    netrw browsing buffer. Choose that by setting
                                    this parameter to 0.
                                     default: =0

                      *g:netrw_alto*        change from above splitting to below splitting
                                    by setting this variable (see |netrw-o|)
                                     default: =&sb           (see |'sb'|)

                      *g:netrw_altv*        change from left splitting to right splitting
                                    by setting this variable (see |netrw-v|)
                                     default: =&spr          (see |'spr'|)

                      *g:netrw_banner*      enable/suppress the banner
                                    =0: suppress the banner
                                    =1: banner is enabled (default)

                      *g:netrw_bannerbackslash* if this variable exists and is not zero, the
                                    banner will be displayed with backslashes
                                    rather than forward slashes.

                      *g:netrw_browse_split*    when browsing, <cr> will open the file by:
                                    =0: re-using the same window (default)
                                    =1: horizontally splitting the window first
                                    =2: vertically   splitting the window first
                                    =3: open file in new tab
                                    =4: act like "P" (ie. open previous window)
                                        Note that |g:netrw_preview| may be used
                                        to get vertical splitting instead of
                                        horizontal splitting.
                                    =[servername,tab-number,window-number]
                                        Given a |List| such as this, a remote server
                                        named by the "servername" will be used for
                                        editing. It will also use the specified tab
                                        and window numbers to perform editing
                                        (see |clientserver|, |netrw-ctrl-r|)
                                    This option does not affect the production of
                                    |:Lexplore| windows.

                                    Related topics:
                                        |g:netrw_alto|  |g:netrw_altv|
                                        |netrw-C|       |netrw-cr|
                                        |netrw-ctrl-r|

                      *g:netrw_browsex_viewer*  specify user's preference for a viewer:
                                        "kfmclient exec"
                                        "gnome-open"
                    <               If
                                        "-"
                    <               is used, then netrwFileHandler() will look for
                                    a script/function to handle the given
                                    extension. (see |netrw_filehandler|).

                      *g:netrw_chgperm*     Unix/Linux: "chmod PERM FILENAME"
                                    Windows:    "cacls FILENAME /e /p PERM"
                                    Used to change access permission for a file.

                      *g:netrw_compress*        ="gzip"
                                        Will compress marked files with this
                                        command

                      *g:Netrw_corehandler*     Allows one to specify something additional
                                    to do when handling <core> files via netrw's
                                    browser's "x" command (see |netrw-x|). If
                                    present, g:Netrw_corehandler specifies
                                    either one or more function references
                                    (see |Funcref|). (the capital g:Netrw...
                                    is required its holding a function reference)


                      *g:netrw_ctags*       ="ctags"
                                    The default external program used to create
                                    tags

                      *g:netrw_cursor*      = 2 (default)
                                    This option controls the use of the
                                    |'cursorline'| (cul) and |'cursorcolumn'|
                                    (cuc) settings by netrw:

                                    Value   Thin-Long-Tree      Wide
                                     =0      u-cul u-cuc      u-cul u-cuc
                                     =1      u-cul u-cuc        cul u-cuc
                                     =2        cul u-cuc        cul u-cuc
                                     =3        cul u-cuc        cul   cuc
                                     =4        cul   cuc        cul   cuc

                                    Where
                                      u-cul : user's |'cursorline'|   setting used
                                      u-cuc : user's |'cursorcolumn'| setting used
                                      cul   : |'cursorline'| locally set
                                      cuc   : |'cursorcolumn'| locally set

                      *g:netrw_decompress*      = { ".gz" : "gunzip" ,
                                        ".bz2" : "bunzip2" ,
                                        ".zip" : "unzip" ,
                                        ".tar" : "tar -xf"}
                                      A dictionary mapping suffices to
                                      decompression programs.

                      *g:netrw_dirhistmax*            =10: controls maximum quantity of past
                                                         history. May be zero to supppress
                                         history.
                                         (related: |netrw-qb| |netrw-u| |netrw-U|)

                      *g:netrw_dynamic_maxfilenamelen* =32: enables dynamic determination of
                                        |g:netrw_maxfilenamelen|, which affects
                                        local file long listing.

                      *g:netrw_errorlvl*        =0: error levels greater than or equal to
                                        this are permitted to be displayed
                                        0: notes
                                        1: warnings
                                        2: errors

                      *g:netrw_fastbrowse*      =0: slow speed directory browsing;
                                        never re-uses directory listings;
                                        always obtains directory listings.
                                    =1: medium speed directory browsing;
                                        re-use directory listings only
                                        when remote directory browsing.
                                        (default value)
                                    =2: fast directory browsing;
                                        only obtains directory listings when the
                                        directory hasn't been seen before
                                        (or |netrw-ctrl-l| is used).

                                    Fast browsing retains old directory listing
                                    buffers so that they don't need to be
                                    re-acquired. This feature is especially
                                    important for remote browsing. However, if
                                    a file is introduced or deleted into or from
                                    such directories, the old directory buffer
                                    becomes out-of-date. One may always refresh
                                    such a directory listing with |netrw-ctrl-l|.
                                    This option gives the user the choice of
                                    trading off accuracy (ie. up-to-date listing)
                                    versus speed.

                      *g:netrw_ffkeep*      (default: doesn't exist)
                                    If this variable exists and is zero, then
                                    netrw will not do a save and restore for
                                    |'fileformat'|.

                      *g:netrw_fname_escape*    =' ?&;%'
                                    Used on filenames before remote reading/writing

                      *g:netrw_ftp_browse_reject*   ftp can produce a number of errors and warnings
                                    that can show up as "directories" and "files"
                                    in the listing. This pattern is used to
                                    remove such embedded messages. By default its
                                    value is:
                                     '^total\s\+\d\+$\|
                                     ^Trying\s\+\d\+.*$\|
                                     ^KERBEROS_V\d rejected\|
                                     ^Security extensions not\|
                                     No such file\|
                                     : connect to address [0-9a-fA-F:]*
                                     : No route to host$'

                      *g:netrw_ftp_list_cmd*    options for passing along to ftp for directory
                                    listing. Defaults:
                                     unix or g:netrw_cygwin set: : "ls -lF"
                                     otherwise                     "dir"


                      *g:netrw_ftp_sizelist_cmd*    options for passing along to ftp for directory
                                    listing, sorted by size of file.
                                    Defaults:
                                     unix or g:netrw_cygwin set: : "ls -slF"
                                     otherwise                     "dir"

                      *g:netrw_ftp_timelist_cmd*    options for passing along to ftp for directory
                                    listing, sorted by time of last modification.
                                    Defaults:
                                     unix or g:netrw_cygwin set: : "ls -tlF"
                                     otherwise                     "dir"

                      *g:netrw_glob_escape*     ='[]*?`{~$' (unix)
                                    ='[]*?`{$' (windows
                                    These characters in directory names are
                                    escaped before applying glob()

                      *g:netrw_gx*          ="<cfile>"
                                    This option controls how gx (|netrw-gx|) picks
                                    up the text under the cursor. See |expand()|
                                    for possibilities.

                      *g:netrw_hide*        Controlled by the "a" map (see |netrw-a|)
                                    =0 : show all
                                    =1 : show not-hidden files
                                    =2 : show hidden files only
                                     default: =1

                      *g:netrw_home*        The home directory for where bookmarks and
                                    history are saved (as .netrwbook and
                                    .netrwhist).
                                    Netrw uses |expand()|on the string.
                                     default: the first directory on the
                                             |'runtimepath'|

                      *g:netrw_keepdir*     =1 (default) keep current directory immune from
                                       the browsing directory.
                                    =0 keep the current directory the same as the
                                       browsing directory.
                                    The current browsing directory is contained in
                                    b:netrw_curdir (also see |netrw-c|)

                      *g:netrw_keepj*       ="keepj" (default) netrw attempts to keep the
                                             |:jumps| table unaffected.
                                    =""      netrw will not use |:keepjumps| with
                                         exceptions only for the
                                         saving/restoration of position.

                      *g:netrw_list_cmd*        command for listing remote directories
                                     default: (if ssh is executable)
                                              "ssh HOSTNAME ls -FLa"

                      *g:netrw_list_cmd_options*    If this variable exists, then its contents are
                                    appended to the g:netrw_list_cmd. For
                                    example, use "2>/dev/null" to get rid of banner
                                    messages on unix systems.


                      *g:netrw_liststyle*       Set the default listing style:
                                                    = 0: thin listing (one file per line)
                                                    = 1: long listing (one file per line with time
                                         stamp information and file size)
                                    = 2: wide listing (multiple files in columns)
                                    = 3: tree style listing

                      *g:netrw_list_hide*       comma separated pattern list for hiding files
                                    Patterns are regular expressions (see |regexp|)
                                    There's some special support for git-ignore
                                    files: you may add the output from the helper
                                    function 'netrw_gitignore#Hide() automatically
                                    hiding all gitignored files.
                                    For more details see |netrw-gitignore|.

                                    Examples:
                                     let g:netrw_list_hide= '.*\.swp$'
                                     let g:netrw_list_hide= netrw_gitignore#Hide().'.*\.swp$'
                                    default: ""

                      *g:netrw_localcopycmd*    ="cp"           Linux/Unix/MacOS/Cygwin
                                    =expand("$COMSPEC")             Windows
                                    Copies marked files (|netrw-mf|) to target
                                    directory (|netrw-mt|, |netrw-mc|)

                      *g:netrw_localcopycmdopt* =''             Linux/Unix/MacOS/Cygwin
                                    =' \c copy'                     Windows
                                    Options for the |g:netrw_localcopycmd|

                      *g:netrw_localcopydircmd* ="cp"           Linux/Unix/MacOS/Cygwin
                                    =expand("$COMSPEC")             Windows
                                    Copies directories to target directory.
                                    (|netrw-mc|, |netrw-mt|)

                      *g:netrw_localcopydircmdopt*  =" -R"          Linux/Unix/MacOS/Cygwin
                                    =" /c xcopy /e /c /h/ /i /k"    Windows
                                    Options for |g:netrw_localcopydircmd|

                      *g:netrw_localmkdir*      ="mkdir"        Linux/Unix/MacOS/Cygwin
                                    =expand("$COMSPEC")             Windows
                                                    command for making a local directory

                      *g:netrw_localmkdiropt*   =""             Linux/Unix/MacOS/Cygwin
                                    =" /c mkdir"                    Windows
                                    Options for |g:netrw_localmkdir|

                      *g:netrw_localmovecmd*    ="mv"           Linux/Unix/MacOS/Cygwin
                                    =expand("$COMSPEC")             Windows
                                    Moves marked files (|netrw-mf|) to target
                                    directory (|netrw-mt|, |netrw-mm|)

                      *g:netrw_localmovecmdopt* =""             Linux/Unix/MacOS/Cygwin
                                    =" /c move"                     Windows
                                    Options for |g:netrw_localmovecmd|

                      *g:netrw_localrmdir*      ="rmdir"        Linux/Unix/MacOS/Cygwin
                                    =expand("$COMSPEC")             Windows
                                    Remove directory command (rmdir)
                                    This variable is only used if your vim is
                                    earlier than 7.4 or if your vim doesn't
                                    have patch#1107. Otherwise, |delete()|
                                    is used with the "d" option.

                      *g:netrw_localrmdiropt*   =""             Linux/Unix/MacOS/Cygwin
                                    =" /c rmdir"                    Windows
                                    Options for |g:netrw_localrmdir|

                      *g:netrw_maxfilenamelen*  =32 by default, selected so as to make long
                                        listings fit on 80 column displays.
                                    If your screen is wider, and you have file
                                    or directory names longer than 32 bytes,
                                    you may set this option to keep listings
                                    columnar.

                      *g:netrw_mkdir_cmd*       command for making a remote directory
                                    via ssh (also see |g:netrw_remote_mkdir|)
                                     default: "ssh USEPORT HOSTNAME mkdir"

                      *g:netrw_mousemaps*        =1 (default) enables mouse buttons while
                                       browsing to:
                                         leftmouse       : open file/directory
                                         shift-leftmouse : mark file
                                         middlemouse     : same as P
                                         rightmouse      : remove file/directory
                                    =0: disables mouse maps

                      *g:netrw_nobeval*     doesn't exist (default)
                                    If this variable exists, then balloon
                                    evaluation will be suppressed
                                    (see |'ballooneval'|)

                     *g:netrw_sizestyle*        not defined: actual bytes (default)
                                    ="b" : actual bytes       (default)
                                    ="h" : human-readable (ex. 5k, 4m, 3g)
                                           uses 1000 base
                                    ="H" : human-readable (ex. 5K, 4M, 3G)
                                           uses 1024 base
                                    The long listing (|netrw-i|) and query-file
                                    maps (|netrw-qf|) will display file size
                                    using the specified style.

                      *g:netrw_usetab*      if this variable exists and is non-zero, then
                                    the <tab> map supporting shrinking/expanding a
                                    Lexplore or netrw window will be enabled.
                                    (see |netrw-c-tab|)

                      *g:netrw_remote_mkdir*    command for making a remote directory
                                    via ftp (also see |g:netrw_mkdir_cmd|)
                                     default: "mkdir"

                      *g:netrw_retmap*      if it exists and is set to one, then:
                                     * if in a netrw-selected file, AND
                                     * no normal-mode <2-leftmouse> mapping exists,
                                    then the <2-leftmouse> will be mapped for easy
                                    return to the netrw browser window.
                                     example: click once to select and open a file,
                                              double-click to return.

                                    Note that one may instead choose to:
                                     * let g:netrw_retmap= 1, AND
                                     * nmap <silent> YourChoice <Plug>NetrwReturn
                                    and have another mapping instead of
                                    <2-leftmouse> to invoke the return.

                                    You may also use the |:Rexplore| command to do
                                    the same thing.

                                      default: =0

                      *g:netrw_rm_cmd*      command for removing remote files
                                     default: "ssh USEPORT HOSTNAME rm"

                      *g:netrw_rmdir_cmd*       command for removing remote directories
                                     default: "ssh USEPORT HOSTNAME rmdir"

                      *g:netrw_rmf_cmd*     command for removing remote softlinks
                                     default: "ssh USEPORT HOSTNAME rm -f"

                      *g:netrw_servername*      use this variable to provide a name for
                                    |netrw-ctrl-r| to use for its server.
                                     default: "NETRWSERVER"

                      *g:netrw_sort_by*     sort by "name", "time", "size", or
                                    "exten".
                                     default: "name"

                      *g:netrw_sort_direction*  sorting direction: "normal" or "reverse"
                                     default: "normal"

                      *g:netrw_sort_options*    sorting is done using |:sort|; this
                                    variable's value is appended to the
                                    sort command. Thus one may ignore case,
                                    for example, with the following in your
                                    .vimrc:
                                        let g:netrw_sort_options="i"
                    <                default: ""

                      *g:netrw_sort_sequence*   when sorting by name, first sort by the
                                    comma-separated pattern sequence. Note that
                                    any filigree added to indicate filetypes
                                    should be accounted for in your pattern.
                                     default: '[\/]$,*,\.bak$,\.o$,\.h$,
                                               \.info$,\.swp$,\.obj$'

                      *g:netrw_special_syntax*  If true, then certain files will be shown
                                    using special syntax in the browser:

                                        netrwBak     : *.bak
                                        netrwCompress: *.gz *.bz2 *.Z *.zip
                                        netrwCoreDump: core.\d\+
                                        netrwData    : *.dat
                                        netrwDoc     : *.doc,*.txt,*.pdf,
                                                       *.pdf,*.docx
                                        netrwHdr     : *.h
                                        netrwLex     : *.l *.lex
                                        netrwLib     : *.a *.so *.lib *.dll
                                        netrwMakefile: [mM]akefile *.mak
                                        netrwObj     : *.o *.obj
                                        netrwPix     : *.bmp,*.fit,*.fits,*.gif,
                                                       *.jpg,*.jpeg,*.pcx,*.ppc
                                                       *.pgm,*.png,*.psd,*.rgb
                                                       *.tif,*.xbm,*.xcf
                                        netrwTags    : tags ANmenu ANtags
                                        netrwTilde   : *
                                        netrwTmp     : tmp* *tmp
                                        netrwYacc    : *.y

                                    In addition, those groups mentioned in
                                    |'suffixes'| are also added to the special
                                    file highlighting group.
                                     These syntax highlighting groups are linked
                                    to netrwGray or Folded by default
                                    (see |hl-Folded|), but one may put lines like
                                        hi link netrwCompress Visual
                    <               into one's <.vimrc> to use one's own
                                    preferences. Alternatively, one may
                                    put such specifications into
                                        .vim/after/syntax/netrw.vim.
                    <                The netrwGray highlighting is set up by
                                    netrw when
                                            * netrwGray has not been previously
                                          defined
                                        * the gui is running
                    <                As an example, I myself use a dark-background
                                    colorscheme with the following in
                                    .vim/after/syntax/netrw.vim:

                     hi netrwCompress term=NONE cterm=NONE gui=NONE ctermfg=10 guifg=green ctermbg=0 guibg=black
                     hi netrwData    term=NONE cterm=NONE gui=NONE ctermfg=9 guifg=blue ctermbg=0 guibg=black
                     hi netrwHdr     term=NONE cterm=NONE,italic gui=NONE guifg=SeaGreen1
                     hi netrwLex     term=NONE cterm=NONE,italic gui=NONE guifg=SeaGreen1
                     hi netrwYacc    term=NONE cterm=NONE,italic gui=NONE guifg=SeaGreen1
                     hi netrwLib     term=NONE cterm=NONE gui=NONE ctermfg=14 guifg=yellow
                     hi netrwObj     term=NONE cterm=NONE gui=NONE ctermfg=12 guifg=red
                     hi netrwTilde   term=NONE cterm=NONE gui=NONE ctermfg=12 guifg=red
                     hi netrwTmp     term=NONE cterm=NONE gui=NONE ctermfg=12 guifg=red
                     hi netrwTags    term=NONE cterm=NONE gui=NONE ctermfg=12 guifg=red
                     hi netrwDoc     term=NONE cterm=NONE gui=NONE ctermfg=220 ctermbg=27 guifg=yellow2 guibg=Blue3
                     hi netrwSymLink term=NONE cterm=NONE gui=NONE ctermfg=220 ctermbg=27 guifg=grey60
                      *g:netrw_ssh_browse_reject*   ssh can sometimes produce unwanted lines,
                                    messages, banners, and whatnot that one doesn't
                                    want masquerading as "directories" and "files".
                                    Use this pattern to remove such embedded
                                    messages. By default its value is:
                                         '^total\s\+\d\+$'

                      *g:netrw_ssh_cmd*     One may specify an executable command
                                    to use instead of ssh for remote actions
                                    such as listing, file removal, etc.
                                     default: ssh

                     *g:netrw_suppress_gx_mesg* =1 : browsers sometimes produce messages
                                    which are normally unwanted intermixed
                                    with the page.
                                    However, when using links, for example,
                                    those messages are what the browser produces.
                                    By setting this option to 0, netrw will not
                                    suppress browser messages.

                      *g:netrw_tmpfile_escape*  =' &;'
                                    escape() is applied to all temporary files
                                    to escape these characters.

                      *g:netrw_timefmt*     specify format string to vim's strftime().
                                    The default, "%c", is "the preferred date
                                    and time representation for the current
                                    locale" according to my manpage entry for
                                    strftime(); however, not all are satisfied
                                    with it. Some alternatives:
                                     "%a %d %b %Y %T",
                                     " %a %Y-%m-%d %I-%M-%S %p"
                                     default: "%c"

                      *g:netrw_use_noswf*       netrw normally avoids writing swapfiles
                                    for browser buffers. However, under some
                                    systems this apparently is causing nasty
                                    ml_get errors to appear; if you're getting
                                    ml_get errors, try putting
                                      let g:netrw_use_noswf= 0
                                    in your .vimrc.
                                      default: 1

                      *g:netrw_winsize*     specify initial size of new windows made with
                                    "o" (see |netrw-o|), "v" (see |netrw-v|),
                                    |:Hexplore| or |:Vexplore|. The g:netrw_winsize
                                    is an integer describing the percentage of the
                                    current netrw buffer's window to be used for
                                    the new window.
                                     If g:netrw_winsize is less than zero, then
                                    the absolute value of g:netrw_winsize will be
                                    used to specify the quantity of lines or
                                    columns for the new window.
                                     If g:netrw_winsize is zero, then a normal
                                    split will be made (ie. |'equalalways'| will
                                    take effect, for example).
                                     default: 50 (for 50%)

                      *g:netrw_wiw*         =1 specifies the minimum window width to use
                                    when shrinking a netrw/Lexplore window
                                    (see |netrw-c-tab|).

                      *g:netrw_xstrlen*     Controls how netrw computes string lengths,
                                    including multi-byte characters' string
                                    length. (thanks to N Weibull, T Mechelynck)
                                    =0: uses Vim's built-in strlen()
                                    =1: number of codepoints (Latin a + combining
                                        circumflex is two codepoints) (DEFAULT)
                                    =2: number of spacing codepoints (Latin a +
                                        combining circumflex is one spacing
                                        codepoint; a hard tab is one; wide and
                                        narrow CJK are one each; etc.)
                                    =3: virtual length (counting tabs as anything
                                        between 1 and |'tabstop'|, wide CJK as 2
                                        rather than 1, Arabic alif as zero when
                                        immediately preceded by lam, one
                                        otherwise, etc)

                      *g:NetrwTopLvlMenu*       This variable specifies the top level
                                    menu name; by default, it's "Netrw.". If
                                    you wish to change this, do so in your
                                    .vimrc.
                    --
                (( NETRW BROWSING AND OPTION INCOMPATIBILITIES *netrw-incompatible* ))
                    Netrw has been designed to handle user options by saving them,
                    setting the options to something that's compatible with netrw's needs, and then restoring them.
                    However, the autochdir option:
                      :set acd
                    is problematic.
                    Autochdir sets the current directory to that containing the file you edit;
                    this apparently also applies to directories.
                    In other words, autochdir sets the current directory to that containing the "file" (even if that "file" is itself a directory).
                    --
                    NETRW SETTINGS WINDOW               *netrw-settings-window*
                With the NetrwSettings.vim plugin, :NetrwSettings ...
                    will bring up a window with the many variables that netrw uses for its settings.
                    You may change any of their values; when you save the file, the settings therein will be used.
                One may also press "?" on any of the lines for help on what each of the variables do.
                    (also see: |netrw-browser-var| |netrw-protocol| |netrw-variables|)
                    ==============================================================================
                    OBTAINING A FILE                    *netrw-obtain* *netrw-O*
                    If there are no marked files:
                When browsing a remote directory, one may obtain a file under the cursor
                    (ie. get a copy on your local machine, but not edit it) by pressing the O key.
                    .
                If there are marked files:
                    The marked files will be obtained (ie. a copy will be transferred to your local machine, but not set up for editing).
                    .
                Only ftp and scp are supported for this operation (but since these two are available for browsing, that shouldn't be a problem).
                    The status bar will then show, on its right hand side, a message like "Obtaining filename".
                    The statusline will be restored after the transfer is complete.
                    Netrw can also "obtain" a file using the local browser.
                    Netrw's display of a directory is not necessarily the same as Vim's "current directory",
                    unless |g:netrw_keepdir| is set to 0 in the user's <.vimrc>.
                    One may select a file using the local browser (by putting the cursor on it) and pressing "O"
                    will then "obtain" the file; ie. copy it to Vim's current directory.
                    Related topics:
                     * To see what the current directory is, use |:pwd|
                     * To make the currently browsed directory the current directory, see |netrw-c|
                     * To automatically make the currently browsed directory the current directory, see |g:netrw_keepdir|.
                        *netrw-newfile* *netrw-createfile*
                    OPEN A NEW FILE IN NETRW'S CURRENT DIRECTORY        *netrw-%*
                To open a new file in netrw's current directory, press "%".
                    This map will query the user for a new filename;
                    an empty file by that name will be placed in the netrw's current directory (ie. b:netrw_curdir).
                    Related topics:               |netrw-d|
                    PREVIEW WINDOW              *netrw-p* *netrw-preview*
                One may use a preview window by using the "p" key when the cursor is atop the desired filename to be previewed.
                    The display will then split to show both the browser (where the cursor will remain) and the file (see |:pedit|).
                    By default, the split will be taken horizontally;
                 one may use vertical splitting if one has set |g:netrw_preview| first.
                    An interesting set of netrw settings is:
                    let g:netrw_preview   = 1
                    let g:netrw_liststyle = 3
                    let g:netrw_winsize   = 30
                    These will:
                    1. Make vertical splitting the default for previewing files
                    2. Make the default listing style "tree"
                    3. When a vertical preview window is opened, the directory listing will use only 30% of the columns available;
                    the rest of the window is used for the preview window.
                    Related: if you like this idea, you may also find :Lexplore
                    (|netrw-:Lexplore|) or |g:netrw_chgwin| of interest
                    Also see: |g:netrw_chgwin| |netrw-P| |'previewwindow'| |CTRL-W_z| |:pclose|
                    --
                    PREVIOUS WINDOW                 *netrw-P* *netrw-prvwin*
                To edit a file or directory under the cursor in the previously used (last accessed) window (see :he |CTRL-W_p|), press a "P".
                    If there's only one window, then the one window will be horizontally split (by default).
                    If there's more than one window, the previous window will be re-used on the selected file/directory.
                    If the previous window's associated buffer has been modified, and there's only one window with that buffer,
                    then the user will be asked if s/he wishes to save the buffer first (yes, no, or cancel).
                    Related Actions |netrw-cr| |netrw-o| |netrw-t| |netrw-v|
                    Associated setting variables:
                    |g:netrw_alto|    control above/below splitting
                    |g:netrw_altv|    control right/left splitting
                    |g:netrw_preview| control horizontal vs vertical splitting
                    |g:netrw_winsize| control initial sizing
                    Also see: |g:netrw_chgwin| |netrw-p|
                    --
                    REFRESHING THE LISTING      *netrw-refresh* *netrw-ctrl-l* *netrw-ctrl_l*
                    To refresh either a local or remote directory listing, press ctrl-l (<c-l>) or hit the <cr> when atop the ./ directory entry in the listing.
                    One may also refresh a local directory by using ":e .".
                    --
                    REVERSING SORTING ORDER     *netrw-r* *netrw-reverse*
                One may toggle between normal and reverse sorting order by pressing the "r" key.
                    Related topics:              |netrw-s|
                    Associated setting variable: |g:netrw_sort_direction|
                    --
                    RENAMING FILES OR DIRECTORIES   *netrw-move* *netrw-rename* *netrw-R*
                    If there are no marked files: (see |netrw-mf|)
                Renaming files/dirs =cursor on the file/directory + press "R".
                    You will then be queried for what you want the file/directory to be renamed to.
                    .
                You may select a range of lines with the "V" command (visual selection), and then press "R";
                    you will be queried for each file as to what you want it renamed to.
                    If there are marked files: (see |netrw-mf|)
                    Marked files will be renamed (moved).
                    You will be queried as above in order to specify where you want the file/directory to be moved.
                If you answer a renaming query with a "s/frompattern/topattern/",
                    then subsequent files on the marked file list will be renamed by taking each name,
                    applying that substitute, and renaming each file to the result.
                    As an example:
                    --
                **
                    mr [query: reply with *.c]
                    R  [query: reply with s/^\(.*\)\.c$/\1.cpp/]
                    This example will mark all *.c files and then rename them to *.cpp files.
                    --
                c-x / c-x c-x
                    The ctrl-X character has special meaning for renaming files:
                    --
                    <c-x>      : a single ctrl-x tells netrw to ignore the portion of the response lying between the last '/' and the ctrl-x.
                    --
                    <c-x><c-x> : a pair of contiguous ctrl-x's tells netrw to ignore any portion of the string preceding the double ctrl-x's.
                    WARNING:~
                    --
                    Note that moving files is a dangerous operation; copies are safer.
                    That's because a "move" for remote files is actually a copy + delete -
                    and if the copy fails and the delete succeeds you may lose the file.
                    Use at your own risk.
                    --
                .
                    The *g:netrw_rename_cmd* variable is used to implement remote renaming.
                    By default its value is:  ssh HOSTNAME mv
                One may rename a block of files and directories by selecting them with V (|linewise-visual|) when using thin style.
                See |cmdline-editing| for more on how to edit the command line;  [**]
                    .
                    in particular, you'll find <ctrl-f> (initiates cmdline window editing) and <ctrl-c> (uses the command line under the cursor) useful in conjunction with the R command.
                    --
                    SELECTING SORTING STYLE         *netrw-s* *netrw-sort*
                s  sort by name / time / file size
                    One may select the sorting style by name, time, or (file) size.
                    The "s" map allows one to circulate amongst the three choices;
                    the directory listing will automatically be refreshed to reflect the selected style.
                    --
                    Related topics:               |netrw-r| |netrw-S|
                    Associated setting variables: |g:netrw_sort_by| |g:netrw_sort_sequence|
                    --
                    SETTING EDITING WINDOW      *netrw-editwindow* *netrw-C* *netrw-:NetrwC*
                One may select a netrw window for editing with the "C" mapping,  (??)
                    using the :NetrwC [win#] command,
                    or by setting |g:netrw_chgwin| to the selected window number.
                    Subsequent selection of a file to edit (|netrw-cr|) will use that window.
                    --
                C by itself, will select the current window holding a netrw buffer for subsequent editing via |netrw-cr|. (??)
                    The C mapping is only available while in netrw buffers.
                    --
                    * [count]C: the count will be used as the window number to be used for subsequent editing via |netrw-cr|.
                    --
                    * :NetrwC will set |g:netrw_chgwin| to the current window
                    --
                    * :NetrwC win# will set |g:netrw_chgwin| to the specified window number
                    --
                    Using
                    let g:netrw_chgwin= -1
                    will restore the default editing behavior
                    (ie. subsequent editing will use the current window).
                    --
                    Related topics:         |netrw-cr| |g:netrw_browse_split|
                    Associated setting variables:   |g:netrw_chgwin|
                    --
                    SHRINKING OR EXPANDING A NETRW OR LEXPLORE WINDOW   *netrw-c-tab*
                    --
                    The <c-tab> key will toggle a netrw or |:Lexplore| window's width,
                    but only if |g:netrw_usetab| exists and is non-zero
                    (and, of course, only if your terminal supports differentiating <c-tab> from a plain <tab>).
                    --
                    * If the current window is a netrw window, toggle its width (between |g:netrw_wiw| and its original width)
                    --
                    * Else if there is a |:Lexplore| window in the current tab, toggle its width
                    --
                    * Else bring up a |:Lexplore| window
                    --
                    If |g:netrw_usetab| exists and is zero,
                    or if there is a pre-existing mapping for <c-tab>,
                    then the <c-tab> will not be mapped.
                    One may map something other than a <c-tab>, too:
                    (but you'll still need to have had |g:netrw_usetab| set).
                    --
                    nmap <unique> (whatever)    <Plug>NetrwShrink
                    Related topics:         |:Lexplore|
                    Associated setting variable:    |g:netrw_usetab|
                    --
                    USER SPECIFIED MAPS                 *netrw-usermaps*
                    --
                    One may make customized user maps.
                Specify a variable, |g:Netrw_UserMaps|, to hold a |List| of lists of keymap strings and function names:
                    [["keymap-sequence","ExampleUserMapFunc"],...]
                    When netrw is setting up maps for a netrw buffer, if |g:Netrw_UserMaps| exists,
                    then the internal function netrw#UserMaps(islocal) is called.
                    This function goes through all the entries in the |g:Netrw_UserMaps| list:
                    --
                    * sets up maps:
                    nno <buffer> <silent> KEYMAP-SEQUENCE
                    :call s:UserMaps(islocal,"ExampleUserMapFunc")
                    * refreshes if result from that function call is the string "refresh"
                    * if the result string is not "", then that string will be executed (:exe result)
                    * if the result is a List, then the above two actions on results will be taken for every string in the result List
                    The user function is passed one argument; it resembles
                    fun! ExampleUserMapFunc(islocal)
                    where a:islocal is 1 if its a local-directory system call
                    or 0 when remote-directory system call.
                    --
                    *netrw-call* *netrw-expose* *netrw-modify*
                    Use netrw#Expose("varname")          to access netrw-internal (script-local) variables.
                    Use netrw#Modify("varname",newvalue) to change netrw-internal variables.
                    Use netrw#Call("funcname"[,args])    to call a netrw-internal function with specified arguments.
                    --
                    Example: Get a copy of netrw's marked file list:
                    --
                    let netrwmarkfilelist= netrw#Expose("netrwmarkfilelist")
                    Example: Modify the value of netrw's marked file list:
                    --
                    call netrw#Modify("netrwmarkfilelist",[])
                    Example: Clear netrw's marked file list via a mapping on gu
                    " ExampleUserMap:
                    fun! ExampleUserMap(islocal)
                      call netrw#Modify("netrwmarkfilelist",[])
                      call netrw#Modify('netrwmarkfilemtch_{bufnr("%")}',"")
                      let retval= ["refresh"]
                      return retval
                    endfun
                    let g:Netrw_UserMaps= [["gu","ExampleUserMap"]]
                    --
                    10. Problems and Fixes                  *netrw-problems*
                    (This section is likely to grow as I get feedback)
                    (also see |netrw-debug|)
                    *netrw-p1*
                    P1. I use windows 95, and my ftp dumps four blank lines at the     end of every read.
                    --
                    See |netrw-fixup|, and put the following into your <.vimrc> file:
                    --
                    let g:netrw_win95ftp= 1
                    --
                    *netrw-p2*
                    P2. I use Windows, and my network browsing with ftp doesn't sort by time or size!
                    -or- The remote system is a Windows server; why don't I get sorts by time or size?
                    --
                    Windows' ftp has a minimal support for ls (ie. it doesn't accept sorting options).
                    It doesn't support the -F which gives an explanatory character (ABC/ for "ABC is a directory").
                    Netrw then uses "dir" to get both its thin and long listings.
                    If you think your ftp does support a full-up ls, put the following into your <.vimrc>:
                    --
                    let g:netrw_ftp_list_cmd    = "ls -lF"
                    let g:netrw_ftp_timelist_cmd= "ls -tlF"
                    let g:netrw_ftp_sizelist_cmd= "ls -slF"
                    --
                    Alternatively, if you have cygwin on your Windows box, put into your <.vimrc>:
                    let g:netrw_cygwin= 1
                    This problem also occurs when the remote system is Windows.
                    In this situation, the various g:netrw_ftp_[time|size]list_cmds are as shown above,
                    but the remote system will not correctly modify its listing behavior.
                    --
                    --
                    *netrw-p3*
                    P3. I tried rcp://user@host/ (or protocol other than ftp) and netrw used ssh!
                    That wasn't what I asked for...
                    --
                    Netrw has two methods for browsing remote directories: ssh and ftp.
                    Unless you specify ftp specifically, ssh is used.
                    When it comes time to do download a file (not just a directory listing),
                    netrw will use the given protocol to do so.
                    --
                    *netrw-p4*
                    P4. I would like long listings to be the default.                  
                    Put the following statement into your |.vimrc|:
                    --
                    let g:netrw_liststyle= 1
                    Check out |netrw-browser-var| for more customizations that you can set.
                    --
                    *netrw-p5*
                    P5. My times come up oddly in local browsing                       
                    Does your system's strftime() accept the "%c" to yield dates such as "Sun Apr 27 11:49:23 1997"?
                    If not, do a "man strftime" and find out what option should be used.
                    Then put it into your |.vimrc|:
                    --
                    let g:netrw_timefmt= "%X" (where X is the option)
                    --
                    P6. I want my current directory to track my browsing.              
                    How do I do that?
                    Put the following line in your |.vimrc|:
                    let g:netrw_keepdir= 0
                    --
                    P7. I use Chinese (or other non-ascii) characters in my filenames,
                    and netrw (Explore, Sexplore, Hexplore, etc) doesn't display them!
                    (taken from an answer provided by Wu Yongwei on the vim mailing list)
                    I now see the problem. Your code page is not 936, right?
                    Vim seems only able to open files with names that are valid in the current code page,
                    as are many other applications that do not use the Unicode version of Windows APIs.
                    This is an OS-related issue.
                    You should not have such problems when the system locale uses UTF-8, such as modern Linux distros.
                    (...it is one more reason to recommend that people use utf-8!)
                    --
                    P8. I'm getting "ssh is not executable on your system" - what do I do?
                    --
                    (Dudley Fox) Most people I know use putty for windows ssh.
                    It is a free ssh/telnet application.
                    You can read more about it here:
                    http://www.chiark.greenend.org.uk/~sgtatham/putty/ Also:
                    --
                    (Marlin Unruh) This program also works for me.
                    It's a single executable, so he/she can copy it into the Windows\System32 folder and create a shortcut to it.
                    (Dudley Fox) You might also wish to consider plink, as it sounds most similar to what you are looking for.
                    plink is an application in the putty suite.
                       http://the.earth.li/~sgtatham/putty/0.58/htmldoc/Chapter7.html#plink
                    (Vissale Neang) Maybe you can try OpenSSH for windows, which can be obtained from:
                    http://sshwindows.sourceforge.net/
                    It doesn't need the full Cygwin package.
                    (Antoine Mechelynck) For individual Unix-like programs needed for work in a native-Windows environment,
                    I recommend getting them from the GnuWin32 project on sourceforge if it has them:
                    http://gnuwin32.sourceforge.net/
                    --
                    Unlike Cygwin, which sets up a Unix-like virtual machine on top of Windows,
                    GnuWin32 is a rewrite of Unix utilities with Windows system calls,
                    and its programs works quite well in the cmd.exe "Dos box".
                    --
                    (dave) Download WinSCP and use that to connect to the server.
                    In Preferences > Editors, set gvim as your editor:
                    --
                    - Click "Add..."
                    - Set External Editor (adjust path as needed, include
                      the quotes and !.! at the end):
                    "c:\Program Files\Vim\vim81\gvim.exe" !.!
                    - Check that the filetype in the box below is
                      {asterisk}.{asterisk} (all files), or whatever types
                      you want (cec: change {asterisk} to * ; I had to
                      write it that way because otherwise the helptags
                      system thinks it's a tag)
                    - Make sure it's at the top of the listbox (click it,
                      then click "Up" if it's not)
                    If using the Norton Commander style, you just have to hit <F4>
                    to edit a file in a local copy of gvim.
                    --
                    (Vit Gottwald) How to generate public/private key and save
                    public key it on server:
                      http://www.chiark.greenend.org.uk/~sgtatham/putty/0.60/htmldoc/Chapter8.html#pubkey-gettingready
                    (8.3 Getting ready for public key authentication)
                    How to use a private key with 'pscp':
                    --
                    http://www.chiark.greenend.org.uk/~sgtatham/putty/0.60/htmldoc/Chapter5.html
                    --
                    (5.2.4 Using public key authentication with PSCP)
                    (Ben Schmidt) I find the ssh included with cwRsync is brilliant,
                    and install cwRsync or cwRsyncServer on most Windows systems I come across these days.
                    I guess COPSSH, packed by the same person, is probably even better for use as just ssh on Windows,
                    and probably includes sftp, etc. which I suspect the cwRsync doesn't, though it might
                    (cec) To make proper use of these suggestions above,
                    you will need to modify the following user-settable variables in your .vimrc:
                    --
                    |g:netrw_ssh_cmd| |g:netrw_list_cmd| |g:netrw_mkdir_cmd|
                    |g:netrw_rm_cmd| |g:netrw_rmdir_cmd| |g:netrw_rmf_cmd|
                    --
                    The first one (|g:netrw_ssh_cmd|) is the most important;
                    most of the others will use the string in g:netrw_ssh_cmd by default.
                    --
                    P9. I'm browsing, changing directory, and bang! ml_get errors appear and I have to kill vim.
                    Any way around this?
                    --
                    Normally netrw attempts to avoid writing swapfiles for its temporary directory buffers.
                    However, on some systems this attempt appears to be causing ml_get errors to appear.
                    Please try setting |g:netrw_use_noswf| to 0 in your <.vimrc>:
                    let g:netrw_use_noswf= 0
                    --
                    P10. I'm being pestered with "[something] is a directory" and      
                     "Press ENTER or type command to continue" prompts...
                    --
                    The "[something] is a directory" prompt is issued by Vim,
                    not by netrw, and there appears to be no way to work around it.
                    Coupled with the default cmdheight of 1, this message causes the "Press ENTER..." prompt.
                    So: read |hit-enter|;
                    I also suggest that you set your |'cmdheight'| to 2 (or more) in your <.vimrc> file.
                    --
                    P11. I want to have two windows; a thin one on the left and my editing window on the right.
                    How may I accomplish this?
                    --
                    You probably want netrw running as in a side window.
                    If so, you will likely find that ":[N]Lexplore" does what you want.
                    The optional "[N]" allows you to select the quantity of columns you
                    wish the |:Lexplore|r window to start with (see |g:netrw_winsize|
                    for how this parameter works).
                    --
                    Previous solution:
                    * Put the following line in your <.vimrc>:
                    let g:netrw_altv = 1
                    * Edit the current directory: :e .
                    * Select some file, press v
                    * Resize the windows as you wish (see |CTRL-W_<| and |CTRL-W_>|).
                    If you're using gvim, you can drag the separating bar with your mouse.
                    * When you want a new file, use ctrl-w h to go back to the netrw browser,
                    select a file, then press P (see |CTRL-W_h| and |netrw-P|).
                    If you're using gvim, you can press <leftmouse> in the browser window
                    and then press the <middlemouse> to select the file.
                    --
                    P12. My directory isn't sorting correctly, or unwanted letters are appearing in the listed filenames,
                    or things aren't lining up properly in the wide listing, ...
                    --
                    This may be due to an encoding problem.
                    I myself usually use utf-8, but really only use ascii (ie. bytes from 32-126).
                    Multibyte encodings use two (or more) bytes per character.
                    You may need to change |g:netrw_sepchr| and/or |g:netrw_xstrlen|.
                    --
                    P13. I'm a Windows + putty + ssh user, and when I attempt to       
                    browse, the directories are missing trailing "/"s so netrw treats
                    them as file transfers instead of as attempts to browse
                    subdirectories. How may I fix this?
                    --
                    (mikeyao) If you want to use vim via ssh and putty under Windows,
                    try combining the use of pscp/psftp with plink. pscp/psftp will
                    be used to connect and plink will be used to execute commands on
                    the server, for example: list files and directory using 'ls'.
                    --
                    These are the settings I use to do this:
                    " list files, it's the key setting, if you haven't set,
                    " you will get a blank buffer
                    let g:netrw_list_cmd = "plink HOSTNAME ls -Fa"
                    " if you haven't add putty directory in system path, you should
                    " specify scp/sftp command. For examples:
                    "let g:netrw_sftp_cmd = "d:\\dev\\putty\\PSFTP.exe"
                    "let g:netrw_scp_cmd = "d:\\dev\\putty\\PSCP.exe"
                    *netrw-p14*
                    P14. I would like to speed up writes using Nwrite and scp/ssh      
                    style connections. How? (Thomer M. Gil)
                    --
                    Try using ssh's ControlMaster and ControlPath (see the ssh_config
                    man page) to share multiple ssh connections over a single network
                    connection. That cuts out the cryptographic handshake on each
                    file write, sometimes speeding it up by an order of magnitude.
                    (see http://thomer.com/howtos/netrw_ssh.html)
                    (included by permission)
                    --
                    Add the following to your ~/.ssh/config:
                    --
                    # you change "*" to the hostname you care about
                    Host *
                    ControlMaster auto
                    ControlPath /tmp/%r@%h:%p
                    --
                    Then create an ssh connection to the host and leave it running:
                    --
                    ssh -N host.domain.com
                    --
                    Now remotely open a file with Vim's Netrw and enjoy the zippiness:
                    vim scp://host.domain.com//home/user/.bashrc
                    --
                    P15. How may I use a double-click instead of netrw's usual single  
                    click to open a file or directory? (Ben Fritz)
                    --
                    First, disable netrw's mapping with
                    let g:netrw_mousemaps= 0
                    <        and then create a netrw buffer only mapping in
                    $HOME/.vim/after/ftplugin/netrw.vim:
                    nmap <buffer> <2-leftmouse> <CR>
                    <        Note that setting g:netrw_mousemaps to zero will turn off
                    all netrw's mouse mappings, not just the <leftmouse> one.
                    (see |g:netrw_mousemaps|)
                    --
                    *netrw-p16*
                    P16. When editing remote files (ex. :e ftp://hostname/path/file),  
                    under Windows I get an |E303| message complaining that its unable
                    to open a swap file.
                    --
                    (romainl) It looks like you are starting Vim from a protected
                    directory. Start netrw from your $HOME or other writable
                    directory.
                    --
                    *netrw-p17*
                    P17. Netrw is closing buffers on its own.                          
                    What steps will reproduce the problem?
                    1. :Explore, navigate directories, open a file
                    2. :Explore, open another file
                    3. Buffer opened in step 1 will be closed. o
                    What is the expected output? What do you see instead?
                    I expect both buffers to exist, but only the last one does.
                    --
                    (Lance) Problem is caused by "set autochdir" in .vimrc.
                    (drchip) I am able to duplicate this problem with |'acd'| set.
                    It appears that the buffers are not exactly closed;
                    a ":ls!" will show them (although ":ls" does not).
                    --
                    P18. How to locally edit a file that's only available via          
                    another server accessible via ssh?
                    See http://stackoverflow.com/questions/12469645/
                    "Using Vim to Remotely Edit A File on ServerB Only
                      Accessible From ServerA"
                    --
                    P19. How do I get numbering on in directory listings?              
                    With |g:netrw_bufsettings|, you can control netrw's buffer
                    settings; try putting
                      let g:netrw_bufsettings="noma nomod nu nobl nowrap ro nornu"
                    <       in your .vimrc. If you'd like to have relative numbering
                    instead, try
                      let g:netrw_bufsettings="noma nomod nonu nobl nowrap ro rnu"
                    --
                    P20. How may I have gvim start up showing a directory listing?     
                    Try putting the following code snippet into your .vimrc:
                    augroup VimStartup
                      au!
                      au VimEnter * if expand("%") == "" && argc() == 0 &&
                      \ (v:servername =~ 'GVIM\d*' || v:servername == "")
                      \ | e . | endif
                    augroup END
                    You may use Lexplore instead of "e" if you're so inclined.
                    This snippet assumes that you have client-server enabled
                    (ie. a "huge" vim version).
                    --
                    P21. I've made a directory (or file) with an accented character,   
                    but netrw isn't letting me enter that directory/read that file:
                    --
                    Its likely that the shell or o/s is using a different encoding
                    than you have vim (netrw) using. A patch to vim supporting
                    "systemencoding" may address this issue in the future; for
                    now, just have netrw use the proper encoding. For example:
                    au FileType netrw set enc=latin1
                    --
                    P22. I get an error message when I try to copy or move a file:     
                    **error** (netrw) tried using g:netrw_localcopycmd<cp>; it doesn't work!
                    What's wrong?
                    Netrw uses several system level commands to do things (see
                    |g:netrw_localcopycmd|, |g:netrw_localmovecmd|,
                    |g:netrw_localrmdir|, |g:netrw_mkdir_cmd|).
                    --
                    You may need to adjust the default commands for one or more of
                    these commands by setting them properly in your .vimrc. Another
                    source of difficulty is that these commands use vim's local
                    directory, which may not be the same as the browsing directory
                    shown by netrw (see |g:netrw_keepdir|).
                    ==============================================================================
                    11. Debugging Netrw Itself              *netrw-debug*
                    Step 1: check that the problem you've encountered hasn't already been resolved
                    by obtaining a copy of the latest (often developmental) netrw at:
                    --
                    http://www.drchip.org/astronaut/vim/index.html#NETRW
                    --
                    The <netrw.vim> script is typically installed on systems as something like:
                    /usr/local/share/vim/vim8x/plugin/netrwPlugin.vim
                    /usr/local/share/vim/vim8x/autoload/netrw.vim
                    (see output of :echo &rtp)
                    which is loaded automatically at startup (assuming :set nocp). If you
                    installed a new netrw, then it will be located at
                    --
                    $HOME/.vim/plugin/netrwPlugin.vim
                    $HOME/.vim/autoload/netrw.vim
                    Step 2: assuming that you've installed the latest version of netrw,
                    check that your problem is really due to netrw. Create a file
                    called netrw.vimrc with the following contents:
                    --
                    set nocp
                    so $HOME/.vim/plugin/netrwPlugin.vim
                    Then run netrw as follows:
                    --
                    vim -u netrw.vimrc --noplugins -i NONE [some path here]
                    Perform whatever netrw commands you need to, and check that the problem is
                    still present. This procedure sidesteps any issues due to personal .vimrc
                    settings, .viminfo file, and other plugins. If the problem does not appear,
                    then you need to determine which setting in your .vimrc is causing the
                    conflict with netrw or which plugin(s) is/are involved.
                    --
                    Step 3: If the problem still is present, then get a debugging trace from
                    netrw:
                    --
                    1. Get the <Decho.vim> script, available as:
                    http://www.drchip.org/astronaut/vim/index.html#DECHO
                       or
                    http://vim.sourceforge.net/scripts/script.php?script_id=120
                    Decho.vim is provided as a "vimball"; see |vimball-intro|.
                    --
                    2. Edit the <netrw.vim> file by typing:
                    --
                    vim netrw.vim
                    :DechoOn
                    :wq
                       To restore to normal non-debugging behavior, re-edit <netrw.vim>
                       and type
                    --
                    vim netrw.vim
                    :DechoOff
                    :wq
                       This command, provided by <Decho.vim>, will comment out all
                       Decho-debugging statements (Dfunc(), Dret(), Decho(), Dredir()).
                    --
                    3. Then bring up vim and attempt to evoke the problem by doing a
                       transfer or doing some browsing. A set of messages should appear
                       concerning the steps that <netrw.vim> took in attempting to
                       read/write your file over the network in a separate tab or
                       server vim window.
                    --
                       To save the file, use
                    --
                    :tabnext
                    :set bt=
                    :w! DBG
                    --
                    <      Furthermore, it'd be helpful if you would type
                    :Dsep <command>
                    <      where <command> is the command you're about to type next,
                       thereby making it easier to associate which part of the
                       debugging trace is due to which command.
                    --
                       Please send that information to <netrw.vim>'s maintainer along
                       with the o/s you're using and the vim version that you're using
                       (see |:version|)
                    NdrOchip at ScampbellPfamily.AbizM - NOSPAM
                    ==============================================================================
                    12. History                     *netrw-history*
                    --
                    v163:   Dec 05, 2017    * (Cristi Balan) reported that a setting ('sel')
                      was left changed
                    * (Holger Mitschke) reported a problem with
                      saving and restoring history. Fixed.
                    * Hopefully I fixed a nasty bug that caused a
                      file rename to wipe out a buffer that it
                      should not have wiped out.
                    * (Holger Mitschke) amended this help file
                      with additional |g:netrw_special_syntax|
                      items
                    v162:   Sep 19, 2016    * (haya14busa) pointed out two syntax errors
                      with a patch; these are now fixed.
                    Oct 26, 2016    * I started using mate-terminal and found that
                      x and gx (|netrw-x| and |netrw-gx|) were no
                      longer working. Fixed (using atril when
                      $DESKTOP_SESSION is "mate").
                    Nov 04, 2016    * (Martin Vuille) pointed out that @+ was
                      being restored with keepregstar rather than
                      keepregplus.
                    Nov 09, 2016    * Broke apart the command from the options,
                      mostly for Windows. Introduced new netrw
                      settings: |g:netrw_localcopycmdopt|
                      |g:netrw_localcopydircmdopt| |g:netrw_localmkdiropt|
                      |g:netrw_localmovecmdopt| |g:netrw_localrmdiropt|
                    Nov 21, 2016    * (mattn) provided a patch for preview; swapped
                      winwidth() with winheight()
                    Nov 22, 2016    * (glacambre) reported that files containing
                      spaces weren't being obtained properly via
                      scp. Fix: apparently using single quotes
                      such as with 'file name' wasn't enough; the
                      spaces inside the quotes also had to be
                      escaped (ie. 'file\ name').
                    * Also fixed obtain (|netrw-O|) to be able to
                      obtain files with spaces in their names
                    Dec 20, 2016    * (xc1427) Reported that using "I" (|netrw-I|)
                      when atop "Hiding" in the banner also caused
                      the active-banner hiding control to occur
                    Jan 03, 2017    * (Enno Nagel) reported that attempting to
                      apply netrw to a directory that was without
                      read permission caused a syntax error.
                    Jan 13, 2017    * (Ingo Karkat) provided a patch which makes
                      using netrw#Call() better. Now returns
                      value of internal routines return, for example.
                    Jan 13, 2017    * (Ingo Karkat) changed netrw#FileUrlRead to
                      use |:edit| instead of |:read|. I also
                      changed the routine name to netrw#FileUrlEdit.
                    Jan 16, 2017    * (Sayem) reported a problem where :Lexplore
                      could generate a new listing buffer and
                      window instead of toggling the netrw display.
                      Unfortunately, the directions for eliciting
                      the problem weren't complete, so I may or
                      may not have fixed that issue.
                    Feb 06, 2017    * Implemented cb and cB. Changed "c" to "cd".
                      (see |netrw-cb|, |netrw-cB|, and |netrw-cd|)
                    Mar 21, 2017    * previously, netrw would specify (safe) settings
                      even when the setting was already safe for
                      netrw. Netrw now attempts to leave such
                      already-netrw-safe settings alone.
                      (affects s:NetrwOptionRestore() and
                      s:NetrwSafeOptions(); also introduced
                      s:NetrwRestoreSetting())
                    Jun 26, 2017    * (Christian Brabandt) provided a patch to
                      allow curl to follow redirects (ie. -L
                      option)
                    Jun 26, 2017    * (Callum Howard) reported a problem with
                      :Lexpore not removing the Lexplore window
                      after a change-directory
                    Aug 30, 2017    * (Ingo Karkat) one cannot switch to the
                      previously edited file (e.g. with CTRL-^)
                      after editing a file:// URL. Patch to
                      have a "keepalt" included.
                    Oct 17, 2017    * (Adam Faryna) reported that gn (|netrw-gn|)
                      did not work on directories in the current
                      tree
                    v157:   Apr 20, 2016    * (Nicola) had set up a "nmap <expr> ..." with
                      a function that returned a 0 while silently
                      invoking a shell command. The shell command
                      activated a ShellCmdPost event which in turn
                      called s:LocalBrowseRefresh(). That looks
                      over all netrw buffers for changes needing
                      refreshes. However, inside a |:map-<expr>|,
                      tab and window changes are disallowed. Fixed.
                      (affects netrw's s:LocalBrowseRefresh())
                    * |g:netrw_localrmdir| not used any more, but
                      the relevant patch that causes |delete()| to
                      take over was #1107 (not #1109).
                    * |expand()| is now used on |g:netrw_home|;
                      consequently, g:netrw_home may now use
                      environment variables
                    * s:NetrwLeftmouse and s:NetrwCLeftmouse will
                      return without doing anything if invoked
                      when inside a non-netrw window
                    Jun 15, 2016    * gx now calls netrw#GX() which returns
                      the word under the cursor. The new
                      wrinkle: if one is in a netrw buffer,
                      then netrw's s:NetrwGetWord().
                    Jun 22, 2016    * Netrw was executing all its associated
                      Filetype commands silently; I'm going
                      to try doing that "noisily" and see if
                      folks have a problem with that.
                    Aug 12, 2016    * Changed order of tool selection for
                      handling http://... viewing.
                      (Nikolay Aleksandrovich Pavlov)
                    Aug 21, 2016    * Included hiding/showing/all for tree
                      listings
                    * Fixed refresh (^L) for tree listings
                    v156:   Feb 18, 2016    * Changed =~ to =~# where appropriate
                    Feb 23, 2016    * s:ComposePath(base,subdir) now uses
                      fnameescape() on the base portion
                    Mar 01, 2016    * (gt_macki) reported where :Explore would
                      make file unlisted. Fixed (tst943)
                    Apr 04, 2016    * (reported by John Little) netrw normally
                      suppresses browser messages, but sometimes
                      those "messages" are what is wanted.
                      See |g:netrw_suppress_gx_mesg|
                    Apr 06, 2016    * (reported by Carlos Pita) deleting a remote
                      file was giving an error message. Fixed.
                    Apr 08, 2016    * (Charles Cooper) had a problem with an
                      undefined b:netrw_curdir. He also provided
                      a fix.
                    Apr 20, 2016    * Changed s:NetrwGetBuffer(); now uses
                      dictionaries. Also fixed the "No Name"
                      buffer problem.
                    v155:   Oct 29, 2015    * (Timur Fayzrakhmanov) reported that netrw's
                      mapping of ctrl-l was not allowing refresh of
                      other windows when it was done in a netrw
                      window.
                    Nov 05, 2015    * Improved s:TreeSqueezeDir() to use search()
                      instead of a loop
                    * NetrwBrowse() will return line to
                      w:netrw_bannercnt if cursor ended up in
                      banner
                    Nov 16, 2015    * Added a <Plug>NetrwTreeSqueeze (|netrw-s-cr|)
                    Nov 17, 2015    * Commented out imaps -- perhaps someone can
                      tell me how they're useful and should be
                      retained?
                    Nov 20, 2015    * Added |netrw-ma| and |netrw-mA| support
                    Nov 20, 2015    * gx (|netrw-gx|) on a URL downloaded the
                      file in addition to simply bringing up the
                      URL in a browser. Fixed.
                    Nov 23, 2015    * Added |g:netrw_sizestyle| support
                    Nov 27, 2015    * Inserted a lot of <c-u>s into various netrw
                      maps.
                    Jan 05, 2016    * |netrw-qL| implemented to mark files based
                      upon |location-list|s; similar to |netrw-qF|.
                    Jan 19, 2016    * using - call delete(directoryname,"d") -
                      instead of using g:netrw_localrmdir if
                      v7.4 + patch#1107 is available
                    Jan 28, 2016    * changed to using |winsaveview()| and
                      |winrestview()|
                    Jan 28, 2016    * s:NetrwTreePath() now does a save and
                      restore of view
                    Feb 08, 2016    * Fixed a tree-listing problem with remote
                      directories
                    v154:   Feb 26, 2015    * (Yuri Kanivetsky) reported a situation where
                      a file was not treated properly as a file
                      due to g:netrw_keepdir == 1
                    Mar 25, 2015    * (requested by Ben Friz) one may now sort by
                      extension
                    Mar 28, 2015    * (requested by Matt Brooks) netrw has a lot
                      of buffer-local mappings; however, some
                      plugins (such as vim-surround) set up
                      conflicting mappings that cause vim to wait.
                      The "<nowait>" modifier has been included
                      with most of netrw's mappings to avoid that
                      delay.
                    Jun 26, 2015    * |netrw-gn| mapping implemted
                    * :Ntree NotADir resulted in having
                      the tree listing expand in the error messages
                      window. Fixed.
                    Jun 29, 2015    * Attempting to delete a file remotely caused
                      an error with "keepsol" mentioned; fixed.
                    Jul 08, 2015    * Several changes to keep the |:jumps| table
                      correct when working with
                      |g:netrw_fastbrowse| set to 2
                    * wide listing with accented characters fixed
                      (using %-S instead of %-s with a |printf()|
                    Jul 13, 2015    * (Daniel Hahler) CheckIfKde() could be true
                      but kfmclient not installed. Changed order
                      in netrw#BrowseX(): checks if kde and
                      kfmclient, then will use xdg-open on a unix
                      system (if xdg-open is executable)
                    Aug 11, 2015    * (McDonnell) tree listing mode wouldn't
                      select a file in a open subdirectory.
                    * (McDonnell) when multiple subdirectories
                      were concurrently open in tree listing
                      mode, a ctrl-L wouldn't refresh properly.
                    * The netrw:target menu showed duplicate
                      entries
                    Oct 13, 2015    * (mattn) provided an exception to handle
                      windows with shellslash set but no shell
                    Oct 23, 2015    * if g:netrw_usetab and <c-tab> now used
                      to control whether NetrwShrink is used
                      (see |netrw-c-tab|)
                    v153:   May 13, 2014    * added another |g:netrw_ffkeep| usage
                    May 14, 2014    * changed s:PerformListing() so that it
                      always sets ft=netrw for netrw buffers
                      (ie. even when syntax highlighting is
                      off, not available, etc)
                    May 16, 2014    * introduced the |netrw-ctrl-r| functionality
                    May 17, 2014    * introduced the |netrw-:NetrwMB| functionality
                    * mb and mB (|netrw-mb|, |netrw-mB|) will
                      add/remove marked files from bookmark list
                    May 20, 2014    * (Enno Nagel) reported that :Lex <dirname>
                      wasn't working. Fixed.
                    May 26, 2014    * restored test to prevent leftmouse window
                      resizing from causing refresh.
                      (see s:NetrwLeftmouse())
                    * fixed problem where a refresh caused cursor
                      to go just under the banner instead of
                      staying put
                    May 28, 2014    * (László Bimba) provided a patch for opening
                      the |:Lexplore| window 100% high, optionally
                      on the right, and will work with remote
                      files.
                    May 29, 2014    * implemented :NetrwC (see |netrw-:NetrwC|)
                    Jun 01, 2014    * Removed some "silent"s from commands used
                      to implemented scp://... and pscp://...
                      directory listing. Permits request for
                      password to appear.
                    Jun 05, 2014    * (Enno Nagel) reported that user maps "/"
                      caused problems with "b" and "w", which
                      are mapped (for wide listings only) to
                      skip over files rather than just words.
                    Jun 10, 2014    * |g:netrw_gx| introduced to allow users to
                      override default "<cfile>" with the gx
                      (|netrw-gx|) map
                    Jun 11, 2014    * gx (|netrw-gx|), with |'autowrite'| set,
                      will write modified files. s:NetrwBrowseX()
                      will now save, turn off, and restore the
                      |'autowrite'| setting.
                    Jun 13, 2014    * added visual map for gx use
                    Jun 15, 2014    * (Enno Nagel) reported that with having hls
                      set and wide listing style in use, that the
                      b and w maps caused unwanted highlighting.
                    Jul 05, 2014    * |netrw-mv| and |netrw-mX| commands included
                    Jul 09, 2014    * |g:netrw_keepj| included, allowing optional
                      keepj
                    Jul 09, 2014    * fixing bugs due to previous update
                    Jul 21, 2014    * (Bruno Sutic) provided an updated
                      netrw_gitignore.vim
                    Jul 30, 2014    * (Yavuz Yetim) reported that editing two
                      remote files of the same name caused the
                      second instance to have a "temporary"
                      name. Fixed: now they use the same buffer.
                    Sep 18, 2014    * (Yasuhiro Matsumoto) provided a patch which
                      allows scp and windows local paths to work.
                    Oct 07, 2014    * gx (see |netrw-gx|) when atop a directory,
                      will now do |gf| instead
                    Nov 06, 2014    * For cygwin: cygstart will be available for
                      netrw#BrowseX() to use if its executable.
                    Nov 07, 2014    * Began support for file://... urls. Will use
                      |g:netrw_file_cmd| (typically elinks or links)
                    Dec 02, 2014    * began work on having mc (|netrw-mc|) copy
                      directories. Works for linux machines,
                      cygwin+vim, but not for windows+gvim.
                    Dec 02, 2014    * in tree mode, netrw was not opening
                      directories via symbolic links.
                    Dec 02, 2014    * added resolved link information to
                      thin and tree modes
                    Dec 30, 2014    * (issue#231) |:ls| was not showing
                      remote-file buffers reliably. Fixed.
                    v152:   Apr 08, 2014    * uses the |'noswapfile'| option (requires
                      vim 7.4 with patch 213)
                    * (Enno Nagel) turn |'rnu'| off in netrw
                      buffers.
                    * (Quinn Strahl) suggested that netrw
                      allow regular window splitting to occur,
                      thereby allowing |'equalalways'| to take
                      effect.
                    * (qingtian zhao) normally, netrw will
                      save and restore the |'fileformat'|;
                      however, sometimes that isn't wanted
                    Apr 14, 2014    * whenever netrw marks a buffer as ro,
                      it will also mark it as nomod.
                    Apr 16, 2014    * sftp protocol now supported by
                      netrw#Obtain(); this means that one
                      may use "mc" to copy a remote file
                      to a local file using sftp, and that
                      the |netrw-O| command can obtain remote
                      files via sftp.
                    * added [count]C support (see |netrw-C|)
                    Apr 18, 2014    * when |g:netrw_chgwin| is one more than
                      the last window, then vertically split
                      the last window and use it as the
                      chgwin window.
                    May 09, 2014    * SavePosn was "saving filename under cursor"
                      from a non-netrw window when using :Rex.
                    v151:   Jan 22, 2014    * extended :Rexplore to return to buffer
                      prior to Explore or editing a directory
                    * (Ken Takata) netrw gave error when
                      clipboard was disabled. Sol'n: Placed
                      several if has("clipboard") tests in.
                    * Fixed ftp://X@Y@Z// problem; X@Y now
                      part of user id, and only Z is part of
                      hostname.
                    * (A Loumiotis) reported that completion
                      using a directory name containing spaces
                      did not work. Fixed with a retry in
                      netrw#Explore() which removes the
                      backslashes vim inserted.
                    Feb 26, 2014    * :Rexplore now records the current file
                       using w:netrw_rexfile when returning via
                      |:Rexplore|
                    Mar 08, 2014    * (David Kotchan) provided some patches
                      allowing netrw to work properly with
                      windows shares.
                    * Multiple one-liner help messages available
                      by pressing <cr> while atop the "Quick
                      Help" line
                    * worked on ShellCmdPost, FocusGained event
                      handling.
                    * |:Lexplore| path: will be used to update
                      a left-side netrw browsing directory.
                    Mar 12, 2014    * |netrw-s-cr|: use <s-cr> to close
                      tree directory implemented
                    Mar 13, 2014    * (Tony Mechylynck) reported that using
                      the browser with ftp on a directory,
                      and selecting a gzipped txt file, that
                      an E19 occurred (which was issued by
                      gzip.vim). Fixed.
                    Mar 14, 2014    * Implemented :MF and :MT (see |netrw-:MF|
                      and |netrw-:MT|, respectively)
                    Mar 17, 2014    * |:Ntree| [dir] wasn't working properly; fixed
                    Mar 18, 2014    * Changed all uses of set to setl
                    Mar 18, 2014    * Commented the netrw_btkeep line in
                      s:NetrwOptionSave(); the effect is that
                      netrw buffers will remain as |'bt'|=nofile.
                      This should prevent swapfiles being created
                      for netrw buffers.
                    Mar 20, 2014    * Changed all uses of lcd to use s:NetrwLcd()
                      instead. Consistent error handling results
                      and it also handles Window's shares
                    * Fixed |netrw-d| command when applied with ftp
                    * https: support included for netrw#NetRead()
                    v150:   Jul 12, 2013    * removed a "keepalt" to allow ":e #" to
                      return to the netrw directory listing
                    Jul 13, 2013    * (Jonas Diemer) suggested changing
                      a <cWORD> to <cfile>.
                    Jul 21, 2013    * (Yuri Kanivetsky) reported that netrw's
                      use of mkdir did not produce directories
                      following the user's umask.
                    Aug 27, 2013    * introduced |g:netrw_altfile| option
                    Sep 05, 2013    * s:Strlen() now uses |strdisplaywidth()|
                      when available, by default
                    Sep 12, 2013    * (Selyano Baldo) reported that netrw wasn't
                      opening some directories properly from the
                      command line.
                    Nov 09, 2013    * |:Lexplore| introduced
                    * (Ondrej Platek) reported an issue with
                      netrw's trees (P15). Fixed.
                    * (Jorge Solis) reported that "t" in
                      tree mode caused netrw to forget its
                      line position.
                    Dec 05, 2013    * Added <s-leftmouse> file marking
                      (see |netrw-mf|)
                    Dec 05, 2013    * (Yasuhiro Matsumoto) Explore should use
                      strlen() instead s:Strlen() when handling
                      multibyte chars with strpart()
                      (ie. strpart() is byte oriented, not
                      display-width oriented).
                    Dec 09, 2013    * (Ken Takata) Provided a patch; File sizes
                      and a portion of timestamps were wrongly
                      highlighted with the directory color when
                      setting `:let g:netrw_liststyle=1` on Windows.
                    * (Paul Domaskis) noted that sometimes
                      cursorline was activating in non-netrw
                      windows. All but one setting of cursorline
                      was done via setl; there was one that was
                      overlooked. Fixed.
                    Dec 24, 2013    * (esquifit) asked that netrw allow the
                      /cygdrive prefix be a user-alterable
                      parameter.
                    Jan 02, 2014    * Fixed a problem with netrw-based ballon
                      evaluation (ie. netrw#NetrwBaloonHelp()
                      not having been loaded error messages)
                    Jan 03, 2014    * Fixed a problem with tree listings
                    * New command installed: |:Ntree|
                    Jan 06, 2014    * (Ivan Brennan) reported a problem with
                      |netrw-P|. Fixed.
                    Jan 06, 2014    * Fixed a problem with |netrw-P| when the
                      modified file was to be abandoned.
                    Jan 15, 2014    * (Matteo Cavalleri) reported that when the
                      banner is suppressed and tree listing is
                      used, a blank line was left at the top of
                      the display. Fixed.
                    Jan 20, 2014    * (Gideon Go) reported that, in tree listing
                      style, with a previous window open, that
                      the wrong directory was being used to open
                      a file. Fixed. (P21)
                    v149:   Apr 18, 2013    * in wide listing format, now have maps for
                      w and b to move to next/previous file
                    Apr 26, 2013    * one may now copy files in the same
                      directory; netrw will issue requests for
                      what names the files should be copied under
                    Apr 29, 2013    * Trying Benzinger's problem again. Seems
                      that commenting out the BufEnter and
                      installing VimEnter (only) works. Weird
                      problem! (tree listing, vim -O Dir1 Dir2)
                    May 01, 2013    * :Explore ftp://... wasn't working. Fixed.
                    May 02, 2013    * introduced |g:netrw_bannerbackslash| as
                      requested by Paul Domaskis.
                    Jul 03, 2013    * Explore now avoids splitting when a buffer
                      will be hidden.
                    v148:   Apr 16, 2013    * changed Netrw's Style menu to allow direct
                      choice of listing style, hiding style, and
                      sorting style
                    --
                    ==============================================================================
                    13. Todo                        *netrw-todo*
                    --
                    07/29/09 : banner   :|g:netrw_banner| can be used to suppress the
                       suppression   banner. This feature is new and experimental,
                      so its in the process of being debugged.
                    09/04/09 : "gp"     : See if it can be made to work for remote systems.
                    : See if it can be made to work with marked files.
                    --
                    ==============================================================================
                    14. Credits                     *netrw-credits*
                    --
                    Vim editor  by Bram Moolenaar (Thanks, Bram!)
                    dav     support by C Campbell
                    fetch       support by Bram Moolenaar and C Campbell
                    ftp     support by C Campbell <NdrOchip@ScampbellPfamily.AbizM>
                    http        support by Bram Moolenaar <bram@moolenaar.net>
                    rcp
                    rsync       support by C Campbell (suggested by Erik Warendorph)
                    scp     support by raf <raf@comdyn.com.au>
                    sftp        support by C Campbell
                    --
                    inputsecret(), BufReadCmd, BufWriteCmd contributed by C Campbell
                    --
                    Jérôme Augé     -- also using new buffer method with ftp+.netrc
                    Bram Moolenaar      -- obviously vim itself, :e and v:cmdarg use,
                       fetch,...
                    Yasuhiro Matsumoto  -- pointing out undo+0r problem and a solution
                    Erik Warendorph     -- for several suggestions (g:netrw_..._cmd
                       variables, rsync etc)
                    Doug Claar      -- modifications to test for success with ftp
                       operation
                    --
                    ==============================================================================
                    Modelines:
                    vim:tw=78:ts=8:noet:ft=help:norl:fdm=marker
--
~/Empire/Doks/Comp/editor/vim/cheatsh-qref/vim-bash_hotkeys.pdf ~/Empire/Doks/Comp/editor/vim/cheatsh-qref/vimbash-hotkeys.pdf
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/vdocs-bashsupport.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/v-bashsupport-shortkeys.txt
--
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/zz_vimoutliner.txt
~/Dropbox/rsc/Doks/phone/Comp/editor/vim/z_emmet-vim.txt

  ~/Empire/Doks/Comp/editor/vim/vim_user_manual.pdf
vim index.txt  [n-commands_list, (excommands) ]
            *index.txt*     For Vim version 8.2.  Last change: 2021 Aug 31

                      VIM REFERENCE MANUAL    by Bram Moolenaar

                                            *index*
            This file contains a list of all commands for each mode, with a tag and a
            short description.  The lists are sorted on ASCII value.

            Tip: When looking for certain functionality, use a search command.  E.g.,
            to look for deleting something, use: "/delete".

            1. Insert mode              |insert-index|
            2. Normal mode              |normal-index|
               2.1. Text objects            |objects|
               2.2. Window commands         |CTRL-W|
               2.3. Square bracket commands     |[|
               2.4. Commands starting with 'g'  |g|
               2.5. Commands starting with 'z'  |z|
               2.6. Operator-pending mode       |operator-pending-index|
            3. Visual mode              |visual-index|
            4. Command-line editing         |ex-edit-index|
            5. Terminal-Job mode            |terminal-job-index|
            6. EX commands              |ex-cmd-index|

            For an overview of options see |option-list|.
            For an overview of built-in functions see |functions|.
            For a list of Vim variables see |vim-variable|.
            For a complete listing of all help items see |help-tags|.

            ==============================================================================
            1. Insert mode                      *insert-index*

            tag     char        action in Insert mode   ~
            -----------------------------------------------------------------------
            |i_CTRL-@|  CTRL-@      insert previously inserted text and stop
                            insert
            |i_CTRL-A|  CTRL-A      insert previously inserted text
                    CTRL-B      not used |i_CTRL-B-gone|
            |i_CTRL-C|  CTRL-C      quit insert mode, without checking for
                            abbreviation, unless 'insertmode' set.
            |i_CTRL-D|  CTRL-D      delete one shiftwidth of indent in the current
                            line
            |i_CTRL-E|  CTRL-E      insert the character which is below the cursor
                    CTRL-F      not used (but by default it's in 'cinkeys' to
                            re-indent the current line)
            |i_CTRL-G_j|    CTRL-G CTRL-J   line down, to column where inserting started
            |i_CTRL-G_j|    CTRL-G j    line down, to column where inserting started
            |i_CTRL-G_j|    CTRL-G <Down>   line down, to column where inserting started
            |i_CTRL-G_k|    CTRL-G CTRL-K   line up, to column where inserting started
            |i_CTRL-G_k|    CTRL-G k    line up, to column where inserting started
            |i_CTRL-G_k|    CTRL-G <Up> line up, to column where inserting started
            |i_CTRL-G_u|    CTRL-G u    start new undoable edit
            |i_CTRL-G_U|    CTRL-G U    don't break undo with next cursor movement
            |i_<BS>|    <BS>        delete character before the cursor
            |i_digraph| {char1}<BS>{char2}
                            enter digraph (only when 'digraph' option set)
            |i_CTRL-H|  CTRL-H      same as <BS>
            |i_<Tab>|   <Tab>       insert a <Tab> character
            |i_CTRL-I|  CTRL-I      same as <Tab>
            |i_<NL>|    <NL>        same as <CR>
            |i_CTRL-J|  CTRL-J      same as <CR>
            |i_CTRL-K|  CTRL-K {char1} {char2}
                            enter digraph
            |i_CTRL-L|  CTRL-L      when 'insertmode' set: Leave Insert mode
            |i_<CR>|    <CR>        begin new line
            |i_CTRL-M|  CTRL-M      same as <CR>
            |i_CTRL-N|  CTRL-N      find next match for keyword in front of the
                            cursor
            |i_CTRL-O|  CTRL-O      execute a single command and return to insert
                            mode
            |i_CTRL-P|  CTRL-P      find previous match for keyword in front of
                            the cursor
            |i_CTRL-Q|  CTRL-Q      same as CTRL-V, unless used for terminal
                            control flow
            |i_CTRL-SHIFT-Q|  CTRL-SHIFT-Q {char}
                            like CTRL-Q unless |modifyOtherKeys| is active
            |i_CTRL-R|  CTRL-R {register}
                            insert the contents of a register
            |i_CTRL-R_CTRL-R| CTRL-R CTRL-R {register}
                            insert the contents of a register literally
            |i_CTRL-R_CTRL-O| CTRL-R CTRL-O {register}
                            insert the contents of a register literally
                            and don't auto-indent
            |i_CTRL-R_CTRL-P| CTRL-R CTRL-P {register}
                            insert the contents of a register literally
                            and fix indent.
                    CTRL-S      not used or used for terminal control flow
            |i_CTRL-T|  CTRL-T      insert one shiftwidth of indent in current
                            line
            |i_CTRL-U|  CTRL-U      delete all entered characters in the current
                            line
            |i_CTRL-V|  CTRL-V {char}   insert next non-digit literally
            |i_CTRL-SHIFT-V|  CTRL-SHIFT-V {char}
                            like CTRL-V unless |modifyOtherKeys| is active
            |i_CTRL-V_digit| CTRL-V {number} insert three digit decimal number as a single
                            byte.
            |i_CTRL-W|  CTRL-W      delete word before the cursor
            |i_CTRL-X|  CTRL-X {mode}   enter CTRL-X sub mode, see |i_CTRL-X_index|
            |i_CTRL-Y|  CTRL-Y      insert the character which is above the cursor
            |i_CTRL-Z|  CTRL-Z      when 'insertmode' set: suspend Vim
            |i_<Esc>|   <Esc>       end insert mode (unless 'insertmode' set)
            |i_CTRL-[|  CTRL-[      same as <Esc>
            |i_CTRL-\_CTRL-N| CTRL-\ CTRL-N go to Normal mode
            |i_CTRL-\_CTRL-G| CTRL-\ CTRL-G go to mode specified with 'insertmode'
                    CTRL-\ a - z    reserved for extensions
                    CTRL-\ others   not used
            |i_CTRL-]|  CTRL-]      trigger abbreviation
            |i_CTRL-^|  CTRL-^      toggle use of |:lmap| mappings
            |i_CTRL-_|  CTRL-_      When 'allowrevins' set: change language
                            (Hebrew, Farsi) {only when compiled with
                            the |+rightleft| feature}

                    <Space> to '~'  not used, except '0' and '^' followed by
                            CTRL-D

            |i_0_CTRL-D|    0 CTRL-D    delete all indent in the current line
            |i_^_CTRL-D|    ^ CTRL-D    delete all indent in the current line, restore
                            it in the next line

            |i_<Del>|   <Del>       delete character under the cursor

                    Meta characters (0x80 to 0xff, 128 to 255)
                            not used

            |i_<Left>|  <Left>      cursor one character left
            |i_<S-Left>|    <S-Left>    cursor one word left
            |i_<C-Left>|    <C-Left>    cursor one word left
            |i_<Right>| <Right>     cursor one character right
            |i_<S-Right>|   <S-Right>   cursor one word right
            |i_<C-Right>|   <C-Right>   cursor one word right
            |i_<Up>|    <Up>        cursor one line up
            |i_<S-Up>|  <S-Up>      same as <PageUp>
            |i_<Down>|  <Down>      cursor one line down
            |i_<S-Down>|    <S-Down>    same as <PageDown>
            |i_<Home>|  <Home>      cursor to start of line
            |i_<C-Home>|    <C-Home>    cursor to start of file
            |i_<End>|   <End>       cursor past end of line
            |i_<C-End>| <C-End>     cursor past end of file
            |i_<PageUp>|    <PageUp>    one screenful backward
            |i_<PageDown>|  <PageDown>  one screenful forward
            |i_<F1>|    <F1>        same as <Help>
            |i_<Help>|  <Help>      stop insert mode and display help window
            |i_<Insert>|    <Insert>    toggle Insert/Replace mode
            |i_<LeftMouse>| <LeftMouse> cursor at mouse click
            |i_<ScrollWheelDown>|   <ScrollWheelDown>   move window three lines down
            |i_<S-ScrollWheelDown>| <S-ScrollWheelDown> move window one page down
            |i_<ScrollWheelUp>| <ScrollWheelUp>     move window three lines up
            |i_<S-ScrollWheelUp>|   <S-ScrollWheelUp>   move window one page up
            |i_<ScrollWheelLeft>|   <ScrollWheelLeft>   move window six columns left
            |i_<S-ScrollWheelLeft>| <S-ScrollWheelLeft> move window one page left
            |i_<ScrollWheelRight>|  <ScrollWheelRight>  move window six columns right
            |i_<S-ScrollWheelRight>| <S-ScrollWheelRight>   move window one page right

            commands in CTRL-X submode              *i_CTRL-X_index*

            |i_CTRL-X_CTRL-D|   CTRL-X CTRL-D   complete defined identifiers
            |i_CTRL-X_CTRL-E|   CTRL-X CTRL-E   scroll up
            |i_CTRL-X_CTRL-F|   CTRL-X CTRL-F   complete file names
            |i_CTRL-X_CTRL-I|   CTRL-X CTRL-I   complete identifiers
            |i_CTRL-X_CTRL-K|   CTRL-X CTRL-K   complete identifiers from dictionary
            |i_CTRL-X_CTRL-L|   CTRL-X CTRL-L   complete whole lines
            |i_CTRL-X_CTRL-N|   CTRL-X CTRL-N   next completion
            |i_CTRL-X_CTRL-O|   CTRL-X CTRL-O   omni completion
            |i_CTRL-X_CTRL-P|   CTRL-X CTRL-P   previous completion
            |i_CTRL-X_CTRL-S|   CTRL-X CTRL-S   spelling suggestions
            |i_CTRL-X_CTRL-T|   CTRL-X CTRL-T   complete identifiers from thesaurus
            |i_CTRL-X_CTRL-Y|   CTRL-X CTRL-Y   scroll down
            |i_CTRL-X_CTRL-U|   CTRL-X CTRL-U   complete with 'completefunc'
            |i_CTRL-X_CTRL-V|   CTRL-X CTRL-V   complete like in : command line
            |i_CTRL-X_CTRL-Z|   CTRL-X CTRL-Z   stop completion, keeping the text as-is
            |i_CTRL-X_CTRL-]|   CTRL-X CTRL-]   complete tags
            |i_CTRL-X_s|        CTRL-X s    spelling suggestions

            commands in completion mode (see |popupmenu-keys|)

            |complete_CTRL-E| CTRL-E    stop completion and go back to original text
            |complete_CTRL-Y| CTRL-Y    accept selected match and stop completion
                    CTRL-L      insert one character from the current match
                    <CR>        insert currently selected match
                    <BS>        delete one character and redo search
                    CTRL-H      same as <BS>
                    <Up>        select the previous match
                    <Down>      select the next match
                    <PageUp>    select a match several entries back
                    <PageDown>  select a match several entries forward
                    other       stop completion and insert the typed character

            ==============================================================================
            2. Normal mode                      *normal-index*

            CHAR     any non-blank character
            WORD     a sequence of non-blank characters
            N    a number entered before the command
            {motion} a cursor movement command
            Nmove    the text that is moved over with a {motion}
            SECTION  a section that possibly starts with '}' instead of '{'

            note: 1 = cursor movement command; 2 = can be undone/redone

            tag     char          note action in Normal mode    ~
            ------------------------------------------------------------------------------
                    CTRL-@         not used
            |CTRL-A|    CTRL-A      2  add N to number at/after cursor
            |CTRL-B|    CTRL-B      1  scroll N screens Backwards
            |CTRL-C|    CTRL-C         interrupt current (search) command
            |CTRL-D|    CTRL-D         scroll Down N lines (default: half a screen)
            |CTRL-E|    CTRL-E         scroll N lines upwards (N lines Extra)
            |CTRL-F|    CTRL-F      1  scroll N screens Forward
            |CTRL-G|    CTRL-G         display current file name and position
            |<BS>|      <BS>        1  same as "h"
            |CTRL-H|    CTRL-H      1  same as "h"
            |<Tab>|     <Tab>       1  go to N newer entry in jump list
            |CTRL-I|    CTRL-I      1  same as <Tab>
            |<NL>|      <NL>        1  same as "j"
            |CTRL-J|    CTRL-J      1  same as "j"
                    CTRL-K         not used
            |CTRL-L|    CTRL-L         redraw screen
            |<CR>|      <CR>        1  cursor to the first CHAR N lines lower
            |CTRL-M|    CTRL-M      1  same as <CR>
            |CTRL-N|    CTRL-N      1  same as "j"
            |CTRL-O|    CTRL-O      1  go to N older entry in jump list
            |CTRL-P|    CTRL-P      1  same as "k"
                    CTRL-Q         not used, or used for terminal control flow
            |CTRL-R|    CTRL-R      2  redo changes which were undone with 'u'
                    CTRL-S         not used, or used for terminal control flow
            |CTRL-T|    CTRL-T         jump to N older Tag in tag list
            |CTRL-U|    CTRL-U         scroll N lines Upwards (default: half a
                               screen)
            |CTRL-V|    CTRL-V         start blockwise Visual mode
            |CTRL-W|    CTRL-W {char}      window commands, see |CTRL-W|
            |CTRL-X|    CTRL-X      2  subtract N from number at/after cursor
            |CTRL-Y|    CTRL-Y         scroll N lines downwards
            |CTRL-Z|    CTRL-Z         suspend program (or start new shell)
                    CTRL-[ <Esc>       not used
            |CTRL-\_CTRL-N| CTRL-\ CTRL-N      go to Normal mode (no-op)
            |CTRL-\_CTRL-G| CTRL-\ CTRL-G      go to mode specified with 'insertmode'
                    CTRL-\ a - z       reserved for extensions
                    CTRL-\ others      not used
            |CTRL-]|    CTRL-]         :ta to ident under cursor
            |CTRL-^|    CTRL-^         edit Nth alternate file (equivalent to
                               ":e #N")
                    CTRL-_         not used

            |<Space>|   <Space>     1  same as "l"
            |!|     !{motion}{filter}
                            2  filter Nmove text through the {filter}
                               command
            |!!|        !!{filter}  2  filter N lines through the {filter} command
            |quote|     "{register}        use {register} for next delete, yank or put
                               ({.%#:} only work with put)
            |#|     #       1  search backward for the Nth occurrence of
                               the ident under the cursor
            |$|     $       1  cursor to the end of Nth next line
            |%|     %       1  find the next (curly/square) bracket on
                               this line and go to its match, or go to
                               matching comment bracket, or go to matching
                               preprocessor directive.
            |N%|        {count}%    1  go to N percentage in the file
            |&|     &       2  repeat last :s
            |'|     '{a-zA-Z0-9}    1  cursor to the first CHAR on the line with
                               mark {a-zA-Z0-9}
            |''|        ''      1  cursor to the first CHAR of the line where
                               the cursor was before the latest jump.
            |'(|        '(      1  cursor to the first CHAR on the line of the
                               start of the current sentence
            |')|        ')      1  cursor to the first CHAR on the line of the
                               end of the current sentence
            |'<|        '<      1  cursor to the first CHAR of the line where
                               highlighted area starts/started in the
                               current buffer.
            |'>|        '>      1  cursor to the first CHAR of the line where
                               highlighted area ends/ended in the current
                               buffer.
            |'[|        '[      1  cursor to the first CHAR on the line of the
                               start of last operated text or start of put
                               text
            |']|        ']      1  cursor to the first CHAR on the line of the
                               end of last operated text or end of put
                               text
            |'{|        '{      1  cursor to the first CHAR on the line of the
                               start of the current paragraph
            |'}|        '}      1  cursor to the first CHAR on the line of the
                               end of the current paragraph
            |(|     (       1  cursor N sentences backward
            |)|     )       1  cursor N sentences forward
            |star|      *       1  search forward for the Nth occurrence of
                               the ident under the cursor
            |+|     +       1  same as <CR>
            |,|     ,       1  repeat latest f, t, F or T in opposite
                               direction N times
            |-|     -       1  cursor to the first CHAR N lines higher
            |.|     .       2  repeat last change with count replaced with
                               N
            |/|     /{pattern}<CR>  1  search forward for the Nth occurrence of
                               {pattern}
            |/<CR>|     /<CR>       1  search forward for {pattern} of last search
            |count|     0       1  cursor to the first char of the line
            |count|     1          prepend to command to give a count
            |count|     2           "
            |count|     3           "
            |count|     4           "
            |count|     5           "
            |count|     6           "
            |count|     7           "
            |count|     8           "
            |count|     9           "
            |:|     :       1  start entering an Ex command
            |N:|        {count}:       start entering an Ex command with range
                               from current line to N-1 lines down
            |;|     ;       1  repeat latest f, t, F or T N times
            |<|     <{motion}   2  shift Nmove lines one 'shiftwidth'
                               leftwards
            |<<|        <<      2  shift N lines one 'shiftwidth' leftwards
            |=|     ={motion}   2  filter Nmove lines through "indent"
            |==|        ==      2  filter N lines through "indent"
            |>|     >{motion}   2  shift Nmove lines one 'shiftwidth'
                               rightwards
            |>>|        >>      2  shift N lines one 'shiftwidth' rightwards
            |?|     ?{pattern}<CR>  1  search backward for the Nth previous
                               occurrence of {pattern}
            |?<CR>|     ?<CR>       1  search backward for {pattern} of last search
            |@|     @{a-z}      2  execute the contents of register {a-z}
                               N times
            |@:|        @:         repeat the previous ":" command N times
            |@@|        @@      2  repeat the previous @{a-z} N times
            |A|     A       2  append text after the end of the line N times
            |B|     B       1  cursor N WORDS backward
            |C|     ["x]C       2  change from the cursor position to the end
                               of the line, and N-1 more lines [into
                               register x]; synonym for "c$"
            |D|     ["x]D       2  delete the characters under the cursor
                               until the end of the line and N-1 more
                               lines [into register x]; synonym for "d$"
            |E|     E       1  cursor forward to the end of WORD N
            |F|     F{char}     1  cursor to the Nth occurrence of {char} to
                               the left
            |G|     G       1  cursor to line N, default last line
            |H|     H       1  cursor to line N from top of screen
            |I|     I       2  insert text before the first CHAR on the
                               line N times
            |J|     J       2  Join N lines; default is 2
            |K|     K          lookup Keyword under the cursor with
                               'keywordprg'
            |L|     L       1  cursor to line N from bottom of screen
            |M|     M       1  cursor to middle line of screen
            |N|     N       1  repeat the latest '/' or '?' N times in
                               opposite direction
            |O|     O       2  begin a new line above the cursor and
                               insert text, repeat N times
            |P|     ["x]P       2  put the text [from register x] before the
                               cursor N times
            |Q|     Q          switch to "Ex" mode
            |R|     R       2  enter replace mode: overtype existing
                               characters, repeat the entered text N-1
                               times
            |S|     ["x]S       2  delete N lines [into register x] and start
                               insert; synonym for "cc".
            |T|     T{char}     1  cursor till after Nth occurrence of {char}
                               to the left
            |U|     U       2  undo all latest changes on one line
            |V|     V          start linewise Visual mode
            |W|     W       1  cursor N WORDS forward
            |X|     ["x]X       2  delete N characters before the cursor [into
                               register x]
            |Y|     ["x]Y          yank N lines [into register x]; synonym for
                               "yy"
            |ZZ|        ZZ         write if buffer changed and close window
            |ZQ|        ZQ         close window without writing
            |[|     [{char}        square bracket command (see |[| below)
                    \          not used
            |]|     ]{char}        square bracket command (see |]| below)
            |^|     ^       1  cursor to the first CHAR of the line
            |_|     _       1  cursor to the first CHAR N - 1 lines lower
            |`|     `{a-zA-Z0-9}    1  cursor to the mark {a-zA-Z0-9}
            |`(|        `(      1  cursor to the start of the current sentence
            |`)|        `)      1  cursor to the end of the current sentence
            |`<|        `<      1  cursor to the start of the highlighted area
            |`>|        `>      1  cursor to the end of the highlighted area
            |`[|        `[      1  cursor to the start of last operated text
                               or start of putted text
            |`]|        `]      1  cursor to the end of last operated text or
                               end of putted text
            |``|        ``      1  cursor to the position before latest jump
            |`{|        `{      1  cursor to the start of the current paragraph
            |`}|        `}      1  cursor to the end of the current paragraph
            |a|     a       2  append text after the cursor N times
            |b|     b       1  cursor N words backward
            |c|     ["x]c{motion}   2  delete Nmove text [into register x] and
                               start insert
            |cc|        ["x]cc      2  delete N lines [into register x] and start
                               insert
            |d|     ["x]d{motion}   2  delete Nmove text [into register x]
            |dd|        ["x]dd      2  delete N lines [into register x]
            |do|        do      2  same as ":diffget"
            |dp|        dp      2  same as ":diffput"
            |e|     e       1  cursor forward to the end of word N
            |f|     f{char}     1  cursor to Nth occurrence of {char} to the
                               right
            |g|     g{char}        extended commands, see |g| below
            |h|     h       1  cursor N chars to the left
            |i|     i       2  insert text before the cursor N times
            |j|     j       1  cursor N lines downward
            |k|     k       1  cursor N lines upward
            |l|     l       1  cursor N chars to the right
            |m|     m{A-Za-z}      set mark {A-Za-z} at cursor position
            |n|     n       1  repeat the latest '/' or '?' N times
            |o|     o       2  begin a new line below the cursor and
                               insert text, repeat N times
            |p|     ["x]p       2  put the text [from register x] after the
                               cursor N times
            |q|     q{0-9a-zA-Z"}      record typed characters into named register
                               {0-9a-zA-Z"} (uppercase to append)
            |q|     q          (while recording) stops recording
            |q:|        q:         edit : command-line in command-line window
            |q/|        q/         edit / command-line in command-line window
            |q?|        q?         edit ? command-line in command-line window
            |r|     r{char}     2  replace N chars with {char}
            |s|     ["x]s       2  (substitute) delete N characters [into
                               register x] and start insert
            |t|     t{char}     1  cursor till before Nth occurrence of {char}
                               to the right
            |u|     u       2  undo changes
            |v|     v          start characterwise Visual mode
            |w|     w       1  cursor N words forward
            |x|     ["x]x       2  delete N characters under and after the
                               cursor [into register x]
            |y|     ["x]y{motion}      yank Nmove text [into register x]
            |yy|        ["x]yy         yank N lines [into register x]
            |z|     z{char}        commands starting with 'z', see |z| below
            |{|     {       1  cursor N paragraphs backward
            |bar|       |       1  cursor to column N
            |}|     }       1  cursor N paragraphs forward
            |~|     ~       2  'tildeop' off: switch case of N characters
                               under cursor and move the cursor N
                               characters to the right
            |~|     ~{motion}      'tildeop' on: switch case of Nmove text
            |<C-End>|   <C-End>     1  same as "G"
            |<C-Home>|  <C-Home>    1  same as "gg"
            |<C-Left>|  <C-Left>    1  same as "b"
            |<C-LeftMouse>| <C-LeftMouse>      ":ta" to the keyword at the mouse click
            |<C-Right>| <C-Right>   1  same as "w"
            |<C-RightMouse>| <C-RightMouse>    same as "CTRL-T"
            |<C-Tab>|   <C-Tab>        same as "g<Tab>"
            |<Del>|     ["x]<Del>   2  same as "x"
            |N<Del>|    {count}<Del>       remove the last digit from {count}
            |<Down>|    <Down>      1  same as "j"
            |<End>|     <End>       1  same as "$"
            |<F1>|      <F1>           same as <Help>
            |<Help>|    <Help>         open a help window
            |<Home>|    <Home>      1  same as "0"
            |<Insert>|  <Insert>    2  same as "i"
            |<Left>|    <Left>      1  same as "h"
            |<LeftMouse>|   <LeftMouse> 1  move cursor to the mouse click position
            |<MiddleMouse>| <MiddleMouse>   2  same as "gP" at the mouse click position
            |<PageDown>|    <PageDown>     same as CTRL-F
            |<PageUp>|  <PageUp>       same as CTRL-B
            |<Right>|   <Right>     1  same as "l"
            |<RightMouse>|  <RightMouse>       start Visual mode, move cursor to the mouse
                               click position
            |<S-Down>|  <S-Down>    1  same as CTRL-F
            |<S-Left>|  <S-Left>    1  same as "b"
            |<S-LeftMouse>| <S-LeftMouse>      same as "*" at the mouse click position
            |<S-Right>| <S-Right>   1  same as "w"
            |<S-RightMouse>| <S-RightMouse>    same as "#" at the mouse click position
            |<S-Up>|    <S-Up>      1  same as CTRL-B
            |<Undo>|    <Undo>      2  same as "u"
            |<Up>|      <Up>        1  same as "k"
            |<ScrollWheelDown>| <ScrollWheelDown>   move window three lines down
            |<S-ScrollWheelDown>|   <S-ScrollWheelDown> move window one page down
            |<ScrollWheelUp>|   <ScrollWheelUp>     move window three lines up
            |<S-ScrollWheelUp>| <S-ScrollWheelUp>   move window one page up
            |<ScrollWheelLeft>| <ScrollWheelLeft>   move window six columns left
            |<S-ScrollWheelLeft>|   <S-ScrollWheelLeft> move window one page left
            |<ScrollWheelRight>|    <ScrollWheelRight>  move window six columns right
            |<S-ScrollWheelRight>|  <S-ScrollWheelRight>    move window one page right

            ==============================================================================
            2.1 Text objects                        *objects*

            These can be used after an operator or in Visual mode to select an object.

            tag     command        action in op-pending and Visual mode ~
            ------------------------------------------------------------------------------
            |v_aquote|  a"         double quoted string
            |v_a'|      a'         single quoted string
            |v_a(|      a(         same as ab
            |v_a)|      a)         same as ab
            |v_a<|      a<         "a <>" from '<' to the matching '>'
            |v_a>|      a>         same as a<
            |v_aB|      aB         "a Block" from "[{" to "]}" (with brackets)
            |v_aW|      aW         "a WORD" (with white space)
            |v_a[|      a[         "a []" from '[' to the matching ']'
            |v_a]|      a]         same as a[
            |v_a`|      a`         string in backticks
            |v_ab|      ab         "a block" from "[(" to "])" (with braces)
            |v_ap|      ap         "a paragraph" (with white space)
            |v_as|      as         "a sentence" (with white space)
            |v_at|      at         "a tag block" (with white space)
            |v_aw|      aw         "a word" (with white space)
            |v_a{|      a{         same as aB
            |v_a}|      a}         same as aB
            |v_iquote|  i"         double quoted string without the quotes
            |v_i'|      i'         single quoted string without the quotes
            |v_i(|      i(         same as ib
            |v_i)|      i)         same as ib
            |v_i<|      i<         "inner <>" from '<' to the matching '>'
            |v_i>|      i>         same as i<
            |v_iB|      iB         "inner Block" from "[{" and "]}"
            |v_iW|      iW         "inner WORD"
            |v_i[|      i[         "inner []" from '[' to the matching ']'
            |v_i]|      i]         same as i[
            |v_i`|      i`         string in backticks without the backticks
            |v_ib|      ib         "inner block" from "[(" to "])"
            |v_ip|      ip         "inner paragraph"
            |v_is|      is         "inner sentence"
            |v_it|      it         "inner tag block"
            |v_iw|      iw         "inner word"
            |v_i{|      i{         same as iB
            |v_i}|      i}         same as iB

            ==============================================================================
            2.2 Window commands                     *CTRL-W*

            tag     command        action in Normal mode    ~
            ------------------------------------------------------------------------------
            |CTRL-W_CTRL-B| CTRL-W CTRL-B      same as "CTRL-W b"
            |CTRL-W_CTRL-C| CTRL-W CTRL-C      same as "CTRL-W c"
            |CTRL-W_CTRL-D| CTRL-W CTRL-D      same as "CTRL-W d"
            |CTRL-W_CTRL-F| CTRL-W CTRL-F      same as "CTRL-W f"
                    CTRL-W CTRL-G      same as "CTRL-W g .."
            |CTRL-W_CTRL-H| CTRL-W CTRL-H      same as "CTRL-W h"
            |CTRL-W_CTRL-I| CTRL-W CTRL-I      same as "CTRL-W i"
            |CTRL-W_CTRL-J| CTRL-W CTRL-J      same as "CTRL-W j"
            |CTRL-W_CTRL-K| CTRL-W CTRL-K      same as "CTRL-W k"
            |CTRL-W_CTRL-L| CTRL-W CTRL-L      same as "CTRL-W l"
            |CTRL-W_CTRL-N| CTRL-W CTRL-N      same as "CTRL-W n"
            |CTRL-W_CTRL-O| CTRL-W CTRL-O      same as "CTRL-W o"
            |CTRL-W_CTRL-P| CTRL-W CTRL-P      same as "CTRL-W p"
            |CTRL-W_CTRL-Q| CTRL-W CTRL-Q      same as "CTRL-W q"
            |CTRL-W_CTRL-R| CTRL-W CTRL-R      same as "CTRL-W r"
            |CTRL-W_CTRL-S| CTRL-W CTRL-S      same as "CTRL-W s"
            |CTRL-W_CTRL-T| CTRL-W CTRL-T      same as "CTRL-W t"
            |CTRL-W_CTRL-V| CTRL-W CTRL-V      same as "CTRL-W v"
            |CTRL-W_CTRL-W| CTRL-W CTRL-W      same as "CTRL-W w"
            |CTRL-W_CTRL-X| CTRL-W CTRL-X      same as "CTRL-W x"
            |CTRL-W_CTRL-Z| CTRL-W CTRL-Z      same as "CTRL-W z"
            |CTRL-W_CTRL-]| CTRL-W CTRL-]      same as "CTRL-W ]"
            |CTRL-W_CTRL-^| CTRL-W CTRL-^      same as "CTRL-W ^"
            |CTRL-W_CTRL-_| CTRL-W CTRL-_      same as "CTRL-W _"
            |CTRL-W_+|  CTRL-W +       increase current window height N lines
            |CTRL-W_-|  CTRL-W -       decrease current window height N lines
            |CTRL-W_:|  CTRL-W :       same as |:|, edit a command line
            |CTRL-W_<|  CTRL-W <       decrease current window width N columns
            |CTRL-W_=|  CTRL-W =       make all windows the same height & width
            |CTRL-W_>|  CTRL-W >       increase current window width N columns
            |CTRL-W_H|  CTRL-W H       move current window to the far left
            |CTRL-W_J|  CTRL-W J       move current window to the very bottom
            |CTRL-W_K|  CTRL-W K       move current window to the very top
            |CTRL-W_L|  CTRL-W L       move current window to the far right
            |CTRL-W_P|  CTRL-W P       go to preview window
            |CTRL-W_R|  CTRL-W R       rotate windows upwards N times
            |CTRL-W_S|  CTRL-W S       same as "CTRL-W s"
            |CTRL-W_T|  CTRL-W T       move current window to a new tab page
            |CTRL-W_W|  CTRL-W W       go to N previous window (wrap around)
            |CTRL-W_]|  CTRL-W ]       split window and jump to tag under cursor
            |CTRL-W_^|  CTRL-W ^       split current window and edit alternate
                               file N
            |CTRL-W__|  CTRL-W _       set current window height to N (default:
                               very high)
            |CTRL-W_b|  CTRL-W b       go to bottom window
            |CTRL-W_c|  CTRL-W c       close current window (like |:close|)
            |CTRL-W_d|  CTRL-W d       split window and jump to definition under
                               the cursor
            |CTRL-W_f|  CTRL-W f       split window and edit file name under the
                               cursor
            |CTRL-W_F|  CTRL-W F       split window and edit file name under the
                               cursor and jump to the line number
                               following the file name.
            |CTRL-W_g_CTRL-]| CTRL-W g CTRL-]  split window and do |:tjump| to tag under
                               cursor
            |CTRL-W_g]| CTRL-W g ]     split window and do |:tselect| for tag
                               under cursor
            |CTRL-W_g}| CTRL-W g }     do a |:ptjump| to the tag under the cursor
            |CTRL-W_gf| CTRL-W g f     edit file name under the cursor in a new
                               tab page
            |CTRL-W_gF| CTRL-W g F     edit file name under the cursor in a new
                               tab page and jump to the line number
                               following the file name.
            |CTRL-W_gt| CTRL-W g t     same as `gt`: go to next tab page
            |CTRL-W_gT| CTRL-W g T     same as `gT`: go to previous tab page
            |CTRL-W_g<Tab>| CTRL-W g <Tab>     same as |g<Tab>|: go to last accessed tab
                               page.
            |CTRL-W_h|  CTRL-W h       go to Nth left window (stop at first window)
            |CTRL-W_i|  CTRL-W i       split window and jump to declaration of
                               identifier under the cursor
            |CTRL-W_j|  CTRL-W j       go N windows down (stop at last window)
            |CTRL-W_k|  CTRL-W k       go N windows up (stop at first window)
            |CTRL-W_l|  CTRL-W l       go to Nth right window (stop at last window)
            |CTRL-W_n|  CTRL-W n       open new window, N lines high
            |CTRL-W_o|  CTRL-W o       close all but current window (like |:only|)
            |CTRL-W_p|  CTRL-W p       go to previous (last accessed) window
            |CTRL-W_q|  CTRL-W q       quit current window (like |:quit|)
            |CTRL-W_r|  CTRL-W r       rotate windows downwards N times
            |CTRL-W_s|  CTRL-W s       split current window in two parts, new
                               window N lines high
            |CTRL-W_t|  CTRL-W t       go to top window
            |CTRL-W_v|  CTRL-W v       split current window vertically, new window
                               N columns wide
            |CTRL-W_w|  CTRL-W w       go to N next window (wrap around)
            |CTRL-W_x|  CTRL-W x       exchange current window with window N
                               (default: next window)
            |CTRL-W_z|  CTRL-W z       close preview window
            |CTRL-W_bar|    CTRL-W |       set window width to N columns
            |CTRL-W_}|  CTRL-W }       show tag under cursor in preview window
            |CTRL-W_<Down>| CTRL-W <Down>      same as "CTRL-W j"
            |CTRL-W_<Up>|   CTRL-W <Up>    same as "CTRL-W k"
            |CTRL-W_<Left>| CTRL-W <Left>      same as "CTRL-W h"
            |CTRL-W_<Right>| CTRL-W <Right>    same as "CTRL-W l"

            ==============================================================================
            2.3 Square bracket commands                 *[* *]*

            tag     char          note action in Normal mode    ~
            ------------------------------------------------------------------------------
            |[_CTRL-D|  [ CTRL-D       jump to first #define found in current and
                               included files matching the word under the
                               cursor, start searching at beginning of
                               current file
            |[_CTRL-I|  [ CTRL-I       jump to first line in current and included
                               files that contains the word under the
                               cursor, start searching at beginning of
                               current file
            |[#|        [#      1  cursor to N previous unmatched #if, #else
                               or #ifdef
            |['|        ['      1  cursor to previous lowercase mark, on first
                               non-blank
            |[(|        [(      1  cursor N times back to unmatched '('
            |[star|     [*      1  same as "[/"
            |[`|        [`      1  cursor to previous lowercase mark
            |[/|        [/      1  cursor to N previous start of a C comment
            |[D|        [D         list all defines found in current and
                               included files matching the word under the
                               cursor, start searching at beginning of
                               current file
            |[I|        [I         list all lines found in current and
                               included files that contain the word under
                               the cursor, start searching at beginning of
                               current file
            |[P|        [P      2  same as "[p"
            |[[|        [[      1  cursor N sections backward
            |[]|        []      1  cursor N SECTIONS backward
            |[c|        [c      1  cursor N times backwards to start of change
            |[d|        [d         show first #define found in current and
                               included files matching the word under the
                               cursor, start searching at beginning of
                               current file
            |[f|        [f         same as "gf"
            |[i|        [i         show first line found in current and
                               included files that contains the word under
                               the cursor, start searching at beginning of
                               current file
            |[m|        [m      1  cursor N times back to start of member
                               function
            |[p|        [p      2  like "P", but adjust indent to current line
            |[s|        [s      1  move to the previous misspelled word
            |[z|        [z      1  move to start of open fold
            |[{|        [{      1  cursor N times back to unmatched '{'
            |[<MiddleMouse>| [<MiddleMouse> 2  same as "[p"

            |]_CTRL-D|  ] CTRL-D       jump to first #define found in current and
                               included files matching the word under the
                               cursor, start searching at cursor position
            |]_CTRL-I|  ] CTRL-I       jump to first line in current and included
                               files that contains the word under the
                               cursor, start searching at cursor position
            |]#|        ]#      1  cursor to N next unmatched #endif or #else
            |]'|        ]'      1  cursor to next lowercase mark, on first
                               non-blank
            |])|        ])      1  cursor N times forward to unmatched ')'
            |]star|     ]*      1  same as "]/"
            |]`|        ]`      1  cursor to next lowercase mark
            |]/|        ]/      1  cursor to N next end of a C comment
            |]D|        ]D         list all #defines found in current and
                               included files matching the word under the
                               cursor, start searching at cursor position
            |]I|        ]I         list all lines found in current and
                               included files that contain the word under
                               the cursor, start searching at cursor
                               position
            |]P|        ]P      2  same as "[p"
            |][|        ][      1  cursor N SECTIONS forward
            |]]|        ]]      1  cursor N sections forward
            |]c|        ]c      1  cursor N times forward to start of change
            |]d|        ]d         show first #define found in current and
                               included files matching the word under the
                               cursor, start searching at cursor position
            |]f|        ]f         same as "gf"
            |]i|        ]i         show first line found in current and
                               included files that contains the word under
                               the cursor, start searching at cursor
                               position
            |]m|        ]m      1  cursor N times forward to end of member
                               function
            |]p|        ]p      2  like "p", but adjust indent to current line
            |]s|        ]s      1  move to next misspelled word
            |]z|        ]z      1  move to end of open fold
            |]}|        ]}      1  cursor N times forward to unmatched '}'
            |]<MiddleMouse>| ]<MiddleMouse> 2  same as "]p"

            ==============================================================================
            2.4 Commands starting with 'g'                      *g*

            tag     char          note action in Normal mode    ~
            ------------------------------------------------------------------------------
            |g_CTRL-A|  g CTRL-A       only when compiled with MEM_PROFILE
                               defined: dump a memory profile
            |g_CTRL-G|  g CTRL-G       show information about current cursor
                               position
            |g_CTRL-H|  g CTRL-H       start Select block mode
            |g_CTRL-]|  g CTRL-]       |:tjump| to the tag under the cursor
            |g#|        g#      1  like "#", but without using "\<" and "\>"
            |g$|        g$      1  when 'wrap' off go to rightmost character of
                               the current line that is on the screen;
                               when 'wrap' on go to the rightmost character
                               of the current screen line
            |g&|        g&      2  repeat last ":s" on all lines
            |g'|        g'{mark}    1  like |'| but without changing the jumplist
            |g`|        g`{mark}    1  like |`| but without changing the jumplist
            |gstar|     g*      1  like "*", but without using "\<" and "\>"
            |g+|        g+         go to newer text state N times
            |g,|        g,      1  go to N newer position in change list
            |g-|        g-         go to older text state N times
            |g0|        g0      1  when 'wrap' off go to leftmost character of
                               the current line that is on the screen;
                               when 'wrap' on go to the leftmost character
                               of the current screen line
            |g8|        g8         print hex value of bytes used in UTF-8
                               character under the cursor
            |g;|        g;      1  go to N older position in change list
            |g<|        g<         display previous command output
            |g?|        g?      2  Rot13 encoding operator
            |g?g?|      g??     2  Rot13 encode current line
            |g?g?|      g?g?        2  Rot13 encode current line
            |gD|        gD      1  go to definition of word under the cursor
                               in current file
            |gE|        gE      1  go backwards to the end of the previous
                               WORD
            |gH|        gH         start Select line mode
            |gI|        gI      2  like "I", but always start in column 1
            |gJ|        gJ      2  join lines without inserting space
            |gN|        gN        1,2  find the previous match with the last used
                               search pattern and Visually select it
            |gP|        ["x]gP      2  put the text [from register x] before the
                               cursor N times, leave the cursor after it
            |gQ|        gQ          switch to "Ex" mode with Vim editing
            |gR|        gR      2  enter Virtual Replace mode
            |gT|        gT         go to the previous tab page
            |gU|        gU{motion}  2  make Nmove text uppercase
            |gV|        gV         don't reselect the previous Visual area
                               when executing a mapping or menu in Select
                               mode
            |g]|        g]         :tselect on the tag under the cursor
            |g^|        g^      1  when 'wrap' off go to leftmost non-white
                               character of the current line that is on
                               the screen; when 'wrap' on go to the
                               leftmost non-white character of the current
                               screen line
            |g_|        g_      1  cursor to the last CHAR N - 1 lines lower
            |ga|        ga         print ascii value of character under the
                               cursor
            |gd|        gd      1  go to definition of word under the cursor
                               in current function
            |ge|        ge      1  go backwards to the end of the previous
                               word
            |gf|        gf         start editing the file whose name is under
                               the cursor
            |gF|        gF         start editing the file whose name is under
                               the cursor and jump to the line number
                               following the filename.
            |gg|        gg      1  cursor to line N, default first line
            |gh|        gh         start Select mode
            |gi|        gi      2  like "i", but first move to the |'^| mark
            |gj|        gj      1  like "j", but when 'wrap' on go N screen
                               lines down
            |gk|        gk      1  like "k", but when 'wrap' on go N screen
                               lines up
            |gm|        gm      1  go to character at middle of the screenline
            |gM|        gM      1  go to character at middle of the text line
            |gn|        gn        1,2  find the next match with the last used
                               search pattern and Visually select it
            |go|        go      1  cursor to byte N in the buffer
            |gp|        ["x]gp      2  put the text [from register x] after the
                               cursor N times, leave the cursor after it
            |gq|        gq{motion}  2  format Nmove text
            |gr|        gr{char}    2  virtual replace N chars with {char}
            |gs|        gs         go to sleep for N seconds (default 1)
            |gt|        gt         go to the next tab page
            |gu|        gu{motion}  2  make Nmove text lowercase
            |gv|        gv         reselect the previous Visual area
            |gw|        gw{motion}  2  format Nmove text and keep cursor
            |netrw-gx|  gx         execute application for file name under the
                               cursor (only with |netrw| plugin)
            |g@|        g@{motion}     call 'operatorfunc'
            |g~|        g~{motion}  2  swap case for Nmove text
            |g<Down>|   g<Down>     1  same as "gj"
            |g<End>|    g<End>      1  same as "g$"
            |g<Home>|   g<Home>     1  same as "g0"
            |g<LeftMouse>|  g<LeftMouse>       same as <C-LeftMouse>
                    g<MiddleMouse>     same as <C-MiddleMouse>
            |g<RightMouse>| g<RightMouse>      same as <C-RightMouse>
            |g<Tab>|    g<Tab>         go to the last accessed tab page.
            |g<Up>|     g<Up>       1  same as "gk"

            ==============================================================================
            2.5 Commands starting with 'z'                      *z*

            tag     char          note action in Normal mode    ~
            ------------------------------------------------------------------------------
            |z<CR>|     z<CR>          redraw, cursor line to top of window,
                               cursor on first non-blank
            |zN<CR>|    z{height}<CR>      redraw, make window {height} lines high
            |z+|        z+         cursor on line N (default line below
                               window), otherwise like "z<CR>"
            |z-|        z-         redraw, cursor line at bottom of window,
                               cursor on first non-blank
            |z.|        z.         redraw, cursor line to center of window,
                               cursor on first non-blank
            |z=|        z=         give spelling suggestions
            |zA|        zA         open a closed fold or close an open fold
                               recursively
            |zC|        zC         close folds recursively
            |zD|        zD         delete folds recursively
            |zE|        zE         eliminate all folds
            |zF|        zF         create a fold for N lines
            |zG|        zG         temporarily mark word as correctly spelled
            |zH|        zH         when 'wrap' off scroll half a screenwidth
                               to the right
            |zL|        zL         when 'wrap' off scroll half a screenwidth
                               to the left
            |zM|        zM         set 'foldlevel' to zero
            |zN|        zN         set 'foldenable'
            |zO|        zO         open folds recursively
            |zR|        zR         set 'foldlevel' to the deepest fold
            |zW|        zW         temporarily mark word as incorrectly spelled
            |zX|        zX         re-apply 'foldlevel'
            |z^|        z^         cursor on line N (default line above
                               window), otherwise like "z-"
            |za|        za         open a closed fold, close an open fold
            |zb|        zb         redraw, cursor line at bottom of window
            |zc|        zc         close a fold
            |zd|        zd         delete a fold
            |ze|        ze         when 'wrap' off scroll horizontally to
                               position the cursor at the end (right side)
                               of the screen
            |zf|        zf{motion}     create a fold for Nmove text
            |zg|        zg         permanently mark word as correctly spelled
            |zh|        zh         when 'wrap' off scroll screen N characters
                               to the right
            |zi|        zi         toggle 'foldenable'
            |zj|        zj      1  move to the start of the next fold
            |zk|        zk      1  move to the end of the previous fold
            |zl|        zl         when 'wrap' off scroll screen N characters
                               to the left
            |zm|        zm         subtract one from 'foldlevel'
            |zn|        zn         reset 'foldenable'
            |zo|        zo         open fold
            |zp|        zp         paste in block-mode without trailing spaces
            |zP|        zP         paste in block-mode without trailing spaces
            |zr|        zr         add one to 'foldlevel'
            |zs|        zs         when 'wrap' off scroll horizontally to
                               position the cursor at the start (left
                               side) of the screen
            |zt|        zt         redraw, cursor line at top of window
            |zuw|       zuw        undo |zw|
            |zug|       zug        undo |zg|
            |zuW|       zuW        undo |zW|
            |zuG|       zuG        undo |zG|
            |zv|        zv         open enough folds to view the cursor line
            |zw|        zw         permanently mark word as incorrectly spelled
            |zx|        zx         re-apply 'foldlevel' and do "zv"
            |zy|        zy         yank without trailing spaces
            |zz|        zz         redraw, cursor line at center of window
            |z<Left>|   z<Left>        same as "zh"
            |z<Right>|  z<Right>       same as "zl"

            ==============================================================================
            2.6 Operator-pending mode           *operator-pending-index*

            These can be used after an operator, but before a {motion} has been entered.

            tag     char        action in Operator-pending mode ~
            -----------------------------------------------------------------------
            |o_v|       v       force operator to work characterwise
            |o_V|       V       force operator to work linewise
            |o_CTRL-V|  CTRL-V      force operator to work blockwise

            ==============================================================================
            3. Visual mode                      *visual-index*

            Most commands in Visual mode are the same as in Normal mode.  The ones listed
            here are those that are different.

            tag     command       note action in Visual mode    ~
            ------------------------------------------------------------------------------
            |v_CTRL-\_CTRL-N| CTRL-\ CTRL-N    stop Visual mode
            |v_CTRL-\_CTRL-G| CTRL-\ CTRL-G    go to mode specified with 'insertmode'
            |v_CTRL-A|  CTRL-A      2  add N to number in highlighted text
            |v_CTRL-C|  CTRL-C         stop Visual mode
            |v_CTRL-G|  CTRL-G         toggle between Visual mode and Select mode
            |v_<BS>|    <BS>        2  Select mode: delete highlighted area
            |v_CTRL-H|  CTRL-H      2  same as <BS>
            |v_CTRL-O|  CTRL-O         switch from Select to Visual mode for one
                               command
            |v_CTRL-V|  CTRL-V         make Visual mode blockwise or stop Visual
                               mode
            |v_CTRL-X|  CTRL-X      2  subtract N from number in highlighted text
            |v_<Esc>|   <Esc>          stop Visual mode
            |v_CTRL-]|  CTRL-]         jump to highlighted tag
            |v_!|       !{filter}   2  filter the highlighted lines through the
                               external command {filter}
            |v_:|       :          start a command-line with the highlighted
                               lines as a range
            |v_<|       <       2  shift the highlighted lines one
                               'shiftwidth' left
            |v_=|       =       2  filter the highlighted lines through the
                               external program given with the 'equalprg'
                               option
            |v_>|       >       2  shift the highlighted lines one
                               'shiftwidth' right
            |v_b_A|     A       2  block mode: append same text in all lines,
                               after the highlighted area
            |v_C|       C       2  delete the highlighted lines and start
                               insert
            |v_D|       D       2  delete the highlighted lines
            |v_b_I|     I       2  block mode: insert same text in all lines,
                               before the highlighted area
            |v_J|       J       2  join the highlighted lines
            |v_K|       K          run 'keywordprg' on the highlighted area
            |v_O|       O          Move horizontally to other corner of area.
                    Q          does not start Ex mode
            |v_R|       R       2  delete the highlighted lines and start
                               insert
            |v_S|       S       2  delete the highlighted lines and start
                               insert
            |v_U|       U       2  make highlighted area uppercase
            |v_V|       V          make Visual mode linewise or stop Visual
                               mode
            |v_X|       X       2  delete the highlighted lines
            |v_Y|       Y          yank the highlighted lines
            |v_aquote|  a"         extend highlighted area with a double
                               quoted string
            |v_a'|      a'         extend highlighted area with a single
                               quoted string
            |v_a(|      a(         same as ab
            |v_a)|      a)         same as ab
            |v_a<|      a<         extend highlighted area with a <> block
            |v_a>|      a>         same as a<
            |v_aB|      aB         extend highlighted area with a {} block
            |v_aW|      aW         extend highlighted area with "a WORD"
            |v_a[|      a[         extend highlighted area with a [] block
            |v_a]|      a]         same as a[
            |v_a`|      a`         extend highlighted area with a backtick
                               quoted string
            |v_ab|      ab         extend highlighted area with a () block
            |v_ap|      ap         extend highlighted area with a paragraph
            |v_as|      as         extend highlighted area with a sentence
            |v_at|      at         extend highlighted area with a tag block
            |v_aw|      aw         extend highlighted area with "a word"
            |v_a{|      a{         same as aB
            |v_a}|      a}         same as aB
            |v_c|       c       2  delete highlighted area and start insert
            |v_d|       d       2  delete highlighted area
            |v_g_CTRL-A|    g CTRL-A    2  add N to number in highlighted text
            |v_g_CTRL-X|    g CTRL-X    2  subtract N from number in highlighted text
            |v_gJ|      gJ      2  join the highlighted lines without
                               inserting spaces
            |v_gq|      gq      2  format the highlighted lines
            |v_gv|      gv         exchange current and previous highlighted
                               area
            |v_iquote|  i"         extend highlighted area with a double
                               quoted string (without quotes)
            |v_i'|      i'         extend highlighted area with a single
                               quoted string (without quotes)
            |v_i(|      i(         same as ib
            |v_i)|      i)         same as ib
            |v_i<|      i<         extend highlighted area with inner <> block
            |v_i>|      i>         same as i<
            |v_iB|      iB         extend highlighted area with inner {} block
            |v_iW|      iW         extend highlighted area with "inner WORD"
            |v_i[|      i[         extend highlighted area with inner [] block
            |v_i]|      i]         same as i[
            |v_i`|      i`         extend highlighted area with a backtick
                               quoted string (without the backticks)
            |v_ib|      ib         extend highlighted area with inner () block
            |v_ip|      ip         extend highlighted area with inner paragraph
            |v_is|      is         extend highlighted area with inner sentence
            |v_it|      it         extend highlighted area with inner tag block
            |v_iw|      iw         extend highlighted area with "inner word"
            |v_i{|      i{         same as iB
            |v_i}|      i}         same as iB
            |v_o|       o          move cursor to other corner of area
            |v_r|       r       2  replace highlighted area with a character
            |v_s|       s       2  delete highlighted area and start insert
            |v_u|       u       2  make highlighted area lowercase
            |v_v|       v          make Visual mode characterwise or stop
                               Visual mode
            |v_x|       x       2  delete the highlighted area
            |v_y|       y          yank the highlighted area
            |v_~|       ~       2  swap case for the highlighted area

            ==============================================================================
            4. Command-line editing                 *ex-edit-index*

            Get to the command-line with the ':', '!', '/' or '?' commands.
            Normal characters are inserted at the current cursor position.
            "Completion" below refers to context-sensitive completion.  It will complete
            file names, tags, commands etc. as appropriate.

            tag     command     action in Command-line editing mode ~
            ------------------------------------------------------------------------------
                    CTRL-@      not used
            |c_CTRL-A|  CTRL-A      do completion on the pattern in front of the
                            cursor and insert all matches
            |c_CTRL-B|  CTRL-B      cursor to begin of command-line
            |c_CTRL-C|  CTRL-C      same as <Esc>
            |c_CTRL-D|  CTRL-D      list completions that match the pattern in
                            front of the cursor
            |c_CTRL-E|  CTRL-E      cursor to end of command-line
            |'cedit'|   CTRL-F      default value for 'cedit': opens the
                            command-line window; otherwise not used
            |c_CTRL-G|  CTRL-G      next match when 'incsearch' is active
            |c_<BS>|    <BS>        delete the character in front of the cursor
            |c_digraph| {char1} <BS> {char2}
                            enter digraph when 'digraph' is on
            |c_CTRL-H|  CTRL-H      same as <BS>
            |c_<Tab>|   <Tab>       if 'wildchar' is <Tab>: Do completion on
                            the pattern in front of the cursor
            |c_<S-Tab>| <S-Tab>     same as CTRL-P
            |c_wildchar|    'wildchar'  Do completion on the pattern in front of the
                            cursor (default: <Tab>)
            |c_CTRL-I|  CTRL-I      same as <Tab>
            |c_<NL>|    <NL>        same as <CR>
            |c_CTRL-J|  CTRL-J      same as <CR>
            |c_CTRL-K|  CTRL-K {char1} {char2}
                            enter digraph
            |c_CTRL-L|  CTRL-L      do completion on the pattern in front of the
                            cursor and insert the longest common part
            |c_<CR>|    <CR>        execute entered command
            |c_CTRL-M|  CTRL-M      same as <CR>
            |c_CTRL-N|  CTRL-N      after using 'wildchar' with multiple matches:
                            go to next match, otherwise: recall older
                            command-line from history.
                    CTRL-O      not used
            |c_CTRL-P|  CTRL-P      after using 'wildchar' with multiple matches:
                            go to previous match, otherwise: recall older
                            command-line from history.
            |c_CTRL-Q|  CTRL-Q      same as CTRL-V, unless it's used for terminal
                            control flow
            |c_CTRL-R|  CTRL-R {regname}
                            insert the contents of a register or object
                            under the cursor as if typed
            |c_CTRL-R_CTRL-R| CTRL-R CTRL-R {regname}
            |c_CTRL-R_CTRL-O| CTRL-R CTRL-O {regname}
                            insert the contents of a register or object
                            under the cursor literally
                    CTRL-S      not used, or used for terminal control flow
            |c_CTRL-T|  CTRL-T      previous match when 'incsearch' is active
            |c_CTRL-U|  CTRL-U      remove all characters
            |c_CTRL-V|  CTRL-V      insert next non-digit literally, insert three
                            digit decimal number as a single byte.
            |c_CTRL-W|  CTRL-W      delete the word in front of the cursor
                    CTRL-X      not used (reserved for completion)
                    CTRL-Y      copy (yank) modeless selection
                    CTRL-Z      not used (reserved for suspend)
            |c_<Esc>|   <Esc>       abandon command-line without executing it
            |c_CTRL-[|  CTRL-[      same as <Esc>
            |c_CTRL-\_CTRL-N| CTRL-\ CTRL-N go to Normal mode, abandon command-line
            |c_CTRL-\_CTRL-G| CTRL-\ CTRL-G go to mode specified with 'insertmode',
                            abandon command-line
                    CTRL-\ a - d    reserved for extensions
            |c_CTRL-\_e|    CTRL-\ e {expr} replace the command line with the result of
                            {expr}
                    CTRL-\ f - z    reserved for extensions
                    CTRL-\ others   not used
            |c_CTRL-]|  CTRL-]      trigger abbreviation
            |c_CTRL-^|  CTRL-^      toggle use of |:lmap| mappings
            |c_CTRL-_|  CTRL-_      when 'allowrevins' set: change language
                            (Hebrew, Farsi)
            |c_<Del>|   <Del>       delete the character under the cursor

            |c_<Left>|  <Left>      cursor left
            |c_<S-Left>|    <S-Left>    cursor one word left
            |c_<C-Left>|    <C-Left>    cursor one word left
            |c_<Right>| <Right>     cursor right
            |c_<S-Right>|   <S-Right>   cursor one word right
            |c_<C-Right>|   <C-Right>   cursor one word right
            |c_<Up>|    <Up>        recall previous command-line from history that
                            matches pattern in front of the cursor
            |c_<S-Up>|  <S-Up>      recall previous command-line from history
            |c_<Down>|  <Down>      recall next command-line from history that
                            matches pattern in front of the cursor
            |c_<S-Down>|    <S-Down>    recall next command-line from history
            |c_<Home>|  <Home>      cursor to start of command-line
            |c_<End>|   <End>       cursor to end of command-line
            |c_<PageDown>|  <PageDown>  same as <S-Down>
            |c_<PageUp>|    <PageUp>    same as <S-Up>
            |c_<Insert>|    <Insert>    toggle insert/overstrike mode
            |c_<LeftMouse>| <LeftMouse> cursor at mouse click

            ==============================================================================
            5. Terminal-Job mode                *terminal-job-index*

            Most Normal mode commands except for window commands (|CTRL-W|) do not work in
            a terminal window. Switch to Terminal-Normal mode to use them.
            This assumes 'termwinkey' is not set.

            tag     char        action in Terminal-Job mode ~
            -----------------------------------------------------------------------
            |t_CTRL-\_CTRL-N| CTRL-\ CTRL-N switch to Terminal-Normal mode
            |t_CTRL-W_N|    CTRL-W N    switch to Terminal-Normal mode
            |t_CTRL-W_:|    CTRL-W :    enter an Ex command
            |t_CTRL-W_.|    CTRL-W .    type CTRL-W in the terminal
                    CTRL-W CTRL-\   send a CTRL-\ to the job in the terminal
            |t_CTRL-W_quote|  CTRL-W " {register}
                            paste register in the terminal
            |t_CTRL-W_CTRL-C| CTRL-W CTRL-C forcefully ends the job
            |t_CTRL-W_CTRL-W| CTRL-W CTRL-W move focus to the next window
            |t_CTRL-W_gt|   CTRL-W gt   go to next tabpage, same as `gt`
            |t_CTRL-W_gT|   CTRL-W gT   go to previous tabpage, same as `gT`

            You found it, Arthur!               *holy-grail* *:smile*

            ==============================================================================
            6. EX commands                  *ex-cmd-index* *:index*

            This is a brief but complete listing of all the ":" commands, without
            mentioning any arguments.  The optional part of the command name is inside [].
            The commands are sorted on the non-optional part of their name.

            tag     command     action ~
            ------------------------------------------------------------------------------
            |:|     :       nothing
            |:range|    :{range}    go to last line in {range}
            |:!|        :!      filter lines or execute an external command
            |:!!|       :!!     repeat last ":!" command
            |:#|        :#      same as ":number"
            |:&|        :&      repeat last ":substitute"
            |:star|     :*      execute contents of a register
            |:<|        :<      shift lines one 'shiftwidth' left
            |:=|        :=      print the cursor line number
            |:>|        :>      shift lines one 'shiftwidth' right
            |:@|        :@      execute contents of a register
            |:@@|       :@@     repeat the previous ":@"
            |:Next|     :N[ext]     go to previous file in the argument list
            |:Print|    :P[rint]    print lines
            |:X|        :X      ask for encryption key
            |:append|   :a[ppend]   append text
            |:abbreviate|   :ab[breviate]   enter abbreviation
            |:abclear|  :abc[lear]  remove all abbreviations
            |:aboveleft|    :abo[veleft]    make split window appear left or above
            |:all|      :al[l]      open a window for each file in the argument
                            list
            |:amenu|    :am[enu]    enter new menu item for all modes
            |:anoremenu|    :an[oremenu]    enter a new menu for all modes that will not
                            be remapped
            |:args|     :ar[gs]     print the argument list
            |:argadd|   :arga[dd]   add items to the argument list
            :argdedupe  :argdedupe  remove duplicates from the argument list
            |:argdelete|    :argd[elete]    delete items from the argument list
            |:argedit|  :arge[dit]  add item to the argument list and edit it
            |:argdo|    :argdo      do a command on all items in the argument list
            |:argglobal|    :argg[lobal]    define the global argument list
            |:arglocal| :argl[ocal] define a local argument list
            |:argument| :argu[ment] go to specific file in the argument list
            |:ascii|    :as[cii]    print ascii value of character under the cursor
            |:autocmd|  :au[tocmd]  enter or show autocommands
            |:augroup|  :aug[roup]  select the autocommand group to use
            |:aunmenu|  :aun[menu]  remove menu for all modes
            |:buffer|   :b[uffer]   go to specific buffer in the buffer list
            |:bNext|    :bN[ext]    go to previous buffer in the buffer list
            |:ball|     :ba[ll]     open a window for each buffer in the buffer list
            |:badd|     :bad[d]     add buffer to the buffer list
            |:balt|     :balt       like ":badd" but also set the alternate file
            |:bdelete|  :bd[elete]  remove a buffer from the buffer list
            |:behave|   :be[have]   set mouse and selection behavior
            |:belowright|   :bel[owright]   make split window appear right or below
            |:bfirst|   :bf[irst]   go to first buffer in the buffer list
            |:blast|    :bl[ast]    go to last buffer in the buffer list
            |:bmodified|    :bm[odified]    go to next buffer in the buffer list that has
                            been modified
            |:bnext|    :bn[ext]    go to next buffer in the buffer list
            |:botright| :bo[tright] make split window appear at bottom or far right
            |:bprevious|    :bp[revious]    go to previous buffer in the buffer list
            |:brewind|  :br[ewind]  go to first buffer in the buffer list
            |:break|    :brea[k]    break out of while loop
            |:breakadd| :breaka[dd] add a debugger breakpoint
            |:breakdel| :breakd[el] delete a debugger breakpoint
            |:breaklist|    :breakl[ist]    list debugger breakpoints
            |:browse|   :bro[wse]   use file selection dialog
            |:bufdo|    :bufdo      execute command in each listed buffer
            |:buffers|  :buffers    list all files in the buffer list
            |:bunload|  :bun[load]  unload a specific buffer
            |:bwipeout| :bw[ipeout] really delete a buffer
            |:change|   :c[hange]   replace a line or series of lines
            |:cNext|    :cN[ext]    go to previous error
            |:cNfile|   :cNf[ile]   go to last error in previous file
            |:cabbrev|  :ca[bbrev]  like ":abbreviate" but for Command-line mode
            |:cabclear| :cabc[lear] clear all abbreviations for Command-line mode
            |:cabove|   :cabo[ve]   go to error above current line
            |:caddbuffer|   :cad[dbuffer]   add errors from buffer
            |:caddexpr| :cadde[xpr] add errors from expr
            |:caddfile| :caddf[ile] add error message to current quickfix list
            |:cafter|   :caf[ter]   go to error after current cursor
            |:call|     :cal[l]     call a function
            |:catch|    :cat[ch]    part of a :try command
            |:cbefore|  :cbef[ore]  go to error before current cursor
            |:cbelow|   :cbel[ow]   go to error below current line
            |:cbottom|  :cbo[ttom]  scroll to the bottom of the quickfix window
            |:cbuffer|  :cb[uffer]  parse error messages and jump to first error
            |:cc|       :cc     go to specific error
            |:cclose|   :ccl[ose]   close quickfix window
            |:cd|       :cd     change directory
            |:cdo|      :cdo        execute command in each valid error list entry
            |:cfdo|     :cfd[o]     execute command in each file in error list
            |:center|   :ce[nter]   format lines at the center
            |:cexpr|    :cex[pr]    read errors from expr and jump to first
            |:cfile|    :cf[ile]    read file with error messages and jump to first
            |:cfirst|   :cfir[st]   go to the specified error, default first one
            |:cgetbuffer|   :cgetb[uffer]   get errors from buffer
            |:cgetexpr| :cgete[xpr] get errors from expr
            |:cgetfile| :cg[etfile] read file with error messages
            |:changes|  :changes    print the change list
            |:chdir|    :chd[ir]    change directory
            |:checkpath|    :che[ckpath]    list included files
            |:checktime|    :checkt[ime]    check timestamp of loaded buffers
            |:chistory| :chi[story] list the error lists
            |:clast|    :cla[st]    go to the specified error, default last one
            |:clearjumps|   :cle[arjumps]   clear the jump list
            |:clist|    :cl[ist]    list all errors
            |:close|    :clo[se]    close current window
            |:cmap|     :cm[ap]     like ":map" but for Command-line mode
            |:cmapclear|    :cmapc[lear]    clear all mappings for Command-line mode
            |:cmenu|    :cme[nu]    add menu for Command-line mode
            |:cnext|    :cn[ext]    go to next error
            |:cnewer|   :cnew[er]   go to newer error list
            |:cnfile|   :cnf[ile]   go to first error in next file
            |:cnoremap| :cno[remap] like ":noremap" but for Command-line mode
            |:cnoreabbrev|  :cnorea[bbrev]  like ":noreabbrev" but for Command-line mode
            |:cnoremenu|    :cnoreme[nu]    like ":noremenu" but for Command-line mode
            |:copy|     :co[py]     copy lines
            |:colder|   :col[der]   go to older error list
            |:colorscheme|  :colo[rscheme]  load a specific color scheme
            |:command|  :com[mand]  create user-defined command
            |:comclear| :comc[lear] clear all user-defined commands
            |:compiler| :comp[iler] do settings for a specific compiler
            |:continue| :con[tinue] go back to :while
            |:confirm|  :conf[irm]  prompt user when confirmation required
            |:const|    :cons[t]    create a variable as a constant
            |:copen|    :cope[n]    open quickfix window
            |:cprevious|    :cp[revious]    go to previous error
            |:cpfile|   :cpf[ile]   go to last error in previous file
            |:cquit|    :cq[uit]    quit Vim with an error code
            |:crewind|  :cr[ewind]  go to the specified error, default first one
            |:cscope|   :cs[cope]   execute cscope command
            |:cstag|    :cst[ag]    use cscope to jump to a tag
            |:cunmap|   :cu[nmap]   like ":unmap" but for Command-line mode
            |:cunabbrev|    :cuna[bbrev]    like ":unabbrev" but for Command-line mode
            |:cunmenu|  :cunme[nu]  remove menu for Command-line mode
            |:cwindow|  :cw[indow]  open or close quickfix window
            |:delete|   :d[elete]   delete lines
            |:debug|    :deb[ug]    run a command in debugging mode
            |:debuggreedy|  :debugg[reedy]  read debug mode commands from normal input
            |:def|      :def        define a Vim9 user function
            |:defcompile|   :defc[ompile]   compile Vim9 user functions in current script
            |:delcommand|   :delc[ommand]   delete user-defined command
            |:delfunction|  :delf[unction]  delete a user function
            |:delmarks| :delm[arks] delete marks
            |:diffupdate|   :dif[fupdate]   update 'diff' buffers
            |:diffget|  :diffg[et]  remove differences in current buffer
            |:diffoff|  :diffo[ff]  switch off diff mode
            |:diffpatch|    :diffp[atch]    apply a patch and show differences
            |:diffput|  :diffpu[t]  remove differences in other buffer
            |:diffsplit|    :diffs[plit]    show differences with another file
            |:diffthis| :diffthis   make current window a diff window
            |:digraphs| :dig[raphs] show or enter digraphs
            |:display|  :di[splay]  display registers
            |:disassemble|  :disa[ssemble]  disassemble Vim9 user function
            |:djump|    :dj[ump]    jump to #define
            |:dl|       :dl     short for |:delete| with the 'l' flag
            |:dlist|    :dli[st]    list #defines
            |:doautocmd|    :do[autocmd]    apply autocommands to current buffer
            |:doautoall|    :doautoa[ll]    apply autocommands for all loaded buffers
            |:dp|       :d[elete]p  short for |:delete| with the 'p' flag
            |:drop|     :dr[op]     jump to window editing file or edit file in
                            current window
            |:dsearch|  :ds[earch]  list one #define
            |:dsplit|   :dsp[lit]   split window and jump to #define
            |:edit|     :e[dit]     edit a file
            |:earlier|  :ea[rlier]  go to older change, undo
            |:echo|     :ec[ho]     echoes the result of expressions
            |:echoconsole|  :echoc[onsole]  like :echomsg but write to stdout
            |:echoerr|  :echoe[rr]  like :echo, show like an error and use history
            |:echohl|   :echoh[l]   set highlighting for echo commands
            |:echomsg|  :echom[sg]  same as :echo, put message in history
            |:echon|    :echon      same as :echo, but without <EOL>
            |:else|     :el[se]     part of an :if command
            |:elseif|   :elsei[f]   part of an :if command
            |:emenu|    :em[enu]    execute a menu by name
            |:enddef|   :enddef     end of a user function started with :def
            |:endif|    :en[dif]    end previous :if
            |:endfor|   :endfo[r]   end previous :for
            |:endfunction|  :endf[unction]  end of a user function started with :function
            |:endtry|   :endt[ry]   end previous :try
            |:endwhile| :endw[hile] end previous :while
            |:enew|     :ene[w]     edit a new, unnamed buffer
            |:eval|     :ev[al]     evaluate an expression and discard the result
            |:ex|       :ex     same as ":edit"
            |:execute|  :exe[cute]  execute result of expressions
            |:exit|     :exi[t]     same as ":xit"
            |:export|   :exp[ort]   Vim9: export an item from a script
            |:exusage|  :exu[sage]  overview of Ex commands
            |:file|     :f[ile]     show or set the current file name
            |:files|    :files      list all files in the buffer list
            |:filetype| :filet[ype] switch file type detection on/off
            |:filter|   :filt[er]   filter output of following command
            |:find|     :fin[d]     find file in 'path' and edit it
            |:final|    :final      declare an immutable variable in Vim9
            |:finally|  :fina[lly]  part of a :try command
            |:finish|   :fini[sh]   quit sourcing a Vim script
            |:first|    :fir[st]    go to the first file in the argument list
            |:fixdel|   :fix[del]   set key code of <Del>
            |:fold|     :fo[ld]     create a fold
            |:foldclose|    :foldc[lose]    close folds
            |:folddoopen|   :foldd[oopen]   execute command on lines not in a closed fold
            |:folddoclosed| :folddoc[losed] execute command on lines in a closed fold
            |:foldopen| :foldo[pen] open folds
            |:for|      :for        for loop
            |:function| :fu[nction] define a user function
            |:global|   :g[lobal]   execute commands for matching lines
            |:goto|     :go[to]     go to byte in the buffer
            |:grep|     :gr[ep]     run 'grepprg' and jump to first match
            |:grepadd|  :grepa[dd]  like :grep, but append to current list
            |:gui|      :gu[i]      start the GUI
            |:gvim|     :gv[im]     start the GUI
            |:hardcopy| :ha[rdcopy] send text to the printer
            |:help|     :h[elp]     open a help window
            |:helpclose|    :helpc[lose]    close one help window
            |:helpfind| :helpf[ind] dialog to open a help window
            |:helpgrep| :helpg[rep] like ":grep" but searches help files
            |:helptags| :helpt[ags] generate help tags for a directory
            |:highlight|    :hi[ghlight]    specify highlighting methods
            |:hide|     :hid[e]     hide current buffer for a command
            |:history|  :his[tory]  print a history list
            |:insert|   :i[nsert]   insert text
            |:iabbrev|  :ia[bbrev]  like ":abbrev" but for Insert mode
            |:iabclear| :iabc[lear] like ":abclear" but for Insert mode
            |:if|       :if     execute commands when condition met
            |:ijump|    :ij[ump]    jump to definition of identifier
            |:ilist|    :il[ist]    list lines where identifier matches
            |:imap|     :im[ap]     like ":map" but for Insert mode
            |:imapclear|    :imapc[lear]    like ":mapclear" but for Insert mode
            |:imenu|    :ime[nu]    add menu for Insert mode
            |:import|   :imp[ort]   Vim9: import an item from another script
            |:inoremap| :ino[remap] like ":noremap" but for Insert mode
            |:inoreabbrev|  :inorea[bbrev]  like ":noreabbrev" but for Insert mode
            |:inoremenu|    :inoreme[nu]    like ":noremenu" but for Insert mode
            |:intro|    :int[ro]    print the introductory message
            |:isearch|  :is[earch]  list one line where identifier matches
            |:isplit|   :isp[lit]   split window and jump to definition of
                            identifier
            |:iunmap|   :iu[nmap]   like ":unmap" but for Insert mode
            |:iunabbrev|    :iuna[bbrev]    like ":unabbrev" but for Insert mode
            |:iunmenu|  :iunme[nu]  remove menu for Insert mode
            |:join|     :j[oin]     join lines
            |:jumps|    :ju[mps]    print the jump list
            |:k|        :k      set a mark
            |:keepalt|  :keepa[lt]  following command keeps the alternate file
            |:keepmarks|    :kee[pmarks]    following command keeps marks where they are
            |:keepjumps|    :keepj[umps]    following command keeps jumplist and marks
            |:keeppatterns| :keepp[atterns] following command keeps search pattern history
            |:lNext|    :lN[ext]    go to previous entry in location list
            |:lNfile|   :lNf[ile]   go to last entry in previous file
            |:list|     :l[ist]     print lines
            |:labove|   :lab[ove]   go to location above current line
            |:laddexpr| :lad[dexpr] add locations from expr
            |:laddbuffer|   :laddb[uffer]   add locations from buffer
            |:laddfile| :laddf[ile] add locations to current location list
            |:lafter|   :laf[ter]   go to location after current cursor
            |:last|     :la[st]     go to the last file in the argument list
            |:language| :lan[guage] set the language (locale)
            |:later|    :lat[er]    go to newer change, redo
            |:lbefore|  :lbef[ore]  go to location before current cursor
            |:lbelow|   :lbel[ow]   go to location below current line
            |:lbottom|  :lbo[ttom]  scroll to the bottom of the location window
            |:lbuffer|  :lb[uffer]  parse locations and jump to first location
            |:lcd|      :lc[d]      change directory locally
            |:lchdir|   :lch[dir]   change directory locally
            |:lclose|   :lcl[ose]   close location window
            |:lcscope|  :lcs[cope]  like ":cscope" but uses location list
            |:ldo|      :ld[o]      execute command in valid location list entries
            |:lfdo|     :lfd[o]     execute command in each file in location list
            |:left|     :le[ft]     left align lines
            |:leftabove|    :lefta[bove]    make split window appear left or above
            |:legacy|   :leg[acy]   make following command use legacy script syntax
            |:let|      :let        assign a value to a variable or option
            |:lexpr|    :lex[pr]    read locations from expr and jump to first
            |:lfile|    :lf[ile]    read file with locations and jump to first
            |:lfirst|   :lfir[st]   go to the specified location, default first one
            |:lgetbuffer|   :lgetb[uffer]   get locations from buffer
            |:lgetexpr| :lgete[xpr] get locations from expr
            |:lgetfile| :lg[etfile] read file with locations
            |:lgrep|    :lgr[ep]    run 'grepprg' and jump to first match
            |:lgrepadd| :lgrepa[dd] like :grep, but append to current list
            |:lhelpgrep|    :lh[elpgrep]    like ":helpgrep" but uses location list
            |:lhistory| :lhi[story] list the location lists
            |:ll|       :ll     go to specific location
            |:llast|    :lla[st]    go to the specified location, default last one
            |:llist|    :lli[st]    list all locations
            |:lmake|    :lmak[e]    execute external command 'makeprg' and parse
                            error messages
            |:lmap|     :lm[ap]     like ":map!" but includes Lang-Arg mode
            |:lmapclear|    :lmapc[lear]    like ":mapclear!" but includes Lang-Arg mode
            |:lnext|    :lne[xt]    go to next location
            |:lnewer|   :lnew[er]   go to newer location list
            |:lnfile|   :lnf[ile]   go to first location in next file
            |:lnoremap| :ln[oremap] like ":noremap!" but includes Lang-Arg mode
            |:loadkeymap|   :loadk[eymap]   load the following keymaps until EOF
            |:loadview| :lo[adview] load view for current window from a file
            |:lockmarks|    :loc[kmarks]    following command keeps marks where they are
            |:lockvar|  :lockv[ar]  lock variables
            |:lolder|   :lol[der]   go to older location list
            |:lopen|    :lope[n]    open location window
            |:lprevious|    :lp[revious]    go to previous location
            |:lpfile|   :lpf[ile]   go to last location in previous file
            |:lrewind|  :lr[ewind]  go to the specified location, default first one
            |:ls|       :ls     list all buffers
            |:ltag|     :lt[ag]     jump to tag and add matching tags to the
                            location list
            |:lunmap|   :lu[nmap]   like ":unmap!" but includes Lang-Arg mode
            |:lua|      :lua        execute |Lua| command
            |:luado|    :luad[o]    execute Lua command for each line
            |:luafile|  :luaf[ile]  execute |Lua| script file
            |:lvimgrep| :lv[imgrep] search for pattern in files
            |:lvimgrepadd|  :lvimgrepa[dd]  like :vimgrep, but append to current list
            |:lwindow|  :lw[indow]  open or close location window
            |:move|     :m[ove]     move lines
            |:mark|     :ma[rk]     set a mark
            |:make|     :mak[e]     execute external command 'makeprg' and parse
                            error messages
            |:map|      :map        show or enter a mapping
            |:mapclear| :mapc[lear] clear all mappings for Normal and Visual mode
            |:marks|    :marks      list all marks
            |:match|    :mat[ch]    define a match to highlight
            |:menu|     :me[nu]     enter a new menu item
            |:menutranslate|  :menut[ranslate] add a menu translation item
            |:messages| :mes[sages] view previously displayed messages
            |:mkexrc|   :mk[exrc]   write current mappings and settings to a file
            |:mksession|    :mks[ession]    write session info to a file
            |:mkspell|  :mksp[ell]  produce .spl spell file
            |:mkvimrc|  :mkv[imrc]  write current mappings and settings to a file
            |:mkview|   :mkvie[w]   write view of current window to a file
            |:mode|     :mod[e]     show or change the screen mode
            |:mzscheme| :mz[scheme] execute MzScheme command
            |:mzfile|   :mzf[ile]   execute MzScheme script file
            |:nbclose|  :nbc[lose]  close the current Netbeans session
            |:nbkey|    :nb[key]    pass a key to Netbeans
            |:nbstart|  :nbs[art]   start a new Netbeans session
            |:next|     :n[ext]     go to next file in the argument list
            |:new|      :new        create a new empty window
            |:nmap|     :nm[ap]     like ":map" but for Normal mode
            |:nmapclear|    :nmapc[lear]    clear all mappings for Normal mode
            |:nmenu|    :nme[nu]    add menu for Normal mode
            |:nnoremap| :nn[oremap] like ":noremap" but for Normal mode
            |:nnoremenu|    :nnoreme[nu]    like ":noremenu" but for Normal mode
            |:noautocmd|    :noa[utocmd]    following commands don't trigger autocommands
            |:noremap|  :no[remap]  enter a mapping that will not be remapped
            |:nohlsearch|   :noh[lsearch]   suspend 'hlsearch' highlighting
            |:noreabbrev|   :norea[bbrev]   enter an abbreviation that will not be
                            remapped
            |:noremenu| :noreme[nu] enter a menu that will not be remapped
            |:normal|   :norm[al]   execute Normal mode commands
            |:noswapfile|   :nos[wapfile]   following commands don't create a swap file
            |:number|   :nu[mber]   print lines with line number
            |:nunmap|   :nun[map]   like ":unmap" but for Normal mode
            |:nunmenu|  :nunme[nu]  remove menu for Normal mode
            |:oldfiles| :ol[dfiles] list files that have marks in the viminfo file
            |:open|     :o[pen]     start open mode (not implemented)
            |:omap|     :om[ap]     like ":map" but for Operator-pending mode
            |:omapclear|    :omapc[lear]    remove all mappings for Operator-pending mode
            |:omenu|    :ome[nu]    add menu for Operator-pending mode
            |:only|     :on[ly]     close all windows except the current one
            |:onoremap| :ono[remap] like ":noremap" but for Operator-pending mode
            |:onoremenu|    :onoreme[nu]    like ":noremenu" but for Operator-pending mode
            |:options|  :opt[ions]  open the options-window
            |:ounmap|   :ou[nmap]   like ":unmap" but for Operator-pending mode
            |:ounmenu|  :ounme[nu]  remove menu for Operator-pending mode
            |:ownsyntax|    :ow[nsyntax]    set new local syntax highlight for this window
            |:packadd|  :pa[ckadd]  add a plugin from 'packpath'
            |:packloadall|  :packl[oadall]  load all packages under 'packpath'
            |:pclose|   :pc[lose]   close preview window
            |:pedit|    :ped[it]    edit file in the preview window
            |:perl|     :pe[rl]     execute Perl command
            |:print|    :p[rint]    print lines
            |:profdel|  :profd[el]  stop profiling a function or script
            |:profile|  :prof[ile]  profiling functions and scripts
            |:promptfind|   :pro[mptfind]   open GUI dialog for searching
            |:promptrepl|   :promptr[epl]   open GUI dialog for search/replace
            |:perldo|   :perld[o]   execute Perl command for each line
            |:pop|      :po[p]      jump to older entry in tag stack
            |:popup|    :popu[p]    popup a menu by name
            |:ppop|     :pp[op]     ":pop" in preview window
            |:preserve| :pre[serve] write all text to swap file
            |:previous| :prev[ious] go to previous file in argument list
            |:psearch|  :ps[earch]  like ":ijump" but shows match in preview window
            |:ptag|     :pt[ag]     show tag in preview window
            |:ptNext|   :ptN[ext]   |:tNext| in preview window
            |:ptfirst|  :ptf[irst]  |:trewind| in preview window
            |:ptjump|   :ptj[ump]   |:tjump| and show tag in preview window
            |:ptlast|   :ptl[ast]   |:tlast| in preview window
            |:ptnext|   :ptn[ext]   |:tnext| in preview window
            |:ptprevious|   :ptp[revious]   |:tprevious| in preview window
            |:ptrewind| :ptr[ewind] |:trewind| in preview window
            |:ptselect| :pts[elect] |:tselect| and show tag in preview window
            |:put|      :pu[t]      insert contents of register in the text
            |:pwd|      :pw[d]      print current directory
            |:py3|      :py3        execute Python 3 command
            |:python3|  :python3    same as :py3
            |:py3do|    :py3d[o]    execute Python 3 command for each line
            |:py3file|  :py3f[ile]  execute Python 3 script file
            |:python|   :py[thon]   execute Python command
            |:pydo|     :pyd[o]     execute Python command for each line
            |:pyfile|   :pyf[ile]   execute Python script file
            |:pyx|      :pyx        execute |python_x| command
            |:pythonx|  :pythonx    same as :pyx
            |:pyxdo|    :pyxd[o]    execute |python_x| command for each line
            |:pyxfile|  :pyxf[ile]  execute |python_x| script file
            |:quit|     :q[uit]     quit current window (when one window quit Vim)
            |:quitall|  :quita[ll]  quit Vim
            |:qall|     :qa[ll]     quit Vim
            |:read|     :r[ead]     read file into the text
            |:recover|  :rec[over]  recover a file from a swap file
            |:redo|     :red[o]     redo one undone change
            |:redir|    :redi[r]    redirect messages to a file or register
            |:redraw|   :redr[aw]     force a redraw of the display
            |:redrawstatus| :redraws[tatus]   force a redraw of the status line(s)
            |:redrawtabline|  :redrawt[abline]  force a redraw of the tabline
            |:registers|    :reg[isters]    display the contents of registers
            |:resize|   :res[ize]   change current window height
            |:retab|    :ret[ab]    change tab size
            |:return|   :retu[rn]   return from a user function
            |:rewind|   :rew[ind]   go to the first file in the argument list
            |:right|    :ri[ght]    right align text
            |:rightbelow|   :rightb[elow]   make split window appear right or below
            |:ruby|     :rub[y]     execute Ruby command
            |:rubydo|   :rubyd[o]   execute Ruby command for each line
            |:rubyfile| :rubyf[ile] execute Ruby script file
            |:rundo|    :rund[o]    read undo information from a file
            |:runtime|  :ru[ntime]  source vim scripts in 'runtimepath'
            |:rviminfo| :rv[iminfo] read from viminfo file
            |:substitute|   :s[ubstitute]   find and replace text
            |:sNext|    :sN[ext]    split window and go to previous file in
                            argument list
            |:sandbox|  :san[dbox]  execute a command in the sandbox
            |:sargument|    :sa[rgument]    split window and go to specific file in
                            argument list
            |:sall|     :sal[l]     open a window for each file in argument list
            |:saveas|   :sav[eas]   save file under another name.
            |:sbuffer|  :sb[uffer]  split window and go to specific file in the
                            buffer list
            |:sbNext|   :sbN[ext]   split window and go to previous file in the
                            buffer list
            |:sball|    :sba[ll]    open a window for each file in the buffer list
            |:sbfirst|  :sbf[irst]  split window and go to first file in the
                            buffer list
            |:sblast|   :sbl[ast]   split window and go to last file in buffer
                            list
            |:sbmodified|   :sbm[odified]   split window and go to modified file in the
                            buffer list
            |:sbnext|   :sbn[ext]   split window and go to next file in the buffer
                            list
            |:sbprevious|   :sbp[revious]   split window and go to previous file in the
                            buffer list
            |:sbrewind| :sbr[ewind] split window and go to first file in the
                            buffer list
            |:scriptnames|  :scr[iptnames]  list names of all sourced Vim scripts
            |:scriptencoding| :scripte[ncoding]  encoding used in sourced Vim script
            |:scriptversion|  :scriptv[ersion]   version of Vim script used
            |:scscope|  :scs[cope]  split window and execute cscope command
            |:set|      :se[t]      show or set options
            |:setfiletype|  :setf[iletype]  set 'filetype', unless it was set already
            |:setglobal|    :setg[lobal]    show global values of options
            |:setlocal| :setl[ocal] show or set options locally
            |:sfind|    :sf[ind]    split current window and edit file in 'path'
            |:sfirst|   :sfir[st]   split window and go to first file in the
                            argument list
            |:shell|    :sh[ell]    escape to a shell
            |:simalt|   :sim[alt]   Win32 GUI: simulate Windows ALT key
            |:sign|     :sig[n]     manipulate signs
            |:silent|   :sil[ent]   run a command silently
            |:sleep|    :sl[eep]    do nothing for a few seconds
            |:sleep!|   :sl[eep]!   do nothing for a few seconds, without the
                            cursor visible
            |:slast|    :sla[st]    split window and go to last file in the
                            argument list
            |:smagic|   :sm[agic]   :substitute with 'magic'
            |:smap|     :smap       like ":map" but for Select mode
            |:smapclear|    :smapc[lear]    remove all mappings for Select mode
            |:smenu|    :sme[nu]    add menu for Select mode
            |:smile|    :smi[le]    make the user happy
            |:snext|    :sn[ext]    split window and go to next file in the
                            argument list
            |:snomagic| :sno[magic] :substitute with 'nomagic'
            |:snoremap| :snor[emap] like ":noremap" but for Select mode
            |:snoremenu|    :snoreme[nu]    like ":noremenu" but for Select mode
            |:sort|     :sor[t]     sort lines
            |:source|   :so[urce]   read Vim or Ex commands from a file
            |:spelldump|    :spelld[ump]    split window and fill with all correct words
            |:spellgood|    :spe[llgood]    add good word for spelling
            |:spellinfo|    :spelli[nfo]    show info about loaded spell files
            |:spellrare|    :spellra[re]    add rare word for spelling
            |:spellrepall|  :spellr[epall]  replace all bad words like last |z=|
            |:spellundo|    :spellu[ndo]    remove good or bad word
            |:spellwrong|   :spellw[rong]   add spelling mistake
            |:split|    :sp[lit]    split current window
            |:sprevious|    :spr[evious]    split window and go to previous file in the
                            argument list
            |:srewind|  :sre[wind]  split window and go to first file in the
                            argument list
            |:stop|     :st[op]     suspend the editor or escape to a shell
            |:stag|     :sta[g]     split window and jump to a tag
            |:startinsert|  :star[tinsert]  start Insert mode
            |:startgreplace|  :startg[replace] start Virtual Replace mode
            |:startreplace| :startr[eplace] start Replace mode
            |:stopinsert|   :stopi[nsert]   stop Insert mode
            |:stjump|   :stj[ump]   do ":tjump" and split window
            |:stselect| :sts[elect] do ":tselect" and split window
            |:sunhide|  :sun[hide]  same as ":unhide"
            |:sunmap|   :sunm[ap]   like ":unmap" but for Select mode
            |:sunmenu|  :sunme[nu]  remove menu for Select mode
            |:suspend|  :sus[pend]  same as ":stop"
            |:sview|    :sv[iew]    split window and edit file read-only
            |:swapname| :sw[apname] show the name of the current swap file
            |:syntax|   :sy[ntax]   syntax highlighting
            |:syntime|  :synti[me]  measure syntax highlighting speed
            |:syncbind| :sync[bind] sync scroll binding
            |:t|        :t      same as ":copy"
            |:tNext|    :tN[ext]    jump to previous matching tag
            |:tabNext|  :tabN[ext]  go to previous tab page
            |:tabclose| :tabc[lose] close current tab page
            |:tabdo|    :tabdo      execute command in each tab page
            |:tabedit|  :tabe[dit]  edit a file in a new tab page
            |:tabfind|  :tabf[ind]  find file in 'path', edit it in a new tab page
            |:tabfirst| :tabfir[st] go to first tab page
            |:tablast|  :tabl[ast]  go to last tab page
            |:tabmove|  :tabm[ove]  move tab page to other position
            |:tabnew|   :tabnew     edit a file in a new tab page
            |:tabnext|  :tabn[ext]  go to next tab page
            |:tabonly|  :tabo[nly]  close all tab pages except the current one
            |:tabprevious|  :tabp[revious]  go to previous tab page
            |:tabrewind|    :tabr[ewind]    go to first tab page
            |:tabs|     :tabs       list the tab pages and what they contain
            |:tab|      :tab        create new tab when opening new window
            |:tag|      :ta[g]      jump to tag
            |:tags|     :tags       show the contents of the tag stack
            |:tcd|      :tc[d]      change directory for tab page
            |:tchdir|   :tch[dir]   change directory for tab page
            |:tcl|      :tcl        execute Tcl command
            |:tcldo|    :tcld[o]    execute Tcl command for each line
            |:tclfile|  :tclf[ile]  execute Tcl script file
            |:tearoff|  :te[aroff]  tear-off a menu
            |:terminal| :ter[minal] open a terminal window
            |:tfirst|   :tf[irst]   jump to first matching tag
            |:throw|    :th[row]    throw an exception
            |:tjump|    :tj[ump]    like ":tselect", but jump directly when there
                            is only one match
            |:tlast|    :tl[ast]    jump to last matching tag
            |:tlmenu|   :tlm[enu]   add menu for Terminal-Job mode
            |:tlnoremenu|   :tln[oremenu]   like ":noremenu" but for Terminal-Job mode
            |:tlunmenu| :tlu[nmenu] remove menu for Terminal-Job mode
            |:tmapclear|    :tmapc[lear]    remove all mappings for Terminal-Job mode
            |:tmap|     :tma[p]     like ":map" but for Terminal-Job mode
            |:tmenu|    :tm[enu]    define menu tooltip
            |:tnext|    :tn[ext]    jump to next matching tag
            |:tnoremap| :tno[remap] like ":noremap" but for Terminal-Job mode
            |:topleft|  :to[pleft]  make split window appear at top or far left
            |:tprevious|    :tp[revious]    jump to previous matching tag
            |:trewind|  :tr[ewind]  jump to first matching tag
            |:try|      :try        execute commands, abort on error or exception
            |:tselect|  :ts[elect]  list matching tags and select one
            |:tunmap|   :tunma[p]   like ":unmap" but for Terminal-Job mode
            |:tunmenu|  :tu[nmenu]  remove menu tooltip
            |:undo|     :u[ndo]     undo last change(s)
            |:undojoin| :undoj[oin] join next change with previous undo block
            |:undolist| :undol[ist] list leafs of the undo tree
            |:unabbreviate| :una[bbreviate] remove abbreviation
            |:unhide|   :unh[ide]   open a window for each loaded file in the
                            buffer list
            |:unlet|    :unl[et]    delete variable
            |:unlockvar|    :unlo[ckvar]    unlock variables
            |:unmap|    :unm[ap]    remove mapping
            |:unmenu|   :unme[nu]   remove menu
            |:unsilent| :uns[ilent] run a command not silently
            |:update|   :up[date]   write buffer if modified
            |:vglobal|  :v[global]  execute commands for not matching lines
            |:var|      :var        variable declaration in Vim9
            |:version|  :ve[rsion]  print version number and other info
            |:verbose|  :verb[ose]  execute command with 'verbose' set
            |:vertical| :vert[ical] make following command split vertically
            |:vim9cmd|  :vim9[cmd]  make following command use Vim9 script syntax
            |:vim9script|   :vim9s[cript]   indicates Vim9 script file
            |:vimgrep|  :vim[grep]  search for pattern in files
            |:vimgrepadd|   :vimgrepa[dd]   like :vimgrep, but append to current list
            |:visual|   :vi[sual]   same as ":edit", but turns off "Ex" mode
            |:viusage|  :viu[sage]  overview of Normal mode commands
            |:view|     :vie[w]     edit a file read-only
            |:vmap|     :vm[ap]     like ":map" but for Visual+Select mode
            |:vmapclear|    :vmapc[lear]    remove all mappings for Visual+Select mode
            |:vmenu|    :vme[nu]    add menu for Visual+Select mode
            |:vnew|     :vne[w]     create a new empty window, vertically split
            |:vnoremap| :vn[oremap] like ":noremap" but for Visual+Select mode
            |:vnoremenu|    :vnoreme[nu]    like ":noremenu" but for Visual+Select mode
            |:vsplit|   :vs[plit]   split current window vertically
            |:vunmap|   :vu[nmap]   like ":unmap" but for Visual+Select mode
            |:vunmenu|  :vunme[nu]  remove menu for Visual+Select mode
            |:windo|    :windo      execute command in each window
            |:write|    :w[rite]    write to a file
            |:wNext|    :wN[ext]    write to a file and go to previous file in
                            argument list
            |:wall|     :wa[ll]     write all (changed) buffers
            |:while|    :wh[ile]    execute loop for as long as condition met
            |:winsize|  :wi[nsize]  get or set window size (obsolete)
            |:wincmd|   :winc[md]   execute a Window (CTRL-W) command
            |:winpos|   :winp[os]   get or set window position
            |:wnext|    :wn[ext]    write to a file and go to next file in
                            argument list
            |:wprevious|    :wp[revious]    write to a file and go to previous file in
                            argument list
            |:wq|       :wq     write to a file and quit window or Vim
            |:wqall|    :wqa[ll]    write all changed buffers and quit Vim
            |:wundo|    :wu[ndo]    write undo information to a file
            |:wviminfo| :wv[iminfo] write to viminfo file
            |:xit|      :x[it]      write if buffer changed and close window
            |:xall|     :xa[ll]     same as ":wqall"
            |:xmapclear|    :xmapc[lear]    remove all mappings for Visual mode
            |:xmap|     :xm[ap]     like ":map" but for Visual mode
            |:xmenu|    :xme[nu]    add menu for Visual mode
            |:xrestore| :xr[estore] restores the X server connection
            |:xnoremap| :xn[oremap] like ":noremap" but for Visual mode
            |:xnoremenu|    :xnoreme[nu]    like ":noremenu" but for Visual mode
            |:xunmap|   :xu[nmap]   like ":unmap" but for Visual mode
            |:xunmenu|  :xunme[nu]  remove menu for Visual mode
            |:yank|     :y[ank]     yank lines into a register
            |:z|        :z      print some lines
            |:~|        :~      repeat last ":substitute"


             vim:tw=78:ts=8:noet:ft=help:norl:
Vim help.txt   [=help basics + Uman toc, REFMAN TOC]
            *help.txt*  For Vim version 8.2.  Last change: 2021 Dec 27

                        VIM - main help file
                                                 k
                  Move around:  Use the cursor keys, or "h" to go left,        h   l
                        "j" to go down, "k" to go up, "l" to go right.   j
            Close this window:  Use ":q<Enter>".
               Get out of Vim:  Use ":qa!<Enter>" (careful, all changes are lost!).

            Jump to a subject:  Position the cursor on a tag (e.g. |bars|) and hit CTRL-].
               With the mouse:  ":set mouse=a" to enable the mouse (in xterm or GUI).
                        Double-click the left mouse button on a tag, e.g. |bars|.
                Jump back:  Type CTRL-O.  Repeat to go further back.

            Get specific help:  It is possible to go directly to whatever you want help
                        on, by giving an argument to the |:help| command.
                        Prepend something to specify the context:  *help-context*

                          WHAT          PREPEND    EXAMPLE  ~
                          Normal mode command          :help x
                          Visual mode command     v_       :help v_u
                          Insert mode command     i_       :help i_<Esc>
                          Command-line command    :    :help :quit
                          Command-line editing    c_       :help c_<Del>
                          Vim command argument    -    :help -r
                          Option              '    :help 'textwidth'
                          Regular expression      /    :help /[
                        See |help-summary| for more contexts and an explanation.

              Search for help:  Type ":help word", then hit CTRL-D to see matching
                        help entries for "word".
                        Or use ":helpgrep word". |:helpgrep|

              Getting started:  Do the Vim tutor, a 30-minute interactive course for the
                        basic commands, see |vimtutor|.
                        Read the user manual from start to end: |usr_01.txt|

            Vim stands for Vi IMproved.  Most of Vim was made by Bram Moolenaar, but only
            through the help of many others.  See |credits|.
            ------------------------------------------------------------------------------
                                    *doc-file-list* *Q_ct*
            BASIC:
            |quickref|  Overview of the most common commands you will use
            |tutor|     30-minute interactive course for beginners
            |copying|   About copyrights
            |iccf|      Helping poor children in Uganda
            |sponsor|   Sponsor Vim development, become a registered Vim user
            |www|       Vim on the World Wide Web
            |bugs|      Where to send bug reports

            USER MANUAL: These files explain how to accomplish an editing task.

            |usr_toc.txt|   Table Of Contents

            Getting Started ~
            |usr_01.txt|  About the manuals
            |usr_02.txt|  The first steps in Vim
            |usr_03.txt|  Moving around
            |usr_04.txt|  Making small changes
            |usr_05.txt|  Set your settings
            |usr_06.txt|  Using syntax highlighting
            |usr_07.txt|  Editing more than one file
            |usr_08.txt|  Splitting windows
            |usr_09.txt|  Using the GUI
            |usr_10.txt|  Making big changes
            |usr_11.txt|  Recovering from a crash
            |usr_12.txt|  Clever tricks

            Editing Effectively ~
            |usr_20.txt|  Typing command-line commands quickly
            |usr_21.txt|  Go away and come back
            |usr_22.txt|  Finding the file to edit
            |usr_23.txt|  Editing other files
            |usr_24.txt|  Inserting quickly
            |usr_25.txt|  Editing formatted text
            |usr_26.txt|  Repeating
            |usr_27.txt|  Search commands and patterns
            |usr_28.txt|  Folding
            |usr_29.txt|  Moving through programs
            |usr_30.txt|  Editing programs
            |usr_31.txt|  Exploiting the GUI
            |usr_32.txt|  The undo tree

            Tuning Vim ~
            |usr_40.txt|  Make new commands
            |usr_41.txt|  Write a Vim script
            |usr_42.txt|  Add new menus
            |usr_43.txt|  Using filetypes
            |usr_44.txt|  Your own syntax highlighted
            |usr_45.txt|  Select your language
            |usr_46.txt|  Write plugins using Vim9 script

            Making Vim Run ~
            |usr_90.txt|  Installing Vim


            REFERENCE MANUAL: These files explain every detail of Vim.  *reference_toc*

            General subjects ~
            |intro.txt| general introduction to Vim; notation used in help files
            |help.txt|  overview and quick reference (this file)
            |helphelp.txt|  about using the help files
            |index.txt| alphabetical index of all commands
            |help-tags| all the tags you can jump to (index of tags)
            |howto.txt| how to do the most common editing tasks
            |tips.txt|  various tips on using Vim
            |message.txt|   (error) messages and explanations
            |quotes.txt|    remarks from users of Vim
            |todo.txt|  known problems and desired extensions
            |develop.txt|   development of Vim
            |debug.txt| debugging Vim itself
            |uganda.txt|    Vim distribution conditions and what to do with your money

            Basic editing ~
            |starting.txt|  starting Vim, Vim command arguments, initialisation
            |editing.txt|   editing and writing files
            |motion.txt|    commands for moving around
            |scroll.txt|    scrolling the text in the window
            |insert.txt|    Insert and Replace mode
            |change.txt|    deleting and replacing text
            |undo.txt|  Undo and Redo
            |repeat.txt|    repeating commands, Vim scripts and debugging
            |visual.txt|    using the Visual mode (selecting a text area)
            |various.txt|   various remaining commands
            |recover.txt|   recovering from a crash

            Advanced editing ~
            |cmdline.txt|   Command-line editing
            |options.txt|   description of all options
            |pattern.txt|   regexp patterns and search commands
            |map.txt|   key mapping and abbreviations
            |tagsrch.txt|   tags and special searches
            |windows.txt|   commands for using multiple windows and buffers
            |tabpage.txt|   commands for using multiple tab pages
            |spell.txt| spell checking
            |diff.txt|  working with two to eight versions of the same file
            |autocmd.txt|   automatically executing commands on an event
            |eval.txt|  expression evaluation, conditional commands
            |builtin.txt|   builtin functions
            |channel.txt|   Jobs, Channels, inter-process communication
            |fold.txt|  hide (fold) ranges of lines

            Special issues ~
            |testing.txt|   testing Vim and Vim scripts
            |print.txt| printing
            |remote.txt|    using Vim as a server or client
            |term.txt|  using different terminals and mice
            |terminal.txt|  Terminal window support
            |popup.txt| popup window support
            |vim9.txt|  using Vim9 script

            Programming language support ~
            |indent.txt|    automatic indenting for C and other languages
            |syntax.txt|    syntax highlighting
            |textprop.txt|  Attaching properties to text for highlighting or other
            |filetype.txt|  settings done specifically for a type of file
            |quickfix.txt|  commands for a quick edit-compile-fix cycle
            |ft_ada.txt|    Ada (the programming language) support
            |ft_ps1.txt|    Filetype plugin for Windows PowerShell
            |ft_raku.txt|   Filetype plugin for Raku
            |ft_rust.txt|   Filetype plugin for Rust
            |ft_sql.txt|    about the SQL filetype plugin

            Language support ~
            |digraph.txt|   list of available digraphs
            |mbyte.txt| multibyte text support
            |mlang.txt| non-English language support
            |rileft.txt|    right-to-left editing mode
            |arabic.txt|    Arabic language support and editing
            |farsi.txt| Farsi (Persian) editing
            |hebrew.txt|    Hebrew language support and editing
            |russian.txt|   Russian language support and editing
            |hangulin.txt|  Hangul (Korean) input mode

            GUI ~
            |gui.txt|   Graphical User Interface (GUI)
            |gui_w32.txt|   Win32 GUI
            |gui_x11.txt|   X11 GUI

            Interfaces ~
            |if_cscop.txt|  using Cscope with Vim
            |if_lua.txt|    Lua interface
            |if_mzsch.txt|  MzScheme interface
            |if_perl.txt|   Perl interface
            |if_pyth.txt|   Python interface
            |if_tcl.txt|    Tcl interface
            |if_ole.txt|    OLE automation interface for Win32
            |if_ruby.txt|   Ruby interface
            |debugger.txt|  Interface with a debugger
            |netbeans.txt|  NetBeans External Editor interface
            |sign.txt|  debugging signs

            Versions ~
            |vi_diff.txt|   Main differences between Vim and Vi
            |version4.txt|  Differences between Vim version 3.0 and 4.x
            |version5.txt|  Differences between Vim version 4.6 and 5.x
            |version6.txt|  Differences between Vim version 5.7 and 6.x
            |version7.txt|  Differences between Vim version 6.4 and 7.x
            |version8.txt|  Differences between Vim version 7.4 and 8.x
                                    *sys-file-list*
            Remarks about specific systems ~
            |os_390.txt|    OS/390 Unix
            |os_amiga.txt|  Amiga
            |os_beos.txt|   BeOS and BeBox
            |os_dos.txt|    MS-DOS and MS-Windows common items
            |os_haiku.txt|  Haiku
            |os_mac.txt|    Macintosh
            |os_mint.txt|   Atari MiNT
            |os_msdos.txt|  MS-DOS (plain DOS and DOS box under Windows)
            |os_os2.txt|    OS/2
            |os_qnx.txt|    QNX
            |os_risc.txt|   RISC-OS
            |os_unix.txt|   Unix
            |os_vms.txt|    VMS
            |os_win32.txt|  MS-Windows
                                    *standard-plugin-list*
            Standard plugins ~
            |pi_getscript.txt| Downloading latest version of Vim scripts
            |pi_gzip.txt|      Reading and writing compressed files
            |pi_logipat.txt|   Logical operators on patterns
            |pi_netrw.txt|     Reading and writing files over a network
            |pi_paren.txt|     Highlight matching parens
            |pi_spec.txt|      Filetype plugin to work with rpm spec files
            |pi_tar.txt|       Tar file explorer
            |pi_vimball.txt|   Create a self-installing Vim script
            |pi_zip.txt|       Zip archive explorer

            LOCAL ADDITIONS:                *local-additions*
            |vundle.txt|          Vundle, a plug-in manager for Vim.             *vundle*
            |bashdbintegration.txt|       BashDB Integration                   Oct 08 2017
            |bashsupport.txt|                Bash Support                      Nov 22 2020
            |templatesupport.txt|         MM Template Support                  Aug 06 2020
            |toolbox.txt|                   MM Toolbox Support                 Sep 30 2017
            |srcery.txt| Color scheme with clearly defined contrasting colors   *srcery*
            |emmet.txt|        *Emmet* for Vim
            |indentwise.txt|    For Vim version 7.3 Last change: 2015 Jan 27
            |commentary.txt|  Comment stuff out
            |votl.txt|      For Vim version 8.1     Last change: 2021-04-23
            |vimwiki-emoji.txt|   A Reference table of markdown emoji
            |vimwiki.txt|   A Personal Wiki for Vim
            |Tabular.txt|   Configurable, flexible, intuitive text aligning
            |csound-repl.txt| Plugin for live coding with Csound
            |trans.txt|   Translate text using translate-shell in vim.
            |matchit.txt|   Extended "%" matching
            |vundle.txt|          Vundle, a plug-in manager for Vim.             *vundle*

            ------------------------------------------------------------------------------
            *bars*      Bars example

            Now that you've jumped here with CTRL-] or a double mouse click, you can use
            CTRL-T, CTRL-O, g<RightMouse>, or <C-RightMouse> to go back to where you were.

            Note that tags are within | characters, but when highlighting is enabled these
            characters are hidden.  That makes it easier to read a command.

            Anyway, you can use CTRL-] on any word, also when it is not within |, and Vim
            will try to find help for it.  Especially for options in single quotes, e.g.
            'compatible'.

            ------------------------------------------------------------------------------
             vim:tw=78:isk=!-~,^*,^\|,^\":ts=8:noet:ft=help:norl:
~/Dropbox/rsc/Doks/Comp/vimdoc8/vman.r.txt
        ^^= TODO: INPUT HEADINGS AND SUBHEADINGS OF INTEREST[!!!!]

~/Empire/Doks/Comp/editor/vim/101vim-hacks.pdf
~/Empire/Doks/Comp/editor/vim/101vim-hacks.txt
            Chapter 1 - Vim Basics ----
            Opening a File  13
            Saving a File  13
            Closing a File  14
            Types of Vim Modes  14
            Moving around a File  16
            Vim Configuration File (~/.vimrc) 17
            Vim Version  19
            Vim Installation  20
            All About Vim Help  21
            Use Vimtutor for Practice  22
            Chapter 2 - Basic Navigation ----
            Hack 1. Scroll Full Page or Half Page  23
            Hack 2. Word Navigation 24
            Hack 3. Position cursor at specific location within a line  25
            Hack 4. Paragraph, Section, Sentence Navigations  26
            Chapter 3 - Advanced Navigation ----
            Hack 5. Screen Navigation 27
            Hack 6. Redraw Screen with Current Line on Top, Bottom or Middle 27
            Hack 7. Navigate to Top and Bottom of the File  28
            Hack 8. Navigate to Nth Character, Nth Percentage of a File  28
            Hack 9. Line Number Navigation  29
            Hack 10. Source Code Navigation  30
            Hack 11. Navigate From Insert Mode  31
            Chapter 4 - Expert Navigation ----
            Hack 12. Jump Using CTRL-O and CTRL-I  32
            Hack 13. Navigate Within a Very Long Line  33
            Hack 14. Vim Command Line Navigation  34
            Hack 15. Create Local Bookmarks inside file using Marks  35
            Hack 16. Create Global Bookmarks inside Vim File  37
            Hack 17. How to Display all Bookmarks  38
            Hack 18. Navigate any Source Code effectively using Ctags  41
            Hack 19. Convert Vim Editor to Beautiful Source Code Browser for Any Programming Language  44
            Chapter 5 - Basic Text Manipulation ----
            Hack 20. Insert or Append Text  49
            Hack 21. Replace Text  50
            Hack 22. Substitute Text  51
            Hack 23. Change Text  52
            Hack 24. Join Lines Using nojoinspaces Option  52
            Chapter 6 - Advanced Text Manipulation ----
            Hack 25. Copy One Character, or Word, or Line, or up to a Position 54
            Hack 26. Paste before or after the copied Line / Word / Others  55
            Hack 27. Delete Single Char, or Word, or Line  56
            Hack 28. Inserting Content from Clipboard Buffer  57
            Hack 29. Insert Content to Clipboard from File  57
            Hack 30. Write Part of File to another File  58
            Hack 31. Swap Adjacent Characters  58
            Hack 32. The power of the . (dot) Command  59
            Hack 33. Visual Mode Commands  60
            Hack 34. Editing with :g  62
            Chapter 7 - Expert Text Manipulation ----
            Hack 35. Copy Lines to Named Buffer for Later Use  65
            Hack 36. Convert Inserted Text to Normal Mode Commands  65
            Hack 37. Abbreviation and Unabbreviation  66
            Hack 38. Automatic Spelling Correction  67
            Hack 39. Record and Play Using Macros  69
            Hack 40. Sort File Content  74
            Hack 41. Recover Deleted Text  75
            Hack 42. Add Automatic Headers to Files Using 76
            Chapter 8 - Vim as a Programmers Editor ----
            Hack 43. Make Vim Highlight Your Code Smartly  81
            Hack 44. Smart Indentation  82
            Hack 45. Access Unix Man page for Functions from Vim  83
            Hack 46. Jump to Variable Declaration  84
            Hack 47. Align the Variable Assignment  84
            Hack 48. Increment and Decrement Number Using CTRL Keys  85
            Hack 49. Execute One Vim Command in Insert Mode  86
            Hack 50. View Current File Details  86
            Hack 51. Take Control of the Vim Status Bar  87
            Hack 52. Change Case  88
            Hack 53. Spell Check  90
            Hack 54. Setup Quit Confirmation  91
            Hack 55. Use :up and Avoid :w  91
            Hack 56. Edit Current Buffer Content  92
            Hack 57. Tabs and Spaces  92
            Chapter 9 - Vim Command Line Hacks ----
            Hack 58. Open File in Read Only Mode  94
            Hack 59. Recover Swap File Explicitly  94
            Hack 60. Execute any Vim Command when opening a file  97
            Hack 61. Execute Commands Stored in a File  97
            Hack 62. Skip Loading Plugins Temporarily  98
            Hack 63. Enter Restricted Mode in Vim  98
            Chapter 10 - gVim Hacks ----
            Hack 64. Display and Hide gVim Menu and Toolbar  99
            Hack 65. Adding a Custom Menu or Menu Items to gVim  100
            Hack 66. Change Font in gVim 102
            Chapter 11 - Vim Look and Feel, Tabs, and Windows ----
            Hack 67. Split Windows Horizontally and Vertically  103
            Hack 68. Change Window Title  105
            Hack 69. Change Vim Colors  106
            Hack 70. Edit Multiple Files in Tabs  107
            Chapter 12 - Additional Features in Vim Editor ----
            Hack 71. Repeat an Operation N number of times  109
            Hack 72. Undo and Redo Action  109
            Hack 73. Open the File whose Name is under the Cursor  110
            Hack 74. Edit Multiple Files Using the Traditional Method  112
            Hack 75. Saving Files Automatically  113
            Hack 76. Encrypt File in Vim  114
            Hack 77. Save and Resume Vim Sessions  114
            Hack 78. Execute Unix Shell Command Inside Vim  116
            Hack 79. Review the Differences between Files using Vimdiff  117
            Hack 80. Vim Map Command  118
            Hack 81. Make Bash Shell work like Vim Editor  121
            Hack 82. Set Vim Options  122
            Hack 83. Unset Vim Options  122
            Hack 84. Default registers and their uses  123
            Hack 85. Numeric Registers and Recovering Deletes  124
            Hack 86. Vim Directory Operation  124
            Chapter 13 - Power of Search ----
            Hack 87. Navigation by Search  127
            Hack 88. Go to Next / Previous Occurrence of the Current Word ...128
            Hack 89. Search for a Character within a Line  129
            Hack 90. 12 Powerful Find and Replace Examples  129
            Hack 91. Search across Multiple Files using vimgrep  137
            Hack 92. Highlight Search Results with Color  138
            Hack 93. Vim Incremental Search  139
            Hack 94. The Power of :match  140
            Chapter 14 - Automatic Completion ----
            Hack 95. Automatic Word Completion  142
            Hack 96. Automatic Line Completion  143
            Hack 97. Automatic Filename Completion  144
            Hack 98. Dictionary Completion  145
            Hack 99. Thesaurus Word Completion  146
            Hack 100. Automatically open a Pop-up menu for Completion  149
            Hack 101. Automatically offers Word Completion as you type  152
            Chapter 15 - Bonus Hacks ----
            Bonus Hack 1. Add Bullet Point Style to List of Items  155
            Bonus Hack 2. Set Vim as Universal Default Editor using update-alternatives  157
            Bonus Hack 3. Make Vim as Default Editor  157
            Bonus Hack 4. Format a Paragraph  158
            Bonus Hack 5. Edit Macros for Reuse  158
            Bonus Hack 6. Indent Code Block  159
            Bonus Hack 7. Power of Combination 160
            Bonus Hack 8. Identify the changes done to a file  161
            Bonus Hack 9. Refresh the Screen 161
            Bonus Hack 10. Insert Non Keyboard Characters  161
            Bonus Hack 11. Vim ex Mode  162
            Bonus Hack 12. Place the cursor at the end of the match  163
            Bonus Hack 13. View ASCII value of a character  163
            Bonus Hack 14. Edit Binary files in Vim Editor  164
            Bonus Hack 15. Folding - View Only Required Part of Code  164
~/Empire/Doks/Comp/editor/vim/cprogramming-invim.pdf  [Maybe TODO]
~/Empire/Doks/Comp/editor/vim/learning_the_vi_editor.pdf

~/Empire/Doks/Comp/editor/vim/vimbash.pdf
~/Empire/Doks/Comp/editor/vim/vimbash.txt
~/Empire/Doks/Comp/editor/vim/vim_bashsupport.pdf
~/Empire/Doks/Comp/editor/vim/vimbook-OPL.pdf
            1 Basic Editing
            2 Editing a Little Faster
            3 Searching
            4 Text Blocks and Multiple Files
            5 Windows
            6 Basic Visual Mode
            7 Commands for Programmers
            8 Basic Abbreviations, Keyboard Mapping, and Initialization Files
            9 Basic Command-Mode Commands
            10 Basic GUI Usage
            11 Dealing with Text Files
            12 Automatic Completion
            13 Autocommands
            14 File Recovery and Command-Line Arguments
            15 Miscellaneous Commands
            16 Cookbook
            17 Topics Not Covered
~/Empire/Doks/Comp/editor/vim/vim-recipes.pdf
            Basics ----
            Choosing the Right Mode  12
            Basic Navigation  14
            Opening Files  16
            Saving a File  20
            Quitting Vim 22
            Deleting Text  24
            Visually Selecting Text 26
            Copying, Cutting, and Pasting  28
            Configuring Vim 30
            Printing 34
            Getting Help 36
            Editing ----
            Indenting Lines 41
            Selecting Text with Motions 44
            Repeating Commands  48
            Changing the Case of Text 50
            Sorting Text  52
            Executing External Commands  55
            Managing Sessions  57
            Formatting with an External Program  60
            Working with Different File Formats  62
            Typing ----
            Spell Checking 65
            Using Templates 67
            Undoing Mistakes 71
            Auto-Completing Text  73
            Abbreviating Common Strings  76
            Inserting Accented or “Foreign” Characters  78
            Opening the File  81
            Inserting the Date 84
            Inserting Snippets 86
            Navigation ----
            Navigating Text Files 91
            Navigating Source Code  93
            Navigating the Viewport  95
            Navigating Buffers  96
            Navigating Tabs  98
            Manually Creating Folds 100
            Navigating Folds  102
            Splitting the Screen  104
            Navigating Marks 106
            Navigating Tags 108
            Bookmarking Lines with Visible Markers (Signs)  111
            GUI ----
            Changing the Font  115
            Maximising Screen Space  117
            Creating Menus and Toolbar Buttons  119
            Searching ----
            Searching for any Word  122
            Searching Over Multiple Files 123
            Searching and Replacing  126
            Searching for the Word Beneath the Cursor 128
            Creating Regular Expressions 129
            Looking up Documentation for the Keyword Under the Cursor  134
            Display ----
            Working with Long Lines 136
            Displaying Line Numbers 138
            Working with Remote Files  139
            Changing the Status Line  141
            Redefining Highlight Groups  144
            Modifying the Cursor  147
            Changing the Window Title  149
            Extending ----
            Creating Keyboard Shortcuts with Key Mappings  153
            Changing the Colour Scheme  155
            Creating Command-Line Commands  157
            Extending Vim with Scripts and Plugins  159
            Integrating Vim with Git  162
            Other Uses of Vim ----
            Browsing Directories 167
            Using Vim as a File Manager  169
            Viewing Differences Between Files  172
            Outlining a Document 174
~/Empire/Doks/Comp/editor/vim/vim-esstomast.pdf **
~/Empire/Doks/Comp/editor/vim/vim-esstomast.txt
~/Empire/Doks/Comp/editor/vim/vim-forwriters.pdf
~/Empire/Doks/Comp/editor/vim/vim-forwriters.txt
~/Empire/Doks/Comp/editor/vim/vim-latexsuite-man.pdf
~/Empire/Doks/Comp/editor/vim/vim-latexsuite-man.txt
  ~/Empire/Doks/Comp/editor/vim/vimlikeapro.mini.pdf
  ~/Empire/Doks/Comp/editor/vim/vimlikeapro.mini.txt
  ~/Empire/Doks/Comp/editor/vim/vimlikepro.pdf
  ~/Empire/Doks/Comp/editor/vim/vimlikepro.txt
~/Empire/Doks/Comp/editor/vim/vimoutliner-manual.txt
~/Empire/Doks/Comp/editor/vim/vim-power-of-g.pdf
~/Empire/Doks/Comp/editor/vim/vimtut-avanc.pdf

