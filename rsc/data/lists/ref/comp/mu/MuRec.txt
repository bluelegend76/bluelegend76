set foldmethod=indent foldlevel=2
vim: fdm=indent:fdl=2:

PICK OUT/OVER QUICKLISTS, LIKE YOUROCK-GUITAR ETC *******
~/Dropbox/rsc/data/lists/at/muRecord.txt  ____  ____  ____  ____


~/SyncThing/rsc/Doks/Comp/mu/rec/nTrackStudio-Android.txt
    ~/SyncThing/rsc/Doks/Comp/mu/rec/nTrackStudio-Linux.txt
~/SyncThing/rsc/Doks/Comp/mu/rec/ntrack-manual_win.txt
----
~/SyncThing/rsc/Doks/Comp/mu/au/sunvox.txt


__
                ----
                .

        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/midi/midiman.txt
        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/midi/modernmidi-sequencing_2020.txt
midish
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/pr/midish/midish.txt
                        .
seq24
                            ~/Dropbox/rsc/Doks/phone/Comp/mu/pr/seq24/seq24-manual.txt
                            ~/Dropbox/rsc/Doks/phone/Comp/mu/pr/seq24/seq24-uman.txt
mma
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/mma.txt
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/mma-tut.txt
timidity-extras
Audacity
AnSynthesis
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/synthcookb.txt
                        ----
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/auprogr-book_2011.txt
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/musiccompute-unconv_2017.txt
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/refinesound-synthesguide_2013.txt
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/synthprogr-powtools.txt
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/synthprogr-powtools_2004.txt
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/syntkorgdw6000_manual.txt
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/thesynthesizer_2014.txt
                        ----
baudline
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/baudline.txt
                        .
Logic X  TODO!!
Ardour  +LUA **
                            ~/Dropbox/rsc/Doks/ardour-2.8.3-bindings-x.pdf
                            ~/Dropbox/rsc/data/lists/ref/comp/pr/mu/ardour/Ardour-KeyShortc.txt
                            ----
                            ~/Dropbox/rsc/Doks/phone/Comp/mu/rec/Ardour6-Man.txt
                            ~/Dropbox/rsc/Doks/phone/Comp/mu/rec/ardour-man.txt
                            ~/Dropbox/rsc/data/lists/learnqna/vanki/decks/comp/mu/Ardour.vdeck.txt
                            ----
                            ~/Dropbox/rsc/data/lists/ref/comp/pr/mu/ardour/ardour-luaclasses.txt
                            ----
Rosegarden
                        ~/Dropbox/rsc/data/lists/learnqna/vanki/pick.legacy/hydrog_roseg.vanki.txt
                        .
hydrogen
MuseScore 4  HM??????  ¤¤¤
                        mscore
                        ~/Dropbox/rsc/data/lists/ptools/mscore3.txt
                        ~/Dropbox/rsc/data/lists/learnqna/vanki/Mscore3.vdeck.txt
                            ----
                                ~/Dropbox/rsc/data/lists/learnqna/vanki/tagged/Mscore3.vdeck.txt  __
                                ~/Dropbox/rsc/data/lists/keys.shortc/mscore3.shortckeys.tagged.txt
                                ~/Dropbox/rsc/data/lists/keys.shortc/mscore3/mscore3.shortckeys.txt
                                ----
                                .... ~/Dropbox/rsc/Doks/phone/Comp/mu/pr/mscore3.man.raw.txt
                                .... ~/Dropbox/rsc/data/lists/ref/comp/mu/mscore3-keys.txt
                                ....       ~/Dropbox/rsc/Doks/phone/Comp/mu/pr/zz_mscore3.txt
                                .... ~/Dropbox/rsc/data/lists/ptools/mscore3.sort.txt
                            ----
                        .
Muse
lmms,  flstudio mobile
                            https://docs.lmms.io/user-manual/getting-started/installation
                            .
Qtractor
calf/lv, ladspa
guitarix
rakarrack
PureData

  btmixer / alto s6
maudio audiophile / focusrite scarlett
yourock-guitar  ____  ¤¤¤
                            - Test/Explore YouRock guitar-output (=for Instrumentalist) {{{
                                    I guess the simplest approach would be to if you could suggest some tool (I'm using Ubuntu Linux) - command line or graphical - that could be used to inspect the signal sent when playing the same note on two different strings of the guitar. If I could isolate what is similar and what is different, I guess there would be a method to parse out which string is played, so the correct note on the correct string could light up in the graphics.
                                    Absolutely! Here are a couple of tools you can use on Ubuntu Linux to inspect the MIDI data sent by your YouRock guitar when playing the same note on different strings:

                                    1. ALSA MIDI Monitor (amidi):

                                    amidi is a command-line tool included in the ALSA sound libraries. It allows you to monitor and view MIDI data flowing through your system.
                                    Here's how to use it:

                                    * Open a terminal window.
                                    * Identify the MIDI port your YouRock guitar is connected to. You can use the command `lsmidi` to list available MIDI devices and ports. 
                                    * Run the following command, replacing `[port number]` with the actual port number of your YouRock guitar:

                                    ```bash
                                    amidi -p [port number]
                                    ```

                                    * Play notes on different strings of your guitar. You'll see the corresponding MIDI data displayed in the terminal, including the note number, velocity, and channel information.
                                    2. QjackCtl (Graphical Option):

                                    QjackCtl is a graphical audio connection manager for Linux that also provides MIDI monitoring capabilities.
                                    Here's how to use it:

                                    * Install QjackCtl using your package manager:

                                    ```bash
                                    sudo apt install qjackctl
                                    ```

                                    * Launch QjackCtl.
                                    * In the "Midi" tab, make sure your YouRock guitar is listed as an input port under "Midi In."
                                    * Click the small red record button next to the input port. This activates MIDI monitoring for that port.
                                    * Play notes on different strings of your guitar. You'll see the corresponding MIDI data displayed in the "Piano Roll" view, along with the note number, velocity, and channel information.
                                    By using either amidi or QjackCtl, you can visually inspect the MIDI data sent when playing the same note on different strings. While the raw data might not explicitly indicate the string used, you might be able to identify patterns or subtle differences in the data that can help differentiate between strings.

                                    Here are some potential areas to investigate:

                                    Velocity: As mentioned earlier, notes played closer to the bridge might have slightly higher velocity values compared to notes played near the neck. This could be a starting point, but it won't be a foolproof indicator.
                                    Onset characteristics: Analyze the initial portion of the MIDI data (note attack) to see if there are any variations in how quickly the note reaches its full velocity depending on the string played.
                                    Time-series data (advanced): If you're comfortable with programming, you could capture the entire sequence of MIDI data points over time (including velocity changes) for each note played on different strings. This data can then be fed into a machine learning model to identify patterns and potentially improve string identification accuracy.
                                    By carefully examining the MIDI data using these tools and potentially implementing some basic data analysis techniques, you might be able to extract enough information to differentiate between strings and control your SVG image lighting accordingly.

                                    Additional Tips:

                                    Experiment with playing techniques like picking dynamics (hard vs. soft) on different strings to see if it introduces any consistent variations in the MIDI data.
                                    Search online forums or communities dedicated to Linux audio and MIDI for tips and tricks on analyzing MIDI data.
                                    Remember, this approach might require some trial and error, but it can be a good starting point before diving into more complex machine learning solutions.
                            }}}
                                ~/Empire/Doks/Comp/mu/yrg-man.txt
                                ~/Empire/Doks/Comp/mu/yrg_new.txt
                                ~/Empire/Doks/Comp/mu/yrg-man2.txt
                                ....   ~/Dropbox/yrg_manual.pdf  (=Search and find files (!!))
                                    .. ~/gdrive/20180316_150807.jpg
                                    .. ~/gdrive/20180316_150824.jpg
                                    .. ~/gdrive/20180316_150845.jpg
                                search: yrg manual pdf
                                https://archive.org/details/yourockguitar/YRG_Manual_1.105/
                                https://www.manualslib.com/manual/873713/Your-Rock-Guitar-1000.html
                                https://www.manualslib.com/manual/830417/Your-Rock-Guitar-Model-1000.html?page=8#manual
                                https://www.manualslib.com/manual/627641/Inspired-Instruments-You-Rock-Guitar.html
                                 https://d1aeri3ty3izns.cloudfront.net/media/6/60241/download_60241.pdf
                            ----

                            Uppgifter/Cookbook {{{
                                Strömkälla för yourock-gitarren
                                    4 AA-batterier, el sladd till usb-uttag **
                                kablar som går att koppla ut yrg:n med
                                    3,5 mm el tele *
                                sätt i/ta ur gitarrhalsen
                                    klicka i/tryck låsspärren på baksidan uppåt + dra ut halsen
                                antal inbyggda gitarr- och syntljud
                                    25 st + 50 st
                                Antal inbyggda Backing track-presets ***
                                    99 st
                                Lista på backing-tracks
                                    s14 pdf		#1-25=hela kompspår, 26-34=olika trumspår mm,, 35=yourock-demo**
                                lista på gitarrljud
                                    s18 pdf
                                Vad händer med ens inspelade 'anteckningar' om man "återställer" y-gitarren?
                                    de raderas
                                
                                mute
                                    hand på metalltråden bak på stallet 
                                öka/minska strängtrycket
                                    skruvarna bak på stallet (höger=hårdare, vänster=mjukare)
                                upp/ner (=t.ex. 'välj nästa patch mm')
                                    panelen, el +/-_knapparna bakom stallet ********



                                spela m gitarrljud				music-knappen
                                välj g-ljud						g-knappen + upp/ner
                                välj b-track					håll track-knapp + upp/ner
                                  tips: koppla in ext. ljud fr. tel, mp3 mm *			#=som b-track
                                ändra volym b-track/g-ljud/synt			håll inne knapp + vrid volymratten
                                spara byte ljud/preset mm				håll 'music' + tryck 'record'
                                  (t.ex. bytt g-ljud för b-track)	
                                                                                                                            slå på/av inbyggda gitarr/synt-ljud
                                                                                                                                tryck guitar/synth-knapparna
                                yourock-b-tracks				play/stop
                                ------
                                                                                                                            byt/aktivera syntljudet till ett visst gitarrljud
                                                                                                                                synt-knappen + upp/ner
                                spela in egna backing tracks
                                    'record'
                                -----
                                ___0000
                                'metronom'-spår för inspeln. **			track 24-26(ca)
                                spela in *****							välj ljud o b-track + håll 'rec' o tryck play ***
                                stoppa inspeln							tryck record
                                lyssna inspelat							play
                                punch-in/out							play =lyssna (+rec för punchin och out)
                                sudda nuv. inspel.						håll rec 3 sek
                                  (=på bakgr.spåret)
                                        (anteckn./inspeln. sparas i b-spåret man spelat in till)
                                spara ut inspeln./inspelad ant.			spela in som ljud(=audio) el(!) spela ut usb/midi till midi-seq


                                ändra midikanal **						håll 'midi' + tryck +/-
                                                            byt kanal el channel range för midi-kanal (för midi out)
                                                                håll in midi-knappen
                                sända midi över en kanal
                                    välj kanal 1-16
                                sända midi över kanalerna 1-6/7-12	
                                    välj kanal 17/18


                                vibrato (m.fl. effekter =beroende på vilken patch)
                                    multi-joysticken nedanför vibratoarmen

                                läge för att spela i öppna stämningar
                                    'open'-knappen
                                lista på tunings
                                    s20 pdf
                                olika stämningar
                                    1-50=öppna stämningar, 51-60=capo-stämningar

                                enkelt spela i samma tonart som nuv. backing track
                                    slå på yourock-läget	#yourock-knappen
                                ------
                                läge för tapping
                                    tap
                                läge för sliding
                                    slide
                            }}}
                            CONTENTS yrg 1000-ug01 (nyaste är gen2) {{{
                                    whats in the box?  7
                                Optional hardware and software  7 {{{ 
                                      GameflexTM cartridges
                                      Removable headstocks
                                    Sound libraries
                                    Jam Tracks
                                    Accessories
                                        http://www.yourockguitar.com/products-store/
                                }}}
                                knappar och kopplingspanelen - Input/output connections  7 {{{
                                    på/av-knapp
                                    anslut m gitarrkabel
                                        =anslut till förstärkare o spela som en vanlig gitarr*
                                    ljud ut (=anslut hörlurar)
                                    ljud in
                                        =kunna spela till mp3 från extern spelare, mm
                                    midi ut
                                        plugga in i midi-keyboard el annan ljudkälla**
                                    usb till midi // usb till interface
                                        så kan kontrollera program mm på datorn m midisignaler från gitarren // ladda in nya ljud/ny mjukvara till gitarren***
                                }}}
                                Digital guitar controls  8 {{{

                                    multimode joystick (modulates guitar and synth sound)
                                    mutebar (=om man lägger handen på stallet??)***
                                    +/-_knapparna (till hö om stallet)
                                    volymratt (mix av synt- o gitarrljud  +  externt mp3ljud o gitarrljudet)

                                }}}
                                CONTROL PANEL  se ev mer 9 {{{
                                  knappar:
                                    Music - tryck in för att kunna spela gitarren 'som en elektrisk gitarr'(???)
                                    Open - Slå på läget för 'öppna stämningar'
                                    Tap - 'tappingläget'***
                                    Guitar - 'slår på/av inbyggda gitarrljud'
                                     game - kunna spela yourockgames
                                    Slide - läget optimerat för slides på brädan
                                    YouRock - ??????
                                    Synth - slår på syntljudsläget
                                    leddisplay siffror
                                    leddisplay 6stjärnorna - vilken av de 6 strängarna som låter just nu*
                                    upp/ner-knapparna
                                    Track*** - håll inne för att kunna välja Backingtrack
                                    Midi - håll inne för att kunna ändra midikanal el midikanalsomfång
                                    play - starta/stoppa playback av backingtracks
                                    record - Spela in dina egna (backing)tracks(??)*******
                                }}}
                                Get connected!  10
                                 Attaching the neck  10
                                 Power  10
                                 Audio  10
                                 Game console 11
                                 Detaching the neck  11

                                Playing the internal sounds  12
                                Playing backing tracks  13
                                Playing with yourock-mode  14

                                    playing games with you rock guitar®  15
                                    using yourock guitar® with wii tm  16
                                    using yourock guitar® with playstation 3 tm  16
                                Playing synths over midi 17
                                Setting the midi channel and mode  17
                                Editing the presets  18
                                Selecting guitar sounds  18
                                Selecting synth sounds  19
                                Playing open tunings  20

                                Recording with yourock tracks  21

                                Adjusting string tension  22
                                    troubleshooting  22
                                    before requesting service  22
                                    specifications  23
                                    regulatory notice  23
                                    limited liability & warranty  24
                                    copyrights & credits  25
                            }}}

                                ----
                            mode for playing (=guitar sounds, etc)
                            {{{
                                'music' button
                                --
                                -p
                                }}}
                            Choose/Turn on Backing Track (**)
                            {{{
                                Hold 'Track' button
                                 +up/down (buttons?) on panel // right of bridge
                                --
                                -p
                                }}}
                            (play external backing track)
                            {{{
                                connect eg. phone/player to 'in' jack
                                --
                                -p
                                }}}
                            play yourock (backing) tracks
                            {{{
                                play / stop  #on the panel
                                --
                                -p
                                }}}
                            change/activate synth sound to certain guitar sound
                            {{{
                                synth button (+up/down)
                                --
                                -p
                                }}}
                            change volume for guitar sound / backing track / synth **
                            {{{
                                hold corresponding button  + turn volume knob(!)
                                --
                                -p
                                }}}
                                ----

                                ----
                            good backing track for 'taking musical notes'  (=if do not want background music) (!)
                            {{{
                                tracks 24, 25, 26  #=metronome track
                                --
                                -p
                                }}}
                            play recorded (=notes etc)
                            {{{
                                press 'play' button
                                --
                                -p
                                }}}
                            vibrato (etc effects =depending on active patch)
                            {{{
                                multi-joystic below vibrato bar
                                --
                                -p
                                }}}
                            [list of tunings]
                            {{{
                                = page 20(??) of pdf
                                --
                                -p
                                }}}
                            [different tunings]
                            {{{
                                1-50   =open tunings
                                51-60  =capo tunings
                                --
                                -p
                                }}}
                            simple way to play in same key as current backing track
                            {{{
                                turn on yourock mode (=the yourock button)
                                --
                                -p
                                }}}
                            [number of included guitar and synth patches]
                            {{{
                                guitar patches   25
                                synth patches    50
                                --
                                -p
                                }}}
                                ----

                                ----
                            [list of guitar patches]
                            {{{
                                page 18(??) of pdf
                                --
                                -p
                                }}}
                            mute tone when playing
                            {{{
                                = hold hand on metal thread at back of bridge(!)
                                --
                                -p
                                }}}
                            decrease / increase string tension (!!)
                            {{{
                                = cross-headed screws at back of bridge (!!)
                                increase tension  =  screw right
                                decrease tension  =  screw left
                                --
                                -p
                                }}}
                            patches that are changeable (and which are not)
                            {{{
                                A-D are changeable
                                0-3 are predefined/locked
                                --
                                -p
                                }}}
                            change bank (=sound patch group) directly (!)
                            {{{
                                bank up / tap-button
                                --
                                -p
                                }}}
                            set/adjust listening volume (=for connected headphones)
                            {{{
                                master level knob (=same as master volume when sound is connected out(?))
                                --
                                -p
                                }}}
                                ----
qsynth
zynaddsubfx
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/pr/zynaddsubfx/zynaddsubfx-man_2020.txt
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/pr/zynaddsubfx/zynaddsubfx-man.txt
 Linuxsynths
 yousician, jellynote
 Irig

Clam
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/ClamFramework.txt
                        .
Juce
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/Juce-startw.txt
                        .
Distrho  ___GEMINI
                             Oh and I have also asked you before about using Distrho to code (I think it is VST) plugins using C++. Could you give me some guidance there and maybe also show me some code so I could get going a bit, and by that I mean (at least hopefully) a bit beyond the basic Hello World type examples?

                            Ah yes, I recall you mentioning your interest in using the DPF (DISTRHO Plugin Framework) for creating VST (and other formats) plugins with C++. That's a really cool and powerful area to explore! Moving beyond the "Hello World" stage is definitely the next logical step.

                            DISTRHO provides a well-structured framework that handles a lot of the boilerplate for plugin development, allowing you to focus on the core audio processing and user interface logic.

                            Here’s a breakdown of how you can get started and a more substantial code example to illustrate some key concepts:
                            Setting up your Development Environment

                                Install Dependencies: You'll need a C++ compiler (like g++), CMake (for building), and the DPF headers and libraries. The exact installation steps might vary slightly depending on your Linux distribution. Generally, you'll be looking for packages like g++, cmake, and dpf-dev or similar. You might need to add the DISTRHO repository to your package manager if it's not included by default.

                                Understand the DPF Structure: A DPF plugin typically involves a few key classes:
                                    Plugin: This is the main class that represents your plugin. It handles audio processing, parameter changes, and MIDI input/output.
                                    Parameter: Defines the parameters that users can control in your plugin (e.g., knobs, sliders).
                                    UI (Optional): If your plugin has a graphical user interface, you'll create a UI class. DPF supports various UI toolkits (like X11, Cocoa, and potentially others). For a cross-platform GUI, you might consider using DPF's built-in UI elements or integrating with a library like JUCE (though that adds complexity). For a simpler, GUI-less plugin, you can skip the UI part initially.

                            A More Substantial Code Example: A Simple Gain Plugin

                            Let's create a basic gain plugin with a single parameter to control the amplification.

                            1. Create the Plugin Source File (e.g., GainPlugin.cpp):
                            C++

#include "DistrhoPlugin.hpp"
#include <cmath> // For std::log10 and std::pow

                            // -----------------------------------------------------------------------------------------------------------

                            class GainPlugin : public DGL::Plugin
                            {
                            public:
                                GainPlugin()
                                    : gainParameter(kGainId, "Gain", 0.0f, 1.0f, 0.5f) // ID, Name, Min, Max, Default
                                {
                                    parameters.push_back(&gainParameter);
                                }

                            protected:
                                // Parameter identification
                                enum ParameterId {
                                    kGainId
                                };

                                // Our gain parameter
                                DGL::Parameter gainParameter;

                                /**
                                  * @brief Get the number of program parameters.
                                  * @return Number of program parameters
                                  */
                                uint32_t getNumParameters() const override
                                {
                                    return parameters.size();
                                }

                                /**
                                  * @brief Get the program parameter at the given index.
                                  * @param index Parameter index
                                  * @return A program parameter object
                                  */
                                const DGL::Parameter* getParameter(uint32_t index) const override
                                {
                                    return parameters[index];
                                }

                                /**
                                  * @brief Get the program parameter with the given identifier.
                                  * @param parameterId Parameter identifier
                                  * @return A program parameter object, or nullptr if not found
                                  */
                                const DGL::Parameter* getParameter(const char* parameterId) const override
                                {
                                    return DGL::Plugin::getParameter(parameterId);
                                }

                                /**
                                  * @brief Get the current value of a program parameter.
                                  * @param parameterId Parameter identifier
                                  * @return Current parameter value
                                  */
                                float getParameterValue(const char* parameterId) const override
                                {
                                    return getParameterValue(getParameterIndex(parameterId));
                                }

                                /**
                                  * @brief Set the current value of a program parameter.
                                  * @param parameterId Parameter identifier
                                  * @param value New parameter value
                                  */
                                void setParameterValue(const char* parameterId, float value) override
                                {
                                    setParameterValue(getParameterIndex(parameterId), value);
                                }

                                /**
                                  * @brief Run the plugin process.
                                  * @param inputs  Input audio buffers
                                  * @param outputs Output audio buffers
                                  * @param frames  Number of frames to process
                                  */
                                void run(const float** inputs, float** outputs, uint32_t frames) override
                                {
                                    const float gainValue = gainParameter.getValue();
                                    const float linearGain = std::pow(10.0f, gainValue * 2.0f); // Convert 0-1 to a reasonable gain range in dB

                                    for (uint32_t channel = 0; channel < getNumOutputs(); ++channel) {
                                        const float* inputBuffer = inputs[channel];
                                        float* outputBuffer = outputs[channel];

                                        for (uint32_t frame = 0; frame < frames; ++frame) {
                                            outputBuffer[frame] = inputBuffer[frame] * linearGain;
                                        }
                                    }
                                }

                            private:
                                // List of all parameters
                                std::vector<DGL::Parameter*> parameters;

                                DISTRHO_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(GainPlugin)
                            };

                            // -----------------------------------------------------------------------------------------------------------

                            Plugin* DISTRHO::createPlugin()
                            {
                                return new GainPlugin();
                            }

                            // -----------------------------------------------------------------------------------------------------------

                            2. Create a CMakeLists.txt file in the same directory:
                            CMake

                            cmake_minimum_required(VERSION 3.10)
                            project(GainPlugin)

                            find_package(DISTRHO REQUIRED)

                            add_d_plugin(GainPlugin
                                SOURCES GainPlugin.cpp
                                PLUGIN_TARGET gainplugin # Lowercase, no spaces
                                FORMATS VST LADSPA LV2 # Specify the plugin formats you want to build
                            )

                            set_target_properties(gainplugin PROPERTIES
                                VST_PRODUCT_STRING "GainPlugin"
                                VST_VENDOR_STRING "Your Name"
                                VST_EFFECT_NAME "Simple Gain"
                                VST_UNIQUE_ID "Gain0001" # Unique 4-character ID (converted to integer)
                                LADSPA_NAME "gainplugin"
                                LADSPA_LABEL "Gain Plugin"
                                LADSPA_MAKER "Your Name"
                                LV2_URI "urn:yourname:gainplugin" # Unique URI
                            )

                            Explanation of the Code:

                                #include "DistrhoPlugin.hpp": Includes the necessary DPF header.
                                class GainPlugin : public DGL::Plugin: Our main plugin class inherits from DGL::Plugin (DISTRHO Graphics Library, even for audio-only plugins, it's the base).
                                enum ParameterId: We define an enumeration to give symbolic names to our parameter IDs, making the code more readable.
                                DGL::Parameter gainParameter(...): We create a DGL::Parameter object. The constructor takes the ID, name (displayed in the host), minimum value, maximum value, and default value.
                                parameters.push_back(&gainParameter);: We add our parameter to a vector of parameters.
                                getNumParameters(), getParameter(index), getParameter(id), getParameterValue(id), setParameterValue(id, value): These are override methods from the Plugin base class that handle parameter management. They allow the host to query and control the plugin's parameters.
                                run(const float** inputs, float** outputs, uint32_t frames): This is the core audio processing function.
                                    It gets the current value of the gainParameter.
                                    It converts the 0-1 parameter value to a linear gain factor (using a power of 10 for a more natural-feeling gain control).
                                    It iterates through each channel and each frame of the audio buffer, multiplying the input sample by the calculated gain and writing it to the output buffer.
                                createPlugin(): This function is the entry point for the plugin. It's called by the host to create an instance of your plugin.
                                CMakeLists.txt: This file tells CMake how to build your plugin.
                                    find_package(DISTRHO REQUIRED): Finds the DISTRHO installation.
                                    add_d_plugin(...): Specifies the source files and the target name for your plugin.
                                    PLUGIN_TARGET: The base name of the generated plugin files.
                                    FORMATS: The plugin formats you want to build (VST, LADSPA, LV2 are common on Linux).
                                    set_target_properties(...): Sets metadata for the different plugin formats, such as the product name, vendor, unique ID/URI, etc. It's crucial to have a unique VST_UNIQUE_ID and LV2_URI for your plugins to avoid conflicts.

                            Building the Plugin

                                Open a terminal in the directory where you saved GainPlugin.cpp and CMakeLists.txt.
                                Create a build directory:
                                Bash

                            mkdir build
                            cd build

                            Run CMake:
                            Bash

                            cmake ..

                            Build the plugin:
                            Bash

                                make -j$(nproc) # Use all available CPU cores for faster building

                            After successful compilation, you'll find the plugin files (e.g., .so for VST and LADSPA, .lv2 directory for LV2) in the build/bin directory (or a similar location depending on your system and DPF configuration).
                            Using the Plugin

                            You can now copy these plugin files to the appropriate plugin directories on your system so that your audio host (like Ardour, Carla, etc.) can find them. The standard locations are often:

                                VST: /usr/lib/vst or ~/.vst
                                LADSPA: /usr/lib/ladspa/ or ~/.ladspa
                                LV2: /usr/lib/lv2/ or ~/.lv2

                            You might need to restart your audio host after installing new plugins.
                            Going Further

                            This simple gain plugin provides a foundation. Here are some ideas for expanding it:

                                More Parameters: Add parameters for panning, different types of gain control (linear, logarithmic), or even basic filters.
                                User Interface: Explore DPF's UI capabilities or look into integrating with a GUI library like IPlug 2 or JUCE for more complex interfaces. This will involve creating a separate UI class in your plugin.
                                MIDI Input: Implement MIDI processing in your run() function or by overriding the midiEvent() method to control the gain or other parameters via MIDI.
                                More Complex Audio Processing: Experiment with different audio algorithms, synthesis techniques, or effects.

                            Remember to consult the DPF documentation and examples for more in-depth information on various aspects of plugin development. The DISTRHO website and GitHub repository are excellent resources.

                            This should give you a solid starting point for moving beyond basic "Hello World" examples with DPF. Good luck with your plugin development! Let me know if you have more specific questions as you progress.
pymidi  ___Gemini
Csound
                        .  ~/Dropbox/rsc/Doks/phone/Comp/mu/au/csound/csound-virtualsoundprocess_2000.txt
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/csound/CsoundBook.txt
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/csound/man-tut/csound-flossman_2011.txt
                        ----
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/csound/blue.txt
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/csound/csoundqt.txt
.   ---- [CSOUND + SUPERCOLLIDER [+ LILYPOND]  EMACS-MODES ****]
                        Could you help me compare and contrast the combination of IDEs with plugins for handling CSound and SuperCollider, firstly when it comes to Vim vs Emacs, and then if applicable, some other IDEs such as JetBrains IDEs
                        Comparing and Contrasting IDEs with Plugins for Csound and SuperCollider

                        When it comes to using IDEs with plugins for handling Csound and SuperCollider, both Vim and Emacs offer powerful and highly customizable environments. Here's a comparison:
                        Vim

                        CSound:

                            Plugin: csound-vim by luisjure.
                            Features:
                                Syntax highlighting for .orc, .sco, .csd, and .udo files.   

                                Code folding for orchestra and score sections, instruments, user-defined opcodes, and multi-line comments.
                                Macros for compiling Csound files and listening to the output directly from Vim (using function keys like F8, F9, F10, F11, F12).
                                Online help by opening the manual page for the opcode under the cursor in the default web browser (using the F1 key).
                                Templates for new .csd files.
                                Autocompletion of opcode names using Vim's built-in completion (Ctrl-n/Ctrl-p).
                            Installation: Follows standard Vim plugin installation methods, including Vim's native package management or plugin managers like Pathogen, Vundle, NeoBundle, or vim-plug. Some Linux distributions may have vim-csound packaged.
                            Live Coding: Can be combined with csound-repl for live coding capabilities.

                        SuperCollider:

                            Plugin: scvim (moved to https://github.com/supercollider/scvim).
                            Features:
                                Syntax highlighting for SuperCollider code.
                                A "faked REPL" via the terminal.
                                Code navigation (jump to definitions) using a global tags file (~/.sctags).
                                Autocompletion of known words via tag completion.
                                Launching the SuperCollider QT Help System.
                                Support for tmux and screen.
                                Key commands for recompiling the SuperCollider library (<leader>sk), opening help files (K), jumping to tags (^]), and executing code blocks/lines (F5, F6).   

                            Installation: Recommended to use Vim 8+'s native packages or a plugin manager. Requires symlinking SCVim.sc to SuperCollider's Extensions directory. May require setting the terminal application in .vimrc.
                            Note: The Gentoo Wiki mentions that scel (the Emacs Lisp interface for SuperCollider) has not been updated recently, which might imply that scvim might also have similar maintenance considerations, although it had a commit in the last year.


                        Summary of Vim vs. Emacs for CSound and SuperCollider:

                            Both Vim and Emacs offer robust plugin ecosystems that extend their functionality to support CSound and SuperCollider development.
                            Vim provides lightweight and efficient environments with plugins focusing on syntax highlighting, code navigation, compilation/execution from within the editor, and integration with external tools like REPLs or help systems. Vim's modal editing might be a preference for some users.
                            Emacs offers highly customizable and extensible environments with plugins that often provide deeper integration, such as REPLs within the editor, more comprehensive code assistance features (completion, documentation), and potentially more features out-of-the-box for Csound (like score alignment in csound-mode or the broader toolset of csound-x). Emacs' modeless interface might be more approachable for beginners, but its customization can have a steeper learning curve.
                            The choice between Vim and Emacs often comes down to personal preference regarding editing philosophy (modal vs. modeless), the desired level of extensibility and customization, and the specific features offered by the available plugins for CSound and SuperCollider.   

                        JetBrains IDEs:

                            Currently, there doesn't seem to be significant dedicated plugin support for CSound and SuperCollider within the JetBrains ecosystem.
                            Users might rely on generic editor enhancements or the dedicated IDE provided by SuperCollider itself, or other standalone CSound editors.

                        For your specific need of remapping keys in AutoHotkey, which you mentioned you're doing with Ctrl, Shift, and AltGr modifiers, this is a separate functionality handled by AutoHotkey scripts themselves and wouldn't directly interact with the choice of IDE for CSound or SuperCollider unless you're also editing your AutoHotkey scripts in the same editor. Both Vim and Emacs have excellent text editing capabilities and plugins for AutoHotkey syntax highlighting if needed.
                        csound vim tools
                        Source icon
                        www.eumus.edu.uy
                        supercollider/scvim: Vim plugin for SuperCollider - GitHub
                        Source icon
                        github.com
                        supercollider/scel: Supercollider emacs package - GitHub
                        Source icon
                        github.com
                        Vim in IntelliJ IDEA - JetBrains
                        Source icon
                        www.jetbrains.com
                        Vim vs Emacs: Which Text Editor is Best for Developer - LightNode VPS
                        Source icon
                        go.lightnode.com

                        ------

                        Could we do the same when it comes to Lilypond, as it's something I use a lot, and I find the Vim-mode for Lilypond good, but a bit anemic

                        Absolutely, let's get LilyPond set up in Emacs with a more robust environment than you've experienced in Vim. Emacs has excellent support for LilyPond through the lilypond-mode, which offers a more feature-rich experience.

                        Here's how we can configure LilyPond in your init.el using use-package, similar to what we did for Csound and SuperCollider:

                        Recommended Package:

                            lilypond-mode: This is the primary mode for editing LilyPond files (.ly). It provides syntax highlighting, indentation, compilation, and other helpful features.

                        Updating your init.el:

                        Add the following configuration block to your init.el file:
                        Code snippet

                        ;;; LilyPond Mode Configuration
                        (use-package lilypond-mode
                          :ensure t
                          :mode "\\.ly\\'"
                          :config
                          ;; --- Keybindings (Optional - adjust to your preference) ---
                          ;; Example: Compile LilyPond file (adjust command as needed for your system)
                          (define-key lilypond-mode-map (kbd "C-c l")
                            (lambda ()
                              (interactive)
                              (shell-command (concat "lilypond " (buffer-file-name)))))

                          ;; Example: View the resulting PDF (adjust command as needed)
                          (define-key lilypond-mode-map (kbd "C-c v")
                            (lambda ()
                              (interactive)
                              (let ((pdf-file (replace-regexp-in-string "\\.ly\\'" "\\.pdf\\'" (buffer-file-name) nil t)))
                                (shell-command (concat "open " pdf-file))))) ;; For macOS, use "xdg-open" for Linux

                          ;; --- Customization ---
                          ;; Example: Set a preferred indentation style (adjust as needed)
                          (setq lilypond-indentation-alist
                                '(("Staff" . 2)
                                  ("Voice" . 4)
                                  ("ChordNames" . 2)
                                  ("Lyrics" . 4)
                                  (default . 2)))

                          ;; Example: Enable auto-fill mode in LilyPond buffers (optional)
                          ;; (add-hook 'lilypond-mode-hook 'auto-fill-mode)
                          )

                        Explanation:

                            :ensure t: Ensures that the lilypond-mode package is installed if it's not already.
                            :mode "\\.ly\\'": Associates files ending with .ly with lilypond-mode.
                            :config: This section contains specific configurations for lilypond-mode.
                                Keybindings (Optional): The examples show how to define custom keybindings within lilypond-mode-map.
                                    C-c l: This example defines Ctrl-c l to run the lilypond command on the current .ly file, compiling it into a PDF. You might need to adjust the lilypond command if it's not directly in your system's PATH.
                                    C-c v: This example defines Ctrl-c v to open the resulting PDF file. It constructs the PDF filename by replacing .ly with .pdf and then uses the open command (for macOS; use xdg-open on Linux or your system's PDF viewer command).
                                Customization:
                                    lilypond-indentation-alist: This allows you to customize the indentation for different blocks in LilyPond code (e.g., Staff, Voice, Lyrics). Adjust the numbers to your preferred indentation levels.
                                    add-hook 'lilypond-mode-hook 'auto-fill-mode: This commented-out line shows how you could enable auto-fill-mode in LilyPond buffers, which automatically wraps lines at a certain width. You can uncomment this if you find it useful.

                        How to Use This:

                            Open your init.el file.
                            Add the lilypond-mode block to your configuration.
                            Customize the keybindings in the :config section if you desire. Make sure the lilypond and PDF viewer commands are correct for your system.
                            Adjust the lilypond-indentation-alist to your preferred indentation style.
                            Save the init.el file.
                            Restart Emacs.

                        Now, when you open a .ly file in Emacs, it should automatically use lilypond-mode, providing syntax highlighting and the custom keybindings and indentation rules you've configured.

                        Addressing the "anemic" Vim experience:

                        lilypond-mode in Emacs typically offers more features than a basic Vim syntax highlighting setup for LilyPond. You should find:

                            More comprehensive syntax highlighting: Better recognition of LilyPond's specific syntax.
                            Improved indentation: With the lilypond-indentation-alist, you have fine-grained control over how different code blocks are indented.
                            Compilation from within the editor: The keybinding example allows you to compile your LilyPond files without leaving Emacs.
                            Potential for further customization: Being in the Emacs ecosystem, you can further enhance your LilyPond workflow with other Emacs packages if needed.

                        Feel free to adjust the keybindings and indentation rules in the init.el to match your preferences. Let me know if you encounter any issues or have further customization requests!
csound-mode (Emacs)
                            Major mode csound-mode

                            The major mode is Csound Mode mode defined in csound-mode.el:

                            A major mode for interacting and coding Csound

                            This mode runs the hook 'csound-mode-hook', as the final or
                            penultimate step during initialization.


                            Key             Binding

                            C-x C-e		csound-repl-evaluate-line

                            C-M-x		csound-repl-evaluate-region
                            M-.		csound-score-find-instr-def

                            C-c C-c		csound-repl-evaluate-region
                            C-c C-k		csound-abort-compilation
                            C-c C-l		csound-repl-interaction-evaluate-last-expression
                            C-c C-n		csound-skeleton-new-csd
                            C-c C-p		csound-play
                            C-c C-r		csound-render
                            C-c C-s		csound-score-align-block
                            C-c C-z		csound-repl-start

                            C-c C-d h	csound-manual-lookup

                              Local minor mode auto-save-mode

                            Auto-Save minor mode (no indicator):
                            Toggle auto-saving in the current buffer (Auto Save mode).

                            When this mode is enabled, Emacs periodically saves each file-visiting
                            buffer in a separate "auto-save file".  This is a safety measure to
                            prevent you from losing more than a limited amount of work if the
                            system crashes.

                            Auto-saving does not alter the file visited by the buffer: the visited
                            file is changed only when you request saving it explicitly (such as
                            with C-x C-s).  If you want to save the buffer into its
                            visited files automatically, use M-x auto-save-visited-mode).

                            For more details, see Info node '(emacs) Auto Save'.

                            This is a minor mode.  If called interactively, toggle the 'Auto-Save
                            mode' mode.  If the prefix argument is positive, enable the mode, and if
                            it is zero or negative, disable the mode.

                            If called from Lisp, toggle the mode if ARG is 'toggle'.  Enable the
                            mode if ARG is nil, omitted, or is a positive number.  Disable the mode
                            if ARG is a negative number.

                            To check whether the minor mode is enabled in the current buffer,
                            evaluate '(and buffer-auto-save-file-name (>= buffer-saved-size 0))'.

                            The mode's hook is called both when the mode is enabled and when it is
                            disabled.
----
sclang-mode (Emacs)
                            Major mode sclang-mode

                            The major mode is SCLang mode defined in sclang-mode.el:

                            Major mode for editing SuperCollider language code.

                            Key             Binding

                            )		sclang-electric-brace
                            *		sclang-electric-star
                            /		sclang-electric-slash
                            ]		sclang-electric-brace
                            }		sclang-electric-brace

                            C-M-h		sclang-goto-help-browser
                            C-M-x		sclang-eval-defun

                            C-c C-c		sclang-eval-region-or-line
                            C-c C-d		sclang-eval-region
                            C-c C-e		sclang-eval-expression
                            C-c C-f		sclang-eval-document
                            C-c C-h		sclang-find-help
                            C-c C-k		sclang-edit-dev-source
                            C-c C-l		sclang-recompile
                            C-c RET		sclang-show-method-args
                            C-c C-n		sclang-complete-symbol
                            C-c C-o		sclang-start
                            C-c C-r		sclang-main-run
                            C-c C-s		sclang-main-stop
                            C-c C-w		sclang-switch-to-workspace
                            C-c C-y		sclang-open-help-gui
                            C-c :		sclang-find-definitions
                            C-c ;		sclang-find-references
                            C-c <		sclang-clear-post-buffer
                            C-c >		sclang-show-post-buffer
                            C-c [		sclang-dump-interface
                            C-c h		sclang-find-help-in-gui
                            C-c {		sclang-dump-full-interface
                            C-c }		sclang-pop-definition-mark

                            C-M-q		prog-indent-sexp
                            M-q		prog-fill-reindent-defun

                            C-c C-p b	sclang-server-boot
                            C-c C-p d	sclang-server-display-default
                            C-c C-p f	sclang-server-free-all
                            C-c C-p m	sclang-server-make-default
                            C-c C-p n	sclang-next-server
                            C-c C-p o	sclang-server-dump-osc
                            C-c C-p p	sclang-show-server-panel
                            C-c C-p q	sclang-server-quit

                            C-c C-p r n	sclang-server-prepare-for-record
                            C-c C-p r p	sclang-server-pause-recording
                            C-c C-p r r	sclang-server-record
                            C-c C-p r s	sclang-server-stop-recording

                            In addition to any hooks its parent mode 'prog-mode' might have run,
                            this mode runs the hook 'sclang-mode-hook', as the final or
                            penultimate step during initialization.
SCollider IDE
                ~/Dropbox/rsc/data/lists/ref/ScolliderIDE-Shortcuts.pdf
                Themes: Dark, Dracula (etc)
                ------
                About Qt
                    About Qt
                About SuperCollider
                    About SuperCollider
                Auto Scroll
                    Scroll to bottom on new posts
                Autoindent Line or Region
                    Autoindent Line or Region
                Boot Interpreter
                    Boot Interpreter
                Boot Server
                    c-b
                Clear
                    cs-p
                    Clear post window
                Clear
                    Clear list of recent documents
                Close
                    c-w
                    Close the current document
                Close All...
                    cs-w
                    Close all documents
                Close Tool Panel
                    Esc
                    Close any open tool panel
                Command Line  ___hm_eng
                    c-e
                    Command line for quick code evaluation
                Command Line from selection
                    cs-e
                    Command Line from selection
                Copy Line Up/Down
                    ca-up / ca-down
                Copy
                    c-c
                    Copy text to clipboard
                Cut
                    c-x
                    Cut text to clipboard
                Paste
                    c-v
                    Paste text from clipboard
                Increase/Decrease Volume
                    ca-PgUp / ca-PgDown
                Delete Word
                    Delete Word
                Documents
                    Show/Hide Documents docklet
                Dump Node Tree
                    c-t
                Dump Node Tree with Controls  ??
                    cs-t
                Enlarge/Shrink Font Size
                    c_+ / c_-
                Reset Font Size
                    c-0 Reset displayed font size
                Evaluate File
                    Evaluate current File
                Evaluate Selection or Line
                    s-Ret
                    Evaluate current selection/line
                Evaluate Selection, Line or Region
                    c-Ret
                    Evaluate current region
                Find...
                    c-f
                    Find text in document
                Find Next/Previous
                    c-g / cs-g
                Focus Post Window
                    c-p
                Full Screen
                    cs-f
                Go To Line
                    c-l
                    Tool to jump to a line by number
                Go to Next/Previous Block
                    c-] / c-[
                Go to Next Empty Line
                    c-down
                Go to Next/Previous Region  [!!]
                    ca-] / ca-[
                Go to Next/Previous Empty Line
                    c-down / c-up
                Help browser  ___hm_eng
                    Show/hide Help browser docklet
                Kill All Servers
                Look Up Documentation for Cursor  __ __
                    c-d
                    Look up documentation for text under cursor
                Look Up Documentation...  __
                    cs-d
                    Enter text to look up in documentation
                Look Up Implementations for Cursor  __ __
                    c-i
                    Look up implementations of class or method under cursor
                Look Up Implementations...  __
                    cs-i
                    Open dialog to look up implementations of a class or a method
                Look Up References for Cursor  __ [__]
                    c-u
                    Look up references to class or method under cursor
                Look Up References...  __
                    cs-u
                    Open dialog to look up references to a class or a method
                Manage Sessions...
                Move Line Down/Up
                    cs-down / cs-up
                Mute  __
                    ca-End
                    Mute
                New
                    c-n
                    Create a new document
                New Session
                    Open a new session
                Next/Previous Document
                    a-right / a-left
                Open startup file
                Open user support directory  [??]
                Open...
                    c-o
                    Open an existing file
                Pause Recording  [__]
                Post window  [__??]
                    Show/hide Post docklet
                Preferences  [!!]
                    Show configuration dialog
                Previous Document
                    Alt+Left
                    Previous Document
                Quarks  [[__]]
                Quit Interpreter
                Quit Server
                Reboot Interpreter
                Reboot Server  [[__]]
                Recompile Class Library  __!!
                    cs-l
                Redo  <__>
                    cs-z
                    Redo next editing action
                Reload  __
                    f5
                    Reload the current document
                Remove All Splits  <__>
                Remove Current Split
                Replace...  (__)
                    c-r
                    Find and replace text in document
                Restore Volume to 0 dB  (__)
                    ca-Home
                Save All...  [__]
                    ca-s
                    Save all open documents
                Save As Extension...  (__)
                    Save the current document into a different file in the extensions folder
                Save As...
                    cs-s
                    Save the current document into a different file
                Save Session As...  [__]
                    Save the current session with a different name
                Select Enclosing Block  __
                    cs-b
                    Select everything between brackets that contain cursor
                Select Region  [__]
                    cs-r
                    Select Region
                Server Dump OSC  ((__))
                Show Autocomplete Help  [__]
                Show Freqscope  __
                    ca-m
                    Show Freqscope
                Show Help Browser  (__)
                    Show and focus the Help Browser
                Show Line Number  (__)
                    ca-#
                    Show Line Number
                Show Node Tree  __ __
                    ca-t
                    Show Node Tree
                Show Scope  (__)
                    cs-m
                    Show Scope
                Show Server Meter  __(!!)
                    c-m
                    Show Server Meter
                Show Spaces and Tabs  [__]
                    a-e  a-v
                    Show Spaces and Tabs
                Split To Bottom  [??__]
                Split To Right
                Start Recording  (__)
                Stop  __(!!)
                    c-.
                    Stop
                Switch Document  (__)
                    c-tab
                    Switch Document
                Switch Session...  [__]
                    cs-q
                    Switch Session
                Toggle Comment  [__]
                    c-/  #cs-7
                    Toggle Comment
                Toggle Overwrite Mode  __
                    Ins
                Trigger Autocompletion  (__)
                    c-space
                    Suggest possible completions of text at cursor
                Trigger Method Call Aid  __ [__]
                    cs-Space
                    Show arguments for currently typed method call
                Use Spaces for Indentation  [[__]]
                    Indent with spaces instead of tabs
                Wrap Text  (__)
                    Wrap lines wider than the post window
SCollider
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/scoll/scoll-mapvisu.tagged.txt
                        ~/Dropbox/rsc/Doks/phone/Comp/mu/au/scoll/ScollBook.txt
                        ~/gdrive/rsc/Doks/taskuj/Misc/scoll-csound/scoll-compose.txt
                        ~/gdrive/rsc/Doks/taskuj/Misc/scoll-csound/scoll-compose.pdf
scoll:python
scoll:clojure (Overtone)
                Overtone Cheat Sheet 0.9.1
                Instruments (need to be manually referred)
                ----
                overtone.inst.drum ----
                kick kick2 kick3 kick4 dub-kick dry-kick
                small-hat closed-hat close-hat2 open-hat
                hat3 soft-hat noise-hat round-kick snare
                snare2 noise-snare tone-snare tom clap bing
                dance-kick quick-kick haziti-clap
                overtone.inst.piano ----
                Piano piano
                overtone.inst.sampled-piano ----
                Sampled Piano sampled-piano
                overtone.inst.sampler ----
                Sampler granular
                overtone.inst.bass ----
                Bass bass grunge-bass vintage-bass daf-bass
                overtone.inst.synth ----
                Synth ticker ping tb303 mooger rise-fall-pad
                pad overpad buzz ks1 ks-stringer fm-demo
                harmonic-swimming whoahaha bubbles supersaw
                cs80lead simple-flute
                overtone.inst.io ----
                IO mic
                Synths (need to be manually referred)
                overtone.synth.sampled-piano ----
                Sampled Piano sampled-piano
                overtone.synth.stringed ----
                Stringed s guitar
                overtone.synth.ixi ----
                Ixi impulser kick kick2 kick3
                overtone.synth.retro ----
                Retro tb-303
                overtone.synth.sts ----
                STS prophet

                REPL helpers
                Documentation odoc ugen-doc find-ugen find-ugen-doc
                Examples examples example get-example
                Shell ls grep
                Synths unify-synthdef
                Pretty Printing opp pp-synth pp-unified-synth
                pp-sc-synth pp-unified-sc-synth

                Timing
                Scheduling
                Function Application now after-delay periodic
                interspaced apply-by apply-at
                OSC at
                Stopping stop-player kill-player
                Feedback show-schedule
                Metronome
                Create metronome
                Manipulate metro-start metro-tick metro-beat
                metro-bpm metro-tock metro-bar metro-bpb
                bps beat-ms

                Studio
                Mixer
                Control volume input-gain
                MIDI
                Connected Controllers midi-connected-devices
                midi-connected-receivers
                midi-find-connected-devices
                midi-find-connected-device
                midi-find-connected-receivers
                midi-find-connected-receiver
                Info midi-device-num
                midi-full-device-key
                Player midi-poly-player midi-player-stop
                midi-inst-controller
                Discovery midi-capture-next-controller-control-key
                midi-capture-next-controller-key
                Keys midi-device-keys
                midi-mk-control-key-keyword
                State midi-agent-for-control
                Scope
                Create & Reset scope pscope spectrogram
                Recording
                Stop & Start recording-start recording-stop
                Query recording?
                Inst Effects
                Instrument inst-volume inst-out-bus inst-fx! clear-fx
                FX fx-noise-gate fx-compressor fx-limiter
                fx-sustainer fx-freeverb fx-reverb
                fx-echo fx-chorus fx-distortion
                fx-distortion2 fx-distortion-tubescreamer
                fx-bitcrusher fx-rlpf fx-rhpf fx-feedback
                fx-feedback-distortion

                Synth Design
                Design definst defsynth
                Examples defexamples
                CGens defcgen
                Auditioning demo run
                Checking with-no-ugen-checks with-ugen-debugging
                Arguments synth-args synth-arg-index

                Synth Control
                Live Control ctl kill
                Node Liveness inactive-node-modification-error
                inactive-buffer-modification-error
                block-node-until-ready?
                without-node-blocking
                with-inactive-node-modification-error
                with-inactive-buffer-modification-error
                with-inactive-modification-error

                Event Handling
                Add on-event on-sync-event on-latest-event
                oneshot-event oneshot-sync-event
                Fire event sync-event
                Remove remove-event-handler
                Debug event-debug-on event-debug-off
                event-monitor-on event-monitor-off
                event-monitor-timer event-monitor
                event-monitor-keys
                Ugen Triggers trig-id on-trigger on-latest-trigger
                on-sync-trigger

                Nodes & Groups
                Create & Free node group node-free group-free
                group-clear group-deep-clear
                Manipulate node-start node-pause node-place
                node-control node-control-range
                node-map-controls
                node-map-n-controls
                group-prepend-node
                group-append-node
                Info node? node-live? node-loading?
                node-active? node-tree
                pp-node-tree node-get-control
                node-get-controls
                Foundation Groups foundation-overtone-group
                foundation-output-group
                foundation-monitor-group
                foundation-input-group
                foundation-user-group
                foundation-default-group
                foundation-safe-group
                foundation-safe-pre-default-group
                foundation-safe-post-default-group
                Manipulation Handlers on-node-destroyed on-node-created
                on-node-paused on-node-started
                Event Keys node-destroyed-event-key
                node-created-event-key
                node-paused-event-key
                node-started-event-key

                Server
                Startup boot-server boot-internal-server
                boot-external-server
                connect-external-server
                Shutdown kill-server
                Control stop clear stop-all clear-all
                OSC Communication snd recv clear-msg-queue at
                snd-immediately
                Diagnostic server-status server-info
                server-opts server-connected?
                server-disconnected?
                server-connecting?
                internal-server? external-server?
                connection-info server-sample-rate
                server-num-output-buses
                server-num-input-buses
                server-num-audio-buses
                server-num-buffers
                ensure-connected!
                Debug sc-osc-log-on sc-osc-log-off
                sc-osc-log sc-debug-on
                sc-debug-off external-server-log
                sc-osc-debug-on sc-osc-debug-off

                Visualisation
                Graphviz
                Dot Notation graphviz
                Show PDF show-graphviz-synth

                External Assets
                Generic URLs
                Auto cache & Return Path asset-path asset-seq
                asset-bundle-path
                asset-bundle-dir
                Freesound.org
                Playable Function freesound
                Auto cache & Query freesound-info freesound-path
                freesound-pack-info
                freesound-pack-dir
                freesound-search freesound-searchm
                freesound-search-paths

                Algorithmic Composition
                Chance
                Choice choose choose-n weighted-choose
                Dice weighted-coin ranged-rand
                Scaling
                Range scale-range
                Rounding closest-to round-to
                Trig
                Scaled cosr sinr tanr
                Functions
                Cycling cycle-fn
                List
                Rotation rotate
                Creation fill

                Music
                Pitch
                Ratios unison octave fifth sixth third fourth
                min-third min-sixth
                Note Shifting shift flat sharp invert inc-first
                dec-last
                Notes note octave-note nth-octave
                nth-equal-tempered-freq
                canonical-pitch-class-name note-info
                mk-midi-string match-note
                Scales scale resolve-scale scale-field
                nth-interval resolve-degree degree->int
                degree->interval degrees->pitches
                resolve-degree resolve-degrees
                interval-freq
                Chords chord resolve-chord rand-chord
                invert-chord chord-degree
                Discovery find-scale-name find-note-name
                find-pitch-class-name find-chord
                Frequencies cents midi->hz hz->midi
                Amplitude db->amp

                Sound Data
                Buffers
                Create & Free buffer buffer-free
                buffer-alloc-read
                Generate Buffer Data data->wavetable
                create-buffer-data
                Read & Write To Server buffer-read buffer-write!
                buffer-write-relay! buffer-fill!
                buffer-set! buffer-get
                buffer-save buffer-data
                buffer-read
                Write To Filesystem write-wav
                Streaming In & Out buffer-stream buffer-stream?
                buffer-stream-close buffer-cue
                buffer-cue? buffer-cue-pos
                buffer-stream-close
                Query buffer? buffer-info?
                file-buffer? buffer-out-stream?
                buffer-in-stream?
                Info buffer-info num-frames buffer-id
                Samples
                Create load-sample load-samples sample defsample
                Playback mono-player stereo-player
                Busses
                Create & Free control-bus audio-bus free-bus
                Modify & Read control-bus-set! control-bus-set-range!
                control-bus-get control-bus-get-range
                Query bus? control-bus? audio-bus?
                Info bus-id
                Monitor bus-monitor control-bus-monitor
                audio-bus-monitor

                Persistence
                Local Store
                Access store-get store-set! store
                CGens
                Audio In sound-in
                Buffer Playback scaled-play-buf scaled-v-disk
                Control hold
                Oscillators pm-osc square
                Mix mix splay sum
                Pitch add-cents
                Tapping tap
                Range range-lin
                UGen Helper Constants
                Done Actions NO-ACTION PAUSE FREE FREE-AND-BEFORE
                FREE-AND-AFTER FREE-AND-GROUP-BEFORE
                FREE-AND-GROUP-AFTER
                FREE-UPTO-THIS FREE-FROM-THIS-ON
                FREE-PAUSE-BEFORE FREE-PAUSE-AFTER
                FREE-AND-GROUP-BEFORE-DEEP
                FREE-AND-GROUP-AFTER-DEEP FREE-CHILDREN
                FREE-GROUP
                FFT Windows SINE HANN RECT
                Lines LINEAR LIN EXPONENTIAL EXP
                Onset Analysis POWER MAGSUM COMPLEX RCOMPLEX PHASE
                WPHASE MKL
                Inﬁnity INFINITE INF
                UGen Envelope Helper Functions
                env-perc env-triangle env-sine env-lin env-cutoff
                env-dadsr env-adsr env-asr
                Unary UGens
                neg not-pos? abs ceil floor frac sign squared cubed
                sqrt exp reciprocal midicps cpsmidi midiratio
                ratiomidi dbamp ampdb octcps cpsoct log log2
                log10 sin cos tan asin acos atan sinh cosh tanh
                distort softclip rect-window han-window wel-window
                tri-window
                Binary UGens
                + - * / mod = not= < > <= >= min max and or xor
                round round-up round-down atan2 hypot hypot-aprox
                pow ring1 ring2 ring3 ring4 difsqr sumsqr sqrsum
                sqrdif absdif thresh amclip scale-neg clip2 excess
                fold2 wrap2
                B Equalization Suit UGens
                b-low-pass b-hi-pass b-all-pass b-band-pass
                b-band-stop b-peak-eq b-low-shelf b-hi-shelf
                Buffer IO UGens
                play-buf t-grains buf-rd buf-wr record-buf
                scope-out local-buf max-local-bufs set-buf
                clear-buf
                Chaos UGens
                quad-n quad-l quad-c cusp-n cusp-l gbman-n
                gbman-l henon-n henon-l henon-c latoocarfian-n
                latoocarfian-l latoocarfian-c lin-cong-n lin-cong-l
                lin-cong-c standard-n standard-l fb-sine-n
                fb-sine-l fb-sine-c lorenz-l
                Compander
                amplitude compander normalizer limiter
                Delay UGens
                delay1 delay-n delay-l delay-c comb-n comb-l
                comb-c allpass-n allpass-l allpass-c buf-delay-n
                buf-delay-l buf-delay-c buf-comb-n buf-comb-l
                buf-comb-c buf-allpass-n buf-allpass-l
                buf-allpass-c
                Demand UGens
                demand duty t-duty demand-env-gen dseries dgeom
                dbufrd dbufwr dseq dser dshuf drand dxrand dswitch1
                dswitch dwhite dbrown dibrown dstutter donce dpoll
                Envelope Ugens
                done free-self pause-self free-self-when-done
                pause-self-when-done pause free env-gen linen
                i-env-gen
                Fixed Frequency Oscillator UGens
                f-sin-osc klang klank blip saw pulse p-sin-grain
                FFT UGens
                fft ifft pv-mag-above pv-mag-below pv-mag-clip
                pv-local-max pv-mag-smear pv-bin-shift pv-mag-shift
                pv-mag-squared pv-mag-noise pv-phase-shift90
                pv-phase-shift270 pv-conj pv-phase-shift
                pv-brick-wall pv-bin-wipe pv-mag-mul pv-copy-phase
                pv-copy pv-max pv-min pv-mul pv-div pv-add
                pv-mag-div pv-rand-comb pv-rect-comb pv-rect-comb2
                pv-rand-wipe pv-diffuser pv-mag-freeze
                pv-bin-scramble fft-trigger
                Extra FFT UGens
                pv-conformal-map convolution convolution2
                convolution2-l stereo-convolution2-l convolution3
                pv-jenson-andersen pv-hainsworth-foote running-sum
                Filter UGens
                resonz one-pole one-zero two-pole two-zero apf
                integrator decay decay2 lag lag2 lag3 ramp lag-ud
                lag2-ud lag3-ud leak-dc rlpf rhpf hpf bpf brf
                mid-eq lpz1 lpz2 hpz1 hpz2 slope bpz2 median slew
                sos ringz formlet detect-silence
                Grain UGens
                grain-sin grain-in warp1
                Information UGens
                sample-rate sample-dur radians-per-sample
                control-rate control-dur subsample-offset
                num-output-busses num-input-busses num-audio-busses
                num-control-busses num-buffers num-running-synths
                buf-sample-rate buf-rate-scale buf-frames
                buf-samples buf-dur buf-channels check-bad-values
                poll
                Input UGens
                mouse-x mouse-y mouse-button key-state
                IO UGens
                disk-out disk-in v-disk-in in local-in lag-in
                in-feedback in-trig shared-in out replace-out
                offset-out local-out x-out shared-out
                Line Ugens
                line x-line lin-exp lin-lin amp-comp amp-comp-a k2a
                a2k t2k t2a dc silent
                Machine Listening UGens
                beat-track loudness onsets key-track mfcc
                beat-track2 spec-flatness spec-pcile spec-centroid
                Miscellaneous UGens
                pitch-shift pluck part-conv hilbert freq-shift
                g-verb free-verb free-verb2 moog-ff spring ball
                t-ball check-bad-values gendy1 gendy2 gendy3
                Noise UGens
                white-noise brown-noise pink-noise clip-noise
                gray-noise crackle logistic lf-noise0 lf-noise1
                lf-noise2 lf-clip-noise lfd-noise0 lfd-noise1
                lfd-noise3 ldf-clip-noise hasher mantissa-mask dust
                dust2
                Oscillator UGens
                osc sin-osc sin-osc-fb osc-n v-osc v-osc3 c-osc
                formant lf-saw lf-par lf-cub lf-tri lf-gauss
                lf-pulse var-saw impulse sync-saw wrap-index
                index-in-between detect-index shaper degree-to-key
                select vibrato index
                Pan UGens
                pan2 lin-pan2 pan4 balance2 rotate2 pan-b pan-b2
                bi-pan-b2 decode-b2 pan-az x-fade2 lin-x-fade2
                Random UGens
                rand-seed rand-id i-rand t-rand ti-rand n-rand
                exp-rand t-exp-rand coin-gate lin-rand
                STK UGens
                stk-pluck stk-flute stk-bowed stk-mandolin
                stk-saxofony stk-shakers stk-banded-wg
                stk-voic-form stk-modal-bar stk-clarinet
                stk-blow-hole stk-moog stk-bee-three
                Trig UGens
                tw-index trig1 trig t-delay send-trig send-reply
                latch gate pulse-count set-reset-ff peak
                running-min running-max stepper pulse-divider
                toggle-ff zero-crossing timer sweep phasor
                peak-follower pitch in-range fold clip wrap
                schmidt in-rect trapezoid most-changed least-change
                last-value
                AY Extra UGens
                ay
                BBCut2 Extra UGens
                analyse-events2
                Bat Extra UGens
                coyote trig-avg w-amp markov-synth frame-compare
                needle-rect skip-needle
                Berlach Extra UGens
                lpf1 lpfvs6 lpf18 bl-buf-rd clipper4 clipper8
                clipper32 soft-clipper4 soft-clipper8
                soft-clip-amp4 soft-clip-amp8 os-wrap4 os-wrap8
                os-fold4 os-fold8 os-trunc4 os-trunc8 drive-noise
                peak-eq2 peak-eq4
                Bhob Extra UGens
                henon2-dn henon2-dl henon2-dc henon-trig
                gbman2-dn gbman2-dl gbman2-dc gbman-trig
                standard2-dn standard2-dl standard2-dc
                standard-trig latoocarfian2-dn latoocarfian2-dl
                latoocarfian2-dc latoocarfian-trig lorenz2-dn
                lorenz2-dl lorenz2-dc lorenz-trig fhn2-dn fhn2-dl
                fhn2-dc fhn-trig pv-common-mag pv-common-mul
                pv-mag-minus pv-mag-gate pv-compander pv-mag-scale
                pv-morph pv-x-fade pv-soft-wipe pv-cutoff
                nested-allpass-n nested-allpass-l nested-allpass-c
                double-nested-allpass-n double-nested-allpass-l
                double-nested-allpass-c moog-ladder rlpfd
                streson nl-filt-n nl-filt-l nl-filt-c gauss-trig
                lf-brown-noise0 lf-brown-noise1 lf-brown-noise2
                t-brown-rand dbrown2 d-gauss t-gauss-rand
                t-beta-rand gendy4 gendy5 t-grains2 t-grains3
                Blackrain Extra UGens
                amplitude-mod b-moog iir-filter svf
                Distortion Extra UGens
                crossover-distortion smooth-decimator sine-shaper
                decimator disintegrator
                Glitch Extra UGens
                glitch-rhpf glitch-hpf
                Mda Extra UGens
                mda-piano
                Membrane Extra UGens
                membrane-circle membrane-hexagon
                RFW Extra UGens
                switch-delay average-output
                    SLU Extra UGens
                    breakcore brusselator double-well double-well2
                    double-well3 gravity-grid gravity-grid2
                    Stk Extra UGens
                    stk-pluck stk-flute stk-bowed stk-mandolin
                    stk-saxofony stk-shakers stk-banded-wg
                    stk-voic-form stk-modal-bar stk-clarinet
                    stk-blow-hole stk-moog stk-bee-three
                    VOSIM Extra UGens
                    vosim
                    Revision: 0.9.1.2, Date: 17th December, 2013
                    Sam Aaron (sam.aaron gmail com)
Nyq                         ___INSTALL
                            ~/Hämtningar/nyqsrc322.zip
                            .
                            So this is actually what I found, which should be more than adequate I think (i.e. "paydirt" is an expression that could be used I guess?)

                            liblo/osx/config.h
                            misc/Makefile
                            misc/makefile.lsp
                            macosxproject/CMakeLists.txt
                            tran/writemake.lsp
                            snd/sndconfig.h
                            docsrc/xlisp/xlisp-doc/reference/make-string-input-stream.htm
                            docsrc/xlisp/xlisp-doc/reference/make-string-output-stream.htm
                            docsrc/xlisp/xlisp-doc/reference/make-array.htm
                            docsrc/xlisp/xlisp-doc/reference/make-symbol.htm
                            jnyqide/build.xml
                            jnyqide/make-osx-app.sh
                            jnyqide/nyproject/build-impl.xml
                            jnyqide/makejar.sh
                            CMakeLists.txt
                            libogg/win32/VS6/build_ogg_static_debug.bat
                            libogg/win32/VS6/build_ogg_dynamic_debug.bat
                            libogg/win32/VS6/build_ogg_static.bat
                            libogg/win32/VS6/build_ogg_dynamic.bat
                            libogg/include/ogg/config_types.h
                            nylsf/config.h
                            nylsf/static.cmake
                            nylsf/GSM610/config.h
                            nylsf/CMakeLists.txt
                            nylsf/sfconfig.h

                            ----
                            Excellent! That list of files definitely looks promising. The presence of CMakeLists.txt and multiple Makefile variations suggests that the project likely uses either CMake or Make (or both) for its build process. This significantly increases our chances of getting it compiled on Linux.

                            Let's focus on the CMakeLists.txt file first, as CMake is a cross-platform build system generator that is often preferred for projects aiming for wider compatibility.

                            Here's a potential approach to try building Nyquist based on the files you found:

                                Ensure CMake is installed: If you don't have CMake installed on your Arch system, you can install it using pacman:
                                Bash

                            sudo pacman -S cmake

                            Create a build directory: It's good practice to build software outside of the source directory. Let's create a build directory inside the main Nyquist source directory:
                            Bash

                            mkdir build
                            cd build

                            Run CMake to generate the build files: Navigate into the build directory and run CMake, pointing it to the top-level directory of the Nyquist source (where CMakeLists.txt is located). You might need to adjust the path depending on where you are in your file system:
                            Bash

                            cmake ..

                            CMake will then analyze the CMakeLists.txt file and generate the necessary build files (usually Makefiles) for your system.

                            Build Nyquist using Make: After CMake successfully generates the build files, you can use the make command to compile the software:
                            Bash

                            make

                            This will start the compilation process. You'll likely see a lot of output as the various parts of Nyquist are built.

                            Install Nyquist (Optional): After a successful build, there might be an installation step. Often, this is done with the command:
                            Bash

                                sudo make install

                                This will typically copy the compiled binaries and libraries to standard system directories (like /usr/local/bin or /usr/local/lib). However, for a standalone command-line tool, this step might not be strictly necessary if the executable is created within the build directory or a subdirectory within the source tree.

                            Things to Watch Out For:

                                Dependencies: CMake will often check for required dependencies on your system. If any are missing, the CMake step might fail with an error message indicating which libraries or tools are needed. You'll then need to install these dependencies using pacman (e.g., sudo pacman -S <dependency-name>-dev). The error messages from CMake should give you clues about what's missing.
                                Build Errors: The make step might encounter compilation errors if there are issues with the code or your build environment. If this happens, carefully read the error messages to understand the problem. You might need to install additional development packages or adjust build flags.

                            Let's try this process:

                                Navigate to the top-level directory of the Nyquist source code you downloaded.
                                Create a build directory: mkdir build
                                Change into the build directory: cd build
                                Run CMake: cmake .. (Make sure there are two dots after cmake and a space)
                                If CMake succeeds, run Make: make

                            Please share the output of the cmake .. command. This will tell us if CMake was able to configure the build environment and if any dependencies are missing. We can then proceed with the make command.

                            This looks very promising indeed! Let's see what CMake tells us.
CLM (Common Lisp Music)     ___INSTALL
            https://github.com/radiganm/clm
            https://ccrma.stanford.edu/software/snd/snd/clm.html
            https://ccrma.stanford.edu/software/snd/snd/sndclm.html
OpusModus (Win/Mac +=ca 4000 SEK)
            https://opusmodus.com/


An. Ljudsyntes = Freakascope Replacement
                            Very good. Could I ask a question on another topic that would really help me in my music-studies: I will start to explore sound-synthesis shortly, and one book I came across (and that looks really promising) really emphasized the utility of using tools such as Freakoscope (I think it's called) to get a spectrum-printout. What that does is to give a very good overview of the harmonic composition of a sound, which makes it if not trivial at least much easier to reproduce a sound using synthesis-techniques.

                            What I would like to explore is what software I could install and what languages (like CSound and SuperCollider, or other programming-languages) I can use to get that toolchain up and running. Could you give me a hand in exploring the possibilies?

                            Absolutely! Exploring the spectral analysis of sound is a fantastic way to deepen your understanding of music and sound synthesis. You're right, a tool that provides a visual representation of the frequency content (a spectrum printout) is incredibly helpful for sound design and reproduction. Let's explore the software and language possibilities on your Arch Linux system:

                            Software for Spectrum Analysis (Freakoscope-like Functionality):

                            While there might not be a piece of software exactly named "Freakoscope" readily available on Linux (it could be a tool specific to a particular environment or a slightly misremembered name), the functionality you're describing is common in several audio analysis tools. Here are some excellent options you can install on Arch Linux:

                                Sonic Visualiser: This is a powerful and free open-source application for visualizing and analyzing the characteristics of audio signals. It supports various visualizations, including spectrograms (which show the spectrum over time), and allows you to zoom, pan, and analyze specific frequency components.
                                Bash

                            sudo pacman -S sonic-visualiser

                            Sonic Visualiser is likely the closest you'll get to the functionality you described with "Freakoscope." It's widely used in music analysis and sound research.

                            Audacity: While primarily an audio editor, Audacity also has excellent spectrum analysis capabilities. You can select a portion of audio and then go to Analyze > Plot Spectrum... to get a detailed frequency analysis.
                            Bash

                            sudo pacman -S audacity

                            Spek - Acoustic Spectrum Analyser: This is a simple, elegant, and focused spectrum analyzer. It provides a clear visual representation of the frequency content of audio files.
                            Bash

                            sudo pacman -S spek

                            Qtractor: If you're getting into more advanced audio production on Linux, Qtractor is a powerful Digital Audio Workstation (DAW) that includes spectrum analysis tools within its plugin ecosystem (often via LADSPA or LV2 plugins).
                            Bash

                                sudo pacman -S qtractor

                                You would then look for spectrum analyzer plugins within Qtractor (they might need to be installed separately, search for "ladspa plugins" or "lv2 plugins" in the Arch repositories).

                            Languages and Libraries for Spectrum Analysis (for programmatic approaches):

                            If you want to go beyond standalone applications and integrate spectrum analysis into your sound synthesis workflows or create your own tools, several programming languages and libraries are excellent choices on Arch Linux:

                                Python: Python has a rich ecosystem of scientific and audio processing libraries:
                                    Librosa: This is a fantastic library specifically designed for audio and music analysis. It provides functions for loading audio, computing spectrograms (which are the basis for spectrum printouts), and much more.
                                    SciPy: The scientific Python library includes signal processing tools, such as the Fast Fourier Transform (FFT), which is fundamental for spectral analysis.
                                    Matplotlib: A powerful plotting library for creating visualizations of the spectrum data.

                                You can install these using pip:
                                Bash

                            pip install librosa scipy matplotlib

                            With these libraries, you could write Python scripts to load audio files, calculate their spectra, and generate plots.

                            SuperCollider: As you mentioned, SuperCollider is a powerful language for sound synthesis and algorithmic composition, and it also has built-in capabilities for audio analysis. You can analyze the spectrum of audio signals within the SuperCollider environment itself using objects like FFT and visualize the results using its plotting tools or by sending the data to other visualization software.

                            Since you're already interested in SuperCollider, this could be a very integrated approach. You can synthesize a sound and immediately analyze its spectrum within the same environment.

                            CSound: Another venerable and powerful computer music language, CSound also has extensive signal processing and analysis capabilities, including tools for spectral analysis. You would typically write CSound code to perform the analysis and then might use external tools or CSound's own output mechanisms to visualize the data.
                            Bash

                                sudo pacman -S csound

                                Other Languages (Less Common for Direct Spectrum Analysis):
                                    C/C++: These languages offer high performance and direct access to audio hardware and DSP libraries (like FFTW). However, they typically require more development effort for visualization.
                                    Pure Data (Pd): A visual programming language for audio and multimedia, Pd has objects for performing FFT and analyzing the spectrum.

                            Getting Started:

                            For your initial exploration, I highly recommend starting with Sonic Visualiser. It provides a user-friendly interface and the exact type of detailed spectrum visualization you're looking for without requiring any programming. Simply load an audio file, and you can generate a spectrogram and analyze the frequency content at any point in time.

                            As you delve deeper into sound synthesis and want more programmatic control, learning Python with Librosa and Matplotlib would be an excellent next step. You'll be able to automate analysis, integrate it into synthesis workflows, and create custom visualizations.

                            SuperCollider is also a fantastic choice, especially if you plan to use it for synthesis. Its integrated analysis capabilities can be very powerful.

                            CSound is a deep and rewarding language, but it might have a steeper learning curve initially compared to Python or SuperCollider for combined synthesis and visualization.

                            By combining a tool like Sonic Visualiser for immediate visual feedback with the programmatic power of Python or SuperCollider, you'll have a robust toolchain for exploring the harmonic composition of sounds and informing your synthesis techniques. Good luck with your sound synthesis studies – it's a fascinating field!

                            Just a quick follow-up, but how about Baudline?

                            Yes, Baudline is another excellent piece of software for real-time spectral analysis and visualization on Linux! It's specifically designed for this purpose and offers a rich set of features.

                            Key Features of Baudline:

                                Real-time Spectrum Analysis: It can analyze live audio input from your sound card.
                                Spectrograms: Creates detailed and colorful spectrogram displays showing frequency content over time.
                                Various Transforms: Uses Fourier, correlation, and raster transforms for signal analysis.
                                Multiple Displays: Offers Spectrogram, Spectrum, Waveform, and Histogram views.
                                Audio Playback and Recording: Can play back audio files with effects and record audio.
                                JACK Audio Connection Kit Support: Integrates well with the JACK audio server for low-latency audio processing.
                                Wide Range of Audio Formats: Supports various file formats for loading and saving audio.
                                Measurements: Provides tools for measuring peaks, fundamental frequencies, distortion, and power.
                                Function Generator: Includes a built-in function generator for testing and experimentation.

                            Installation on Arch Linux:

                            While Baudline isn't in the main Arch repositories, you can likely find it in the AUR (Arch User Repository). You can install it using your preferred AUR helper (like yay, paru, or trizen):
                            Bash

                            yay -S baudline

                            or
                            Bash

                            paru -S baudline

                            or
                            Bash

                            trizen -S baudline

                            The AUR helper will handle downloading the build files, compiling Baudline, and installing it on your system.

                            Using Baudline:

                            Once installed, you can typically launch Baudline from your application menu or by typing baudline in your terminal.

                                Input Selection: You'll need to configure the audio input source in Baudline's settings. This could be your microphone, system audio output (if you want to analyze what's playing), or a specific JACK input if you're using JACK.
                                Visualization: Experiment with the different display modes (Spectrogram, Spectrum, etc.) to see the frequency content in various ways.
                                Real-time Analysis: If you select a live audio input, you'll see the spectrum and spectrogram update in real time as sound occurs.
                                File Analysis: You can open audio files to analyze their spectral characteristics.

                            Integration with Synthesis Tools:

                            You can use Baudline alongside your synthesis tools (like SuperCollider or CSound) by:

                                Analyzing Output: Direct the audio output of your synthesis environment to a virtual audio cable or through JACK, and then have Baudline listen to that input to visualize the spectrum of the synthesized sounds.
                                Comparing Sounds: Analyze the spectrum of a target sound in Baudline and then try to recreate it in your synthesizer, using Baudline as a visual feedback tool to guide your parameter adjustments.

                            In short, Baudline is an excellent and dedicated tool for the kind of spectral analysis you're interested in. Its real-time capabilities and focus on visualization make it very useful for understanding the harmonic content of sounds, which will indeed be a great asset in your sound synthesis studies. Make sure to explore its various settings and features to get the most out of it!

                            Is it possible to interact with Baudline using any programming- or scripting-language?

                            That's a great question, and the answer is indirectly, but with some limitations. Baudline itself is primarily a standalone graphical application and doesn't offer a direct, built-in API or scripting interface in the way that, for example, SuperCollider or Python libraries do.

                            However, there are a few ways you might be able to interact with or automate tasks involving Baudline:

                            1. Command-Line Arguments:

                            Baudline has some command-line options that allow you to control certain aspects of its behavior when you launch it. You can see these by running baudline --help in your terminal. These options might include:

                                Specifying an input audio device or file.
                                Setting initial window configurations.
                                Potentially triggering certain analysis modes.

                            While this isn't a full scripting API, you could use shell scripting (like Bash) to launch Baudline with specific configurations based on your needs. For example, you could create a script that opens a particular audio file in Baudline with a specific window size.

                            Example (Bash script):
                            Bash

#!/bin/bash

                            audio_file="/path/to/your/audio.wav"
                            baudline "$audio_file" -geometry 800x600

                            2. Inter-Process Communication (IPC):

                            More advanced users might explore IPC mechanisms available on Linux to potentially communicate with a running Baudline instance. This could involve techniques like:

                                X Window System Automation: Tools like xdotool could be used to simulate keyboard and mouse events to interact with Baudline's graphical interface. This is a somewhat brittle approach and highly dependent on Baudline's UI remaining consistent.
                                D-Bus: If Baudline exposes any D-Bus interfaces (which is not commonly the case for such focused applications, but worth a check with dbus-monitor), you might be able to send commands or retrieve information.

                            These methods are generally more complex and less reliable than direct scripting APIs.

                            3. Analyzing Baudline's Output (Indirect):

                            If Baudline has features to save or export its analysis data (e.g., saving a spectrogram image or perhaps some numerical analysis results to a file), you could then use a scripting language to process that output. For example, you could:

                                Run Baudline on an audio file.
                                Have Baudline save a spectrogram image.
                                Use Python with image processing libraries (like Pillow or OpenCV) to analyze the colors or patterns in the spectrogram.

                            This is an indirect form of interaction, as your script isn't directly controlling Baudline, but rather working with the results it produces.

                            4. Creating Your Own Tool (If Deep Integration is Needed):

                            If you require very tight integration of spectral analysis within a larger automated workflow, you might consider using the underlying libraries that Baudline (or similar tools) are built upon. For example, many audio analysis tools rely on libraries for:

                                Audio Decoding: Libraries like libsndfile or ffmpeg libraries.
                                Digital Signal Processing (DSP): Libraries like FFTW (for Fast Fourier Transform).
                                Graphics and Visualization: Libraries like Qt or GTK+.

                            You could use these libraries directly in a language like Python, C++, or even SuperCollider to build a custom spectral analysis tool that fits your exact needs and can be controlled programmatically. This, of course, requires significant development effort.

                            In summary, while Baudline is a powerful tool for visual spectral analysis, it doesn't offer a straightforward programming or scripting API for direct control. The most likely avenues for interaction would be through command-line arguments for initial setup or indirectly by analyzing any data or images that Baudline might export. For deeper programmatic integration, you might need to look at the underlying libraries or consider using tools like Python with audio analysis libraries or SuperCollider, which have strong scripting capabilities and built-in analysis features.

CSound / SuperCollider + MIDI (etc Controllers)
                            Hi again. I'm going to be looking into CSound and SuperCollider a bit, and I'm keen to learn some more about how to use the sounds programmed in those languages (and maybe also PD or PureData a bit as well) with other Linux-utilities or music-tools. Things I'm considering for example is how to control and play those sounds using things like different midi-controllers, and other programs like Rosegarden, Ardour, and maybe even FluidSynth and how to use CSound on Android (for a truly on-the-road kind of workflow). I know that's a bit of a mouthful of questions, but hopefully you can help me get going with those.

                            Hey there! It sounds like you're embarking on a really exciting journey into the world of sound synthesis and Linux audio tools. It's fantastic that you're thinking about integrating these powerful environments with other utilities and controllers – that's where things can get really interesting! Let's break down some of your ideas and see if we can get you pointed in the right direction.
                            Connecting CSound, SuperCollider, and PD with MIDI Controllers

                            This is a very common and rewarding area to explore. All three of these environments have excellent support for MIDI. Here's a general overview:

                                CSound: CSound has opcodes specifically designed for MIDI input, such as midiin, midictrl, noteon, noteoff, and many others. You'll typically use these within your orchestra files (.orc) to receive MIDI data from a controller. You can then map this data to control various parameters of your sound synthesis. For example, a MIDI note number could control the frequency of an oscillator, and a MIDI CC (Continuous Controller) could control the filter cutoff.

                                SuperCollider: SuperCollider has a robust MIDI system integrated into its language (sclang). You can use the MIDIFunc and MIDIdef classes to easily set up mappings between MIDI messages (notes, control changes, pitch bend, etc.) and functions that control aspects of your synthesis. It's a very flexible and expressive system.

                                Pure Data (PD): PD has a dedicated set of objects for handling MIDI input, such as notein, ctlin, bendin, and sysexin. You connect these objects to other PD objects that control your sound parameters. PD's visual patching environment makes it quite intuitive to see and manage these connections.

                            To get started with any of these, you'll typically need to:

                                Connect your MIDI controller to your Linux system. This usually happens automatically via USB. You might need to ensure your system recognizes the device. Tools like amidi -l in the terminal can help list connected MIDI devices.
                                Identify the MIDI input port in your chosen sound environment. Each program will have its own way of selecting the active MIDI input. You'll need to configure this to receive data from your controller.
                                Write code (CSound orchestra), scripts (SuperCollider), or create patches (PD) to interpret the incoming MIDI messages and map them to sound parameters. This is where the creative part comes in!

                            Integrating with Rosegarden and Ardour

                            Both Rosegarden and Ardour are powerful Digital Audio Workstations (DAWs) on Linux, and they can certainly interact with the sounds you generate in CSound, SuperCollider, and PD. Here are a few common approaches:

                                Using JACK: JACK (Jack Audio Connection Kit) is a low-latency audio server for Linux that allows different audio applications to connect to each other. This is often the key to integrating these environments.
                                    You can run CSound, SuperCollider, or PD as JACK clients, outputting their audio to JACK.
                                    Then, within Rosegarden or Ardour, you can create audio tracks that receive the audio output from these JACK clients. This allows you to record, mix, and process the synthesized sounds within the DAW.
                                    Similarly, Rosegarden and Ardour can send MIDI data out through JACK MIDI. You could potentially route MIDI tracks from the DAW to CSound, SuperCollider, or PD for live control.

                                Using Plugins (VST/LADSPA/LV2): While CSound and SuperCollider don't natively export as standard plugin formats out-of-the-box, there are ways to bridge this gap.
                                    LADSPA/LV2: There are projects and tools that allow you to create LADSPA or LV2 plugins from CSound or SuperCollider code, though this might involve some extra steps and potentially specific frameworks.
                                    VST: Interfacing with VST plugins from these environments is less direct but might be possible through wrapper technologies or by using a DAW as an intermediary.
                                    PD has a more direct route to plugin creation through projects like pd~vst.

                                Recording Audio: The simplest approach is often to record the audio output of CSound, SuperCollider, or PD directly into an audio track in Rosegarden or Ardour once you've created a sound you like.

                            FluidSynth

                            FluidSynth is a software synthesizer that uses SoundFont files (.sf2) to generate audio. It's primarily used for playing back MIDI files or receiving live MIDI input.

                                Playing sounds from CSound/SuperCollider/PD through FluidSynth: This isn't a typical workflow, as CSound, SuperCollider, and PD are themselves sound synthesis environments. You'd generally create sounds within them rather than using them to trigger sounds in FluidSynth.
                                Controlling FluidSynth with MIDI from CSound/SuperCollider/PD: You could potentially send MIDI messages generated within CSound, SuperCollider, or PD to FluidSynth if you wanted to leverage its SoundFont library. This would involve setting up MIDI routing, likely using JACK MIDI. For example, you could have SuperCollider generate a MIDI sequence and send it to FluidSynth for playback using a specific piano sound from a SoundFont.

                            CSound on Android

                            Yes, running CSound on Android is definitely possible! There are a few approaches:

                                CsoundAC: This is a dedicated Android application that allows you to write and run CSound code directly on your Android device. It often includes a built-in editor and the Csound engine. You can typically interact with the device's sensors (like accelerometers) and potentially external audio interfaces.
                                Termux: Termux is a terminal emulator for Android that provides a Linux-like environment. It's often possible to install command-line versions of audio tools, including Csound, within Termux. This can be a more advanced approach but offers a lot of flexibility.
                                WebCSound: This is a version of Csound that runs in a web browser using WebAssembly. While it might not be a native Android app, you could potentially use it in a web browser on your Android device.

                            For on-the-road workflows with CSound on Android, CsoundAC is probably the most user-friendly starting point. You can experiment with sound synthesis directly on your phone or tablet.
                            Getting Started

                            Given the breadth of your interests, I'd suggest tackling things in smaller steps:

                                Pick one sound environment (CSound, SuperCollider, or PD) to focus on initially. Get comfortable with its basics and how to generate sound.
                                Try connecting a MIDI controller to it. See how you can map MIDI input to control sound parameters within that environment.
                                Experiment with JACK. Get a basic understanding of how to start the JACK server and connect the audio output of your chosen sound environment to the audio input of Ardour or Rosegarden.
                                Explore the Android options for CSound. Install CsoundAC and try running some basic examples.

                            There's a wealth of documentation and tutorials available for all of these tools. Don't hesitate to dive into their respective communities and resources as you learn.

                            This is a fantastic and rewarding path you're on. Feel free to ask more specific questions as you delve deeper into any of these areas!

Progr.languages = Interact with CSound/SuperCollider
                            From what I can gather, there are a couple of programming-languages that can be used to interact with CSound and SuperCollider. Could you help me get an overview by listing some of them?

                            You're right! Both CSound and SuperCollider have been designed with extensibility and interaction with other programming environments in mind. Here's an overview of some of the languages commonly used to interact with them:

                            Interacting with SuperCollider:

                            SuperCollider has a client-server architecture. The SuperCollider language (sclang) acts as the client, communicating with the synthesis server (scsynth) via the Open Sound Control (OSC) protocol. This OSC-based communication makes it inherently possible to interact with scsynth from virtually any language that has OSC client capabilities.

                            Here are some popular languages and environments used to interact with SuperCollider:

                                SuperCollider Language (sclang): While technically the primary language of SuperCollider, it's often used to control the server and can be considered interacting with the synthesis engine. You write sclang code to define synths, control parameters, and create musical structures that are then executed on scsynth.

                                Python: Python has several libraries for OSC communication, such as python-osc. This allows you to write Python scripts that send OSC messages to scsynth to control synthesis parameters, trigger events, and more. This is a very popular way to integrate SuperCollider with other Python-based tools for data analysis, machine learning, or creative coding.

                                Ruby: Libraries like rb-osc provide OSC capabilities in Ruby, making it possible to control SuperCollider from Ruby scripts.

                                Haskell: The hsc3 library provides Haskell bindings for interacting with the SuperCollider server. This allows for a more functional programming approach to controlling SuperCollider.

                                Scala: ScalaCollider is a library that enables interaction with SuperCollider using the Scala programming language.

                                Clojure: Overtone is a powerful library built in Clojure that provides a high-level way to interact with SuperCollider, offering a unique functional approach to music creation.

                                Scheme: rsc3 is a Scheme client for the SuperCollider server.

                                JavaScript: With tools like WebSockets and OSC libraries for JavaScript (e.g., node-osc for Node.js or browser-based OSC libraries), you can even control SuperCollider from web applications.

                                Pure Data (Pd) and Max/MSP: These visual programming environments have objects for sending and receiving OSC, allowing them to communicate with and control scsynth.

                            Interacting with CSound:

                            CSound has a more monolithic architecture, but it also offers various ways to be controlled and integrated with other languages:

                                Python: The pyo library is a powerful Python module that embeds the CSound engine within Python. This allows you to write Python code to generate and process audio using CSound opcodes, control parameters in real-time, and even build graphical user interfaces.

                                C/C++: CSound has a well-documented API in C, allowing developers to embed the CSound engine into their own C or C++ applications for custom audio processing.

                                Java: JCsound provides Java bindings for the CSound API, enabling interaction with CSound from Java applications.

                                Lua: Lua scripting can be integrated with CSound to control aspects of the synthesis and performance.

                                CsoundACADEMY: This project provides a Python-based environment for interacting with CSound, particularly focused on educational purposes.

                            Choosing a Language:

                            The best language for you will depend on your existing programming skills, the specific goals of your project, and your preferred programming paradigm.

                                If you're comfortable with Python and want a versatile language with strong audio processing libraries (like pyo for CSound or OSC libraries for SuperCollider), it's an excellent choice.
                                If you're interested in functional programming, Haskell or Clojure (with Overtone) offer powerful ways to interact with SuperCollider.
                                If you prefer visual programming environments, Pd or Max/MSP can communicate effectively with SuperCollider via OSC.
                                If you need to embed the sound synthesis engine directly into a custom application with high performance requirements, C/C++ might be the way to go.

                            Exploring the options available for both SuperCollider and CSound will open up a world of possibilities for integrating these powerful audio synthesis tools into your broader creative and technical workflows. Since you're on Arch Linux, you'll find that installing the necessary libraries for these languages is generally straightforward using pacman or pip.




- Could you also help me do the
  same with the SuperCollider IDE,
  CsoundQt, and the NyquistIDE,
  just for me to get an overview?

You're right, each of these
sound-programming environments has
its own unique set of
keyboard-shortcuts tailored to its
specific workflow. Here's an
overview of some useful shortcuts
for SuperCollider IDE, CsoundQt,
and NyquistIDE.

SuperCollider IDE

The SuperCollider IDE is designed
for live-coding and is highly
keyboard-centric. The shortcuts
focus on code-evaluation,
documentation, and managing the
server.

- c-Enter: Evaluate the current
  line, a selected region, or an
  entire code-block.
- c-.: Stop all currently running
  code and free all synths. This is
  your "panic-button."
- c-d: Open the Help-Browser and
  find the help-page for the word
  under the cursor. This is
  invaluable for quick reference.
- c-l: Recompile the class-library.
  This is necessary after you
  install a new Quark (package) or
  modify a class-file.
- Tab: Auto-indent the current line
  or a selected block of code.
- c-f: Find text in the current
  document.


CsoundQt

CsoundQt is a front-end for Csound
that provides a more traditional
IDE-experience with features for
code-editing, compiling, and
running scores.

- c-r: Run the Csound-code.
- cs-w: Evaluate only the selected
  code, which is useful for testing
  small snippets.
- c-/ (cs-7): Comment or uncomment
  the selected text with the
  semicolon-character (;).
- c-i: Indent the selected code or
  the current line.


NyquistIDE

Nyquist is a language primarily
used within Audacity, and the
NyquistIDE is a simplified
environment for developing
Nyquist-plugins. The shortcuts are
more focused on text-editing and
running the code.

- c-Enter: Execute the code in the
  editor-window.
- c-f: Open the find-and-replace
  dialog.

You can learn more about some of
the most useful keyboard shortcuts
for digital audio workstations in
general from Top 10 Keyboard
Shortcuts for DAWs that you GOTTA
KNOW!.

https://www.youtube.com/watch?v=tWXUDJivh8M

